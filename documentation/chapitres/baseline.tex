%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapter{Programmes pour baseline}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}




\section{Structure d’un programme pour baseline}

Un programme Piccolo pour \emph{baseline} a la structure suivante :

\begin{lstlisting}[language=piccolo]
baseline nom "nom_composant" :
  liste_de_sections
end
\end{lstlisting}


Dans l’en-tête :
\begin{itemize}
  \item le nom « \emph{nom} » est le nom du fichier (sans son extension) qui contient ce texte source ;
  \item le nom du composant « \emph{nom\_composant} » doit être exactement le nom de l’un des composants supportés (pour obtenir la liste des \emph{baseline} pris en charge, utiliser l’option « \texttt{-{}-baseline} », voir \refSubsectionPage{listeBaseline}).
\end{itemize}


Le corps du programme est constitué d’une liste non ordonnée de sections. Les sections disponibles sont listées dans le \refTableau{sectionsBaseline}.
\begin{table}[ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}lll}
    \textbf{Type de section} & \textbf{Mot-clé introductif} & \textbf{Référence}\\
    \hline
    Configuration & \texttt{configuration} & \refChapterPage{configuration}\\
    Définition de variable & \texttt{ram} & \refChapterPage{ram}\\
    Définition de constante & \texttt{const} & \refChapterPage{constante}\\
    Définition de routine baseline & \texttt{routine} & \refSectionPage{routineBaseline}\\
    Inclusion  & \texttt{include} & \refSectionPage{sectionIncludeBaseline} \\
  \end{tabular}
  \caption{Les sections d'un programme pour \emph{baseline}}
  \labelTableau{sectionsBaseline}
\end{table}




\sectionLabel{Routines baseline}{routineBaseline}

Les routines définissent le code exécutable de votre programme. L’une d’entre elles doit s’appeler \texttt{main} : c’est la routine qui s’exécute au démarrage. Il y a deux types de routine, les routines \emph{régulières} et les routines \emph{sans retour}.


L’ordre des déclarations des routines est quelconque, il est possible d’appeler une routine qui est déclarée après l’instruction d’appel. Simplement Piccolo engendrera leur code dans leur ordre d’apparition. 

~\\
\textbf{Routine et pages de la ROM.} Un problème important en Piccolo \emph{baseline} est la gestion des pages de la ROM (voir \refSectionPage{gestionPagesBaseline}).

~\\
\textbf{Liste d’instructions d’une routine.} Elle est structurée : Piccolo définit des instructions de sélection et de répétition : cela signifie que vous ne pouvez pas déclarer d’étiquette, ni utiliser de \texttt{goto} pour effectuer des branchements à l’intérieur d’une routine.


\subsection{Routine régulière}

C'est un sous-programme. Une routine régulière peut ne comporter aucune instruction Piccolo, l'instruction \texttt{retlw} est implicitement ajoutée. Une routine régulière est déclarée par :
\begin{lstlisting}[language=piccolo]
routine maRoutine ... {
  ...
}
\end{lstlisting}

\texttt{maRoutine} est le nom de la routine, celui qui sera nommé dans un instruction d’appel de routine. Entre les accolades « \texttt{\{} » et « \texttt{\}} », apparaît la liste des instructions.

~\\
\textbf{Appel d’une routine régulière.} Utiliser l'instruction \texttt{call}.

~\\
\textbf{Dernière instruction d’une routine régulière.} Une particularité du jeu d'instructions des \emph{baseline} est qu'il ne possède pas d'instruction \texttt{RETURN}, mais une instruction \texttt{RETLW} qui combine retour de sous-programme et chargement immédiat de \texttt{W}. Piccolo ne définit pas l'instruction \texttt{RETLW}, mais définit \texttt{movlw} : c'est le compilateur Piccolo qui repère une instruction \texttt{movlw} comme dernière instruction d'une routine, et qui la transforme en \texttt{RETLW}.

En conséquence, la liste des instructions d'une routine régulière ne peut pas être vide. Elle doit comprendre au moins une instruction. D'une manière générale, la dernière instruction d'une routine régulière peut être :
\begin{itemize}
  \item une instruction \texttt{movlw} ; le compilateur Piccolo la transformera en \texttt{RETLW} ;
  \item une instruction \texttt{call} vers une routine régulière ; le compilateur Piccolo la transformera en \texttt{GOTO} ;
  \item une instruction \texttt{if} structurée dont toutes les branches se terminent soit par une instruction \texttt{movlw}, soit par une instruction \texttt{call} vers une routine régulière, soit une autre instruction \texttt{if} structurée.
\end{itemize}

Voici quelques exemples de routines régulières Piccolo et leur traduction en assembleur. Noter qu'il s'agit du code engendré sans aucune optimisation.
\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  movlw 45
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  RETLW 0x2D
\end{lstlisting}
\end{multicols}

\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  call autreRoutineReguliere
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  GOTO autreRoutineReguliere
\end{lstlisting}
\end{multicols}


\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  if (STATUS.Z)
    call autreRoutineReguliere
  else
    movlw 45
  end
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  BTFSS STATUS, 2
  GOTO _label_0
  GOTO autreRoutineReguliere
_label_0:
  RETLW 0x2D
\end{lstlisting}
\end{multicols}


\subsection{Routine sans retour}

L’exécution ne revient pas jamais à l’appelant. Ce type de routine doit donc se terminer par des constructions particulières qui assurent le non-retour : une boucle infinie, un branchement \texttt{goto} vers une autre routine sans retour.

Une routine sans retour doit être déclarée avec qualificatif « \texttt{noreturn} » :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine ... {
  ...
}
\end{lstlisting}

~\\
\textbf{Appel d’une routine sans retour.} Utiliser \texttt{goto}.


~\\
\textbf{Déclaration de la routine \texttt{main}.} Dans un programme, il doit exister une et une seule routine \texttt{main}, qui doit être déclarée comme suit :

\begin{lstlisting}[language=piccolo]
noreturn routine main {
   liste d'instructions
}

\end{lstlisting}

Le compilateur Piccolo place cette routine au début de la ROM, de façon qu'elle soit exécutée au démarrage du micro-contrôleur.


~\\
\textbf{Comment terminer une routine sans retour.} La dernière instruction de la liste des instructions d’une routine sans retour doit être :
\begin{itemize}
  \item une instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item un appel vers une autre routine sans retour, au moyen d’un \texttt{goto} ;
  \item une instruction conditionnelle structurée, dont toutes les branches présentent comme dernière instruction les instructions d’appel d’un routine sans retour, un branchement calculé (comme évoqué ci-dessus), ou encore une instruction conditionnelle structurée, dont toutes les branches, etc.

\end{itemize}

Exemple simple : la dernière instruction est une boucle infinie :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  forever
    ...
  end
}
\end{lstlisting}

Exemple simple : la dernière instruction est un branchement vers une routine sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  goto autreRoutineSansRetour
}
\end{lstlisting}


La dernière instruction est un \texttt{if} dont aucune des branches ne se termine (\texttt{r1} est une routine sans retour) :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    goto r1
  else
    ...
    forever
      ...
    end
  end
}

\end{lstlisting}


La dernière instruction est un \texttt{if} dont la première branche se termine elle même par un \texttt{if} dont les deux branches se terminent par des branchements vers des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    if (...)
      ...
      goto r1
    else
      ...
      goto r2
    end
  else
    ...
    goto r3
  end
}
\end{lstlisting}









\section{Les instructions}

Elles sont de deux types (la distinction est importante pour l’instruction \emph{conditionnelle simple}) :
\begin{itemize}
  \item les instructions simples ;
  \item les instructions composées.

\end{itemize}


~\\
\textbf{Les instructions simples.} Elles correspondent à une partie des instructions assembleur. Attention, pour certaines, la syntaxe n'est pas exactement la même que celle de l'instruction assembleur correspondante.

Le \refTableau{instructionsAssembleurBaseline} donnent la liste des instructions assembleur \emph{baseline} et les liens vers les sections précisant leur prise en charge en Piccolo.

 
\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \texttt{ADDWF f, d} & Add W and f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW} \\
    \texttt{ANDLW k} & And Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{ANDWF f, d} & And W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{BCF f, b, a} & Bit Clear f & \refSubsectionPage{opBaselineAffectationBit} \\
    \texttt{BSF f, b, a} & Bit Set f & \refSubsectionPage{opBaselineAffectationBit} \\
    \texttt{BTFSC f, b, a} & Bit Test f, Skip if Clear & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{BTFSS f, b, a} & Bit Test f, Skip if Set & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{CALL n, s} & Call Subroutine &  \refSubsectionPage{appelRoutineReguliereBaseline} \\
    \texttt{CLRF f} & Clear f & \refSubsectionPage{instructionsBaseLineNommantRegistre} \\
    \texttt{CLRW} & Clear W & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{CLRWDT} & Clear Watchdog Timer & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{COMF f, d} & Complement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{DECF f, d} & Decrement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{DECFSZ f, d} & Decrement f, Skip if 0 & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{GOTO n} & Go to Address & \refSubsectionPage{appelRoutineSansRetourBaseline} \\
    \texttt{INCF f, d} & Decrement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{INCFSZ f, d} & Increment f, Skip if 0 & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{IORLW k} & Inclusive OR Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{IORWF f, d} & Inclusive OR W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{MOVF f, d} & Move f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{MOVLW k} & Move Literal to W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{NOP} & No Operation & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{RETLW k} & Return with Literal in W & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{RLF f, d} & Rotate Left f through Carry & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{RLF f, d} & Rotate Left f through Carry & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{SLEEP} & Go into Standby Mode & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{SUBWF f, d} & Substract W from f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{SWAPF f, d} & Swap Nibbles in f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{TRIS f} & Load TRIS register & \refSubsectionPage{instructionTRIS}\\
    \texttt{XORLW k} & Exclusive OR Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{XORWF f, d} & Exclusive OR W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
  \hline
  \end{tabular}
  \caption{Instructions \emph{byte-oriented} pour \emph{baseline}}
  \labelTableau{instructionsAssembleurBaseline}
\end{table}






~\\
\textbf{Les instructions composées.} Piccolo définit les instructions suivantes :
\begin{itemize}
  \item l'instruction \texttt{mnop} (\refSectionPage{instructionMNOP}) ;
  \item l'instruction conditionnelle simple (\refSectionPage{instructionConditionnelleSimple}) ;
  \item l'instruction conditionnelle structurée (\refSectionPage{instructionConditionnelleStructuree}) ;
  \item l'instruction répétitive (\refSectionPage{instructionRepetitive}) ;
  \item l'instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
\end{itemize}




\subsectionLabel{Les instructions que vous ne trouverez pas en Piccolo}{instructionsBaselineIntrouvables}

Elles n’existent pas en Piccolo parce qu’elles sont remplacées par des constructions structurées, ou bien engendrées automatiquement lors de la compilation.

Voici leur liste avec les liens vers les sections appropriées :\begin{itemize}
  \item \texttt{BTFSC}, \texttt{BTFSS}, \texttt{DCFSNZ} et \texttt{INCFSZ} : ces instructions sont engendrées par l’instruction conditionnelle simple, l’instruction conditionnelle structurée et l’instruction répétitive ;
  \item \texttt{RETLW} : utiliser une instruction \texttt{MOVLW}, et c’est le compilateur Piccolo qui remplacera la séquence \texttt{MOVLW k, RETURN} par une instruction \texttt{RETLW k}.

\end{itemize}





\sectionLabel{Les instructions simples}{instructionsSimplesBaseline}


\subsectionLabel{Instructions nommant un registre}{instructionsBaseLineNommantRegistre}

Ce sont les instructions listées dans le \refTableau{operationsBaselineNommantUnRegistre}.



\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRF f} & Clear f & \texttt{clrf f} \\
    \texttt{MOVWF f} & Move f & \texttt{movf f} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{baseline} nommant un registre}
  \labelTableau{operationsBaselineNommantUnRegistre}
\end{table}








\subsectionLabel{Instructions nommant un registre, et optionnellement \texttt{W}}{instructionsBaselineNommantRegistreEtW}

Ces instructions, ainsi que le traduction en Piccolo, sont listées dans le \refTableau{instructionsBaselineRegistreEtW}. En assembleur, elles nomment deux opérandes :
\begin{itemize}
  \item \texttt{f} : désigne le registre, il en est de même en Piccolo ;
  \item \texttt{d} : optionnel en Piccolo ; si absent, le registre \texttt{f} est destination de l'opération, si égal à \texttt{W}, c'est le registre \texttt{W} qui est destinaire.
\end{itemize}


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{llll}
     &  & \multicolumn{2}{l}{\textbf{En Piccolo, destination :}} \\
    \textbf{Assembleur} & \textbf{Description} & \textbf{f} & \textbf{W}\\
    \hline
    \texttt{ADDWF f, d} & Add W and f & \texttt{addwf f}  & \texttt{addwf f, W} \\
    \texttt{ANDWF f, d} & And W with f & \texttt{andwf f} & \texttt{andwf f, W}\\
    \texttt{COMF f, d} & Complement f & \texttt{comf f} & \texttt{comf f, W}\\
    \texttt{DECF f, d} & Decrement f & \texttt{decf f} & \texttt{decf f, W}\\
    \texttt{INCF f, d} & Increment f & \texttt{incf f}& \texttt{incf f, W}\\
    \texttt{IORWF f, d} & Inclusive OR W with f & \texttt{iorwf f} & \texttt{iorwf f, W}\\
    \texttt{MOVF f, d} & Move f & \texttt{movf f} & \texttt{movf f, W}\\
    \texttt{RLF f, d} & Rotate Left f through Carry & \texttt{rlf f} & \texttt{rlf f, W}\\
    \texttt{RRF f, d} & Rotate Right f through Carry & \texttt{rrf f} & \texttt{rrf f, W}\\
    \texttt{SUBWF f, d} & Substract W from f & \texttt{subwf f} & \texttt{subwf f, W}\\
    \texttt{SWAPF f, d} & Swap Nibbles in f & \texttt{swapf f} & \texttt{swapf f, W}\\
    \texttt{XORWF f, d} & Exclusive OR W with f & \texttt{xorwf f} & \texttt{xorwf f, W}\\
  \hline
  \end{tabular}
  \caption{Instructions \emph{baseline} nommant un registre, et optionnellement \texttt{W}}
  \labelTableau{instructionsBaselineRegistreEtW}
\end{table}


\subsectionLabel{Opérations d'affectation de bit}{opBaselineAffectationBit}

Ces instructions Piccolo correspondent aux instructions assembleur \texttt{BCF} et \texttt{BSF} (\refTableau{operationsBaselineAffectationBit}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{BCF f, b} & Bit Clear f & \texttt{bcf f.b} \\
    \texttt{BSF f, b} & Bit Set f & \texttt{bsf f.b} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{baseline} sur un bit d'un registre}
  \labelTableau{operationsBaselineAffectationBit}
\end{table}

En Piccolo, ces instructions ont toujours deux arguments :
\begin{itemize}
  \item le premier argument est une référence à un registre (\refSectionPage{referenceRegistre}) ;
  \item le second est le bit concerné, précédé par un point.
\end{itemize}

Pour désigner le bit concerné, vous pouvez utiliser un nombre compris entre 0 et 7. Par exemple :
\begin{lstlisting}[language=piccolo]
bcf maVariable.3
\end{lstlisting}

Si le registre a été défini en déclarant des noms de bit :
\begin{lstlisting}[language=piccolo]
ram ... {
  byte maVariable <a, -, b [3], -, -, ->
}
\end{lstlisting}

Vous pouvez utiliser l’un de ces noms comme second argument :
\begin{lstlisting}[language=piccolo]
bcf maVariable.a # a designe le bit 7
\end{lstlisting}
ou encore
\begin{lstlisting}[language=piccolo]
bcf maVariable.b [1] # b[1] designe le bit 4
\end{lstlisting}

Vous pouvez de cette façon accéder aux bits des registres spéciaux. Pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} (ou sa version courte \texttt{-R}), comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=10F220}.


\subsectionLabel{Opérations littérales avec \texttt{W}}{opBaselineImmediate}

Ces opérations sont listées dans le \refTableau{operationsLiteralesBaselineAvecW}. L’instruction \texttt{RETLW k} n’existe pas en Piccolo, l’optimiseur repérera une instruction \texttt{MOVLW k} en fin de routine et la transformera en \texttt{RETLW k}.

En Piccolo, \texttt{k} est une \emph{expression statique}. Une expression statique est une expression dont la valeur est calculée à la compilation. Sa forme générale est présentée à la \refSectionPage{expressionImmediate}. Le compilateur effectue tous les calculs d'une expression statique avec des nombres entiers 32 bits signés.

Pour être valide dans les opérations statiques avec \texttt{W}, le résultat devra être :
\begin{itemize}
  \item soit un nombre positif inférieur ou égal à 255 ;
  \item soit un nombre négatif supérieur ou égal à -128.
\end{itemize}

Par exemple : \texttt{movlw -14} engendre l’instruction assembleur : \texttt{MOVLW 0xf2}.


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{ANDLW k} & And Literal with W & \texttt{andlw k}\\
    \texttt{IORLW k} & Inclusive OR Literal with W & \texttt{iorlw k}\\
    \texttt{MOVLW k} & Move Literal to W & \texttt{movlw k}\\
    \texttt{XORLW k} & Exclusive OR Literal with W & \texttt{xorlw k}\\
    \hline
  \end{tabular}
  \caption{Opérations statiques avec \texttt{W} pour \emph{baseline}}
  \labelTableau{operationsLiteralesBaselineAvecW}
\end{table}


\subsectionLabel{Instructions identiques à celles de l’assembleur}{operationsBaselineIdentiquesAssembleur}

Ces instructions sont listées dans le \refTableau{operationsBaselineIdentiquesAssembleur}.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRWDT} & Clear Watchdog Timer & \texttt{clrwdt}\\
    \texttt{CLRW} & Clear W & \texttt{clrw}\\
    \texttt{NOP} & No Operation & \texttt{nop}\\
    \texttt{OPTION} & Load OPTION register & \texttt{option}\\
    \texttt{SLEEP} & Go into Standby Mode & \texttt{sleep}\\
    \hline
  \end{tabular}
  \caption{Instructions \emph{baseline} identiques en assembleur et en Piccolo}
  \labelTableau{operationsBaselineIdentiquesAssembleur}
\end{table}















\subsectionLabel{Instruction \texttt{TRIS}}{instructionTRIS}

En Piccolo, l'instruction \texttt{TRIS} a un opérande qui peut être: \texttt{GPIO}, \texttt{PORTA}, \texttt{PORTB}, \texttt{PORTC}, \texttt{PORTD} ou \texttt{PORTE}. Pour un composant donné, uniquement un sous-ensemble de ces valeurs est acceptable (\refTableau{TRISoperands}). D'une manière générale, pour que l'un des noms cités puisse être utilisé pour un composant donnée, il faut qu'il apparaisse parmi ses registres spéciaux (pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} ou sa version courte \texttt{-R}, comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=10F220}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{ll}
    \textbf{Composant} & \textbf{Instructions \texttt{TRIS} en Piccolo}\\
    \hline
    10F200, 10F202  & \texttt{tris GPIO}\\
    10F204, 10F206  & \texttt{tris GPIO}\\
    10F220  & \texttt{tris GPIO}\\
    12F508, 12F509  & \texttt{tris GPIO}\\
    12F510, 12F519  & \texttt{tris GPIO}\\
    16F505, 16F506  & \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F526  & \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F54  & \texttt{tris PORTA}, \texttt{tris PORTB}\\
    16F57  & \texttt{tris PORTA}, \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F59  & \texttt{tris PORTA}, \texttt{tris PORTB}, \texttt{tris PORTC}, \texttt{tris PORTD}, \texttt{tris PORTE}\\
    \hline
  \end{tabular}
  \caption{Instructions \texttt{tris} en Piccolo}
  \labelTableau{TRISoperands}
\end{table}












\subsectionLabel{Appeler une routine régulière}{appelRoutineReguliereBaseline}

Une routine régulière est une routine déclarée sans le qualificatif \texttt{noreturn}. L'appel s’effectue au moyen de l'instruction \texttt{CALL}.

Syntaxiquement, il faut simplement nommer la routine appelée après le nom de l’instruction d’appel :

\begin{lstlisting}[language=piccolo]
call nom_routine
\end{lstlisting}




\subsectionLabel{Appeler une routine sans retour}{appelRoutineSansRetourBaseline}

Appeler une routine sans retour (c'est-à-dire déclarée avec le qualificatif \texttt{noreturn}) s'effectue par une instruction \texttt{goto}. L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
goto nom_routine
\end{lstlisting}




\sectionLabel{Section \texttt{include}}{sectionIncludeBaseline}

Une section \texttt{include} permet d'inclure un fichier contenant lui-même des sections telles que définies dans le \refTableauPage{sectionsBaseline}.  Son format est le suivant :

\begin{lstlisting}[language=piccolo]
  include "chemin"
\end{lstlisting}

\texttt{chemin} est le chemin vers le fichier inclus, et est :
\begin{itemize}
  \item soit un chemin absolu (il commence par « \texttt{/} ») ;
  \item soit un chemin relatif par rapport au fichier source.
\end{itemize}

\sectionLabel{Gestion des pages de la ROM}{gestionPagesBaseline}








