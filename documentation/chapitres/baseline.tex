%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapter{Programmes pour baseline}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}




\section{Structure d’un programme pour baseline}

Un programme Piccolo pour \emph{baseline} a la structure suivante :

\begin{lstlisting}[language=piccolo]
baseline nom "nom_composant" :
  liste_de_sections
end
\end{lstlisting}


Dans l’en-tête :
\begin{itemize}
  \item le nom « \emph{nom} » est le nom du fichier (sans son extension) qui contient ce texte source ;
  \item le nom du composant « \emph{nom\_composant} » doit être exactement le nom de l’un des composants supportés (pour obtenir la liste des \emph{baseline} pris en charge, utiliser l’option « \texttt{-{}-baseline} », voir \refSubsectionPage{listeBaseline}).
\end{itemize}


Le corps du programme est constitué d’une liste non ordonnée de sections. Les sections disponibles sont listées dans le \refTableau{sectionsBaseline}.
\begin{table}[ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}lll}
    \textbf{Type de section} & \textbf{Mot-clé introductif} & \textbf{Référence}\\
    \hline
    Configuration & \texttt{configuration}\index{Mot réservé!configuration} & \refChapterPage{configuration}\\
    Définition de variable & \texttt{ram}\index{Mot réservé!ram} & \refChapterPage{ram}\\
    Définition de constante & \texttt{const}\index{Mot réservé!const} & \refChapterPage{constante}\\
    Définition de routine régulière & \texttt{routine}\index{Mot réservé!routine} & \refSectionPage{routineBaseline}\\
    Définition de routine sans retour & \texttt{noreturn}\index{Mot réservé!noreturn} & \refSectionPage{routineBaseline}\\
    Inclusion  & \texttt{include}\index{Mot réservé!include} & \refSectionPage{sectionIncludeBaseline} \\
  \end{tabular}
  \caption{Les sections d'un programme pour \emph{baseline}}
  \labelTableau{sectionsBaseline}
\end{table}




\sectionLabel{Routines baseline}{routineBaseline}

Les routines définissent le code exécutable de votre programme. L’une d’entre elles doit s’appeler \texttt{main} : c’est la routine qui s’exécute au démarrage. Il y a deux types de routine, les routines \emph{régulières} et les routines \emph{sans retour}.


L’ordre des déclarations des routines est quelconque, il est possible d’appeler une routine qui est déclarée après l’instruction d’appel. Simplement Piccolo engendrera leur code dans leur ordre d’apparition. 

~\\
\textbf{Routine et pages de la mémoire programme.} Un problème important en Piccolo \emph{baseline} est la gestion des pages de la mémoire programme (voir \refSectionPage{gestionPagesBaseline}).

~\\
\textbf{Liste d’instructions d’une routine.} Elle est structurée : Piccolo définit des instructions de sélection et de répétition : cela signifie que vous ne pouvez pas déclarer d’étiquette, ni utiliser de \texttt{goto} pour effectuer des branchements à l’intérieur d’une routine.


\subsectionLabel{Routine régulière}{routineReguliereBaseline}
\index{Routine régulière!baseline}

C'est un sous-programme. Une routine régulière peut ne comporter aucune instruction Piccolo, l'instruction \texttt{retlw} est implicitement ajoutée. Une routine régulière est déclarée par :
\begin{lstlisting}[language=piccolo]
routine maRoutine ... {
  ...
}
\end{lstlisting}

\texttt{maRoutine} est le nom de la routine, celui qui sera nommé dans un instruction d’appel de routine. Entre les accolades « \texttt{\{} » et « \texttt{\}} », apparaît la liste des instructions.

~\\
\textbf{Appel d’une routine régulière.} Utiliser l'instruction \texttt{call} ou l'instruction \texttt{jsr} (\refSectionPage{gestionPagesBaseline}).

~\\
\textbf{Dernière instruction d’une routine régulière.} Une particularité du jeu d'instructions des \emph{baseline} est qu'il ne possède pas d'instruction \texttt{RETURN}, mais une instruction \texttt{RETLW} qui combine retour de sous-programme et chargement immédiat de \texttt{W}. Piccolo ne définit pas l'instruction \texttt{RETLW}, mais définit \texttt{movlw} : c'est le compilateur Piccolo qui repère une instruction \texttt{movlw} comme dernière instruction d'une routine, et qui la transforme en \texttt{RETLW}.

En conséquence, la liste des instructions d'une routine régulière ne peut pas être vide. Elle doit comprendre au moins une instruction. D'une manière générale, la dernière instruction d'une routine régulière peut être :
\begin{itemize}
  \item une instruction \texttt{movlw} ; le compilateur Piccolo la transformera en \texttt{RETLW} ;
  \item une instruction \texttt{call} ou une instruction \texttt{jsr} vers une routine régulière ; le compilateur Piccolo la transformera en \texttt{GOTO} ;
  \item une instruction \texttt{if} structurée dont toutes les branches se terminent soit par une instruction \texttt{movlw}, soit par une instruction \texttt{call} vers une routine régulière, soit une autre instruction \texttt{if} structurée.
\end{itemize}

Voici quelques exemples de routines régulières Piccolo et leur traduction en assembleur. Noter qu'il s'agit du code engendré sans aucune optimisation.
\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  movlw 45
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  RETLW 0x2D
\end{lstlisting}
\end{multicols}

\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  call autreRoutineReguliere
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  GOTO autreRoutineReguliere
\end{lstlisting}
\end{multicols}


\begin{multicols}{2}
\textbf{Routine Piccolo}
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  if (STATUS.Z)
    call autreRoutineReguliere
  else
    movlw 45
  end
}
\end{lstlisting}
\columnbreak
\textbf{Traduction assembleur}
\begin{lstlisting}[language=assembleur]
maRoutine:
  BTFSS STATUS, 2
  GOTO _label_0
  GOTO autreRoutineReguliere
_label_0:
  RETLW 0x2D
\end{lstlisting}
\end{multicols}


\subsection{Routine sans retour}
\index{Routine sans retour!baseline}

L’exécution ne revient pas jamais à l’appelant. Ce type de routine doit donc se terminer par des constructions particulières qui assurent le non-retour : une boucle infinie, un branchement \texttt{goto} ou \texttt{jump} vers une autre routine sans retour.

Une routine sans retour doit être déclarée avec qualificatif \texttt{noreturn} :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine ... {
  ...
}
\end{lstlisting}

~\\
\textbf{Appel d’une routine sans retour.} Utiliser \texttt{goto} ou l'instruction \texttt{jump} (\refSectionPage{gestionPagesBaseline}).


~\\
\textbf{Déclaration de la routine \texttt{main}.} Dans un programme, il doit exister une et une seule routine \texttt{main}, qui doit être déclarée comme suit :

\begin{lstlisting}[language=piccolo]
noreturn routine main {
   liste d'instructions
}

\end{lstlisting}

Le compilateur Piccolo place cette routine au début de la ROM, de façon qu'elle soit exécutée au démarrage du micro-contrôleur.


~\\
\textbf{Comment terminer une routine sans retour.} La dernière instruction de la liste des instructions d’une routine sans retour doit être :
\begin{itemize}
  \item une instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item un appel vers une autre routine sans retour, au moyen d’un \texttt{goto} ou d'un \texttt{jump} ;
  \item une instruction conditionnelle structurée, dont toutes les branches présentent comme dernière instruction les instructions d’appel d’un routine sans retour, un branchement calculé (comme évoqué ci-dessus), ou encore une instruction conditionnelle structurée, dont toutes les branches, etc.

\end{itemize}

Exemple simple : la dernière instruction est une boucle infinie :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  forever
    ...
  end
}
\end{lstlisting}

Exemple simple : la dernière instruction est un branchement vers une routine sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  goto autreRoutineSansRetour
}
\end{lstlisting}


La dernière instruction est un \texttt{if} dont aucune des branches ne se termine (\texttt{r1} est une routine sans retour) :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    goto r1
  else
    ...
    forever
      ...
    end
  end
}

\end{lstlisting}


La dernière instruction est un \texttt{if} dont la première branche se termine elle même par un \texttt{if} dont les deux branches se terminent par des branchements vers des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    if (...)
      ...
      goto r1
    else
      ...
      goto r2
    end
  else
    ...
    goto r3
  end
}
\end{lstlisting}









\section{Les instructions}
\index{Baseline!Instructions machine}

Elles sont de deux types (la distinction est importante pour l’instruction \emph{conditionnelle simple}) :
\begin{itemize}
  \item les instructions simples ;
  \item les instructions composées.

\end{itemize}


~\\
\textbf{Les instructions simples.} Elles correspondent à une partie des instructions machine. Attention, pour certaines, la syntaxe n'est pas exactement la même que celle de l'instruction assembleur correspondante.

Le \refTableau{instructionsAssembleurBaseline} donnent la liste des instructions machine \emph{baseline} et les liens vers les sections précisant leur prise en charge en Piccolo.

 
\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Instruction} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \texttt{ADDWF f, d} & Add W and f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW} \\
    \texttt{ANDLW k} & And Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{ANDWF f, d} & And W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{BCF f, b} & Bit Clear f & \refSubsectionPage{opBaselineAffectationBit} \\
    \texttt{BSF f, b} & Bit Set f & \refSubsectionPage{opBaselineAffectationBit} \\
    \texttt{BTFSC f, b} & Bit Test f, Skip if Clear & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{BTFSS f, b} & Bit Test f, Skip if Set & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{CALL k} & Call Subroutine &  \refSubsectionPage{appelRoutineReguliereBaseline} \\
    \texttt{CLRF f} & Clear f & \refSubsectionPage{instructionsBaseLineNommantRegistre} \\
    \texttt{CLRW} & Clear W & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{CLRWDT} & Clear Watchdog Timer & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{COMF f, d} & Complement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{DECF f, d} & Decrement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{DECFSZ f, d} & Decrement f, Skip if 0 & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{GOTO k} & Go to Address & \refSubsectionPage{appelRoutineSansRetourBaseline} \\
    \texttt{INCF f, d} & Decrement f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{INCFSZ f, d} & Increment f, Skip if 0 & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{IORLW k} & Inclusive OR Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{IORWF f, d} & Inclusive OR W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{MOVF f, d} & Move f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{MOVLW k} & Move Literal to W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{MOVWF f} & Move W to f & \refSubsectionPage{instructionsBaseLineNommantRegistre} \\
    \texttt{NOP} & No Operation & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{RETLW k} & Return with Literal in W & \refSubsectionPage{instructionsBaselineIntrouvables}\\
    \texttt{RLF f, d} & Rotate Left f through Carry & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{RRF f, d} & Rotate Right f through Carry & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{SLEEP} & Go into Standby Mode & \refSubsectionPage{operationsBaselineIdentiquesAssembleur}\\
    \texttt{SUBWF f, d} & Substract W from f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{SWAPF f, d} & Swap Nibbles in f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
    \texttt{TRIS f} & Load TRIS register & \refSubsectionPage{instructionTRIS}\\
    \texttt{XORLW k} & Exclusive OR Literal with W & \refSubsectionPage{opBaselineImmediate}\\
    \texttt{XORWF f, d} & Exclusive OR W with f & \refSubsectionPage{instructionsBaselineNommantRegistreEtW}\\
  \hline
  \end{tabular}
  \caption{Instructions machine des \emph{baseline}}
  \labelTableau{instructionsAssembleurBaseline}
\end{table}






~\\
\textbf{Les instructions composées.} Piccolo définit les instructions suivantes :
\begin{itemize}
  \item l'instruction \texttt{mnop} (\refSectionPage{instructionMNOP}) ;
  \item l'instruction conditionnelle simple (\refSectionPage{instructionConditionnelleSimple}) ;
  \item l'instruction conditionnelle structurée (\refSectionPage{instructionConditionnelleStructuree}) ;
  \item l'instruction répétitive (\refSectionPage{instructionRepetitive}) ;
  \item l'instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item l'instruction d'appel de routine régulière \texttt{jsr} (\refSectionPage{gestionPagesBaseline}) ;
  \item l'instruction d'appel de routine sans retour \texttt{jump} (\refSectionPage{gestionPagesBaseline}) ;
\end{itemize}




\subsectionLabel{Les instructions que vous ne trouverez pas en Piccolo}{instructionsBaselineIntrouvables}

Elles n’existent pas en Piccolo parce qu’elles sont remplacées par des constructions structurées, ou bien engendrées automatiquement lors de la compilation.

Voici leur liste avec les liens vers les sections appropriées :\begin{itemize}
  \item \texttt{BTFSC}, \texttt{BTFSS}, \texttt{DECFSZ} et \texttt{INCFSZ} : ces instructions sont engendrées par l’instruction conditionnelle simple, l’instruction conditionnelle structurée et l’instruction répétitive (\refSubsectionPage{conditionsElementairesBaselineMidRange}) ;
  \item \texttt{RETLW} : utiliser une instruction \texttt{MOVLW}, et c’est le compilateur Piccolo qui la remplacera par une instruction \texttt{RETLW k} (\refSubsectionPage{routineReguliereBaseline}).

\end{itemize}





\sectionLabel{Les instructions simples}{instructionsSimplesBaseline}


\subsectionLabel{Instructions nommant un registre}{instructionsBaseLineNommantRegistre}

Ce sont les instructions listées dans le \refTableau{operationsBaselineNommantUnRegistre}.



\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRF f} & Clear f & \texttt{clrf f} \\
    \texttt{MOVWF f} & Move f & \texttt{movwf f} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{baseline} nommant un registre}
  \labelTableau{operationsBaselineNommantUnRegistre}
\end{table}








\subsectionLabel{Instructions nommant un registre, et optionnellement \texttt{W}}{instructionsBaselineNommantRegistreEtW}

Ces instructions, ainsi que le traduction en Piccolo, sont listées dans le \refTableau{instructionsBaselineRegistreEtW}. En assembleur, elles nomment deux opérandes :
\begin{itemize}
  \item \texttt{f} : désigne le registre, il en est de même en Piccolo ;
  \item \texttt{d} : optionnel en Piccolo ; si absent, le registre \texttt{f} est destination de l'opération, si égal à \texttt{W}, c'est le registre \texttt{W} qui est destinaire.
\end{itemize}


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{llll}
     &  & \multicolumn{2}{l}{\textbf{En Piccolo, destination :}} \\
    \textbf{Assembleur} & \textbf{Description} & \textbf{f} & \textbf{W}\\
    \hline
    \texttt{ADDWF f, d} & Add W and f & \texttt{addwf f}  & \texttt{addwf f, W} \\
    \texttt{ANDWF f, d} & And W with f & \texttt{andwf f} & \texttt{andwf f, W}\\
    \texttt{COMF f, d} & Complement f & \texttt{comf f} & \texttt{comf f, W}\\
    \texttt{DECF f, d} & Decrement f & \texttt{decf f} & \texttt{decf f, W}\\
    \texttt{INCF f, d} & Increment f & \texttt{incf f}& \texttt{incf f, W}\\
    \texttt{IORWF f, d} & Inclusive OR W with f & \texttt{iorwf f} & \texttt{iorwf f, W}\\
    \texttt{MOVF f, d} & Move f & \texttt{movf f} & \texttt{movf f, W}\\
    \texttt{RLF f, d} & Rotate Left f through Carry & \texttt{rlf f} & \texttt{rlf f, W}\\
    \texttt{RRF f, d} & Rotate Right f through Carry & \texttt{rrf f} & \texttt{rrf f, W}\\
    \texttt{SUBWF f, d} & Substract W from f & \texttt{subwf f} & \texttt{subwf f, W}\\
    \texttt{SWAPF f, d} & Swap Nibbles in f & \texttt{swapf f} & \texttt{swapf f, W}\\
    \texttt{XORWF f, d} & Exclusive OR W with f & \texttt{xorwf f} & \texttt{xorwf f, W}\\
  \hline
  \end{tabular}
  \caption{Instructions \emph{baseline} nommant un registre, et optionnellement \texttt{W}}
  \labelTableau{instructionsBaselineRegistreEtW}
\end{table}


\subsectionLabel{Opérations d'affectation de bit}{opBaselineAffectationBit}

Ces instructions Piccolo correspondent aux instructions machine \texttt{BCF} et \texttt{BSF} (\refTableau{operationsBaselineAffectationBit}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{BCF f, b} & Bit Clear f & \texttt{bcf f.b} \\
    \texttt{BSF f, b} & Bit Set f & \texttt{bsf f.b} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{baseline} sur un bit d'un registre}
  \labelTableau{operationsBaselineAffectationBit}
\end{table}

En Piccolo, ces instructions ont toujours deux arguments :
\begin{itemize}
  \item le premier argument est une référence à un registre (\refSectionPage{referenceRegistre}) ;
  \item le second est le bit concerné, précédé par un point.
\end{itemize}

Pour désigner le bit concerné, vous pouvez utiliser un nombre compris entre 0 et 7. Par exemple :
\begin{lstlisting}[language=piccolo]
bcf maVariable.3
\end{lstlisting}

Si le registre a été défini en déclarant des noms de bit :
\begin{lstlisting}[language=piccolo]
ram ... {
  byte maVariable <a, -, b [3], -, -, ->
}
\end{lstlisting}

Vous pouvez utiliser l’un de ces noms comme second argument :
\begin{lstlisting}[language=piccolo]
bcf maVariable.a # a designe le bit 7
\end{lstlisting}
ou encore
\begin{lstlisting}[language=piccolo]
bcf maVariable.b [1] # b[1] designe le bit 4
\end{lstlisting}

Vous pouvez de cette façon accéder aux bits des registres spéciaux. Pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} (ou sa version courte \texttt{-R}), comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=10F220}.


\subsectionLabel{Opérations littérales avec \texttt{W}}{opBaselineImmediate}

Ces opérations sont listées dans le \refTableau{operationsLiteralesBaselineAvecW}. L’instruction \texttt{RETLW k} n’existe pas en Piccolo, l’optimiseur repérera une instruction \texttt{MOVLW k} en fin de routine et la transformera en \texttt{RETLW k}.

En Piccolo, \texttt{k} est une \emph{expression statique}. Une expression statique est une expression dont la valeur est calculée à la compilation. Sa forme générale est présentée à la \refSectionPage{expressionImmediate}. Le compilateur effectue tous les calculs d'une expression statique avec des nombres entiers 32 bits signés.

Pour être valide dans les opérations statiques avec \texttt{W}, le résultat devra être :
\begin{itemize}
  \item soit un nombre positif inférieur ou égal à 255 ;
  \item soit un nombre négatif supérieur ou égal à -128.
\end{itemize}

Par exemple : \texttt{movlw -14} engendre l’instruction assembleur : \texttt{MOVLW 0xf2}.


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{ANDLW k} & And Literal with W & \texttt{andlw k}\\
    \texttt{IORLW k} & Inclusive OR Literal with W & \texttt{iorlw k}\\
    \texttt{MOVLW k} & Move Literal to W & \texttt{movlw k}\\
    \texttt{XORLW k} & Exclusive OR Literal with W & \texttt{xorlw k}\\
    \hline
  \end{tabular}
  \caption{Opérations litérales avec \texttt{W} pour \emph{baseline}}
  \labelTableau{operationsLiteralesBaselineAvecW}
\end{table}


\subsectionLabel{Instructions identiques à celles de l’assembleur}{operationsBaselineIdentiquesAssembleur}

Ces instructions sont listées dans le \refTableau{operationsBaselineIdentiquesAssembleur}.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRWDT} & Clear Watchdog Timer & \texttt{clrwdt}\\
    \texttt{CLRW} & Clear W & \texttt{clrw}\\
    \texttt{NOP} & No Operation & \texttt{nop}\\
    \texttt{OPTION} & Load OPTION register & \texttt{option}\\
    \texttt{SLEEP} & Go into Standby Mode & \texttt{sleep}\\
    \hline
  \end{tabular}
  \caption{Instructions \emph{baseline} identiques en assembleur et en Piccolo}
  \labelTableau{operationsBaselineIdentiquesAssembleur}
\end{table}















\subsectionLabel{Instruction \texttt{TRIS}}{instructionTRIS}

En Piccolo, l'instruction \texttt{TRIS} a un opérande qui peut être: \texttt{GPIO}, \texttt{PORTA}, \texttt{PORTB}, \texttt{PORTC}, \texttt{PORTD} ou \texttt{PORTE}. Pour un composant donné, uniquement un sous-ensemble de ces valeurs est acceptable (\refTableau{TRISoperands}). D'une manière générale, pour que l'un des noms cités puisse être utilisé pour un composant donnée, il faut qu'il apparaisse parmi ses registres spéciaux (pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} ou sa version courte \texttt{-R}, comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=10F220}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{ll}
    \textbf{Composant} & \textbf{Instructions \texttt{TRIS} en Piccolo}\\
    \hline
    10F200, 10F202  & \texttt{tris GPIO}\\
    10F204, 10F206  & \texttt{tris GPIO}\\
    10F220  & \texttt{tris GPIO}\\
    12F508, 12F509  & \texttt{tris GPIO}\\
    12F510, 12F519  & \texttt{tris GPIO}\\
    16F505, 16F506  & \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F526  & \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F54  & \texttt{tris PORTA}, \texttt{tris PORTB}\\
    16F57  & \texttt{tris PORTA}, \texttt{tris PORTB}, \texttt{tris PORTC}\\
    16F59  & \texttt{tris PORTA}, \texttt{tris PORTB}, \texttt{tris PORTC}, \texttt{tris PORTD}, \texttt{tris PORTE}\\
    \hline
  \end{tabular}
  \caption{Instructions \texttt{tris} en Piccolo}
  \labelTableau{TRISoperands}
\end{table}












\subsectionLabel{Appeler une routine régulière}{appelRoutineReguliereBaseline}

Une routine régulière est une routine déclarée sans le qualificatif \texttt{noreturn}. L'appel s’effectue au moyen de l'instruction \texttt{CALL}.

Syntaxiquement, il faut simplement nommer la routine appelée après le nom de l’instruction d’appel :

\begin{lstlisting}[language=piccolo]
call nom_routine
\end{lstlisting}




\subsectionLabel{Appeler une routine sans retour}{appelRoutineSansRetourBaseline}

Appeler une routine sans retour (c'est-à-dire déclarée avec le qualificatif \texttt{noreturn}) s'effectue par une instruction \texttt{goto}. L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
goto nom_routine
\end{lstlisting}




\sectionLabel{Section \texttt{include}}{sectionIncludeBaseline}

Une section \texttt{include} permet d'inclure un fichier contenant lui-même des sections telles que définies dans le \refTableauPage{sectionsBaseline}.  Son format est le suivant :

\begin{lstlisting}[language=piccolo]
  include "chemin"
\end{lstlisting}

\texttt{chemin} est le chemin vers le fichier inclus, et est :
\begin{itemize}
  \item soit un chemin absolu (il commence par « \texttt{/} ») ;
  \item soit un chemin relatif par rapport au fichier source.
\end{itemize}

\sectionLabel{Gestion des pages de la mémoire programme}{gestionPagesBaseline}

La mémoire programme d'un \emph{baseline} est constituée d'une ou plusieurs pages de 512 instructions chacune. Le \refTableau{nombrePagesBaseline} cite quelques micro-contrôleurs \emph{baseline} et le nombre de pages de leur mémoire programme.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Composant} & \textbf{Mémoire programme} & \textbf{Nombre de pages}\\
    \hline
    10F200, 10F204  & 256 instructions & 1\\
    10F202, 10F206  & 512 instructions & 1\\
    10F220  & 256 instructions & 1\\
    12F508  & 512 instructions & 1\\
    12F509  & 1024 instructions & 2\\
    12F510, 12F519  & 1024 instructions & 2\\
    16F505, 16F506  & 1024 instructions & 2\\
    16F526 & 1024 instructions & 2\\
    16F54  & 512 instructions & 1\\
    16F57, 16F59  & 2048 instructions & 4\\
    \hline
  \end{tabular}
  \caption{Mémoire programme de quelques micro-contrôleurs \emph{baseline}}
  \labelTableau{nombrePagesBaseline}
\end{table}

Les deux instructions de branchement que le jeu d'instructions des \emph{baseline} définit sont \texttt{CALL} et \texttt{GOTO} (\refTableau{callGotoBaseline}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{3}{}{\fondTableau}
  \begin{tabular}{llllllllllllll}
    \textbf{Instruction} & \textbf{Description} & \multicolumn{12}{l}{\bf Code binaire}\\
                         &                      & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
    \hline
    \texttt{CALL k}  & Call subroutine & 1 & 0 & 0 & 1 & k & k & k & k & k & k & k & k\\
    \texttt{GOTO k}  & Go to Address   & 1 & 0 & 1 & k & k & k & k & k & k & k & k & k\\
    \hline
  \end{tabular}
  \caption{Instructions \texttt{CALL} et \texttt{GOTO} des \emph{baseline}}
  \labelTableau{callGotoBaseline}
\end{table}

En résumé, ces instructions ne permettent pas d'effectuer par elles mêmes un branchement à tout position de la mémoire programme :
\begin{itemize}
  \item un \texttt{CALL} utilisé seul exige que la routine appelée soit dans les 256 premiers octets de la page courante ;
  \item un \texttt{GOTO} utilisé seul permet d'effectuer un branchement à toute position de la page courante.
\end{itemize}

Pour changer de page, il faut modifier les bits \texttt{PA} du registre \texttt{STATUS} avant d'appeler l'instruction \texttt{CALL} ou \texttt{GOTO}.

Voici comment ces contraintes sont prises en compte en Piccolo :
\begin{itemize}
  \item une routine doit complètement résider à l'intérieur d'une page ;
  \item lors de la déclaration d'une routine, la page dans laquelle elle réside est précisée (\refSubsectionPage{declarationRoutineBaselineEtPage}) ;
  \item les instructions Piccolo \texttt{call} et \texttt{goto} effectuent des branchements à l'intérieur de la page courante ;
  \item pour appeler des routines placées dans une autre page, utiliser les instructions Piccolo \texttt{jsr} (\refSubsectionPage{instructionJsrBaseline}) et \texttt{jump} (\refSubsectionPage{instructionJumpBaseline}).
\end{itemize}



\subsectionLabel{Instruction \texttt{jump}}{instructionJumpBaseline}

L'instruction Piccolo  \texttt{jump} engendre des instructions machine \texttt{BCF} ou \texttt{BSF} pour modifier les bits \texttt{PA} du registre \texttt{STATUS}, puis l'instruction machine \texttt{GOTO}.

Elle occupe donc $n+1$ mots de la mémoire programme, $n$ étant le nombre de bits \texttt{PA} du registre \texttt{STATUS} à changer.




\subsectionLabel{Instruction \texttt{jsr}}{instructionJsrBaseline}

L'instruction Piccolo  \texttt{jsr} engendre des instructions machine \texttt{BCF} ou \texttt{BSF} pour modifier les bits \texttt{PA} du registre \texttt{STATUS}, puis l'instruction machine \texttt{CALL}, puis de nouveau des instructions machine \texttt{BCF} ou \texttt{BSF} pour rétablir les bits \texttt{PA} du registre \texttt{STATUS}.

Elle occupe donc $2n+1$ mots de la mémoire programme, $n$ étant le nombre de bits \texttt{PA} du registre \texttt{STATUS} à changer pour effectuer l'appel.

\subsectionLabel{Déclaration de routine et page}{declarationRoutineBaselineEtPage}

Pour spécifier dans quelle page de la mémoire programme une routine régulière doit résider, il suffit de la déclarer comme suit :
\begin{lstlisting}[language=piccolo]
  routine nom page numero_page {
    ...
  }
\end{lstlisting}

Où \texttt{numero\_page} est un entier positif ou nul strictement inférieur au nombre de pages.

Pour une routine régulière sans retour :
\begin{lstlisting}[language=piccolo]
  noreturn routine nom page numero_page {
    ...
  }
\end{lstlisting}

\subsection{Exemple}

Différents exemples sont donnés sur la page \url{http://piccolo.rts-software.org/examples/index.php}.

Le 12F510 a une mémoire programme de deux pages. 

\begin{lstlisting}[language=piccolo]
baseline pages_12F510 "12F510" :

noreturn routine main {
  mnop 249
  call regularRoutineInPage0
  jsr  regularRoutineInPage1
  jump routineInPage1
}

routine regularRoutineInPage0 {
  mnop 256
  movlw 0
}

noreturn routine routineInPage1 page 1 {
  forever
  end
}

routine regularRoutineInPage1 page 1 {
  movlw 0
}

end
\end{lstlisting}

Sans aucune optimisation, le code assembleur engendré est :

\begin{lstlisting}[language=assembleur]
Address Code Mnemonic
   0000        ORG 0x0
   0000 0000   NOP
   (248 lignes semblables)
   01F2 09FF   CALL regularRoutineInPage0
   01F4 05A3   BSF STATUS, 5
   01F6 0901   CALL regularRoutineInPage1
   01F8 04A3   BCF STATUS, 5
   01FA 05A3   BSF STATUS, 5
   01FC 0A00   GOTO routineInPage1
   01FE      ;  END OF ROUTINE main IN PAGE 0
   01FE      ;  BEGIN OF ROUTINE regularRoutineInPage0
   01FE      regularRoutineInPage0:
   01FE 0000   NOP
   (255 lignes semblables)
   03FE 0800   RETLW 0x0
   0400      ;  END OF ROUTINE regularRoutineInPage0 IN PAGE 0
   0400        ORG 0x200
   0400      ;  BEGIN OF ROUTINE routineInPage1
   0400      routineInPage1:
   0400      _label_0:
   0400 0A00   GOTO _label_0
   0402      ;  END OF ROUTINE routineInPage1 IN PAGE 1
   0402      ;  BEGIN OF ROUTINE regularRoutineInPage1
   0402      regularRoutineInPage1:
   0402 0800   RETLW 0x0
   0404      ;  END OF ROUTINE regularRoutineInPage1 IN PAGE 1
\end{lstlisting}








\section{Optimisation}

Cette section indique les différentes optimisations d'un code \emph{baseline}. L'optimisation est activée par l'option « \texttt{-o} ».

Pour optimiser, Piccolo applique les remplacements indiqués par le \refTableau{optimisationsBaseline}, et élimine le code mort. Le code est balayé de manière répétitive, tant que des optimisations sont effectuées.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{ll}
    \textbf{Situation} & \textbf{Optimisation} \\
    \hline
    \texttt{CALL} vers \texttt{RETLW k}  & Remplacement par \texttt{MOVLW k}\\
    \texttt{GOTO} vers \texttt{RETLW k}  & Remplacement par \texttt{RETLW k}\\
    \texttt{GOTO a} vers \texttt{GOTO b}  & Remplacement par \texttt{GOTO b}\\
    \texttt{GOTO} vers l'instruction qui suit  & Suppression\\
    \texttt{JSR} vers \texttt{RETLW k}  & Remplacement par \texttt{MOVLW k}\\
    \texttt{JUMP} vers \texttt{RETLW k}  & Remplacement par \texttt{RETLW k}\\
    \texttt{JUMP a} vers \texttt{JUMP b}  & Remplacement par \texttt{JUMP b}\\
    \texttt{JUMP a} vers \texttt{GOTO b}  & Remplacement par \texttt{JUMP b}\\
    \hline
  \end{tabular}
  \caption{Optimisation du code \emph{baseline}}
  \labelTableau{optimisationsBaseline}
\end{table}

