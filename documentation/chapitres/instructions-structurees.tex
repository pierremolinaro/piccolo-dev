%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapterLabel{Instructions structurées}{instructionsStructurees}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}

En Piccolo, il existe deux types d'instructions :
\begin{itemize}
  \item les instructions simples ;
  \item les instructions composées.
\end{itemize}

\textbf{Instructions simples.} Les instructions simples sont propres à type de micro-contrôleur (\emph{baseline}, \emph{mid-range} et \emph{pic18}) : elles sont donc présentées dans des sections disctinctes :
\begin{itemize}
  \item \emph{baseline} : \refSectionPage{instructionsSimplesBaseline} ;
  \item \emph{midrange} : \refSectionPage{instructionsSimplesMidRange} ;
  \item \emph{pic18} : \refSectionPage{instructionsSimplesPic18}.
\end{itemize}


\textbf{Instructions structurées.} Les instructions structurées sont en grande partie communes aux \emph{baseline}, \emph{mid-range} et \emph{pic18} : aussi elles sont présentées dans ce chapitre commun.

Piccolo définit les instructions structurées suivantes :
\begin{itemize}
  \item l'instruction \piccolo{mnop} (\refSectionPage{instructionMNOP}) ;
  \item l'instruction conditionnelle simple (\refSectionPage{instructionConditionnelleSimple}) ;
  \item l'instruction conditionnelle structurée (\refSectionPage{instructionConditionnelleStructuree}) ;
  \item l'instruction répétitive (\refSectionPage{instructionRepetitive}) ;
  \item l'instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item l'instruction de répétition statique (\refSectionPage{repetitionStatique}) ;
  \item l'instruction \piccolo{block} (\refSectionPage{instructionBloc}) ;
  \item l'instruction \piccolo{computed retlw} (\refSubsectionPage{instructionComputedRetlw}) ;
  \item l'instruction \piccolo{computed bra} (\refSubsectionPage{instructionComputedBra}) ;
  \item l'instruction \piccolo{computed goto} (\refSubsectionPage{instructionComputedGoto}) ;
  \item l'instruction \piccolo{banksel} (\refSubsectionPage{instructionBanksel}) ;
  \item l'instruction \piccolo{nobank} (\refSubsectionPage{instructionNoBank}) ;
  \item l'instruction \piccolo{banksave} (\refSubsectionPage{instructionBanksave}).
\end{itemize}

\sectionLabel{Instruction \texttt{mnop}}{instructionMNOP}

Cette instruction n'existe pas en assembleur. En Piccolo, \piccolo{mnop k} engendre une séquence de \piccolo{k} instructions \assembleur{NOP}.

\piccolo{k} est une expression statique. La forme générale des expressions statiques est donnée à la \refSectionPage{expressionImmediate}. Une expression statique est évaluée à la compilation. Le compilateur effectue tous les calculs avec des nombres entiers 32 bits signés.





\sectionLabel{Instruction conditionnelle simple}{instructionConditionnelleSimple}

Ces instructions permettent d'exploiter directement les instructions assembleur qui ignorent conditionnellement l'instruction qui les suit, c'est à dire :
\begin{itemize}
\item pour les \emph{baseline} et les \emph{mid-range} : \assembleur{DECFSZ}, \assembleur{INCFSZ}, \assembleur{BTFSC} et \assembleur{BTFSS} ;
\item pour les \emph{pic18} : \assembleur{CPFSEQ}, \assembleur{CPFSGT}, \assembleur{CPFSLT}, \assembleur{DECFSZ}, \assembleur{DCFSNZ}, \assembleur{INCFSZ}, \assembleur{INFSNZ}, \assembleur{TSTFSZ}, \assembleur{BTFSC} et \assembleur{BTFSS}.
\end{itemize}

La syntaxe de l'instruction conditionnelle simple est la suivante :

\begin{lstlisting}[language=piccolo]
if condition_simple : instruction_simple
\end{lstlisting}

Noter que l'instruction exécutée conditionnellement ne peut être qu'une instruction simple.

Noter aussi la différence suivante : l'instruction assembleur indique la condition de saut de l'instruction suivante, tandis que le conditionnelle simple nomme sa condition d'exécution, c'est à dire son complémentaire.

Pour les \emph{pic18}, seules trois comparaisons d'un registre avec \piccolo{W} existent pour l'instruction conditionnelle simple : elles correspondent aux instructions assembleur \assembleur{CPFSEQ}, \assembleur{CPFSGT} et \assembleur{CPFSLT}. L'instruction conditionnelle structurée implémente les six comparaisons.

Pour le test individuel d'un bit, la notation \piccolo{registre.bit} est utilisée : celle-ci est présentée \refSubsectionPage{opBaselineAffectationBit} (\emph{baseline}), \refSubsectionPage{opMidRangeAffectationBit} (\emph{mid-range}) et \refSubsectionPage{opPic18AffectationBit} (\emph{pic18}).

Le \refTableau{instructionsConditionnellesSimplesBaseline} donne la liste de toutes les instructions conditionnelles simples pour les \emph{baseline} et \emph{mid-range}, et le \refTableau{instructionsConditionnellesSimplesPic18} pour celles des \emph{pic18}.

\begin{table}[!ht]
  \centering
  \small
%  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lp{4cm}lll}
    \textbf{Instruction} & \textbf{Code engendré}\\
    \hline
    \piccolo{if reg.bit : instruction} & \assembleur{BTFSC reg, bit instruction} \\
    \hdashline
    \piccolo{if ! reg.bit : instruction} & \assembleur{BTFSS reg, bit instruction} \\
    \hdashline
    \piccolo{if decf reg nz : instruction} & \assembleur{DECFSZ reg instruction} \\
    \hdashline
    \piccolo{if decf reg, W nz : instruction} & \assembleur{DECFSZ reg, W instruction} \\
    \hdashline
    \piccolo{if incf reg nz : instruction} & \assembleur{INCFSZ reg instruction} \\
    \hdashline
    \piccolo{if incf reg, W nz : instruction} & \assembleur{INCFSZ reg, W instruction} \\
    \hline
  \end{tabular}
  \caption{Instructions conditionnelles simples pour \emph{baseline} et \emph{mid-range}}
  \labelTableau{instructionsConditionnellesSimplesBaseline}
\end{table}

\begin{table}[!ht]
  \centering
  \small
%  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lp{4cm}lll}
    \textbf{Instruction} & \textbf{Code engendré}\\
    \hline
    \piccolo{if reg != W : instruction} & \assembleur{CPFSEQ reg instruction} \\
    \hdashline
    \piccolo{if reg >= W : instruction} & \assembleur{CPFSLT reg instruction} \\
    \hdashline
    \piccolo{if reg <= W : instruction} & \assembleur{CPFSGT reg instruction} \\
    \hdashline
    \piccolo{if reg nz : instruction} & \assembleur{TSTFSZ reg instruction} \\
    \hdashline
    \piccolo{if reg.bit : instruction} & \assembleur{BTFSC reg, bit instruction} \\
    \hdashline
    \piccolo{if ! reg.bit : instruction} & \assembleur{BTFSS reg, bit instruction} \\
    \hdashline
    \piccolo{if decf reg z : instruction} & \assembleur{DCFSNZ reg instruction} \\
    \hdashline
    \piccolo{if decf reg, W z : instruction} & \assembleur{DCFSNZ reg, W instruction} \\
    \hdashline
    \piccolo{if decf reg nz : instruction} & \assembleur{DECFSZ reg instruction} \\
    \hdashline
    \piccolo{if decf reg, W nz : instruction} & \assembleur{DECFSZ reg, W instruction} \\
    \hdashline
    \piccolo{if incf reg z : instruction} & \assembleur{INFSNZ reg instruction} \\
    \hdashline
    \piccolo{if incf reg, W z : instruction} & \assembleur{INFSNZ reg, W instruction} \\
    \hdashline
    \piccolo{if incf reg nz : instruction} & \assembleur{INCFSZ reg instruction} \\
    \hdashline
    \piccolo{if incf reg, W nz : instruction} & \assembleur{INCFSZ reg, W instruction} \\
    \hline
  \end{tabular}
  \caption{Instructions conditionnelles simples pour \emph{pic18}}
  \labelTableau{instructionsConditionnellesSimplesPic18}
\end{table}




\sectionLabel{Instruction conditionnelle structurée}{instructionConditionnelleStructuree}

L'instruction conditionnelle est une construction classique des langages de programmation et accepte zéro, un ou plusieurs blocs \piccolo{elsif}, et zéro ou un bloc \piccolo{else} ; voici différents exemples, \piccolo{cca}, \piccolo{ccb} et \piccolo{ccc} étant des expressions conditionnelles (voir \refSectionPage{formeGeneraleConditions}).


Pas de branche \piccolo{elsif} ni \piccolo{else} :
\begin{lstlisting}[language=piccolo]
if (cca)
  instructions 1
end
\end{lstlisting}

Pas de branche \piccolo{elsif} et une branche \piccolo{else} :
\begin{lstlisting}[language=piccolo]
if (cca)
  instructions 1
else
  instructions 3
end
\end{lstlisting}

Une branche \piccolo{elsif} et une branche \piccolo{else} :
\begin{lstlisting}[language=piccolo]
if (cca)
  instructions 1
elsif (ccb)
  instructions 2
else
  instructions 3
end
\end{lstlisting}

Plusieurs branches \piccolo{elsif}, pas de branche \piccolo{else} :
\begin{lstlisting}[language=piccolo]
if (cca)
  instructions 1
elsif (ccb)
  instructions 2
elsif (ccc)
  instructions 3
end
\end{lstlisting}





\sectionLabel{Instruction de répétition infinie}{repetitionInfinie}

Cette instruction exprime la répétition infinie des instructions qu'elle contient.
\begin{lstlisting}[language=piccolo]
forever
  liste d'instructions simples ou structurees
end
\end{lstlisting}

Implémentation : la répétition infinie est simplement réalisée par une instruction de \piccolo{jump} (pour les \emph{pic18}) ou \piccolo{goto} (pour les \emph{baseline} et \emph{mid-range}), placée à la fin de la séquence d'instructions, qui renvoie l'exécution au début de la séquence.





\sectionLabel{Instruction de répétition statique}{repetitionStatique}

\textbf{À partir de Piccolo 3.0.3.}


Cette instruction a la syntaxe suivante :
\begin{lstlisting}[language=piccolo]
do (expression)
  liste d'instructions simples ou structurees
end
\end{lstlisting}

L'\piccolo{expression} est une expression statique, c'est-à-dire calculée à la compilation, qui doit être strictement positive. Cette expression spécifie le nombre de fois que le corps de la boucle est répété. La répétition est organisée par le compilateur, le code engendré est \piccolo{expression} fois le corps de la boucle.

Par exemple, le code suivant :
\begin{lstlisting}[language=piccolo]
do (3)
  bcf PORTA.0
  nop
  bsf PORTA.0
end
\end{lstlisting}

Est équivalent à :
\begin{lstlisting}[language=piccolo]
bcf PORTA.0
nop
bsf PORTA.0
bcf PORTA.0
nop
bsf PORTA.0
bcf PORTA.0
nop
bsf PORTA.0
\end{lstlisting}


Pour les \emph{pic18} et les \emph{mid-range}, le corps de la boucle ne doit pas changer la sélection de banc.








\sectionLabel{Instruction répétitive}{instructionRepetitive}


L'instruction répétitive a une structure moins répandue car elle accepte un ou plusieurs blocs \piccolo{while} ; voici plusieurs exemples, \piccolo{cca}, \piccolo{ccb} et \piccolo{ccc} étant des expressions conditionnelles (voir \refSectionPage{formeGeneraleConditions}).


Voici un premier exemple, qui a une exécution équivalente à l'instruction \texttt{while (cca) do \{ instructions \}} du langage C (\refFigure{}{organigrammeDoWhile1}) :
\begin{lstlisting}[language=piccolo]
do
while (cca)
  instructions
end
\end{lstlisting}

\begin{figure}[!ht]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=10mm
    ]
    \node [cloud] (start) {\textsc{début}} ;
    \node [decision] (cca) [below=of start] {\tt cca ?} ;
    \node [block] (instr) [right=of cca] {\tt instructions} ;
    \node [cloud] (end) [below=of cca] {\textsc{fin}} ;
    
    \draw [          thick] (start) -- (cca) ;
    \draw [-stealth, thick] (cca) to node[right] {\bf faux} (end) ;
    \draw [-stealth, thick] (cca.east) to node[above] {\bf vrai} (instr) ;
    \draw [-stealth, thick] (instr.east) -- +(1, 0) -- +(1, 1) -| (cca.north) ;
  \end{tikzpicture}
  \caption{Organigramme d'exécution d'une instruction équivalente au  \texttt{while} \texttt{do} du langage C}
  \labelFigure{organigrammeDoWhile1}
\end{figure}

La construction suivante a une exécution équivalente à l'instruction \texttt{do \{ instructions \} while (cca) ;} du langage C (\refFigure{}{organigrammeDoWhile2}) :
\begin{lstlisting}[language=piccolo]
do
  instructions
while (cca)
end
\end{lstlisting}

\begin{figure}[!ht]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=10mm
    ]
    \node [cloud] (start) {\textsc{début}} ;
    \node [block] (init) [below=of start] {\tt instructions} ;
    \node [decision] (cca) [below=of init] {\tt cca ?} ;
    \node [cloud] (end) [below=of cca] {\textsc{fin}} ;
    
    \draw [          thick] (start) -- (init) ;
    \draw [-stealth, thick] (init) -- (cca) ;
    \draw [-stealth, thick] (cca) to node[right] {\bf faux} (end) ;
    \draw [-stealth, thick] (cca.east) to node[above] {\bf vrai} +(1.5, 0) -- +(1.5, 2.3) -| (init.north) ;
  \end{tikzpicture}
  \caption{Organigramme d'exécution d'une instruction équivalente au \texttt{do} \texttt{while} du langage C}
  \labelFigure{organigrammeDoWhile2}
\end{figure}

Enfin, voici un exemple avec deux branches \piccolo{while} (\refFigure{}{organigrammeDoWhile3}) :
\begin{lstlisting}[language=piccolo]
do
  instructions 1
while (cca)
  instructions 2
while (ccb)
  instructions 3
end
\end{lstlisting}

\begin{figure}[!ht]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=10mm
    ]
    \node [cloud] (start) {\textsc{début}} ;
    \node [block] (init) [below=of start] {\tt instructions 1} ;
    \node [decision] (premierTest) [below=of init] {\tt cca ?} ;
    \node [block] (instr2) [right=of premierTest] {\tt instructions 2} ;
    \node [decision] (test2) [below=of premierTest] {\tt ccb ?} ;
    \node [block] (instr3) [right=of test2] {\tt instructions 3} ;
    \node [cloud] (end) [below=of test2] {\textsc{fin}} ;
    
    \draw [          thick] (start) -- (init) ;
    \draw [-stealth, thick] (init) -- (premierTest) ;
    \draw [-stealth, thick] (premierTest) to node[above] {\bf vrai} (instr2) ;
    \draw [-stealth, thick] (premierTest) to node[right] {\bf faux} (test2) ;
    \draw [-stealth, thick] (test2) to node[above] {\bf vrai} (instr3) ;
    \draw [-stealth, thick] (test2) to node[right] {\bf faux} (end) ;
    \draw [-stealth, thick] (instr3.east) -- +(1, 0) -- +(1, 4) -| (init.north) ;
    \draw [-stealth, thick] (instr2.east) -- +(1, 0) ;
  \end{tikzpicture}
  \caption{Organigramme d'exécution d'une instruction \texttt{do} avec deux branches \texttt{while}}
  \labelFigure{organigrammeDoWhile3}
\end{figure}




\sectionLabel{Forme générale des conditions}{formeGeneraleConditions}


Les instructions conditionnelles structurées (\refSectionPage{instructionConditionnelleStructuree}) et les instructions répétitives (\refSectionPage{instructionRepetitive}) acceptent les mêmes formes de conditions, qui sont des expressions :\begin{itemize}
  \item dont les conditions élémentaires sont données à la \refSubsectionPage{conditionsElementairesPic18} (\emph{pic18}) ;
  \item dont les opérateurs sont la négation \piccolo{\!}, le \emph{et logique} \piccolo{&}, le \emph{ou logique} \piccolo{|} ;
  \item utilisant les parenthèses \piccolo{(} et \piccolo{)} pour forcer le groupement.
\end{itemize}

\textbf{La négation \piccolo{\!}.} C'est un opérateur unaire préfixé : si \piccolo{cc} est une condition, \piccolo{\!cc} exprime la condition complémentaire. % Noter que la négation est résolue lors de la compilation, ainsi par exemple les conditions (registre z) et (! registre nz) engendrent exactement le même code.


\textbf{Le \emph{et logique} \piccolo{\&}.} C'est un opérateur infixe : si \piccolo{cc1} et \piccolo{cc2} sont deux conditions, \piccolo{cc1 \& cc2} exprime le \emph{et logique} de ces deux conditions. Son fonctionnement est du type court-circuit : \piccolo{cc1} est toujours évaluée la première et, si elle est évaluée fausse, \piccolo{cc2} n'est pas évaluée. Ce point est important si l'évaluation de la seconde condition a un effet de bord (c'est le cas des conditions nommant \piccolo{decf} ou \piccolo{incf}).

\textbf{Le \emph{ou logique} \piccolo{|}.} De même, c'est un opérateur infixe : \piccolo{cc1 | cc2} exprime le \emph{ou logique} de ces deux conditions. Son fonctionnement est aussi du type court-circuit : \piccolo{cc1} est toujours évaluée la première et, si elle est évaluée vraie, \piccolo{cc2} n'est pas évaluée.

\textbf{Priorité des opérateurs.} La négation \piccolo{\!} est l'opérateur le plus prioritaire, le \emph{ou logique} \piccolo{|} le moins prioritaire. Par exemple, \piccolo{\!cc1\&cc2} est équivalent à \piccolo{(\!cc1)\&cc2} et \piccolo{cc1|cc2\&cc3} est équivalent à \piccolo{cc1|(cc2\&cc3)}.

\textbf{Associativité des opérateurs.} Le \emph{et logique} \piccolo{\&} et le \emph{ou logique} \piccolo{|} sont associatifs à gauche. Par exemple, \piccolo{cc1\&cc2\&cc3} est équivalent à \piccolo{(cc1\&cc2)\&cc3}.


\subsectionLabel{Conditions élémentaires pour \emph{baseline} et \emph{mid-range}}{conditionsElementairesBaselineMidRange}

Les conditions élémentaires exploitent les quatre instructions conditionnelles des \emph{baseline} et des \emph{mid-range} : \assembleur{BTFSC}, \assembleur{BTFSS}, \assembleur{DECFSZ} et \assembleur{INCFSZ}. Les conditions exprimables en Piccolo peuvent être classées en deux groupes :
\begin{itemize}
  \item les conditions basées sur le test d'un bit d'un registre (\refTableau{conditionsElementairesBaselineTestRegistre}) ;
  \item les conditions basées sur la décrémentation ou l'incrémentation d'un registre (\refTableau{conditionsElementairesBaseLineIncDecRegistre}).
\end{itemize}


Les conditions basées sur le test d'un bit d'un registre sont listées dans le \refTableau{conditionsElementairesBaselineTestRegistre}.

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{lll}
    \textbf{Condition} & \textbf{Signification} & \textbf{Code engendré}\\
    \hline
                           \piccolo{reg.bit}  & reg.bit $\ne$ 0 ? &\assembleur{BTFSS reg,bit}\\
                                        &                        & \assembleur{GOTO label}\\
    \hdashline
    \piccolo{\! reg.bit}  & reg.bit = 0 ? & \assembleur{BTFSC reg,bit} \\
                        &                    & \assembleur{GOTO label}\\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{baseline} et \emph{mid-range} basées sur le test d'un bit d'un registre}
  \labelTableau{conditionsElementairesBaselineTestRegistre}
\end{table}


Le \refTableau{conditionsElementairesBaseLineIncDecRegistre} liste les conditions basées sur les instructions \assembleur{DECFSZ} et \assembleur{INCFSZ}. La non symétrie du jeu d'instructions provoquent des codes engendrés de tailles différentes selon les conditions exprimées. 

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{lllll}
    \textbf{Condition} & \textbf{Signification} & \textbf{Code engendré}\\
    \hline
    \piccolo{decf reg z}   & reg := reg - 1 ; reg = 0 ?  & \assembleur{DECFSZ reg}  \\
                           &                             & \assembleur{GOTO \$ + 2} \\
                           &                             & \assembleur{GOTO label}  \\
    \hdashline
    \piccolo{decf reg, W z} & WREG := reg - 1 ; WREG = 0 ? & \assembleur{DECFSZ reg, W} \\
                            &                              & \assembleur{GOTO \$ + 2}   \\
                            &                              & \assembleur{GOTO label}    \\
    \hdashline
    \piccolo{decf reg nz}  & reg := reg - 1 ; reg $\ne$ 0 ?   &\assembleur{DECFSZ reg} \\
                           &                                  &\assembleur{GOTO label}   \\
    \hdashline
    \piccolo{decf reg, W nz} & WREG := reg - 1 ; WREG $\ne$ 0 ?  &\assembleur{DECFSZ reg, W}  \\
                             &                                   &\assembleur{GOTO label}        \\
    \hdashline
    \piccolo{incf reg z} & reg := reg + 1 ; reg = 0 ? &\assembleur{INCFSZ reg} \\
                         &                            &\assembleur{GOTO \$ + 2} \\
                         &                            &\assembleur{GOTO label} \\
    \hdashline
    \piccolo{incf reg, W z} & WREG := reg + 1 ; WREG = 0 ? &\assembleur{INCFSZ reg, W} \\
                            &                              &\assembleur{GOTO \$ + 2}          \\
                            &                              &\assembleur{GOTO label}          \\
    \hdashline
    \piccolo{incf reg nz} & reg := reg + 1 ; reg $\ne$ 0 ? &\assembleur{INCFSZ reg}\\
                          &                                &\assembleur{BRA label}   \\
    \hdashline
    \piccolo{incf reg, W nz} & WREG := reg + 1 ; WREG $\ne$ 0 ? & \assembleur{INCFSZ reg, W}  \\
                             &                                  & \assembleur{GOTO label}         \\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{baseline} et \emph{mid-range} basées sur la décrémentation et l'incrémentation d'un registre}
  \labelTableau{conditionsElementairesBaseLineIncDecRegistre}
\end{table}





\subsectionLabel{Conditions élémentaires pour \emph{pic18}}{conditionsElementairesPic18}

Les conditions élémentaires exploitent les différentes instructions conditionnelles des \emph{pic18}. L'abondance de ces instructions engendre une liste très fournie :
\begin{itemize}
  \item les conditions basées sur les instructions de saut conditionnelles (\refTableau{conditionsElementairesPic18SautConditionnel}) ;
  \item les conditions basées sur la comparaison d'un registre avec \assembleur{WREG} (\refTableau{conditionsElementairesPic18ComparaisonsW}) ;
  \item les conditions basées sur le test d'un registre ou de l'un de ses bits (\refTableau{conditionsElementairesPic18TestRegistre}) ;
  \item les conditions basées sur la décrémentation ou l'incrémentation d'un registre (\refTableau{conditionsElementairesPic18IncDecRegistre}).
\end{itemize}


Les instructions de saut conditionnel permettent d'exploiter directement la valeur des bits du registre \assembleur{STATUS}. Les conditions correspondantes sont listées dans le \refTableau{conditionsElementairesPic18SautConditionnel}. Leur compilation engendre un code de 2, 4 ou 6 octets, selon l'amplitude du branchement. Piccolo engendre toujours le code le plus petit possible.

\begin{table}[!ht]
  \centering
  \small
%  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lp{3.5cm}lp{2.2cm}p{2.5cm}}
    \textbf{Condition} & \textbf{Signification} & \multicolumn{3}{l}{\bf Code engendré}\\
                       &                        & \textbf{2 octets} & \textbf{4 octets} & \textbf{6 octets}\\
    \hline
    \piccolo{c} & \assembleur{STATUS.C} $\ne$ 0 ? &\assembleur{BC label}  & \assembleur{BNC \$ + 4} & \assembleur{BNC \$ + 6} \\
                &                                 &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{nc} & \assembleur{STATUS.C} = 0 ? &\assembleur{BNC label}  & \assembleur{BC \$ + 4}  & \assembleur{BC \$ + 6} \\
                &                              &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{z} & \assembleur{STATUS.Z} $\ne$ 0 ? &\assembleur{BZ label}  & \assembleur{BNZ \$ + 4}  & \assembleur{BNZ \$ + 6} \\
                &                                 &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{nz} & \assembleur{STATUS.Z} = 0 ? &\assembleur{BNZ label}  & \assembleur{BZ \$ + 4}  & \assembleur{BZ \$ + 6} \\
                &                              &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{n} & \assembleur{STATUS.N} $\ne$ 0 ? &\assembleur{BN label}  & \assembleur{BNN \$ + 4}  & \assembleur{BNN \$ + 6} \\
                &                                 &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{nn} & \assembleur{STATUS.N} = 0 ? &\assembleur{BNN label}  & \assembleur{BN \$ + 4}  & \assembleur{BN \$ + 6} \\
                &                              &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{ov} & \assembleur{STATUS.OV} $\ne$ 0 ? &\assembleur{BOV label}  & \assembleur{BNOV \$ + 4}  & \assembleur{BNOV \$ + 6} \\
                &                                   &                       & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hdashline
    \piccolo{nov} & \assembleur{STATUS.OV} = 0 ? &\assembleur{BNOV label}  & \assembleur{BOV \$ + 4}  & \assembleur{BOV \$ + 6} \\
                &                                &                         & \assembleur{BRA label}  & \assembleur{GOTO label} \\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{pic18} basées sur les instructions de saut conditionnel}
  \labelTableau{conditionsElementairesPic18SautConditionnel}
\end{table}


La comparaison du contenu d'un registre avec la valeur de \assembleur{WREG} est effectuée par les instructions assembleur \assembleur{CPFSEQ}, \assembleur{CPFSLT} et \assembleur{CPFSGT}. En Piccolo, les 6 comparaisons sont possibles, et la non symétrie des instructions assembleur provoque la génération d'un code pouvant atteindre 8 octets. Piccolo engendre toujours le code le plus petit possible. Le \refTableau{conditionsElementairesPic18ComparaisonsW} liste ces conditions.

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{llll}
    \textbf{Condition} & \multicolumn{3}{l}{\bf Code engendré}\\
                       & \textbf{4 octets} & \textbf{6 octets} & \textbf{8 octets}\\
    \hline
    \piccolo{reg != W} &\assembleur{CPFSEQ reg}  & \assembleur{CPFSEQ reg}  &  \\
                      &\assembleur{BRA label}        & \assembleur{GOTO label}  &  \\
    \hdashline
    \piccolo{reg >= W} &\assembleur{CPFSLT reg}  & \assembleur{CPFSLT reg}  &  \\
                      &\assembleur{BRA label}        & \assembleur{GOTO label}  &  \\
    \hdashline
    \piccolo{reg <= W} &\assembleur{CPFSGT reg}  & \assembleur{CPFSGT reg}  &  \\
    \piccolo{reg <= W} &\assembleur{BRA label}        & \assembleur{GOTO label}  &  \\
    \hdashline
    \piccolo{reg == W} & &\assembleur{CPFSEQ reg}  & \assembleur{CPFSEQ reg}  \\
                      & &\assembleur{BRA \$ + 4}       & \assembleur{BRA \$ + 6}  \\
                      & &\assembleur{BRA label}        & \assembleur{GOTO label}  \\
    \hdashline
    \piccolo{reg > W}  & &\assembleur{CPFSGT reg}  & \assembleur{CPFSGT reg}  \\
                      & &\assembleur{BRA \$ + 4}       & \assembleur{BRA \$ + 6}  \\
                      & &\assembleur{BRA label}        & \assembleur{GOTO label}  \\
    \hdashline
    \piccolo{reg > W}  & &\assembleur{CPFSLT reg}  & \assembleur{CPFSLT reg}  \\
                      & &\assembleur{BRA \$ + 4}       & \assembleur{BRA \$ + 6}  \\
                      & &\assembleur{BRA label}        & \assembleur{GOTO label}  \\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{pic18} basées sur les comparaisons avec \texttt{WREG}}
  \labelTableau{conditionsElementairesPic18ComparaisonsW}
\end{table}

Les conditions basées sur le test d'un registre sont listées dans le \refTableau{conditionsElementairesPic18TestRegistre}. Remarquer que les conditions listées ne sont pas toutes élémentaires. Ainsi, la condition \piccolo{\!registre nz} est équivalente à \piccolo{registre z}, et \piccolo{\!registre z} équivalente à \piccolo{registre nz}. Remarquer aussi que l'absence d'instruction complémentaire à \assembleur{TSTFSZ} entraîne un code plus long pour la condition \piccolo{registre z}.

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{lllll}
    \textbf{Condition} & \textbf{Signification} & \multicolumn{2}{l}{\bf Code engendré}\\
                       &                        & \textbf{Court} & \textbf{Long}\\
    \hline
                           \piccolo{reg nz}   & reg $\ne$ 0 ? &\assembleur{TSTFSZ reg}  & \assembleur{TSTFSZ reg}\\
                                                  &                 &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hdashline
    \piccolo{reg z}    & reg = 0 ? &\assembleur{TSTFSZ reg}  & \assembleur{TSTFSZ reg}\\
                           &                &\assembleur{BRA \$ + 4}       & \assembleur{BRA \$ + 6}  \\
                           &                 &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hdashline
                           \piccolo{reg.bit}  & reg.bit $\ne$ 0 ? &\assembleur{BTFSS reg,bit}  & \assembleur{BTFSS reg,bit}\\
                                                  &                     &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hdashline
    \piccolo{\! reg.bit}  & reg.bit = 0 ? &\assembleur{BTFSC reg,bit}  & \assembleur{BTFSC reg,bit}\\
                             &                     &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{pic18} basées sur le test d'un registre}
  \labelTableau{conditionsElementairesPic18TestRegistre}
\end{table}


Enfin, le \refTableau{conditionsElementairesPic18IncDecRegistre} liste les conditions basées sur les instructions \assembleur{DECFSZ}, \assembleur{DECFSZ}, \assembleur{INCFSZ} et \assembleur{INFSNZ}. Là encore, elles ne sont pas toutes élementaires : par exemple, \piccolo{decf registre nz} est équivalente à \piccolo{\! decf registre z}. 

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{lllll}
    \textbf{Condition} & \textbf{Signification} & \multicolumn{2}{l}{\bf Code engendré}\\
                       &                        & \textbf{Court} & \textbf{Long}\\
    \hline
      \piccolo{decf reg z}   & reg := reg - 1 ;   &\assembleur{DCFSNZ reg}  & \assembleur{DCFSNZ reg}\\
                             &  reg = 0 ?         &\assembleur{BRA label}   & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{decf reg, W z} & WREG := reg - 1 ;  &\assembleur{DCFSNZ reg, W}  & \assembleur{DCFSNZ reg, W}\\
                              & WREG = 0 ?         &\assembleur{BRA label}      & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{decf reg nz}  & reg := reg - 1 ; &\assembleur{DECFSZ reg}  & \assembleur{DECFSZ reg}\\
                             & reg $\ne$ 0 ?    &\assembleur{BRA label}   & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{decf reg, W nz} & WREG := reg - 1 ; &\assembleur{DECFSZ reg, W}  & \assembleur{DECFSZ reg, W}\\
                               & WREG $\ne$ 0 ?    &\assembleur{BRA label}      & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{incf reg z}   & reg := reg + 1 ; &\assembleur{INFSNZ reg}  & \assembleur{INFSNZ reg}\\
                             & reg = 0 ?        &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{incf reg, W z} & WREG := reg + 1 ; &\assembleur{INFSNZ reg, W}  & \assembleur{INFSNZ reg, W}\\
                              & WREG = 0 ?        &\assembleur{BRA label}           & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{incf reg nz}  & reg := reg + 1 ; &\assembleur{INCFSZ reg}  & \assembleur{INCFSZ reg}\\
                             & reg $\ne$ 0 ?    &\assembleur{BRA label}        & \assembleur{GOTO label}\\
    \hdashline
      \piccolo{incf reg, W nz} & WREG := reg + 1 ; &\assembleur{INCFSZ reg, W}  & \assembleur{INCFSZ reg, W}\\
                               & WREG $\ne$ 0 ?    &\assembleur{BRA label}           & \assembleur{GOTO label}\\
    \hline
  \end{tabular}
  \caption{Conditions pour \emph{pic18} basées sur la décrémentation et l'incrémentation d'un registre}
  \labelTableau{conditionsElementairesPic18IncDecRegistre}
\end{table}







\section{Instructions \texttt{computed}}

\subsectionLabel{Instruction \texttt{computed retlw}}{instructionComputedRetlw}

\textcolor{red}{\bf Cette instruction n'est valide que pour les \emph{pic18}.}

\textbf{Description.} L'instruction \piccolo{computed retlw} est la suivante :
\begin{lstlisting}[language=piccolo]
computed [n] retlw cst0, cst1, cst2, ...
\end{lstlisting}

$n$ est une \emph{expression statique} et doit être égale au nombre des constantes citées après \piccolo{retlw}. Ce codage redondant permet de s'assurer que la liste des constantes présente une longueur correcte. Chaque \piccolo{cst_...} doit avoir une valeur comprise entre -128 et 255.

L'implémentation limite à 128 la valeur de $n$.

\textbf{Fonctionnement.} Cette instruction remplace la valeur de \assembleur{WREG} par la constante qui lui correspond : \piccolo{cst0} pour $0$, \piccolo{cst1} pour $1$, …, \piccolo{cst$_{n-1}$} pour $n-1$. 

\textbf{Limitation.} À l'exécution, il est nécessaire que la valeur non signée de \assembleur{WREG} soit strictement inférieur au nombre de constantes. \textcolor{red}{\bf Le code engendré par Piccolo n'effectue aucune vérification.} Il est donc probable que ne pas respecter cette règle entraîne un plantage du programme.


\textbf{Exemple.} Voici comment un chiffre hexadécimal peut être transformé en le caractère ASCII le représentant :
\begin{lstlisting}[language=piccolo]
routine CONVERSION_HEX_ASCII {
  andlw   0x0F
  computed [16] retlw
   '0', '1', '2', '3', '4', '5', '6', '7',
   '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
}
\end{lstlisting}

Le code assembleur engendré est le suivant :
\begin{lstlisting}[language=assembleur]
CONVERSION_HEX_ASCII:
  ANDLW   0x0F
  RCALL  _computed_goto_2
  RETLW  '0'
  RETLW  '1'
  RETLW  '2'
  RETLW  '3'
  RETLW  '4'
  RETLW  '5'
  RETLW  '6'
  RETLW  '7'
  RETLW  '8'
  RETLW  '9'
  RETLW  'A'
  RETLW  'B'
  RETLW  'C'
  RETLW  'D'
  RETLW  'E'
  RETLW  'F'
\end{lstlisting}

Si la distance d'appel est trop longue pour une instruction \assembleur{RCALL}, une instruction \assembleur{CALL} est utilisée.

Ce code fait appel à la routine \assembleur{\_computed\_goto\_2} qui est ajoutée automatiquement si nécessaire, à la fin du code (\refSubsectionPage{implementationComputedGoto}). 

\subsectionLabel{Instruction \texttt{computed bra}}{instructionComputedBra}

\textcolor{red}{\bf Cette instruction n'est valide que pour les \emph{pic18}.}

\textbf{Description.} Celle-ci est :
\begin{lstlisting}[language=piccolo]
computed [n] bra routine0, routine1, routine2, ...
\end{lstlisting}

$n$ est une \emph{expression statique} doit être égal au nombre de routines citées après \piccolo{bra}. Ce codage redondant permet de s'assurer que la liste des routines présente une longueur correcte. Les routines citées doivent toutes être sans retour (c'est-à-dire déclarées avec le qualificatif \piccolo{noreturn}), et pouvoir être atteintes par une instruction \piccolo{bra} (si ce n'est pas possible, utiliser le \piccolo{computed goto} décrite à la \refSubsectionPage{instructionComputedGoto}).

L'implémentation limite à 128 la valeur de $n$.

\textbf{Fonctionnement.} Cette instruction agit comme une instruction de branchement en fonction de la valeur de \assembleur{WREG} : branchement vers \piccolo{routine0} pour 0, vers \piccolo{routine1} pour 1, ..., vers \texttt{routine}$_{n-1}$ pour $n-1$. 

\textbf{Limitation.} À l'exécution, il est nécessaire que la valeur non signée de \assembleur{WREG} soit strictement inférieur au nombre de routines. \textcolor{red}{\bf Le code engendré par Piccolo n'effectue aucune vérification.} Il est donc probable que ne pas respecter cette règle entraîne un plantage du programme.

Ce code fait appel à la routine \assembleur{\_computed\_goto\_2} qui est ajoutée automatiquement si nécessaire, à la fin du code (\refSubsectionPage{implementationComputedGoto}). 



\subsectionLabel{Instruction \texttt{computed goto}}{instructionComputedGoto}

\textcolor{red}{\bf Cette instruction n'est valide que pour les \emph{pic18}.}

\textbf{Description.} Celle-ci est :
\begin{lstlisting}[language=piccolo]
computed [n] goto routine0, routine1, routine2, ...
\end{lstlisting}

$n$ est une \emph{expression statique} doit être égal au nombre de routines citées après \piccolo{goto}. Ce codage redondant permet de s'assurer que la liste des routines présente une longueur correcte. Les routines citées doivent toutes être sans retour (c'est-à-dire déclarées avec le qualificatif \piccolo{noreturn}).

L'implémentation limite à 64 la valeur de $n$.

\textbf{Fonctionnement.} Cette instruction agit comme une instruction de branchement en fonction de la valeur de \assembleur{WREG} : branchement vers \piccolo{routine0} pour 0, vers \piccolo{routine1} pour 1, \dots 

\textbf{Limitation.} À l'exécution, il est nécessaire que la valeur non signée de \assembleur{WREG} soit strictement inférieur au nombre de routines. \textcolor{red}{\bf Le code engendré par Piccolo n'effectue aucune vérification.} Il est donc probable que ne pas respecter cette règle entraîne un plantage du programme.


Ce code fait appel à la routine \assembleur{\_computed\_goto\_4} qui est ajoutée automatiquement si nécessaire, à la fin du code (\refSubsectionPage{implementationComputedGoto}). 




\subsectionLabel{Implémentation de \texttt{\_computed\_goto\_x}}{implementationComputedGoto}

Les deux routines \assembleur{\_computed\_goto\_2} et \assembleur{\_computed\_goto\_4} sont automatiquement ajoutées à la fin du code, si nécessaire. Voici l'implémentation de \assembleur{\_computed\_goto\_2} :
\begin{lstlisting}[language=assembleur]
_computed_goto_2:
  ADDWF  WREG, W
  ADDWFC TOSL, F
  MOVLW  0
  ADDWFC TOSH, F
  ADDWFC TOSU, F
  RETURN
\end{lstlisting}

Et celle de \assembleur{\_computed\_goto\_4} :
\begin{lstlisting}[language=assembleur]
_computed_goto_4:
  ADDWF  WREG, W
  ADDWF  WREG, W
  ADDWFC TOSL, F
  MOVLW  0
  ADDWFC TOSH, F
  ADDWFC TOSU, F
  RETURN
\end{lstlisting}

À noter que Piccolo effectue un partage de code lorsque ces routines sont toutes les deux nécessaires :
\begin{lstlisting}[language=assembleur]
_computed_goto_4:
  ADDWF  WREG, W
_computed_goto_2:
  ADDWF  WREG, W
  ADDWFC TOSL, F
  MOVLW  0
  ADDWFC TOSH, F
  ADDWFC TOSU, F
  RETURN
\end{lstlisting}












\sectionLabel{Instruction \texttt{block}}{instructionBloc}

\textbf{À partir de Piccolo 3.0.4.} \textcolor{red}{\bf L'instruction \piccolo{block} n'est définie que pour les \emph{pic18}.}

En Piccolo, un \emph{bloc} est une séquence d'instructions terminée par une instruction de débranchement. L'instruction \piccolo{block} permet de définir un ensemble de blocs s'appelant les uns les autres. Ceci permet d'exprimer des graphes d'exécution non structurées, qu'il serait très difficile d'exprimer avec les instructions structurées classiques. 

\subsection{Syntaxe}

Sa syntaxe est la suivante :

\lstset{emph={definitions_de_blocs, nom_du_block, liste_instructions_structurees, branchement, nom_bloc_entree}, emphstyle=\emph}

\begin{lstlisting}[language=piccolo]
block nom_bloc_entree :
  definitions_de_blocs
end
\end{lstlisting}

\piccolo{definitions_de_blocs} est une liste non ordonnée de blocs ; \piccolo{nom_bloc_entree} est le nom de l'un de ces blocs, et c'est celui qui sera exécuté lorsque l'exécution atteindra l'instruction \piccolo{block}.

Une définition de bloc a l'allure suivante :

\begin{lstlisting}[language=piccolo]
nom_du_block { liste_instructions_structurees } branchement
\end{lstlisting}

Le \piccolo{nom_du_block} est le nom donné au bloc ; ce nom est interne à l'instruction \piccolo{block} qui le contient. \piccolo{liste_instructions_structurees} est une liste d'instructions structurées quelconques, qui peut être vide. \piccolo{branchement} est une expression particulière, qui définit où l'exécution se poursuit à l'issue de l'exécution des instructions structurées ; cette expression peut prendre plusieurs formes, indiquées dans le \refTableau{terminaisonBloc}.

\begin{table}[!ht]
  \centering
  \small
  \begin{tabular}{lp{9cm}}
    \textbf{Syntaxe} & \textbf{Signification} \\
    \hline
      \piccolo{-} & L'exécution de l'instruction \piccolo{block} est terminée : l'exécution se poursuit par celle qui suit le \piccolo{end} de l'instruction\piccolo{block}. \\
    \hdashline
      \piccolo{nom} & L'exécution se poursuit par l'exécution du bloc nommé \piccolo{nom}. \\
    \hdashline
      \piccolo{cc ? br1 : br2} & \piccolo{cc} est une condition (voir \refSectionPage{formeGeneraleConditions}), \piccolo{br1} et \piccolo{br2} des expressions de branchement ; si \piccolo{cc} estvrai, alors le branchement \piccolo{br1} est effectué, sinon c'est le branchement \piccolo{br2}. \\
    \hdashline
      \piccolo{[br0, br1, br2, ...]} & Cette expression utilise la valeur courante du registre \assembleur{WREG} (c'est-à-dire celle obtenue à l'issue de l'exécution des instructions structurées) : si \assembleur{WREG} est nul, alors le branchement \piccolo{br0} est effectué, si il vaut 1, c'est \piccolo{br1} … \textcolor{red}{Si \assembleur{WREG} a une valeur supérieure ou égal au nombre de branchements, le comportement est indéfini.}\\
    \hline
  \end{tabular}
  \caption{Expressions de branchement d'un bloc de l'instruction \texttt{block}}
  \labelTableau{terminaisonBloc}
\end{table}

\subsection{Blocs utiles}

Le compilateur Piccolo analyse l'instruction \piccolo{block} en partant du premier bloc appelé et en examinant de proche en proche tous les blocs atteints via les expressions de branchement. Il détecte ainsi facilement les blocs inutiles, qui ne sont jamais appelés. Par exemple :

\begin{lstlisting}[language=piccolo]
  block start :
    start { ... } STATUS.Z ? next : -
    next { ...  } -
    other { ...  } STATUS.Z ? - : another
    another { ...  } -
  end
\end{lstlisting}

Les blocs qui sont accessibles sont \piccolo{start} et \piccolo{next}. Les blocs \piccolo{other} et \piccolo{another} sont inaccessibles et leur présence déclenche des \emph{warnings} signalant leur inutilité.








\subsection{Instruction \texttt{block} et gestion des bancs}

Dans l'instruction \piccolo{block}, la gestion des bancs est réalisée grâce aux instructions régulières de Piccolo : celles qui contrôlent directement les bancs : \piccolo{banksel} (\refSubsectionPage{instructionBanksel}), \piccolo{nobank} (\refSubsectionPage{instructionNoBank}), et celles qui les contrôlent d'une manière indirecte : appel de routine, instruction structurée. Toutes ces instructions peuvent apparaître parmi les instructions de \piccolo{liste_instructions_structurees}.

Ainsi, chaque bloc hérite de la sélection de banc du bloc qui s'est exécuté avant lui, et impose la sélection de banc au bloc qui exécuté ensuite.

Considérons l'exemple suivant :

\begin{lstlisting}[language=piccolo]
  banksel 1
  block start :
    start {
      # bank 1 is selected
      banksel 2
    } STATUS.Z ? next : other
    next {
      # bank 2 is selected
      banksel 3
    } -
    other {
      # bank 2 is selected
      banksel 3
    } -
  end
  # bank 3 is selected
\end{lstlisting}

Le premier bloc qui est exécuté est \piccolo{start}. Comme l'instruction qui précède l'instruction \piccolo{block} a sélectionné le banc 1, le banc 1 demeure sélectionné au début des instructions du bloc \piccolo{start}. Leur exécution sélectionne le banc 2, et l'expression de branchement dirige vers le bloc \piccolo{next} ou \piccolo{other}. Ainsi, on peut affirmer que le banc 2 sera sélectionné lors de l'invocation de ces blocs. Ceux-ci sélectionnent le banc 3, et leur expression de branchement est \piccolo{-}, signifiant que l'exécution est déroutée vers l'instruction qui suit l'instruction \piccolo{block} où la sélection du banc 3 est assurée. Si ces deux blocs ne sélectionnaient pas le même banc, une erreur serait détectée par le compilateur Piccolo.

D'une manière générale, le compilateur Piccolo commence par examiner le premier bloc exécuté (\piccolo{start} dans l'exemple précédent), et calcule de proche en proche pour chaque bloc la sélection héritée du bloc qui le précède et la sélection qu'il impose au bloc exécuté ensuite. Il détecte et signale une erreur si plusieurs blocs essaient d'imposer des sélections de blocs différentes à un même bloc.













\sectionLabel{Instructions de gestion des bancs mémoire}{instructionsGestionBancsMemoire}

Les \emph{baseline} ne possèdent pas de mécanisme pour fixer l'adressage d'un banc : l'accès direct est toujours dans le banc 0 (les adresses comprises entre 0x0 et 0x1F). Les autres bancs doivent être accédés via l'adressage indirect.

\textcolor{red}{\bf Les instructions de gestion de bancs mémoire décrites dans cette section ne sont valides que pour les \emph{mid-range} et les \emph{pic18}.}

Pour un \emph{mid-range}, le banc sélectionné est désigné par la valeur des bits \assembleur{RP} du registre \assembleur{STATUS}. Certains micro-contrôleurs ont jusqu'à 8 bancs, il y a donc 3 bits \assembleur{RP}. En assembleur, le changement de banc est réalisé par une séquence d'instructions \assembleur{BCF} et \assembleur{BSF} sur ces bits (trois instructions dans le pire des cas). 


Pour un \emph{pic18}, le banc sélectionné est désigné par la valeur du registre \assembleur{BSR}. En assembleur, le changement de banc est réalisé par une instruction \assembleur{MOVLB}.

Le but des instructions de gestion des bancs mémoire de Piccolo est multiple :
\begin{itemize}
  \item proposer des instructions génériques pour les \emph{mid-range} et les \emph{pic18} ;
  \item effectuer à la compilation la vérification de la bonne gestion des bancs.
\end{itemize}

Le second point est primordial lors que l'on ré-utilise un code écrit auparavant pour un autre micro-contrôleur : différents micro-contrôleurs de la même famille peuvent présenter des différences de localisation de bancs pour des registres spéciaux de même nom ; Piccolo repérera toutes les erreurs d'adressage de banc.

Le second point a aussi des implications importantes dans les attributs associés aux routines : ceci est discuté dans les sections suivantes.







\subsectionLabel{Instruction et banc courant}{instructionEtBancCourant}


Piccolo définit précisément pour chaque instruction son comportement vis à vis de la sélection courante de banc. Cela permet au compilateur de signaler toute erreur.

\textbf{En entrée.} Une instruction peut :
\begin{itemize}
  \item soit accepter n'importe quelle sélection de banc ;
  \item soit exiger qu'un certain banc soit sélectionné.
\end{itemize}

Par exemple, considérons l'instruction Piccolo \piccolo{bsf STATUS.C}. Pour un \emph{mid-range}, le registre \assembleur{STATUS} est présent dans tous les bancs, cette instruction est donc indifférente vis à vis de la sélection de banc. Pour un \emph{pic18}, le registre \assembleur{STATUS} est situé dans l'\emph{accessbank}, cette instruction est aussi indifférente vis à vis de la sélection de banc. 

Considérons maintenant l'instruction Piccolo \piccolo{clrf var}. Pour un \emph{mid-range}, si la variable \piccolo{var} est déclarée dans \emph{gprnobank} qui apparaît en miroir dans tous les bancs, cette instruction est donc indifférente vis à vis de la sélection de banc. Sinon, l'instruction exige que le banc correspondant soit sélectionné. Pour un \emph{pic18}, si la variable \piccolo{var} est situés dans l'\emph{accessbank}, cette instruction est aussi indifférente vis à vis de la sélection de banc.  Sinon, l'instruction exige que le banc correspondant soit sélectionné. 


\textbf{En sortie.} L'exécution d'une instruction peut :
\begin{itemize}
  \item soit préserver la sélection courante de banc ;
  \item soit sélectionner un banc particulier ;
  \item soit rendre inconnue la sélection courante de banc.
\end{itemize}

\subsectionLabel{Instruction \texttt{banksel}}{instructionBanksel}

Cette instruction peut prendre quatre formes différentes :
\begin{itemize}
  \item \piccolo{banksel numero\_de\_banc}
  \item \piccolo{banksel nom\_registre}
  \item \piccolo{banksel numero\_de\_banc, *}
  \item \piccolo{banksel nom\_registre, *}
\end{itemize}


\subsubsection{Instruction \piccolo{banksel b}}
\begin{lstlisting}[language=piccolo]
banksel numero_de_banc
\end{lstlisting}

Cette instruction sélectionne le banc de numéro \piccolo{numero\_de\_banc}. Pour les \emph{mid-range}, le compilateur engendre une à trois instructions \assembleur{BCF} ou \assembleur{BSF} des bits \assembleur{RP} du registre \assembleur{STATUS}. Pour les \emph{pic18}, le compilateur engendre une instruction \assembleur{MOVLB}.

Le compilateur Piccolo garde trace de cette instruction, et permet d'assurer que l'accès aux registres du banc \piccolo{numero\_de\_banc} est possible pour les instructions suivantes.

Un \emph{warning} est affiché si l'instruction est inutile, c'est-à-dire si le banc indiqué est déjà sélectionné. À partir de la version 2.0.2 de Piccolo, les instructions assembleur correspondantes ne sont alors pas engendrées.






\subsubsection{Instruction \piccolo{banksel nom\_registre}}
À partir de la version 2.0.2 de Piccolo, il est possible de faire figurer un nom de registre à la place du numéro de banc :
\begin{lstlisting}[language=piccolo]
banksel nom_registre
\end{lstlisting}

Cette instruction sélectionne le banc du registre \piccolo{nom\_registre}. Pour les \emph{mid-range}, le compilateur engendre une à trois instructions \assembleur{BCF} ou \assembleur{BSF} des bits \assembleur{RP} du registre \assembleur{STATUS}. Pour les \emph{pic18}, le compilateur engendre une instruction \assembleur{MOVLB}.

Le compilateur Piccolo garde trace de cette instruction, et permet d'assurer que l'accès aux registres du banc sélectionné est possible pour les instructions suivantes.

Un \emph{warning} est affiché si l'instruction est inutile, c'est-à-dire si le banc indiqué est déjà sélectionné ; les instructions assembleur correspondantes ne sont alors pas engendrées.




\subsubsection{Instruction \piccolo{banksel b, *}}
\begin{lstlisting}[language=piccolo]
banksel numero_de_banc, *
\end{lstlisting}

Seule différence avec l'instruction \piccolo{banksel b} : le \emph{warning} n'est pas affiché si l'instruction est inutile.






\subsubsection{Instruction \piccolo{banksel nom\_registre, *}}
\begin{lstlisting}[language=piccolo]
banksel nom_registre, *
\end{lstlisting}

Seule différence avec l'instruction \piccolo{banksel nom\_registre} : le \emph{warning} n'est pas affiché si l'instruction est inutile.









\subsectionLabel{Instruction \texttt{checkbank}}{instructionCheckBank}

\begin{lstlisting}[language=piccolo]
checkbank numero
\end{lstlisting}

Cette instruction vérifie que le banc mémoire sélectionné est \piccolo{numero}. Aucun code n'est engendré, la vérification est faite statiquement par le compilateur.

\piccolo{numero} doit être un numéro valide de banc, c'est-à-dire un entier compris entre $0$ et $15$.











\subsectionLabel{Instruction \texttt{nobank}}{instructionNoBank}
\begin{lstlisting}[language=piccolo]
nobank
\end{lstlisting}

Cette instruction signifie qu'à partir de ce point, on considère que la sélection courante de banc est inconnue. Elle n'engendre aucun code, c'est juste une information destinée au compilateur.





\subsectionLabel{Instruction \texttt{checknobank}}{instructionCheckNoBank}

\textbf{À partir de Piccolo 3.0.4.}

\begin{lstlisting}[language=piccolo]
checknobank
\end{lstlisting}

Cette instruction vérifie que la sélection courante de banc est inconnue. Elle n'engendre aucun code, c'est juste une vérification statique.





\subsectionLabel{Instruction \texttt{banksave}}{instructionBanksave}

\begin{lstlisting}[language=piccolo]
banksave var
  liste_instructions
end
\end{lstlisting}

Pour les \emph{mid-range}, cette instruction sauve le registre \assembleur{STATUS} dans la variable \piccolo{var} avant l'exécution de \piccolo{liste\_instructions}, et restitue le registre \assembleur{STATUS} quand le \piccolo{end} est atteint. La variable \piccolo{var} doit être accessible à partir de n'importe quel banc, c'est-à-dire déclaré dans la zone commune \emph{grpnobnk}. L'accumulateur \assembleur{W} est utilisé à chaque fois, aussi bien pour la sauvegarde que pour la restitution.

Pour les \emph{pic18}, cette instruction sauve le registre \assembleur{BSR} dans la variable \piccolo{var} avant l'exécution de \piccolo{liste\_instructions}, et restitue le registre \assembleur{BSR} quand le \piccolo{end} est atteint. Comme les deux transferts sont réalisés au moyen de l'instruction \assembleur{MOVFF}, la variable \piccolo{var} peut être déclarée dans n'importe quel banc.



\subsectionLabel{Déclaration de routine et gestion des bancs}{declarationRoutineEtBancs}

Le comportement des routines vis à vis de la sélection courante de banc doit être déclaré dans son en-tête. Il y a deux qualificatifs possibles pour une routine sans retour (\refTableau{routineSansRetourEtBanc}), et cinq pour une routine régulière (\refTableau{routineReguliereEtBanc}).



\begin{table}[!ht]
  \centering
%  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{ll}
    \textbf{Qualificatif} & \textbf{Sélection de banc lors de l'appel} \\
    \hline
    \emph{aucun} & ?\\ 
    \piccolo{bank:requires be} & Banc $be$\\ 
    \hline
  \end{tabular}
  \caption{Routine sans retour et qualificatifs associés aux bancs}
  \labelTableau{routineSansRetourEtBanc}
\end{table}

\begin{table}[!ht]
  \centering
%  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Qualificatif} & \multicolumn{2}{l}{\bf Sélection de banc} \\
                          & \textbf{Lors de l'appel}  & \textbf{Lors du retour} \\
    \hline
    \emph{aucun} & ? & ?\\ 
    \piccolo{bank:preserved} & ? & Sélection préservée\\ 
    \hdashline
    \piccolo{bank:requires be} & Banc $be$ & ?\\ 
    \hdashline
    \piccolo{bank:ensures bs} & ? & Banc $bs$\\ 
    \hdashline
    \piccolo{bank:requires be ensures bs} & Banc $be$ & Banc $bs$\\ 
    \hline
  \end{tabular}
  \caption{Routine régulière et qualificatifs associés aux bancs}
  \labelTableau{routineReguliereEtBanc}
\end{table}

\subsectionLabel{Déclaration de routine sans qualificatif de banc}{declarationRoutineSansBanc}

Le contrat est le suivant :
\begin{itemize}
\item pour l'appelant, aucune contrainte sur la sélection de banc au moment de l'appel, aucune garantie sur la sélection de banc après l'exécution de la routine ; 
\item pour la routine appelée, cela signifie que la sélection de banc est inconnue au début de la routine : seul un registre accessible à partir de n'importe quel banc pourra être accédé directement ; pour les autres, il faudra utiliser une instruction \piccolo{banksel} pour fixer la sélection d'un banc ; la valeur de sélection de banc à la fin de l'exécution de la routine est quelconque.
\end{itemize}

\textbf{Exemple 1.} \piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2 :
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  clrf varAnyBank
  banksel 1
  clrf varBank1
  banksel 2
  clrf varBank2
}
\end{lstlisting}

Cette routine est compilée sans erreur.


\textbf{Exemple 2.} \piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2 :
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  clrf varAnyBank
  clrf varBank1
  clrf varBank2
}
\end{lstlisting}

La compilation de cette routine provoque deux erreurs (utiliser l’option \texttt{-d} pour obtenir des messages détaillés) :

\begin{quote}
\texttt{  clrf varBank1}\\
\texttt{-{-}-{-}-{-}-{-}-{-}-{-}-\^{}}\\
\textcolor{red}{\tt semantic error: Accessing the 'varBank1' needs the bank selection set to 1, but current bank selection cannot be known}\\

\texttt{  clrf varBank2}\\
\texttt{-{-}-{-}-{-}-{-}-{-}-{-}-\^}\\
\textcolor{red}{\tt semantic error: Accessing the 'varBank2' needs the bank selection set to 2, but current bank selection cannot be known}
\end{quote}




\textbf{Exemple 3.} \piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2 :
\begin{lstlisting}[language=piccolo]
routine maRoutine {
  clrf varAnyBank
  banksel 1
  clrf varBank1
  clrf varBank2
}
\end{lstlisting}

La compilation de cette routine provoque une erreur (utiliser l’option \texttt{-d} pour obtenir des messages détaillés) :

\begin{quote}
\texttt{  clrf varBank2}\\
\texttt{-{-}-{-}-{-}-{-}-{-}-{-}-\^}\\
\textcolor{red}{\tt semantic error: Accessing the 'varBank2' needs the bank selection set to 2, but but current bank selection is set to 1}
\end{quote}













\subsectionLabel{Routine déclarée avec \texttt{bank:preserved}}{declarationRoutineBancPreserve}

Le contrat est le suivant :
\begin{itemize}
  \item pour l'appelant, aucune contrainte sur la sélection de banc au moment de l'appel, garantie que l'exécution de la routine ne modifiera pas la sélection de banc ; 
\item pour la routine appelée, cela signifie que la sélection de banc est inconnue au début de la routine : seul un registre accessible à partir de n'importe quel banc pourra être accédé directement ; pour les autres, il faudra utiliser une instruction \piccolo{banksel} pour fixer la sélection d'un banc ; la valeur de sélection de banc à la fin de l'exécution doit être préservée.
\end{itemize}

Si utiliser une instruction \piccolo{banksel} dans la routine est indispensable, la seule façon de préserver la sélection de banc est d'utiliser l'instruction \piccolo{banksave}. 

\textbf{Exemple 1.} \piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2 :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:preserved {
  clrf varAnyBank
  banksave save_bank
    banksel 1
    clrf varBank1
    banksel 2
    clrf varBank2
  end
}
\end{lstlisting}

Cette routine est compilée sans erreur.


\textbf{Exemple 2.} \piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2 :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:preserved {
  clrf varAnyBank
  banksel 1
  clrf varBank1
  banksel 2
  clrf varBank2
}
\end{lstlisting}

La compilation de cette routine provoque deux erreurs (utiliser l’option \texttt{-d} pour obtenir des messages détaillés) :

\begin{quote}
\texttt{ banksel 1}\\
\texttt{-{-}-{-}-{-}-{-}-\^}\\
\textcolor{red}{\tt semantic error: cannot use "banksel" here: bank selection should be preserved (use "banksave" instruction)}\\

\texttt{  banksel 2}\\
\texttt{-{-}-{-}-{-}-{-}-\^}\\
\textcolor{red}{\tt semantic error: cannot use "banksel" here: bank selection should be preserved (use "banksave" instruction)}
\end{quote}













\subsectionLabel{Routine déclarée avec \texttt{bank:requires be}}{declarationRoutineBancRequires}

Le contrat est le suivant :
\begin{itemize}
  \item pour l'appelant, le banc \piccolo{be} doit être sélectionné au moment de l'appel, aucune garantie sur la sélection de banc après l'exécution de la routine ; 
  \item pour la routine appelée, garantie que le banc \piccolo{be} banc est sélectionné au début de la routine : ainsi les registres accessibles à partir de n'importe quel banc et du banc $be$ peuvent être accédés directement ; pour les autres, il faudra utiliser une instruction \piccolo{banksel} pour fixer la sélection ; la valeur de sélection de banc à la fin de l'exécution de la routine est quelconque.
\end{itemize}

Par exemple (\piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2) :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:requires 1 {
  clrf varAnyBank
  clrf varBank1
  banksel 2
  clrf varBank2
}
\end{lstlisting}







\subsectionLabel{Routine déclarée avec \texttt{bank:ensures bs}}{declarationRoutineBancEnsures}

Le contrat est le suivant :
\begin{itemize}
  \item pour l'appelant, aucune contrainte sur la sélection de banc au moment de l'appel, garantie que le banc \piccolo{bs} est sélectionné après l'exécution de la routine ; 
  \item cela signifie que la sélection de banc est inconnue au début de la routine : seul un registre accessible à partir de n'importe quel banc pourra être accédé directement ; pour les autres, il faudra utiliser une instruction \piccolo{banksel} pour fixer la sélection d'un banc ; le banc \piccolo{bs} doit être sélectionné à la fin de l'exécution.
\end{itemize}

Par exemple (\piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2) :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:ensures 1 {
  clrf varAnyBank
  banksel 1
  clrf varBank1
  banksel 2
  clrf varBank2
  banksel 1
}
\end{lstlisting}

La dernière instruction \piccolo{banksel 1} est indipensable pour garantir que le banc 1 est sélectionné à la fin de l'exécution de la routine.


Par contre, dans le cas suivant, on n'a pas besoin de fixer la sélection de banc à la fin de la routine :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:ensures 2 {
  clrf varAnyBank
  banksel 1
  clrf varBank1
  banksel 2
  clrf varBank2
}
\end{lstlisting}












\subsectionLabel{Routine déclarée avec \texttt{bank:requires be ensures bs}}{declarationRoutineBancRequiresEnsures}

Le contrat est le suivant :
\begin{itemize}
  \item pour l'appelant, le banc \piccolo{be} doit être sélectionné au moment de l'appel, garantie que le banc \piccolo{bs} est sélectionné après l'exécution de la routine ; 
  \item cela signifie que le banc \piccolo{be} est sélectionné au début de la routine : seul un registre accessible à partir de n'importe quel banc pourra être accédé directement ; pour les autres, il faudra utiliser une instruction \piccolo{banksel} pour fixer la sélection d'un banc ; le banc \piccolo{bs} doit être sélectionné à la fin de l'exécution.
\end{itemize}

Par exemple (\piccolo{varAnyBank} est accessible quel soit la sélection de banc, \piccolo{varBank1} est déclaré dans le banc 1, \piccolo{varBank2} dans le banc 2) :
\begin{lstlisting}[language=piccolo]
routine maRoutine bank:requires 1 ensures 2 {
  clrf varAnyBank
  clrf varBank1
  banksel 2
  clrf varBank2
}
\end{lstlisting}









\subsectionLabel{Sélection de banc et instruction conditionnelle structurée}{selectionBancInstructionConditionnelleStructuree}

L'instruction conditionnelle structurée est présentée à la \refSectionPage{instructionConditionnelleStructuree} et a la forme générale suivante :

\begin{lstlisting}[language=piccolo]
if (cca)
  instructions 1
elsif (ccb)
  instructions 2
else
  instructions 3
end
\end{lstlisting}

\textbf{Règles :}
\begin{itemize}
  \item la sélection initiale de banc sera utilisée pour l’évaluation des conditions \piccolo{cca} et \piccolo{ccb}, et sera la valeur au début de l'exécution de chaque branche ;
  \item toutes les branches doivent laisser la sélection de banc dans le même état : soit avec la même valeur connue, soit avec une valeur considérée comme invalide.
\end{itemize}


\subsectionLabel{Sélection de banc et instruction de répétition infinie}{selectionBancInstructionRepetitionInfinie}

L'instruction de répétition infinie est présentée à la \refSectionPage{repetitionInfinie} et a la forme générale suivante :

\begin{lstlisting}[language=piccolo]
forever
  instructions_repetees
end
\end{lstlisting}

\textbf{Règle :}
\begin{itemize}
  \item la liste d'instructions \piccolo{instructions\_repetees} doit préserver la sélection de banc.
\end{itemize}



\subsectionLabel{Sélection de banc et instruction répétitive}{selectionBancInstructionRepetitive}

L'instruction de répétition infinie est présentée à la \refSectionPage{instructionRepetitive} et a la forme générale suivante :

\begin{lstlisting}[language=piccolo]
do
  instructions 1
while (cca)
  instructions 2
while (ccb)
  instructions 3
end
\end{lstlisting}

\textbf{Règles :}
\begin{itemize}
  \item chaque liste d'instructions (\piccolo{instructions 1}, \piccolo{instructions 2}, \piccolo{instructions 3}) doit préserver la sélection de banc ;
  \item l'évaluation des conditions \piccolo{cca} et \piccolo{ccb} s'effectue avec cette sélection de banc.
\end{itemize}
