%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapter{Programmes pour mid-range}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}




\section{Structure d’un programme pour mid-range}

Un programme Piccolo pour \emph{mid-range} a la structure suivante :

\begin{lstlisting}[language=piccolo]
midrange nom "nom_composant" :
  liste_de_sections
end
\end{lstlisting}


Dans l’en-tête :
\begin{itemize}
  \item le nom « \emph{nom} » est le nom du fichier (sans son extension) qui contient ce texte source ;
  \item le nom du composant « \emph{nom\_composant} » doit être exactement le nom de l’un des composants supportés (pour obtenir la liste des \emph{mid-range} pris en charge, utiliser l’option « \texttt{-{}-midrange} », voir \refSubsectionPage{listeMidrange}).
\end{itemize}


Le corps du programme est constitué d’une liste non ordonnée de sections. Les sections disponibles sont listées dans le \refTableau{sectionsMidrange}.

\begin{table}[ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}lll}
    \textbf{Type de section} & \textbf{Mot-clé introductif} & \textbf{Référence}\\
    \hline
    Configuration & \texttt{configuration} & \refChapterPage{configuration}\\
    Définition de variable & \texttt{ram} & \refChapterPage{ram}\\
    Définition de constante & \texttt{const} & \refChapterPage{constante}\\
    Définition de routine mid-range & \texttt{routine} & \refSectionPage{routineMidrange}\\
    Définition de routine d'interruption mid-range & \texttt{interrupt} & \refSectionPage{routineInterruptionMidrange}\\
  \hline
  \end{tabular}
  \caption{Les sections d'un programme pour \emph{mid-range}}
  \labelTableau{sectionsMidrange}
\end{table}




\sectionLabel{Routines mid-range}{routineMidrange}

Les routines définissent le code exécutable de votre programme. L’une d’entre elles doit s’appeler \texttt{main} : c’est la routine qui s’exécute au démarrage. Il y a deux types de routine, les routines \emph{régulières} et les routines \emph{sans retour}.


L’ordre des déclarations des routines est quelconque, il est possible d’appeler une routine qui est déclarée après l’instruction d’appel. Simplement Piccolo engendrera leur code dans leur ordre d’apparition. 

~\\
\textbf{Routine et sélection de banc.} Un problème important en assembleur est la gestion de la sélection de banc par l’intermédiaire des bits \texttt{RP} du registre \texttt{STATUS} : son utilisation correcte en assembleur est complètement à la charge du programmeur. Piccolo propose des instructions pour sécuriser son emploi : voir la \refSectionPage{instructionsGestionBancsMemoire}.

~\\
\textbf{Liste d’instructions d’une routine.} Elle est structurée : Piccolo définit des instructions de sélection et de répétition : cela signifie que vous ne pouvez pas déclarer d’étiquette, ni utiliser des \texttt{goto} pour effectuer des branchements à l’intérieur d’une routine.

~\\
\textbf{Routine et pages de la mémoire programme.} La mémoire programme d’un midrange est divisé en blocs de 2048 instructions, et franchir ces frontières posent des problèmes particuliers. Piccolo impose les contraintes suivantes :\begin{itemize}
  \item une routine doit être complètement contenue dans une page (son code ne peut franchir une frontière) ;
  \item les sauts inter-pages ne peuvent être effectués qu’avec les instructions \texttt{jump} ou \texttt{jsr} (\refSectionPage{gestionPagesMidRange}).
\end{itemize}

\subsectionLabel{Routine régulière}{routineReguliereMidRange}

C'est un sous-programme. Une routine régulière peut ne comporter aucune instruction Piccolo, l'instruction \texttt{return} est implicitement ajoutée. Une routine régulière est déclarée par :
\begin{lstlisting}[language=piccolo]
routine maRoutine ... {
  ...
}
\end{lstlisting}

\texttt{maRoutine} est le nom de la routine, celui qui sera nommé dans un instruction d’appel de routine. Entre les accolades « \texttt{\{} » et « \texttt{\}} », apparaît la liste des instructions.

~\\
\textbf{Appel d’une routine régulière.} Utiliser \texttt{CALL} ou \texttt{JSR}.

\subsection{Routine sans retour}

L’exécution ne revient pas jamais à l’appelant. Ce type de routine doit donc se terminer par des constructions particulières qui assurent le non-retour : une boucle infinie, un branchement (\texttt{goto} ou \texttt{jump}) vers une autre routine sans retour, un \texttt{goto} calculé vers d’autres routines sans retour.

Une routine sans retour doit être déclarée avec qualificatif \texttt{noreturn} :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine ... {
  ...
}
\end{lstlisting}

~\\
\textbf{Appel d’une routine sans retour.} Utiliser \texttt{goto} ou \texttt{jump}.


~\\
\textbf{Déclaration de la routine \texttt{main}.} Dans un programme, il doit exister une et une seule routine \texttt{main}, qui doit être déclarée comme suit :

\begin{lstlisting}[language=piccolo]
noreturn routine main bank:requires 0 {
   liste d'instructions
}

\end{lstlisting}

Le compilateur Piccolo insère à l’adresse zéro une instruction \texttt{goto} vers cette routine, de façon que la routine \texttt{main} soit exécutée au démarrage du micro-contrôleur. Le qualificatif \texttt{bank:requires 0} est exigé par le compilateur Piccolo car les bits \texttt{RP} du registre \texttt{STATUS} sont initialisés à zéro au démarrage du micro-contrôleur.


~\\
\textbf{Comment terminer une routine sans retour.} La dernière instruction de la liste des instructions d’une routine sans retour doit être :
\begin{itemize}
  \item un appel vers une autre routine sans retour, au moyen d’un \texttt{goto} ou d'un \texttt{jump} ;
  \item un branchement calculé vers une routine parmi plusieurs, au moyen d’un \texttt{computed goto} ;
  \item une instruction conditionnelle structurée, dont toutes les branches présentent comme dernière instruction les instructions d’appel d’un routine sans retour, un branchement calculé (comme évoqué ci-dessus), ou encore une instruction conditionnelle structurée, dont toutes les branches, etc.

\end{itemize}

Exemple simple : la dernière instruction est une boucle infinie :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  forever
    ...
  end
}
\end{lstlisting}

Exemple simple : la dernière instruction est un branchement vers une routine sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  goto autreRoutineSansRetour
}
\end{lstlisting}

La dernière instruction est un \texttt{computed goto} nommant les routines \texttt{r1}, \texttt{r2}, \texttt{r3} qui doivent être toutes les trois des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  computed [3] goto r1, r2, r3
}
\end{lstlisting}

La dernière instruction est un \texttt{if} dont aucune des branches ne se termine (\texttt{r1} est une routine sans retour) :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    goto r1
  else
    ...
    forever
      ...
    end
  end
}

\end{lstlisting}


La dernière instruction est un \texttt{if} dont la première branche se termine elle même par un \texttt{if} dont les deux branches se terminent par des branchements vers des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    if (...)
      ...
      goto r1
    else
      ...
      goto r2
    end
  else
    ...
    goto r3
  end
}
\end{lstlisting}








\section{Les instructions}
\index{MidRange!Instructions machine}

Elles sont de deux types (la distinction est importante pour l’instruction \emph{conditionnelle simple}) :
\begin{itemize}
  \item les instructions simples ;
  \item les instructions composées.

\end{itemize}


~\\
\textbf{Les instructions simples.} Elles correspondent à une partie des instructions machine. Attention, pour certaines, la syntaxe n'est pas exactement la même que celle de l'instruction assembleur correspondante.

Le \refTableau{instructionsAssembleurMidRange} donnent la liste des instructions machine \emph{mid-range} et les liens vers les sections précisant leur prise en charge en Piccolo.

 
\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Instruction} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \assembleur{ADDLW k} & Add Literal and W & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{ADDWF f, d} & Add W and f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW} \\
    \assembleur{ANDLW k} & And Literal with W & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{ANDWF f, d} & And W with f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{BCF f, b} & Bit Clear f & \refSubsectionPage{opMidRangeAffectationBit} \\
    \assembleur{BSF f, b} & Bit Set f & \refSubsectionPage{opMidRangeAffectationBit} \\
    \assembleur{BTFSC f, b} & Bit Test f, Skip if Clear & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{BTFSS f, b} & Bit Test f, Skip if Set & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{CALL k} & Call Subroutine &  \refSubsectionPage{appelRoutineReguliereMidRange} \\
    \assembleur{CLRF f} & Clear f & \refSubsectionPage{instructionsMidRangeNommantRegistre} \\
    \assembleur{CLRW} & Clear W & \refSubsectionPage{operationsMidRangeIdentiquesAssembleur}\\
    \assembleur{CLRWDT} & Clear Watchdog Timer & \refSubsectionPage{operationsMidRangeIdentiquesAssembleur}\\
    \assembleur{COMF f, d} & Complement f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{DECF f, d} & Decrement f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{DECFSZ f, d} & Decrement f, Skip if 0 & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{GOTO n} & Go to Address & \refSubsectionPage{appelRoutineSansRetourMidRange} \\
    \assembleur{INCF f, d} & Decrement f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{INCFSZ f, d} & Increment f, Skip if 0 & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{IORLW k} & Inclusive OR Literal with W & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{IORWF f, d} & Inclusive OR W with f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{MOVF f, d} & Move f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{MOVLW k} & Move Literal to W & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{MOVWF f} & Move W to f & \refSubsectionPage{instructionsMidRangeNommantRegistre}\\
    \assembleur{NOP} & No Operation & \refSubsectionPage{operationsMidRangeIdentiquesAssembleur}\\
    \assembleur{RETFIE} & Return from interrupt & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{RETLW k} & Return with Literal in W & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{RETURN} & Return from Subroutine & \refSubsectionPage{instructionsMidRangeIntrouvables}\\
    \assembleur{RLF f, d} & Rotate Left f through Carry & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{RRF f, d} & Rotate Right f through Carry & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{SLEEP} & Go into Standby Mode & \refSubsectionPage{operationsMidRangeIdentiquesAssembleur}\\
    \assembleur{SUBLW k} & Substract W from literal & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{SUBWF f, d} & Substract W from f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{SWAPF f, d} & Swap Nibbles in f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
    \assembleur{XORLW k} & Exclusive OR Literal with W & \refSubsectionPage{opMidRangeImmediate}\\
    \assembleur{XORWF f, d} & Exclusive OR W with f & \refSubsectionPage{instructionsMidRangeNommantRegistreEtW}\\
  \hline
  \end{tabular}
  \caption{Instructions machine des \emph{mid-range}}
  \labelTableau{instructionsAssembleurMidRange}
\end{table}






~\\
\textbf{Les instructions composées.} Piccolo définit les instructions suivantes :
\begin{itemize}
  \item l'instruction \texttt{mnop} (\refSectionPage{instructionMNOP}) ;
  \item l'instruction conditionnelle simple (\refSectionPage{instructionConditionnelleSimple}) ;
  \item l'instruction conditionnelle structurée (\refSectionPage{instructionConditionnelleStructuree}) ;
  \item l'instruction répétitive (\refSectionPage{instructionRepetitive}) ;
  \item l'instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item l'instruction d'appel de routine régulière \texttt{jsr} (\refSectionPage{gestionPagesMidRange}) ;
  \item l'instruction d'appel de routine sans retour \texttt{jump} (\refSectionPage{gestionPagesMidRange}) ;
\end{itemize}




\subsectionLabel{Les instructions que vous ne trouverez pas en Piccolo}{instructionsMidRangeIntrouvables}

Elles n’existent pas en Piccolo parce qu’elles sont remplacées par des constructions structurées, ou bien engendrées automatiquement lors de la compilation.

Voici leur liste avec les liens vers les sections appropriées :\begin{itemize}
  \item \texttt{BTFSC}, \texttt{BTFSS}, \texttt{DECFSZ} et \texttt{INCFSZ} : ces instructions sont engendrées par l’instruction conditionnelle simple, l’instruction conditionnelle structurée et l’instruction répétitive (\refSubsectionPage{conditionsElementairesBaselineMidRange}) ;
  \item \texttt{RETFIE} : ajoutée automatiquement par la compilateur Piccolo à la fin de la routine d'interruption (\refSectionPage{routineInterruptionMidrange}).
  \item \texttt{RETURN} : ajoutée automatiquement par la compilateur Piccolo à la fin d'une routine régulière (\refSubsectionPage{routineReguliereMidRange}).
  \item \texttt{RETLW} : utiliser une instruction \texttt{MOVLW}, et c’est le compilateur Piccolo qui remplacera la séquence \texttt{MOVLW k RETURN} par une instruction \texttt{RETLW k} (\refSubsectionPage{routineReguliereMidRange}).

\end{itemize}





\sectionLabel{Les instructions simples}{instructionsSimplesMidRange}


\subsectionLabel{Instructions nommant un registre}{instructionsMidRangeNommantRegistre}

Ce sont les instructions listées dans le \refTableau{operationsMidRangeNommantUnRegistre}.



\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRF f} & Clear f & \texttt{clrf f} \\
    \texttt{MOVWF f} & Move f & \texttt{movwf f} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{mid-range} nommant un registre}
  \labelTableau{operationsMidRangeNommantUnRegistre}
\end{table}








\subsectionLabel{Instructions nommant un registre, et optionnellement \texttt{W}}{instructionsMidRangeNommantRegistreEtW}

Ces instructions, ainsi que le traduction en Piccolo, sont listées dans le \refTableau{instructionsMidRangeRegistreEtW}. En assembleur, elles nomment deux opérandes :
\begin{itemize}
  \item \texttt{f} : désigne le registre, il en est de même en Piccolo ;
  \item \texttt{d} : optionnel en Piccolo ; si absent, le registre \texttt{f} est destination de l'opération, si égal à \texttt{W}, c'est le registre \texttt{W} qui est destinaire.
\end{itemize}


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{3}{}{\fondTableau}
  \begin{tabular}{llll}
     &  & \multicolumn{2}{l}{\textbf{En Piccolo, destination :}} \\
    \textbf{Assembleur} & \textbf{Description} & \textbf{f} & \textbf{W}\\
    \hline
    \assembleur{ADDWF f, d} & Add W and f & \texttt{addwf f}  & \texttt{addwf f, W} \\
    \assembleur{ANDWF f, d} & And W with f & \texttt{andwf f} & \texttt{andwf f, W}\\
    \assembleur{COMF f, d} & Complement f & \texttt{comf f} & \texttt{comf f, W}\\
    \assembleur{DECF f, d} & Decrement f & \texttt{decf f} & \texttt{decf f, W}\\
    \assembleur{INCF f, d} & Increment f & \texttt{incf f}& \texttt{incf f, W}\\
    \assembleur{IORWF f, d} & Inclusive OR W with f & \texttt{iorwf f} & \texttt{iorwf f, W}\\
    \assembleur{MOVF f, d} & Move f & \texttt{movf f} & \texttt{movf f, W}\\
    \assembleur{RLF f, d} & Rotate Left f through Carry & \texttt{rlf f} & \texttt{rlf f, W}\\
    \assembleur{RRF f, d} & Rotate Right f through Carry & \texttt{rrf f} & \texttt{rrf f, W}\\
    \assembleur{SUBWF f, d} & Substract W from f & \texttt{subwf f} & \texttt{subwf f, W}\\
    \assembleur{SWAPF f, d} & Swap Nibbles in f & \texttt{swapf f} & \texttt{swapf f, W}\\
    \assembleur{XORWF f, d} & Exclusive OR W with f & \texttt{xorwf f} & \texttt{xorwf f, W}\\
  \hline
  \end{tabular}
  \caption{Instructions \emph{mid-range} nommant un registre, et optionnellement \texttt{W}}
  \labelTableau{instructionsMidRangeRegistreEtW}
\end{table}


\subsectionLabel{Opérations d'affectation de bit}{opMidRangeAffectationBit}

Ces instructions Piccolo correspondent aux instructions machine \assembleur{BCF} et \assembleur{BSF} (\refTableau{operationsMidRangeAffectationBit}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \assembleur{BCF f, b} & Bit Clear f & \texttt{bcf f.b} \\
    \assembleur{BSF f, b} & Bit Set f & \texttt{bsf f.b} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{mid-range} sur un bit d'un registre}
  \labelTableau{operationsMidRangeAffectationBit}
\end{table}

En Piccolo, ces instructions ont toujours deux arguments :
\begin{itemize}
  \item le premier argument est une référence à un registre (\refSectionPage{referenceRegistre}) ;
  \item le second est le bit concerné, précédé par un point.
\end{itemize}

Pour désigner le bit concerné, vous pouvez utiliser un nombre compris entre 0 et 7. Par exemple :
\begin{lstlisting}[language=piccolo]
bcf maVariable.3
\end{lstlisting}

Si le registre a été défini en déclarant des noms de bit :
\begin{lstlisting}[language=piccolo]
ram ... {
  byte maVariable <a, -, b [3], -, -, ->
}
\end{lstlisting}

Vous pouvez utiliser l’un de ces noms comme second argument :
\begin{lstlisting}[language=piccolo]
bcf maVariable.a # a designe le bit 7
\end{lstlisting}
ou encore
\begin{lstlisting}[language=piccolo]
bcf maVariable.b [1] # b[1] designe le bit 4
\end{lstlisting}

Vous pouvez de cette façon accéder aux bits des registres spéciaux. Pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} (ou sa version courte \texttt{-R}), comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=16F690}.


\subsectionLabel{Opérations littérales avec \texttt{W}}{opMidRangeImmediate}

Ces opérations sont listées dans le \refTableau{operationsLiteralesMidRangeAvecW}. L’instruction \assembleur{RETLW k} n’existe pas en Piccolo, l’optimiseur repérera une instruction \assembleur{MOVLW k} en fin de routine et la transformera en \assembleur{RETLW k}.

En Piccolo, \texttt{k} est une \emph{expression statique}. Une expression statique est une expression dont la valeur est calculée à la compilation. Sa forme générale est présentée à la \refSectionPage{expressionImmediate}. Le compilateur effectue tous les calculs d'une expression statique avec des nombres entiers 32 bits signés.

Pour être valide dans les opérations statiques avec \texttt{W}, le résultat devra être :
\begin{itemize}
  \item soit un nombre positif inférieur ou égal à 255 ;
  \item soit un nombre négatif supérieur ou égal à -128.
\end{itemize}

Par exemple : \texttt{movlw -14} engendre l’instruction assembleur : \assembleur{MOVLW 0xf2}.


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \assembleur{ADDLW k} & Add Literal and W & \texttt{addlw k}\\
    \assembleur{ANDLW k} & And Literal with W & \texttt{andlw k}\\
    \assembleur{IORLW k} & Inclusive OR Literal with W & \texttt{iorlw k}\\
    \assembleur{MOVLW k} & Move Literal to W & \texttt{movlw k}\\
    \assembleur{SUBLW k} & Substract W frol literal & \texttt{sublw k}\\
    \assembleur{XORLW k} & Exclusive OR Literal with W & \texttt{xorlw k}\\
    \hline
  \end{tabular}
  \caption{Opérations litérales avec \texttt{W} pour \emph{mid-range}}
  \labelTableau{operationsLiteralesMidRangeAvecW}
\end{table}


\subsectionLabel{Instructions identiques à celles de l’assembleur}{operationsMidRangeIdentiquesAssembleur}

Ces instructions sont listées dans le \refTableau{operationsMidRangeIdentiquesAssembleur}.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \assembleur{CLRWDT} & Clear Watchdog Timer & \texttt{clrwdt}\\
    \assembleur{CLRW} & Clear W & \texttt{clrw}\\
    \assembleur{NOP} & No Operation & \texttt{nop}\\
    \assembleur{OPTION} & Load OPTION register & \texttt{option}\\
    \assembleur{SLEEP} & Go into Standby Mode & \texttt{sleep}\\
    \hline
  \end{tabular}
  \caption{Instructions \emph{mid-range} identiques en assembleur et en Piccolo}
  \labelTableau{operationsMidRangeIdentiquesAssembleur}
\end{table}



























\subsectionLabel{Appeler une routine régulière}{appelRoutineReguliereMidRange}

Une routine régulière est une routine déclarée sans le qualificatif \texttt{noreturn}. L'appel s’effectue avec l'instruction \texttt{call}, si la routine se trouve dans la même page de la mémoire programme que l'instruction d'appel, ou avec l'instruction \texttt{jsr} (\refSubsectionPage{instructionJsrMidRange}).

Syntaxiquement, il faut simplement nommer la routine appelée après l’instruction d’appel :

\begin{lstlisting}[language=piccolo]
call nom_routine
\end{lstlisting}

Ou :

\begin{lstlisting}[language=piccolo]
jsr nom_routine
\end{lstlisting}




\subsectionLabel{Appeler une routine sans retour}{appelRoutineSansRetourMidRange}

Appeler une routine sans retour (c'est-à-dire déclarée avec le qualificatif \texttt{noreturn}) s'effectue par une instruction \texttt{goto}, si la routine se trouve dans la même page de la mémoire programme que l'instruction d'appel, ou avec l'instruction \texttt{jump} (\refSubsectionPage{instructionJumpMidRange}). L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
goto nom_routine
\end{lstlisting}

Ou :

\begin{lstlisting}[language=piccolo]
jump nom_routine
\end{lstlisting}




\sectionLabel{Section \texttt{include}}{sectionIncludeMidRange}

Une section \texttt{include} permet d'inclure un fichier contenant lui-même des sections telles que définies dans le \refTableauPage{sectionsMidrange}.  Son format est le suivant :

\begin{lstlisting}[language=piccolo]
  include "chemin"
\end{lstlisting}

\texttt{chemin} est le chemin vers le fichier inclus, et est :
\begin{itemize}
  \item soit un chemin absolu (il commence par « \texttt{/} ») ;
  \item soit un chemin relatif par rapport au fichier source.
\end{itemize}

\sectionLabel{Gestion des pages de la mémoire programme}{gestionPagesMidRange}

La mémoire programme d'un \emph{mid-range} est constituée d'une ou plusieurs pages de 2048 instructions chacune. Le \refTableau{nombrePagesMidRange} cite quelques micro-contrôleurs \emph{mid-range} et le nombre de pages de leur mémoire programme.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Composant} & \textbf{Mémoire programme} & \textbf{Nombre de pages}\\
    \hline
    16F631  & 1024 instructions & 1\\
    16F677  & 2048 instructions & 1\\
    16F690  & 4096 instructions & 2\\
    16F722  & 2048 instructions & 1\\
    16F723, 16F724  & 4096 instructions & 2\\
    16F727  & 8192 instructions & 4\\
    \hline
  \end{tabular}
  \caption{Mémoire programme de quelques micro-contrôleurs \emph{mid-range}}
  \labelTableau{nombrePagesMidRange}
\end{table}

Les deux instructions machine de branchement que le jeu d'instructions des \emph{mid-range} définit sont \assembleur{CALL} et \assembleur{GOTO} (\refTableau{callGotoMidRange}). En résumé, ces instructions ne permettent pas d'effectuer par elles mêmes un branchement à tout position de la mémoire programme, mais uniquement un branchement à toute position de la page courante.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{3}{}{\fondTableau}
  \begin{tabular}{llcccc}
    \textbf{Instruction} & \textbf{Description} & \multicolumn{4}{l}{\bf Code binaire}\\
                         &                      & 13 & 12 & 11 & 10 à 0\\
    \hline
    \texttt{call k}  & Call subroutine & 1 & 0 & 0 & k \\
    \texttt{goto k}  & Go to Address   & 1 & 0 & 1 & k \\
    \hline
  \end{tabular}
  \caption{Instructions \texttt{call} et \texttt{goto} des \emph{mid-range}}
  \labelTableau{callGotoMidRange}
\end{table}



Pour changer de page en assembleur, il faut modifier les bits 3 et 4 du registre \assembleur{PCLATH} avant d'appeler l'instruction \assembleur{CALL} ou \assembleur{GOTO}.

En Piccolo, il est déconseillé d'accéder directement à \assembleur{PCLATH}. Les instructions \texttt{jsr} et \texttt{jump} prennent en charge les branchements vers une autre page. En résumé :
\begin{itemize}
  \item une routine doit complètement résider à l'intérieur d'une page ;
  \item lors de la déclaration d'une routine, la page dans laquelle elle réside est précisée (\refSubsectionPage{declarationRoutineMidRangeEtPage}) ;
  \item les instructions Piccolo \texttt{call} et \texttt{goto} effectuent des branchements à l'intérieur de la page courante ;
  \item pour appeler des routines placées dans une autre page, utiliser les instructions Piccolo \texttt{jsr} (\refSubsectionPage{instructionJsrMidRange}) et \texttt{jump} (\refSubsectionPage{instructionJumpMidRange}).
\end{itemize}



\subsectionLabel{Instruction \texttt{jump}}{instructionJumpMidRange}

L'instruction Piccolo \texttt{jump} engendre des instructions machine \assembleur{BCF} ou \assembleur{BSF} pour modifier les bits 3 et 4 du registre \assembleur{PCLATH}, puis l'instruction machine \assembleur{GOTO}.

Elle occupe donc $n+1$ mots de la mémoire programme, $n$ étant le nombre de bits du registre \assembleur{PCLATH} à changer.




\subsectionLabel{Instruction \texttt{jsr}}{instructionJsrMidRange}

L'instruction Piccolo  \texttt{jsr} engendre des instructions machine \assembleur{BCF} ou \assembleur{BSF} pour modifier les bits 3 et 4 du registre \assembleur{PCLATH}, puis l'instruction machine \assembleur{CALL}, puis de nouveau des instructions machine \assembleur{BCF} ou \assembleur{BSF} pour rétablir les bits 3 et 4 du registre \assembleur{PCLATH}.

Elle occupe donc $2n+1$ mots de la mémoire programme, $n$ étant le nombre de bits du registre \assembleur{PCLATH} à changer pour effectuer l'appel.

\subsectionLabel{Déclaration de routine et page}{declarationRoutineMidRangeEtPage}

Pour spécifier dans quelle page de la mémoire programme une routine régulière doit résider, il suffit de la déclarer comme suit :
\begin{lstlisting}[language=piccolo]
  routine nom page numero_page bank:... {
    ...
  }
\end{lstlisting}

Où \texttt{numero\_page} est un entier positif ou nul strictement inférieur au nombre de pages. Par défaut, si la page n'est pas déclarée, la routine est placée dans la page zéro. La déclaration de la page doit précéder la déclaration de banc \texttt{bank}.

Pour une routine régulière sans retour :
\begin{lstlisting}[language=piccolo]
  noreturn routine nom page numero_page bank:... {
    ...
  }
\end{lstlisting}

\subsection{Exemple}

Différents exemples sont donnés sur la page \url{http://piccolo.rts-software.org/examples/index.php}.

Le 16F690 a une mémoire programme de deux pages. 

\begin{lstlisting}[language=piccolo]
midrange multiple_pages "16F690" :

noreturn routine main page 1 bank:requires 0 {
  jsr  routinePage0
  jump routineNoReturnPage0
}

noreturn  routine routineNoReturnPage0 page 0 {
  forever
  end
}

routine routinePage0 page 0 {
  jsr  routinePage1
}

routine routinePage1 page 1 {
}

end
\end{lstlisting}












\sectionLabel{Routine d'interruption mid-range}{routineInterruptionMidrange}


Les micro-contrôleurs \emph{mid-range} acceptent qu’une seule routine d’interruption (à l’adresse 0x04). Lors de la réponse à une interruption, seul le compteur programme PC est empilé dans la pile matérielle. Or, il peut être nécessaire de sauver :
\begin{itemize}
  \item le registre \assembleur{W} ;
  \item le registre \assembleur{STATUS} ;
  \item le registre \assembleur{PCLATH}.
\end{itemize}

Nous allons d'abord voir comment cette sauvegarde doit être réalisée en assembleur, et ensuite nous exposerons comment elle est faite en Piccolo.

\subsection{Allure générale de la routine d'interruption en assembleur}

La routine d'interruption a l'allure suivante :
\begin{enumerate}
  \item sauvegarde de \assembleur{W} ;
  \item sauvegarde de \assembleur{STATUS} ;
  \item sauvegarde de \assembleur{PCLATH} ;
  \item instructions utilisateur;
  \item restitution de \assembleur{PCLATH} ;
  \item restitution de \assembleur{STATUS} ;
  \item restitution de \assembleur{W} ;
  \item instruction de retour d'interruption.
\end{enumerate}


Le but de Piccolo est de simplifier au maximum l'expression des opérations de sauvegarde et de restitution en proposant des constructions appropriées.

\subsubsection{Sauvegarde de \assembleur{W}}

Il est nécessaire de sauver \assembleur{W} si des instructions de la routine d'interruption le modifie. Pour effectuer cette sauvegarde, on exécute simplement l'instruction suivante, qui copie le contenu de \assembleur{W} dans la mémoire \assembleur{W\_TEMP} :

\begin{lstlisting}[language=assembleur]
MOVWF W_TEMP 
\end{lstlisting}

Où déclarer \assembleur{W\_TEMP} ? C'est là où cela se complique. En effet, dans le cas général, le micro-contrôleur présente plusieurs bancs mémoire, et il est impossible de savoir le banc qui est sélectionné au moment où l'interruption survient.

Si le micro-contrôleur présente une zone \emph{partagée} qui apparaît en miroir sur tous les bancs, alors \assembleur{W\_TEMP} doit être déclaré dans cette zone. Souvent cette zone partagée apparaît aux adresses 0x70 à 0x7F dans le banc 0, 0xF0 à 0xFF dans le banc 1, …

Malheureusement, certains micro-contrôleurs ne possèdent pas de zone partagée entre tous les bancs : c'est par exemple le cas des 16F873\index{16F873} et 16F874\index{16F874}. En fait, pour ces deux micro-contrôleurs, les emplacements mémoire (les « \emph{General Purpose Registers} ») du banc 2 sont le miroir du banc 0, et ceux du banc 3 le miroir du banc 1. La seule possibilité en assembleur est donc de déclarer manuellement une variable dans les deux premiers bancs de façon qu'elles apparaissent en miroir ; par exemple \assembleur{W\_TEMP0} dans le banc 0 à l'adresse 0x20 et \assembleur{W\_TEMP1} dans le banc 1 à l'adresse 0xA0.


\subsubsection{Sauvegarde de \assembleur{STATUS}}

Il est à noter que l'instruction précédente \assembleur{MOVWF W\_TEMP} ne modifie pas les indicateurs du registre d'état \assembleur{STATUS}. Pour sauver ce registre dans une mémoire \assembleur{STATUS\_TEMP}, il faut passer par l'intermédiaire de \assembleur{W}. Pour transférer le contenu de \assembleur{STATUS} dans \assembleur{W}, on ne peut pas utiliser l'instruction \assembleur{MOVF} car elle modififie l'indicateur \assembleur{Z}. On utilise donc \assembleur{SWAPF}, et, c'est le contenu \emph{swappé} du registre \assembleur{STATUS} qui est transféré dans \assembleur{W}. Avant d'écrire \assembleur{W} dans \assembleur{STATUS\_TEMP}, on exécute \assembleur{CLRF STATUS}, ce qui a pour effet d'effacer les bits \assembleur{RP} : ainsi \assembleur{STATUS\_TEMP} doit être déclaré dans le banc 0. La séquence complète de sauvegarde du registre \assembleur{STATUS} est donc :

\begin{lstlisting}[language=assembleur]
SWAPF STATUS, W
CLRF  STATUS
MOVWF STATUS_TEMP 
\end{lstlisting}

\subsubsection{Sauvegarde de \assembleur{PCLATH}}

La réponse à l'interruption laisse le registre \assembleur{PCLATH} inchangé. Si la routine d'interruption n'invoque ni l'instruction \assembleur{CALL} ni l'instruction \assembleur{GOTO}, \assembleur{PCLATH} n'est pas utilisé et il est inutile de le sauvegarder. Dans le cas contraire, et si le programme s'étend sur plusieurs pages de la mémoire programme, le contenu des bits 3 et 4 de \assembleur{PCLATH} -- les bits utilisés par les instructions \assembleur{CALL} et \assembleur{GOTO} -- est inconnu. Il faut donc sauvegarder ce registre, puis l'effacer (\assembleur{PCLATH\_TEMP} est déclaré dans le banc 0) :

\begin{lstlisting}[language=assembleur]
MOVF  PCLATH, W
MOVWF PCLATH_TEMP 
CLRF  PCLATH
\end{lstlisting}




\subsubsection{Restitution de \assembleur{STATUS}}

La restitution de \assembleur{PCLATH} est simple, il suffit de recopier \assembleur{PCLATH\_TEMP} dans \assembleur{PCLATH}, en se souvenant que \assembleur{PCLATH\_TEMP} contient la valeur \emph{swappée} :

\begin{lstlisting}[language=assembleur]
SWAPF STATUS_TEMP, W
MOVWF STATUS
\end{lstlisting}


\subsubsection{Restitution de \assembleur{W}}

Il y a une petite subtilité, car on ne peut pas utiliser \assembleur{MOVF W\_TEMP, W}. En effet, cette instruction modifie l'indicateur \assembleur{Z}. On utilise donc l'instruction \assembleur{SWAPF} qui a la particularité de ne modifier aucun indicateur. Pour restituer la valeur non \emph{swappée}, on effectue d'abord un \emph{swap} en mémoire :

\begin{lstlisting}[language=assembleur]
SWAPF W_TEMP, F
SWAPF W_TEMP, W
\end{lstlisting}





\subsubsection{Récapitulatif}

La routine d'interruption d'un \emph{mid-range} a l'allure suivante en assembleur :

\begin{lstlisting}[language=assembleur]
; 1- Sauvegarde de W
  MOVWF W_TEMP 
; 2- Sauvegarde de STATUS
  SWAPF STATUS, W
  CLRF  STATUS
  MOVWF STATUS_TEMP 
; 3- Sauvegarde de PCLATH
  MOVF  PCLATH, W
  MOVWF PCLATH_TEMP 
  CLRF  PCLATH
; 4- instructions utilisateur

; 5- Restitution de PCLATH
  MOVF  PCLATH_TEMP, W
  MOVWF PCLATH 
; 6- Restitution de STATUS
  SWAPF STATUS_TEMP, W
  MOVWF STATUS
; 7- Restitution de W
  SWAPF W_TEMP, F
  SWAPF W_TEMP, W
; 8- Retour d'interruption
  RETFIE
\end{lstlisting}






\subsection{Routine d'interruption en Piccolo}


En Piccolo, la routine d’interruption \emph{midrange} est décrite dans une section \texttt{interrupt} :

\begin{lstlisting}[language=piccolo]
interrupt contextsave ... {
 instructions
}
\end{lstlisting}

La section \texttt{interrupt} peut apparaître n’importe où dans le programme, Piccolo rangera toujours le code engendré à l’adresse 0x04. Le qualificatif \texttt{page} d’une routine ne peut pas être utilisée pour une routine d’interruption. Le qualificatif \texttt{contextsave} permet de préciser les zones mémoire utilisées pour la sauvegarde du contexte (voir à partir de la page suivante).

Dans un programme, au plus une routine d’interruption peut être définie : une erreur est signalée si plusieurs le sont.

Toutes les instructions décrites sont autorisées, sauf les instructions qui ne terminent jamais telles que la boucle infinie et les instructions de branchement vers une routine sans retour \texttt{goto} et \texttt{jump}.

L’instruction assembleur \assembleur{RETFIE} n’existe pas en Piccolo : le compilateur l’insère automatiquement à la fin de la routine d’interruption.

\subsection{Interruption et sauvegarde du contexte en Piccolo}

En conséquence de l'étude qui précède, il y a donc quatre cas à considérer, en fonction des deux conditions suivantes :
\begin{itemize}
  \item le micro-contrôleur présente-t-il une zone mémoire commune à tous les bancs on non ?
  \item le programme s’étend-il sur plusieurs pages et le sous-programme d’interruption contient-il des branchements ou des appels de sous-programmes ? Si oui, \assembleur{PCLATH} devra aussi être sauvé.
\end{itemize}


Piccolo détecte automatiquement les différents cas, et propose une écriture unique :
\begin{lstlisting}[language=piccolo]
interrupt contextsave sauveA, sauveB {
  ...
}
\end{lstlisting}

Le \refTableau{sauvegardeItMidRange} précise comment déclarer \texttt{sauveA} et \texttt{sauveB} en fonction des quatre différentes situations, et le \refTableau{roleVarSauveContexteMidrange} en détaille l'utilisation.

\begin{table}[!ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}p{4cm}p{4cm}}
    \textbf{Situation} & \texttt{\bf sauveA} & \texttt{\bf sauveB}\\
    \hline
    (1) Zone mémoire commune à tous les bancs, programme dans la page 0 & 1 octet dans le banc 0 & 1 octet dans le banc commun\\
    (2) Zone mémoire commune à tous les bancs, programme sur plusieurs pages & 2 octets dans le banc 0 & 1 octet dans le banc commun\\
    (3) Aucune zone mémoire commune à tous les bancs, programme dans la page 0 & 2 octets dans le banc 0 & 1 octet dans le banc commun\\
    (4) Aucune mémoire commune à tous les bancs, programme sur plusieurs pages & 3 octets dans le banc 0 & 1 octet dans le banc commun\\
  \hline
  \end{tabular}
  \caption{Sauvegarde du contexte pour \emph{mid-range}}
  \labelTableau{sauvegardeItMidRange}
\end{table}

\begin{table}[!ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}p{5cm}l}
    \textbf{Situation} & \texttt{\bf sauveA} & \texttt{\bf sauveB}\\
    \hline
    (1) Zone mémoire commune à tous les bancs, programme dans la page 0 & Sauvegarde de \texttt{STATUS} & Sauvegarde de \texttt{W}\\
    (2) Zone mémoire commune à tous les bancs, programme sur plusieurs pages & Sauvegarde de \texttt{STATUS} et de \texttt{PCLATH} & Sauvegarde de \texttt{W}\\
    (3) Aucune zone mémoire commune à tous les bancs, programme dans la page 0 & Sauvegarde de \texttt{W} et de \texttt{STATUS} & Sauvegarde de \texttt{W}\\
    (4) Aucune mémoire commune à tous les bancs, programme sur plusieurs pages & Sauvegarde de \texttt{W}, \texttt{STATUS} et de \texttt{PCLATH} & Sauvegarde de \texttt{W}\\
  \hline
  \end{tabular}
  \caption{Rôle des variables de sauvegarde du contexte pour \emph{mid-range}}
  \labelTableau{roleVarSauveContexteMidrange}
\end{table}


~\\
\textbf{Situation (1) : zone mémoire commune à tous les bancs, programme dans la page 0.} Le code Piccolo est le suivant :
\begin{lstlisting}[language=piccolo]
midrange interrupt1 "16F690" :
ram gpr0 {
  byte itSave0 
}
ram gprnobnk {
  byte itsave1
}
interrupt contextsave itSave0, itsave1 {
  instructions
}
...
end
\end{lstlisting}

Et le code engendré pour la routine d'interruption est :
\begin{lstlisting}[language=assembleur]
  ORG 0x4
  MOVWF itsave1
  SWAPF STATUS, W
  CLRF STATUS
  MOVWF itSave0
  instructions
  SWAPF itSave0, W
  MOVWF STATUS
  SWAPF itsave1, F
  SWAPF itsave1, W
  RETFIE
\end{lstlisting}



~\\
\textbf{Situation (2) : zone mémoire commune à tous les bancs, programme sur plusieurs pages.} Le code Piccolo est le suivant :
\begin{lstlisting}[language=piccolo]
midrange interrupt2 "16F690" :
ram gpr0 {
  byte itSave0 [2]
}
ram gprnobnk {
  byte itsave1
}
interrupt contextsave itSave0, itsave1 {
  instructions
}
...
end
\end{lstlisting}

Et le code engendré pour la routine d'interruption est :
\begin{lstlisting}[language=assembleur]
  ORG 0x4
  MOVWF itsave1
  SWAPF STATUS, W
  CLRF STATUS
  MOVWF itSave0
  MOVF PCLATH, W
  MOVWF itSave0 + 0x1
  instructions
  MOVF itSave0 + 0x1, W
  MOVWF PCLATH
  SWAPF itSave0, W
  MOVWF STATUS
  SWAPF itsave1, F
  SWAPF itsave1, W
  RETFIE
\end{lstlisting}







~\\
\textbf{Situation (3) : aucune zone mémoire commune à tous les bancs, programme dans la page 0.} Le code Piccolo est le suivant :
\begin{lstlisting}[language=piccolo]
midrange interrupt3 "16F873" :
ram gpr0 {
  byte itSave0 [2]
}
ram gpr1 {
  byte itsave1
}
interrupt contextsave itSave0, itsave1 {
  instructions
}
...
end
\end{lstlisting}

Et le code engendré pour la routine d'interruption est :
\begin{lstlisting}[language=assembleur]
  ORG 0x4
  MOVWF itSave0
  SWAPF STATUS, W
  CLRF STATUS
  MOVWF itSave0 + 0x1
  instructions
  SWAPF itSave0 + 0x1, W
  MOVWF STATUS
  SWAPF itSave0, F
  SWAPF itSave0, W
  RETFIE
\end{lstlisting}





~\\
\textbf{Situation (4) : aucune mémoire commune à tous les bancs, programme sur plusieurs pages.} Le code Piccolo est le suivant :
\begin{lstlisting}[language=piccolo]
midrange interrupt4 "16F873" :
ram gpr0 {
  byte itSave0 [3]
}
ram gpr1 {
  byte itsave1
}
interrupt contextsave itSave0, itsave1 {
  instructions
}
...
end
\end{lstlisting}

Et le code engendré pour la routine d'interruption est :
\begin{lstlisting}[language=assembleur]
  ORG 0x4
  MOVWF itSave0
  SWAPF STATUS, W
  CLRF STATUS
  MOVWF itSave0 + 0x1
  MOVF PCLATH, W
  MOVWF itSave0 + 0x2
  CLRF PCLATH
  instructions
  MOVF itSave0 + 0x2, W
  MOVWF PCLATH
  SWAPF itSave0 + 0x1, W
  MOVWF STATUS
  SWAPF itSave0, F
  SWAPF itSave0, W
  RETFIE\end{lstlisting}








\section{Optimisations}

Cette section indique les différentes optimisations d'un code \emph{mid-range}. L'optimisation est activée par l'option « \texttt{-o} ».

Pour optimiser, Piccolo applique les remplacements indiqués par le \refTableau{optimisationsMidRange}, et élimine le code mort. Le code est balayé de manière répétitive, tant que des optimisations sont effectuées.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{ll}
    \textbf{Situation} & \textbf{Optimisation} \\
    \hline
    \texttt{CALL} vers \texttt{RETLW k}  & Remplacement par \texttt{MOVLW k}\\
    \texttt{GOTO} vers \texttt{RETLW k}  & Remplacement par \texttt{RETLW k}\\
    \texttt{GOTO a} vers \texttt{GOTO b}  & Remplacement par \texttt{GOTO b}\\
    \texttt{GOTO} vers l'instruction qui suit  & Suppression\\
    \texttt{JSR} vers \texttt{RETLW k}  & Remplacement par \texttt{MOVLW k}\\
    \texttt{JUMP} vers \texttt{RETLW k}  & Remplacement par \texttt{RETLW k}\\
    \texttt{JUMP a} vers \texttt{JUMP b}  & Remplacement par \texttt{JUMP b}\\
    \texttt{JUMP a} vers \texttt{GOTO b}  & Remplacement par \texttt{JUMP b}\\
    \hline
  \end{tabular}
  \caption{Optimisation du code \emph{mid-range}}
  \labelTableau{optimisationsMidRange}
\end{table}




