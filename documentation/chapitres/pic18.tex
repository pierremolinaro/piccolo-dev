%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapter{Programmes pour pic18}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}




\section{Exemples de programmes pour pic18}

\subsection{Premier exemple : \emph{blink led}}

Ce simple programme est destiné à un 18F448 et fait clignoter à 1 Hz environ une led connectée au port \texttt{RE0}. Il programme donc \texttt{RE0} (broche 8) en sortie. La configuration suppose qu'il est connecté à une horloge externe à 40 MHz sur la broche \texttt{OSC1} (broche 13). 

Ce programme a l'allure suivante :
\begin{lstlisting}[language=piccolo]
pic18 blink_led "18F448" :
#------------ Configuration
configuration {
  ...
}
#------------ RAM
ram accessram {
  ...
}
#------------ Routine main
noreturn routine main bank:requires 0 {
  ...
}
#------------ Fin
end
\end{lstlisting}

L'en-tête indique qu'il s'agit d'un programme pour \emph{pic18}, qu'il s'appelle \emph{blink\_led}, et qu'il est destiné au micro-contrôleur 18F448. Ce corps de ce programme est constitué de trois sections, décrites dans la suite de cette section : configuration, ram, et routine \emph{main}. D'autres types de sections peuvent être définies, mais sont absentes de ce premier exemple. La \refSectionPage{structurePrgmPic18} donne une liste exhaustive des différentes sections d'un programme pour \emph{pic18}. 

La section \texttt{configuration} décrit les valeurs qui sont affectées aux \emph{bits de configuration} du micro-contrôleur. Les valeurs choisies pour cet exemple sont listées ci-dessous. Pour une description complète de cette section, nous invitons le lecteur à se reporter au \refChapterPage{configuration}.
\begin{lstlisting}[language=piccolo]
#------------ Configuration
configuration {
  OSC : "EC-OSC2 as RA6"
  OSCS : Disabled
  WDT : "Disabled-Controlled by SWDTEN bit"
  WDTPS : "1:128"
  STVR : Disabled
  LVP : Disabled
  CP_0 : Disabled
  CP_1 : Disabled
  CP_2 : Disabled
  CP_3 : Disabled
  WRT_1 : Disabled
  WRT_2 : Disabled
  WRT_3 : Disabled
  WRT_0 : Disabled
  EBTR_0 : Disabled
  EBTR_1 : Disabled
  EBTR_2 : Disabled
  EBTR_3 : Disabled
  BACKBUG : Disabled
  BODEN : Disabled
  BODENV : "4.5V"
  CPB : Disabled
  CPD : Disabled
  EBTRB : Disabled
  PUT : Enabled
  WRTB : Disabled
  WRTC : Disabled
  WRTD : Disabled
}
\end{lstlisting}


La section \texttt{ram} déclare les variables du programme. Ce type de section est complètement décrit au \refChapterPage{ram}. Le 18F448 possède plusieurs bancs mémoire, dont on obtient la composition en appelant \texttt{piccolo} avec l'option \texttt{-{}-memory=18F448} (voir \refSubsectionPage{exempleOptionMemory}) :


{\footnotesize \lstinputlisting[frame=l]{files-from-piccolo/memory-18F448.txt}}

Ainsi, le 18F448 possède quatre bancs mémoire : \emph{accessram}, \emph{gpr0}, \emph{gpr1} et \emph{gpr2}. En consultant la document du 18F448, on établit que le banc \emph{accessram} est accessible quel que soit \texttt{BSR}, que l'accès aux variables du banc \emph{gpr0} impose que \texttt{BSR} soit égal à 0, que l'accès aux variables du banc \emph{gpr1} impose que \texttt{BSR} soit égal à 1, etc.

Pour simplifier l'écriture de ce premier programme, on place donc les trois variables dont on a besoin dans le banc \emph{accessram} :
\begin{lstlisting}[language=piccolo]
#------------ RAM
ram accessram {
  byte compteurL
  byte compteurH
  byte compteurU
}
\end{lstlisting}

Cette écriture alloue les emplacements séquentiellement : \texttt{compteurL} sera à l'adresse 0, \texttt{compteurH} à l'adresse 1, et \texttt{compteurU} à l'adresse 2.

Il reste maintenant à décrire la routine \emph{main}. Un programme valide doit toujours contenir une routine nommée \emph{main} : c'est le point d'entrée de l'exécution à la mise sous tesion ou après un \emph{reset}. L'en-tête de la routine \emph{main} doit en outre comporter deux qualificatifs :
\begin{itemize}
  \item \texttt{noreturn} : ceci exprime que la routine doit se terminer par une boucle infinie, ou un branchement à une routine elle aussi sans retour ;
  \item \texttt{bank:requires 0} : ceci exprime que lors de l'appel, le registre \texttt{BSR} contient la valeur 0\footnote{\texttt{BSR} est initialisé à 0 à la mise sous tension ou lors d'un \emph{reset}.}, et que donc on pourrait utiliser des variables dans le banc \emph{gpr0} sans modifier \texttt{BSR}.
\end{itemize}

Dans le code de la routine, parmi les instructions assembleur, on trouve une instruction \texttt{if} structurée, dont les conditions cachent une utilisation de l’instruction \texttt{TSTFSZ}, à l'intérieur d'une boucle infinie implémentée par la construction \texttt{forever ... end}.

\begin{lstlisting}[language=piccolo]
#------------ Routine main
noreturn routine main bank:requires 0 {
#--- Aucune entree analogique
  movlw 7
  movwf ADCON1
#--- Programmer RE0 en sortie
  bcf  TRISE.0
#--- Initialiser les compteurs
  clrf compteurL
  clrf compteurH
  clrf compteurU
#--- Boucle infinie
  forever
    if (compteurL NZ)
      decf compteurL
    elsif (compteurH NZ)
      decf compteurH
      setf compteurL
    elsif (compteurU NZ)
      decf compteurU
      setf compteurH
      setf compteurL
    else
    #--- Reinitialiser les compteurs
      movlw  0x0F
      movwf  compteurU
      movlw  0x42
      movwf  compteurH
      movlw  0x40
      movwf  compteurL
    #--- Clignoter
      btg  PORTE.0
    end
  end
}
\end{lstlisting}

Pour terminer ce premier exemple, il est utile de jeter un coup d’œil sur le code assembleur engendré (option « \texttt{-S} »), à gauche sans optimisation, à droite avec optimisations grâce à l’option « \texttt{-O} ». L’optimisation gagne 4 instructions (le \texttt{bra main} initial, et la meilleure utilisation des trois occurrences de l’instruction \texttt{TSTFSZ}. Observez aussi l’optimisation des sauts (ne vous basez pas sur les noms des étiquettes, elles changent de signification avec l’optimisation).

\begin{multicols}{2}
\textbf{Code non optimisé}
\begin{lstlisting}[language=assembleur]
  ORG 0
  bra   main
main:
  movlw 0x7
  movwf ADCON1
  bcf  TRISE, 0
  clrf compteurL
  clrf compteurH
  clrf compteurU
_label_0:
  TSTFSZ compteurL
  bra _bcc_label_0
  bra _label_1
_bcc_label_0:
  decf compteurL, F
  bra   _label_2
_label_1:
  TSTFSZ compteurH
  bra _bcc_label_1
  bra _label_3
_bcc_label_1:
  decf compteurH, F
  setf compteurL
  bra   _label_4
_label_3:
  TSTFSZ compteurU
  bra _bcc_label_2
  bra _label_5
_bcc_label_2:
  decf compteurU, F
  setf compteurH
  setf compteurL
  bra   _label_6
_label_5:
  movlw 0xF
  movwf compteurU
  movlw 0x42
  movwf compteurH
  movlw 0x40
  movwf compteurL
  BTG  PORTE, 0
_label_6:
_label_4:
_label_2:
  bra   _label_0
\end{lstlisting}
\columnbreak
\textbf{Code optimisé}
\begin{lstlisting}[language=assembleur]
  ORG 0
  movlw 0x7
  movwf ADCON1
  bcf  TRISE, 0
  clrf compteurL
  clrf compteurH
  clrf compteurU
_label_0:
  TSTFSZ compteurL
  bra _label_1
  TSTFSZ compteurH
  bra _label_3
  TSTFSZ compteurU
  bra _label_5
  movlw 0xF
  movwf compteurU
  movlw 0x42
  movwf compteurH
  movlw 0x40
  movwf compteurL
  BTG  PORTE, 0
  bra   _label_0
_label_5:
  decf compteurU, F
  setf compteurH
  setf compteurL
  bra   _label_0
_label_3:
  decf compteurH, F
  setf compteurL
  bra   _label_0
_label_1:
  decf compteurL, F
  bra   _label_0
\end{lstlisting}
\end{multicols}


\subsection{Deuxième exemple : \emph{blink led} sous interruption}

Ce simple programme fait clignoter à 4 Hz une led connectée au port \texttt{RE0}. Il programme donc \texttt{RE0} (broche 8) en sortie. La configuration suppose qu'il est connecté à une horloge externe à 40 MHz sur \texttt{OSC1} (broche 13). Un sous-programme d'interruption est déclenché toutes les 0,1 ms par le timer 2. Pour illustrer les instructions de gestion des bancs, les deux variables sont placées dans le banc 2. Supprimez ou déplacez les instructions \texttt{banksel}, pour mettre en évidence les vérifications faites par le compilateur.

Le programme a l'allure suivante :
\begin{lstlisting}[language=piccolo]
pic18 blink_led_it "18F448" :
#------------ Configuration
configuration {
  ...
}
#------------ RAM
ram accessram {
  ...
}
#------------ Routine d'interruption
interrupt high fast {
  ...
}
#------------ Routine main
noreturn routine main bank:requires 0 {
  ...
}
#------------ Fin
end
\end{lstlisting}

Le code de configuration est le même que celui du premier exemple.


\begin{lstlisting}[language=piccolo]
ram gpr2 {
  byte compteurL
  byte compteurH
}
\end{lstlisting}
La section \texttt{ram} décrit l’attribution de la RAM du micro-contrôleur. Le nom \texttt{gpr2} est le nom du banc qui commence à l’adresse 0x100. Les adresses sont allouées séquentiellement : \texttt{compteurL} a pour adresse 0x100, et \texttt{compteurH} a pour adresse 0x101. Ces deux registres ne seront donc accessibles que via le registre \texttt{BSR}.


\begin{lstlisting}[language=piccolo]
interrupt high fast {
#--- Acquitter l'interruption du timer 2 
  bcf  PIR1.TMR2IF 
#--- Decompter le temps
  banksel 2 
  if (compteurL NZ)
    decf compteurL
  elsif (compteurH NZ)
    decf compteurH
    setf compteurL
  else
  #--- Reinitialiser les compteurs
    movlw  0x13
    movwf  compteurH
    movlw  0x87
    movwf  compteurL
  #--- Clignoter
    btg  PORTE.0
  end
}
\end{lstlisting}
Une section \texttt{interrupt} définit un sous-programme d’interruption. Il porte le nom « \texttt{high} », ce qui signifie qu’il est attaché au point d’entrée d’adresse 0x8. Il porte aussi le qualificatif \texttt{fast}, ce qui signifie que l’instruction \texttt{retfie 1} sera engendrée pour effectuer le retour d’interruption.

Dans un programme plus complexe, il n’est pas possible de prévoir à la compilation la valeur de \texttt{BSR} quand une interruption survient. Aussi l’instruction \texttt{banksel 2} est obligatoire avant d’adresser les registres du compteur (essayez de la supprimer, le compilateur engendrera un message d'erreur).

\begin{lstlisting}[language=piccolo]
noreturn routine main bank:requires 0 {
#--- Aucune entree analogique
  movlw 7
  movwf ADCON1
#--- Programmer RE0 en sortie
  bcf  TRISE.0
#--- Initialiser les compteurs
  banksel 2
  clrf compteurL
  clrf compteurH
#--- Initialiser le Timer 2
#  Horloge de base : 10 MHz
#  Le Prescaler est fixe a 4 -> 2 500 kHz
#  PR2 est fixe a 250 -> 10 kHz
  movlw  250 - 1 # La periode est PR2 + 1
  movwf  PR2
  movlw  @T2CON (TOUTPS:0, TMR2ON:1, T2CKPS:1)
  movwf  T2CON  
#--- Autoriser les priorites d'interruption
  bsf  RCON.IPEN
#--- Autoriser l'interruption en provenance du Timer 0
  bsf  PIE1.TMR2IE
#--- Valider les its
  bsf  INTCON.GIEH
  bsf  INTCON.GIEL
#--- Boucle infinie
  forever
  end
}
\end{lstlisting}

Deux commentaires : ici aussi, l’instruction \texttt{banksel 2} est obligatoire avant d’adresser les registres du compteur (essayez de la supprimer…) ; tous les autres accès s’effectuant via l’acces bank, il n’est pas nécessaire de changer la valeur de \texttt{BSR}.

L’instruction
\begin{lstlisting}[language=piccolo]
  movlw  @T2CON (TOUTPS:0, TMR2ON:1, T2CKPS:1)
\end{lstlisting}
est particulière : elle permet de construire une valeur statique champ par champ (voir à §§).







\sectionLabel{Structure d’un programme pour pic18}{structurePrgmPic18}

Un programme Piccolo pour \emph{pic18} a la structure suivante :

\begin{lstlisting}[language=piccolo]
pic18 nom "nom_composant" :
  liste_de_sections
end
\end{lstlisting}


Dans l’en-tête :
\begin{itemize}
  \item le nom « \emph{nom} » est le nom du fichier (sans son extension) qui contient ce texte source ;
  \item le nom du composant « \emph{nom\_composant} » doit être exactement le nom de l’un des composants supportés (pour obtenir la liste des pic18 pris en charge, utiliser l’option « \texttt{-{}-pic18} », voir \refSubsectionPage{listePic18}).
\end{itemize}


Le corps du programme est constitué d’une liste non ordonnée de sections. Les sections disponibles sont listées dans le \refTableau{sectionsPic18}.
\begin{table}[!ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}lll}
    \textbf{Type de section} & \textbf{Mot-clé introductif} & \textbf{Référence}\\
    \hline
    Vérification du type du micro-contrôleur & \texttt{checkpic} & \refChapterPage{checkpic}\\
    Configuration & \texttt{configuration} & \refChapterPage{configuration}\\
    Définition de variable & \texttt{ram} & \refChapterPage{ram}\\
    Définition de constante & \texttt{const} & \refChapterPage{constante}\\
    Définition de routine pic18 & \texttt{routine} & \refSectionPage{routinePic18}\\
    Définition de routine d'interruption pic18 & \texttt{interrupt} & \refSectionPage{routineInterruptionPic18}\\
    Data & \texttt{data} & \refSectionPage{sectionData} \\
    Include & \texttt{include} & \refSectionPage{sectionInclude} \\
  \hline
  \end{tabular}
  \caption{Les sections d'un programme pour \emph{pic18}}
  \labelTableau{sectionsPic18}
\end{table}









\sectionLabel{Routines pic18}{routinePic18}

Les routines définissent le code exécutable de votre programme. L’une d’entre elles doit s’appeler \texttt{main} : c’est la routine qui s’exécute au démarrage. Il y a deux types de routine, les routines \emph{régulières} et les routines \emph{sans retour}.


L’ordre des déclarations des routines est quelconque, il est possible d’appeler une routine qui est déclarée après l’instruction d’appel. Simplement Piccolo engendrera leur code dans leur ordre d’apparition. 

~\\
\textbf{Routine et BSR.} Un problème important en assembleur est la gestion du registre de sélection de banc \texttt{BSR} : son utilisation correcte en assembleur est complètement à la charge du programmeur. Piccolo propose des instructions pour sécuriser son emploi : voir la \refSectionPage{instructionsGestionBancsMemoire}.

~\\
\textbf{Liste d’instructions d’une routine.} Elle est structurée : Piccolo définit des instructions de sélection et de répétition : cela signifie que vous ne pouvez pas déclarer d’étiquette, ni utiliser des \texttt{bra} ni des \texttt{goto} pour effectuer des branchements à l’intérieur d’une routine.


\subsection{Routine régulière}

C'est un sous-programme. Une routine régulière peut ne comporter aucune instruction Piccolo, l'instruction \texttt{return} est implicitement ajoutée. Une routine régulière est déclarée par :
\begin{lstlisting}[language=piccolo]
routine maRoutine ... {
  ...
}
\end{lstlisting}

\texttt{maRoutine} est le nom de la routine, celui qui sera nommé dans un instruction d’appel de routine. Entre les accolades « \texttt{\{} » et « \texttt{\}} », apparaît la liste des instructions.

~\\
\textbf{Appel d’une routine régulière.} Utiliser \texttt{RCALL}, \texttt{CALL} ou \texttt{JSR}, comme indiqué à la \refSubsectionPage{appelRoutineRegulierePic18}.

\subsection{Routine sans retour}

L’exécution ne revient pas jamais à l’appelant. Ce type de routine doit donc se terminer par des constructions particulières qui assurent le non-retour : une boucle infinie, un branchement (\texttt{bra}, Bcc, \texttt{goto} ou \texttt{jump}) vers une autre routine sans retour, un \texttt{bra} calculé ou un \texttt{goto} calculé vers d’autres routines sans retour.

Une routine sans retour doit être déclarée avec qualificatif \texttt{noreturn} :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine ... {
  ...
}
\end{lstlisting}

~\\
\textbf{Appel d’une routine sans retour.} Utiliser \texttt{bra}, \texttt{goto}, Bcc ou \texttt{jump}.


~\\
\textbf{Déclaration de la routine \texttt{main}.} Dans un programme, il doit exister une et une seule routine \texttt{main}, qui doit être déclarée comme suit :

\begin{lstlisting}[language=piccolo]
noreturn routine main bank:requires 0 {
   liste d'instructions
}

\end{lstlisting}

Le compilateur Piccolo insère à l’adresse zéro une instruction \texttt{bra} (ou \texttt{goto}) vers cette routine, de façon que la routine \texttt{main} soit exécutée au démarrage du micro-contrôleur. Le qualificatif \texttt{bank:requires 0} est exigé par le compilateur Piccolo car \texttt{BSR} est initialisé à zéro au démarrage du micro-contrôleur.


~\\
\textbf{Comment terminer une routine sans retour.} La dernière instruction de la liste des instructions d’une routine sans retour doit être :
\begin{itemize}
  \item une instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item un appel vers une autre routine sans retour, au moyen d’un \texttt{bra}, \texttt{goto}, Bcc ou \texttt{jump} ;
  \item un branchement calculé vers une routine parmi plusieurs, au moyen d’un \texttt{computed bra} ou d’un \texttt{computed goto} ;
  \item une instruction conditionnelle structurée, dont toutes les branches présentent comme dernière instruction les instructions d’appel d’un routine sans retour, un branchement calculé (comme évoqué ci-dessus), ou encore une instruction conditionnelle structurée, dont toutes les branches, etc.

\end{itemize}

Exemple simple : la dernière instruction est une boucle infinie :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  forever
    ...
  end
}
\end{lstlisting}

Exemple simple : la dernière instruction est un branchement vers une routine sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  bra autreRoutineSansRetour
}
\end{lstlisting}

La dernière instruction est un \texttt{computed bra} nommant les routines \texttt{r1}, \texttt{r2}, \texttt{r3} qui doivent être toutes les trois des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  computed [3] bra r1, r2, r3
}
\end{lstlisting}

La dernière instruction est un \texttt{if} dont aucune des branches ne se termine (\texttt{r1} est une routine sans retour) :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    bra r1
  else
    ...
    forever
      ...
    end
  end
}

\end{lstlisting}


La dernière instruction est un \texttt{if} dont la première branche se termine elle même par un \texttt{if} dont les deux branches se terminent par des branchements vers des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    if (...)
      ...
      bra r1
    else
      ...
      bra r2
    end
  else
    ...
    bra r3
  end
}
\end{lstlisting}








\sectionLabel{Routines d'interruption}{routineInterruptionPic18}

Les \emph{pic18} acceptent deux niveaux d’interruption, le niveau haut (\texttt{high}), et le niveau faible (\texttt{low}) :
l’occurrence d’une interruption de niveau haut provoque un branchement à l’adresse 0x08 ;
l’occurrence d’une interruption de niveau faible provoque un branchement à l’adresse 0x18.

Durant la réponse à une interruption, PC est sauvé dans la pile, et les registres \texttt{WREG}, \texttt{STATUS} et \texttt{BSR} sont sauvés dans des registres cachés. Le retour d’interruption s’effectue par une instruction \texttt{retfie} ; si l’opérande 1 (pour \texttt{FAST}) est précisée (\texttt{retfie 1}), alors \texttt{WREG}, \texttt{STATUS} et \texttt{BSR} sont restitués à partir des registres cachés.

Si les deux interruptions sont activées (\emph{enabled}), Microchip précise que le retour par \texttt{retfie 1} ne peut pas être utilisée fiablement pour l’interruption de faible priorité : « \emph{If both low and high priority interrupts are enabled, the stack registers cannot be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten} ».

Nous allons voir dans la suite comment Piccolo gère cette situation.

En Piccolo, une routine d’interruption PIC 18 est décrite dans une section \texttt{interrupt} :

\begin{lstlisting}[language=piccolo]
interrupt nom ... {
 instructions
}
\end{lstlisting}

Seuls deux noms sont possibles : \texttt{low} pour l’interruption de faible priorité, et \texttt{high} pour l’interruption de haute priorité. Bien entendu, un nom ne peut apparaître qu’une seule fois, aussi un programme ne peut comporter qu'au plus deux routines d'interruption, qui peuvent apparaître dans un ordre quelconque.

Dans une routine d'interruption, toutes les instructions décrites sont disponibles, sauf les instructions qui sont sans retour : boucle infinie, \texttt{bra} (branchement vers une routine sans retour), etc.

L’instruction assembleur \texttt{retfie} n’existe pas en Piccolo : le compilateur l’insère automatiquement à la fin des routines d’interruption.



\subsection{Qualificatif \texttt{fast}}

En Piccolo, vous pouvez ajouter le qualificatif \texttt{fast} à l’en-tête d’une routine d’interruption :

\begin{lstlisting}[language=piccolo]
interrupt nom fast {
 instructions
}
\end{lstlisting}

Avec ce qualificatif, l’instruction de retour engendrée par Piccolo est \texttt{retfie 1} (sans ce qualificatif, c’est \texttt{retfie 0}).

Si les deux routines d’interruption \texttt{low} et \texttt{high} sont déclarées, et si la routine \texttt{high} est déclarée \texttt{fast}, alors Piccolo considère comme une erreur de déclarer la routine \texttt{low} avec le qualificatif \texttt{fast}.






\subsection{Routine d'interruption et \texttt{BSR}}

\textbf{Routine déclarée avec \texttt{fast}.} Le contenu initial de \texttt{BSR}, au début de la routine d’interruption est inconnu. Il faut donc fixer sa valeur par une instruction \texttt{banksel} si besoin est. Comme le retour d’interruption restituera le contenu initial de \texttt{BSR}, il est inutile de le préserver par une construction \texttt{banksave}.

\begin{lstlisting}[language=piccolo]
interrupt nom fast {
  banksel 1
  clrf varBank1 #  Variable declaree dans le banc 1
}
\end{lstlisting}

~\\
\textbf{Routine déclarée sans \texttt{fast}.} Le contenu initial de \texttt{BSR}, au début de la routine d’interruption est inconnu. Si il doit être utilisé, et comme le retour d’interruption ne restituera pas son contenu initial, il est indispensable de le préserver par une construction \texttt{banksave}, nommant une variable \texttt{sauve\_bsr} déclarée dans le banc \texttt{accessram}. Il faut ensuite fixer sa valeur par une instruction \texttt{banksel}. 

\begin{lstlisting}[language=piccolo]
interrupt nom {
  banksave sauve_bsr
    banksel 1
    clrf varBank1 #  Variable declaree dans le banc 1
  end
}
\end{lstlisting}

Le compilateur Piccolo détectera l’oubli de la sauvegarde par \texttt{banksave}, en émettant un message d’erreur.


\section{Les instructions}

Elles sont de deux types (la distinction est importante pour l’instruction \emph{conditionnelle simple}) :
\begin{itemize}
  \item les instructions simples ;
  \item les instructions composées.

\end{itemize}


\textbf{Les instructions simples.} Elles correspondent à une partie des instructions assembleur. Attention, pour certaines, la syntaxe n'est pas exactement la même que celle de l'instruction assembleur correspondante. \textcolor{red}{\bf Dans sa version actuelle, Piccolo ne prend pas en charge le jeu d'instruction étendu.} Les \refTableau{instructionsPic18Assembleur1},  \refTableau{instructionsPic18Assembleur2} et \refTableau{instructionsPic18Assembleur3} donnent la liste des instructions assembleur \emph{pic18} et les liens vers les sections précisant leur prise en charge en Piccolo. Le \refTableau{pic18InstructionsPropresPiccolo} liste les instructions complémentaires disponibles en Piccolo.
 
\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \texttt{ADDLW k} & Add Literal and WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{ADDWF f, d, a} & Add WREG and f & \refSubsectionPage{instructionsNommantRegistreEtW} \\
    \texttt{ADDWFC f, d, a} & Add WREG and Carry bit to f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{ANDLW k} & And Literal with WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{ANDWF f, d, a} & And WREG with f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{BC n} & Branch if Carry & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BCF f, b, a} & Bit Clear f & \refSubsectionPage{opPic18AffectationBit} \\
    \texttt{BN n} & Branch if Negative & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BNC n} & Branch if Not Carry & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BNN n} & Branch if Not Negative & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BNOV n} & Branch if Not Overflow & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BNZ n} & Branch if Not Zero & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BOV n} & Branch if Overflow & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BRA n} & Branch Unconditionally & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{BSF f, b, a} & Bit Set f & \refSubsectionPage{opPic18AffectationBit} \\
    \texttt{BTFSC f, b, a} & Bit Test f, Skip if Clear & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{BTFSS f, b, a} & Bit Test f, Skip if Set & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{BTG f, b, a} & Bit Toggle f & \refSubsectionPage{opPic18AffectationBit} \\
    \texttt{BZ n} & Branch if Zero & \refSubsectionPage{appelRoutineSansRetourPic18}\\
    \texttt{CALL n, s} & Call Subroutine &  \refSubsectionPage{appelRoutineRegulierePic18} \\
    \texttt{CLRF f, a} & Clear f & \refSubsectionPage{instructionsNommantRegistre} \\
    \texttt{CLRWDT} & Clear Watchdog Timer & \refSubsectionPage{OperationsPic18IdentiquesAssembleur}\\
    \texttt{COMF f, d, a} & Complement f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{CPFSEQ f, a} & Compare f with WREG, Skip = & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{CPFSGT f, a} & Compare f with WREG, Skip > & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{CPFSLT f, a} & Compare f with WREG, Skip < & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{DAW} & Decimal Adjust WREG & \refSubsectionPage{OperationsPic18IdentiquesAssembleur}\\
    \texttt{DECF f, d, a} & Decrement f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{DECFSZ f, d, a} & Decrement f, Skip if 0 & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{DCFSNZ f, d, a} & Decrement f, Skip if Not 0 & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{GOTO n} & Go to Address & \refSubsectionPage{appelRoutineSansRetourPic18} \\
  \hline
  \end{tabular}
  \caption{Instructions assembleur \emph{pic18} [A-G]}
  \labelTableau{instructionsPic18Assembleur1}
\end{table}

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \texttt{INCF f, d, a} & Decrement f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{INCFSZ f, d, a} & Increment f, Skip if 0 & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{INFSNZ f, d, a} & Increment f, Skip if Not 0 & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{IORLW k} & Inclusive OR Literal with WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{IORWF f, d, a} & Inclusive OR WREG with f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{LFSR f, k} & Move Literal to FSR(f) & \refSubsectionPage{instructionLFSR} \\
    \texttt{MOVF f, d, a} & Move f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{MOVFF fs, fd} & Move fs to fd & \refSubsectionPage{instructionMOVFF} \\
    \texttt{MOVLB k} & Move Literal to BSR & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{MOVLW k} & Move Literal to WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{MULLW k} & Multiply Literal with WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{MULWF f, a} & Multiply WREG with f & \refSubsectionPage{instructionsNommantRegistre}\\
    \texttt{NEGF f, a} & Negate f & \refSubsectionPage{instructionsNommantRegistre}\\
    \texttt{NOP} & No Operation & \refSubsectionPage{OperationsPic18IdentiquesAssembleur}\\
    \texttt{POP} & Pop Top of Return Stack & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{PUSH} & Push Top of Return Stack & \refSubsectionPage{OperationsPic18IdentiquesAssembleur}\\
    \texttt{RCALL n} & Relative Call & \refSubsectionPage{appelRoutineRegulierePic18} \\
    \texttt{RESET} & Software Device Reset & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{RETFIE s} & Return from Interrupt Enable & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{RETLW k} & Return with Literal in WREG & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{RETURN s} & Return from Subroutine & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{RLCF f, d, a} & Rotate Left f through Carry & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{RLNCF f, d, a} & Rotate Left f (No Carry) & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{RRCF f, d, a} & Rotate Right f through Carry & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{RRNCF f, d, a} & Rotate Right f (No Carry) & \refSubsectionPage{instructionsNommantRegistreEtW}\\
  \hline
  \end{tabular}
  \caption{Instructions assembleur \emph{pic18} [I-S]}
  \labelTableau{instructionsPic18Assembleur2}
\end{table}

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Référence en Piccolo}\\
    \hline
    \texttt{SETF f, a} & Set f & \refSubsectionPage{instructionsNommantRegistre}\\
    \texttt{SLEEP} & Go into Standby Mode & \refSubsectionPage{OperationsPic18IdentiquesAssembleur}\\
    \texttt{SUBFWB f, d, a} & Substract f from WREG with Borrow & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{SUBLW k} & Substract WREG from Literal & \refSubsectionPage{opPic18Immediate}\\
    \texttt{SUBWF f, d, a} & Substract WREG from f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{SUBWFB f, d, a} & Substract WREG from f with Borrow & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{SWAPF f, d, a} & Swap Nibbles in f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
    \texttt{TBLRD*} & Table Read & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLRD*+} & Table Read with Post-Increment & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLRD*-} & Table Read with Post-Decrement & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLRD+*} & Table Read with Pre-Increment & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLWT*} & Table Write & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLWT*+} & Table Write with Post-Increment & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLWT*-} & Table Write with Post-Decrement & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TBLWT+*} & Table Write with Pre-Increment & \refSubsectionPage{OperationsPic18IdentiquesAssembleur} \\
    \texttt{TSTFSZ f, a} & Test f, Skip if 0 & \refSubsectionPage{instructionsPic18Introuvables}\\
    \texttt{XORLW k} & Exclusive OR Literal with WREG & \refSubsectionPage{opPic18Immediate}\\
    \texttt{XORWF f, d, a} & Exclusive OR WREG with f & \refSubsectionPage{instructionsNommantRegistreEtW}\\
  \hline
  \end{tabular}
  \caption{Instructions assembleur \emph{pic18} [T-X]}
  \labelTableau{instructionsPic18Assembleur3}
\end{table}




\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Piccolo} & \textbf{Description} & \textbf{Référence}\\
    \hline
    \texttt{jump} & Appel de routine sans retour & \refSubsectionPage{appelRoutineSansRetourPic18} \\
    \texttt{jsr} & Appel de routine régulière &  \refSubsectionPage{appelRoutineRegulierePic18} \\
    \hline
  \end{tabular}
  \caption{Instructions propres à Piccolo pour \emph{pic18}}
  \labelTableau{pic18InstructionsPropresPiccolo}
\end{table}

\textbf{Les instructions composées.} Piccolo définit les instructions suivantes :
\begin{itemize}
  \item l'instruction \texttt{mnop} (\refSectionPage{instructionMNOP}) ;
  \item l'instruction \texttt{ldataptr} (\refSubsectionPage{instructionLDATAPTR}) ;
  \item l'instruction \texttt{ltblptr} (\refSubsectionPage{instructionLTBLPTR}) ;
  \item l'instruction conditionnelle simple (\refSectionPage{instructionConditionnelleSimple}) ;
  \item l'instruction conditionnelle structurée (\refSectionPage{instructionConditionnelleStructuree}) ;
  \item l'instruction répétitive (\refSectionPage{instructionRepetitive}) ;
  \item l'instruction de répétition infinie (\refSectionPage{repetitionInfinie}) ;
  \item l'instruction \texttt{computed retlw} (\refSubsectionPage{instructionComputedRetlw}) ;
  \item l'instruction \texttt{computed bra} (\refSubsectionPage{instructionComputedBra}) ;
  \item l'instruction \texttt{computed goto} (\refSubsectionPage{instructionComputedGoto}) ;
  \item l'instruction \texttt{banksel} (\refSubsectionPage{instructionBanksel}) ;
  \item l'instruction \texttt{nobank} (\refSubsectionPage{instructionNoBank}) ;
  \item l'instruction \texttt{banksave} (\refSubsectionPage{instructionBanksave}).
\end{itemize}




\subsectionLabel{Les instructions que vous ne trouverez pas en Piccolo}{instructionsPic18Introuvables}

Elles n’existent pas en Piccolo parce qu’elles sont remplacées par des constructions structurées, ou bien engendrées automatiquement lors de la compilation.

Voici leur liste avec les liens vers les sections appropriées :\begin{itemize}
  \item \texttt{BTFSC}, \texttt{BTFSS}, \texttt{CPFSEQ}, \texttt{CPFSGT}, \texttt{CPFSLT}, \texttt{DECFSZ}, \texttt{DCFSNZ}, \texttt{INCFSZ}, \texttt{INFSZ}, \texttt{TSTFSZ} : ces instructions sont engendrées par l’instruction conditionnelle simple, l’instruction conditionnelle structurée et l’instruction répétitive ;
  \item \texttt{MOVLB} : l’affectation de \texttt{BSR} est pris en charge par \texttt{banksel} (\refSubsectionPage{instructionBanksel}) ;
  \item \texttt{RETFIE} : engendrée automatiquement lors de la compilation d’une routine d’interruption ;
  \item \texttt{RETLW} : utiliser une instruction \texttt{MOVLW}, et c’est l’optimiseur qui remplacera la séquence \texttt{MOVLW k, RETURN} par une instruction \texttt{RETLW k} ;
  \item \texttt{RETURN} : engendrée automatiquement lors de la compilation d’une routine.

\end{itemize}





\sectionLabel{Les instructions simples}{instructionsSimplesPic18}


\subsectionLabel{Instructions nommant un registre}{instructionsNommantRegistre}

Ce sont les instructions listées dans le \refTableau{operationsPic18NommantUnRegistre}. Pour ces instructions, l'opérande \texttt{a} est toujours implicite. Le compilateur Piccolo regarde d'abord si le registre \texttt{f} est dans l'\emph{accessram}. Si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 0. Sinon, il examine si le registre \texttt{BSR} contient la valeur correspondant au banc de \texttt{f}. Si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 1. Sinon, le compilateur signale l'erreur.



\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRF f, a} & Clear f & \texttt{clrf f} \\
    \texttt{MULWF f, a} & Multiply WREG with f & \texttt{mulwf f} \\
    \texttt{NEGF f, a} & Negate f & \texttt{negf f} \\
    \texttt{SETF f, a} & Set f & \texttt{setf f}\\
  \hline
  \end{tabular}
  \caption{Opérations nommant un registre}
  \labelTableau{operationsPic18NommantUnRegistre}
\end{table}








\subsectionLabel{Instructions nommant un registre, et optionnellement \texttt{W}}{instructionsNommantRegistreEtW}

Ces instructions, ainsi que le traduction en Piccolo, sont listées dans le \refTableau{instructionsPic18RegistreEtW}. En assembleur, elles nomment trois opérandes :
\begin{itemize}
  \item \texttt{f} : désigne le registre, il en est de même en Piccolo ;
  \item \texttt{d} : optionnel en Piccolo ; si absent, le registre \texttt{f} est destination de l'opération, si égal à \texttt{W}, c'est le registre \texttt{WREG} qui est destinaire ;
  \item \texttt{a} : toujours absent en Piccolo ; le compilateur Piccolo regarde d'abord si le registre \texttt{f} est dans l'\emph{accessram} ; si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 0, sinon il examine si le registre \texttt{BSR} contient la valeur correspondant au banc de \texttt{f} ; si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 1, sinon le compilateur signale l'erreur.
\end{itemize}


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{llll}
     &  & \multicolumn{2}{l}{\textbf{En Piccolo, destination :}} \\
    \textbf{Assembleur} & \textbf{Description} & \textbf{f} & \textbf{WREG}\\
    \hline
    \texttt{ADDWF f, d, a} & Add WREG and f & \texttt{addwf f}  & \texttt{addwf f, W} \\
    \texttt{ADDWFC f, d, a} & Add WREG and Carry bit to f & \texttt{addwfc f} & \texttt{addwfc f, W}\\
    \texttt{ANDWF f, d, a} & And WREG with f & \texttt{andwf f} & \texttt{andwf f, W}\\
    \texttt{COMF f, d, a} & Complement f & \texttt{comf f} & \texttt{comf f, W}\\
    \texttt{DECF f, d, a} & Decrement f & \texttt{decf f} & \texttt{decf f, W}\\
    \texttt{INCF f, d, a} & Increment f & \texttt{incf f}& \texttt{incf f, W}\\
    \texttt{IORWF f, d, a} & Inclusive OR WREG with f & \texttt{iorwf f} & \texttt{iorwf f, W}\\
    \texttt{MOVF f, d, a} & Move f & \texttt{movf f} & \texttt{movf f, W}\\
    \texttt{RLCF f, d, a} & Rotate Left f through Carry & \texttt{rlcf f} & \texttt{rlcf f, W}\\
    \texttt{RLNCF f, d, a} & Rotate Left f (No Carry) & \texttt{rlncf f} & \texttt{rlncf f, W}\\
    \texttt{RRCF f, d, a} & Rotate Right f through Carry & \texttt{rrcf f} & \texttt{rrcf f, W}\\
    \texttt{RRNCF f, d, a} & Rotate Right f (No Carry) & \texttt{rrncf f} & \texttt{rrncf f, W}\\
    \texttt{SUBFWB f, d, a} & Substract f from WREG with Borrow & \texttt{subfwb f} & \texttt{subfwb f, W}\\
    \texttt{SUBWF f, d, a} & Substract WREG from f & \texttt{subwf f} & \texttt{subwf f, W}\\
    \texttt{SUBWFB f, d, a} & Substract WREG from f with Borrow & \texttt{subwfb f} & \texttt{subwfb f, W}\\
    \texttt{SWAPF f, d, a} & Swap Nibbles in f & \texttt{swapf f} & \texttt{swapf f, W}\\
    \texttt{XORWF f, d, a} & Exclusive OR WREG with f & \texttt{xorwf f} & \texttt{xorwf f, W}\\
  \hline
  \end{tabular}
  \caption{Instructions \emph{pic18} nommant un registre, et optionnellement \texttt{W}}
  \labelTableau{instructionsPic18RegistreEtW}
\end{table}


\subsectionLabel{Opérations d'affectation de bit}{opPic18AffectationBit}

Ces instructions Piccolo correspondent aux instructions assembleur \texttt{BCF}, \texttt{BSF} et \texttt{BTG} (\refTableau{operationsPic18AffectationBit}).

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{llll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{En Piccolo}\\
    \hline
    \texttt{BCF f, b, a} & Bit Clear f & \texttt{bcf f.b} \\
    \texttt{BSF f, b, a} & Bit Set f & \texttt{bsf f.b} \\
    \texttt{BTG f, b, a} & Bit Toggle f & \texttt{btg f.b} \\
  \hline
  \end{tabular}
  \caption{Opérations \emph{pic18} d'affectation de bit}
  \labelTableau{operationsPic18AffectationBit}
\end{table}

En Piccolo, ces instructions ont toujours deux arguments séparés par un point :
\begin{itemize}
  \item le premier argument \texttt{f} est une référence à un registre (\refSectionPage{referenceRegistre}) ;
  \item le second \texttt{b} est le bit concerné.
\end{itemize}

Le troisième argument \texttt{a} de l'instruction assembleur est toujours absent : le compilateur Piccolo regarde d'abord si le registre \texttt{f} est dans l'\emph{accessram} ; si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 0, sinon il examine si le registre \texttt{BSR} contient la valeur correspondant au banc de \texttt{f} ; si oui, il engendre l'instruction assembleur correspondante avec \texttt{a} égal à 1, sinon le compilateur signale l'erreur.

Pour désigner le bit concerné, vous pouvez utiliser un nombre compris entre 0 et 7. Par exemple :
\begin{lstlisting}[language=piccolo]
bcf maVariable.3
\end{lstlisting}

Si le registre a été défini en déclarant des noms de bit :
\begin{lstlisting}[language=piccolo]
ram ... {
  byte maVariable <a, -, b [3], -, -, ->
}
\end{lstlisting}

Vous pouvez utiliser l’un de ces noms comme second argument :
\begin{lstlisting}[language=piccolo]
bcf maVariable.a # a designe le bit 7
\end{lstlisting}
ou encore
\begin{lstlisting}[language=piccolo]
bcf maVariable.b [1] # b[1] designe le bit 4
\end{lstlisting}

Vous pouvez de cette façon accéder aux bits des registres spéciaux. Pour connaître la liste des registres de contrôle, utilisez l’option \texttt{-{}-registers} (ou sa version courte \texttt{-R}), comme décrite à la \refSubsectionPage{exempleOptionRegisters} ; par exemple : \texttt{piccolo -R=18F442}.


\subsectionLabel{Opérations littérales avec \texttt{WREG}}{opPic18Immediate}

Ces opérations sont listées dans le \refTableau{operationsLiteralesPic18AvecW}. L’instruction \texttt{RETLW k} n’existe pas en Piccolo, l’optimiseur repérera une séquence \texttt{MOVLW k RETURN} et la transformera en \texttt{RETLW k}.

En Piccolo, \texttt{k} est une \emph{expression statique}. Une expression statique est une expression dont la valeur est calculée à la compilation. Sa forme générale est présentée à la \refSectionPage{expressionImmediate}. Le compilateur effectue tous les calculs d'une expression statique avec des nombres entiers 32 bits signés.

Pour être valide dans les opérations statiques avec \texttt{WREG}, le résultat devra être :
\begin{itemize}
  \item soit un nombre positif inférieur ou égal à 255 ;
  \item soit un nombre négatif supérieur ou égal à -128.
\end{itemize}

Par exemple : \texttt{movlw -14} engendre l’instruction assembleur : \texttt{MOVLW 0xf2}.


\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{ADDLW k} & Add Literal and WREG & \texttt{addlw k}\\
    \texttt{ANDLW k} & And Literal with WREG & \texttt{andlw k}\\
    \texttt{IORLW k} & Inclusive OR Literal with WREG & \texttt{iorlw k}\\
    \texttt{MOVLW k} & Move Literal to WREG & \texttt{movlw k}\\
    \texttt{MULLW k} & Multiply Literal with WREG & \texttt{mullw k}\\
    \texttt{SUBLW k} & Substract WREG from Literal & \texttt{sublw k}\\
    \texttt{XORLW k} & Exclusive OR Literal with WREG & \texttt{xorlw k}\\
    \hline
  \end{tabular}
  \caption{Opérations statiques avec \texttt{WREG} pour \emph{pic18}}
  \labelTableau{operationsLiteralesPic18AvecW}
\end{table}


\subsectionLabel{Instructions identiques à celles de l’assembleur}{OperationsPic18IdentiquesAssembleur}

Ces instructions sont listées dans le \refTableau{operationsPic18IdentiquesAssembleur}.

\begin{table}[!ht]
  \centering
  \small
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{lll}
    \textbf{Assembleur} & \textbf{Description} & \textbf{Écriture en Piccolo}\\
    \hline
    \texttt{CLRWDT} & Clear Watchdog Timer & \texttt{clrwdt}\\
    \texttt{DAW} & Decimal Adjust WREG & \texttt{daw}\\
    \texttt{NOP} & No Operation & \texttt{nop}\\
    \texttt{POP} & Pop Top of Return Stack & \texttt{pop} \\
    \texttt{PUSH} & Push Top of Return Stack & \texttt{push}\\
    \texttt{RESET} & Software Device Reset & \texttt{reset} \\
    \texttt{SLEEP} & Go into Standby Mode & \texttt{sleep}\\
    \texttt{TBLRD*} & Table Read & \texttt{tblrd *} \\
    \texttt{TBLRD*+} & Table Read with Post-Increment & \texttt{tblrd *+} \\
    \texttt{TBLRD*-} & Table Read with Post-Decrement & \texttt{tblrd *-} \\
    \texttt{TBLRD+*} & Table Read with Pre-Increment & \texttt{tblrd +*} \\
    \texttt{TBLWT*} & Table Write & \texttt{tblwt *} \\
    \texttt{TBLWT*+} & Table Write with Post-Increment & \texttt{tblwt *+} \\
    \texttt{TBLWT*-} & Table Write with Post-Decrement & \texttt{tblwt *-} \\
    \texttt{TBLWT+*} & Table Write with Pre-Increment & \texttt{tblwt +*} \\
    \hline
  \end{tabular}
  \caption{Instructions \emph{pic18} identiques en assembleur et en Piccolo}
  \labelTableau{operationsPic18IdentiquesAssembleur}
\end{table}


\subsectionLabel{Instruction \texttt{lfsr}}{instructionLFSR}

En assembleur comme en Piccolo, l'instruction \texttt{lfsr f, k} comporte deux arguments :
\begin{itemize}
  \item \texttt{f} : le numéro du registre destination : une expression statique dont l’évaluation donne le résultat 0, 1 ou 2 ;
  \item \texttt{k} : la valeur à charger dans le registre, une expression statique dont l’évaluation donne un résultat compris entre 0 et 4095.
\end{itemize}

La forme générale des expressions statiques est donnée à la \refSectionPage{expressionImmediate}. Une expression statique est évaluée à la compilation. Le compilateur effectue tous les calculs avec des nombres entiers 32 bits signés.







\subsectionLabel{Instruction \texttt{movff}}{instructionMOVFF}

En assembleur comme en Piccolo, l'instruction \texttt{movff fs, fd} comporte deux arguments :
\begin{itemize}
  \item \texttt{fs} : le registre source (\refSectionPage{referenceRegistre}) ;
  \item \texttt{fd} : le registre destination (\refSectionPage{referenceRegistre}).
\end{itemize}








\subsectionLabel{Appeler une routine régulière}{appelRoutineRegulierePic18}

Une routine régulière est une routine déclarée sans le qualificatif \texttt{noreturn}. L'appel s’effectue au moyen d’une des trois instructions \texttt{rcall}, \texttt{CALL} ou \texttt{JSR}.

Ces instructions se distinguent par leurs propriétés suivantes :
\begin{itemize}
  \item \texttt{rcall} correspond à l’instruction assembleur \texttt{RCALL} : elle occupe deux octets, mais sa compilation entraîne une erreur si le déplacement est trop important pour être codé ;
  \item \texttt{call} correspond à l’instruction assembleur \texttt{CALL} : elle peut coder tout appel, mais occupe quatre octets ;
  \item \texttt{jsr} est un ajout propre à Piccolo : cette instruction est par défaut codée par un \texttt{RCALL}, mais, si le déplacement est trop important, elle est silencieusement codée par un \texttt{CALL}.
\end{itemize}

Syntaxiquement, il faut simplement nommer la routine appelée après le nom de l’instruction d’appel :

\begin{lstlisting}[language=piccolo]
rcall nom_routine
\end{lstlisting}
ou
\begin{lstlisting}[language=piccolo]
call nom_routine
\end{lstlisting}
ou
\begin{lstlisting}[language=piccolo]
jsr nom_routine
\end{lstlisting}




\subsectionLabel{Appeler une routine sans retour}{appelRoutineSansRetourPic18}

Appeler une routine sans retour (c'est-à-dire déclarée avec le qualificatif \texttt{noreturn}) peut s'effectuer :
\begin{itemize}
  \item soit inconditionnellement par une instruction  \texttt{bra}, \texttt{goto} ou \texttt{jump} ;
  \item soit conditionnellement par une instruction $B_{CC}$ (nom collectif pour les huit instructions de saut conditionnels : \texttt{bc}, \texttt{bnc}, \texttt{bn}, \texttt{bnn}, \texttt{bov}, \texttt{bnov}, \texttt{bz} ou \texttt{bnz}) ;
  \item soit conditionnellement par une instruction \texttt{jump} $cc$ (où $cc$ est un nom collectif pour les huit conditions : \texttt{c}, \texttt{nc}, \texttt{n}, \texttt{nn}, \texttt{ov}, \texttt{nov}, \texttt{z} ou \texttt{nz}).
\end{itemize}



~\\
\texttt{bra} correspond à l’instruction assembleur \texttt{BRA} : elle occupe deux octets, mais sa compilation entraîne une erreur si le déplacement est trop important pour être codé. L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
bra nom_routine
\end{lstlisting}



~\\
\texttt{goto} correspond à l’instruction assembleur \texttt{GOTO} : elle peut coder tout branchement inconditionnel, mais occupe quatre octets. L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
goto nom_routine
\end{lstlisting}


~\\
\texttt{jump} est un ajout propre à Piccolo. Dans sa forme incondionnelle, il engendre par défaut une instruction \texttt{BRA}, ou, si le déplacement est trop important, une instruction \texttt{GOTO}. L'appel s'écrit :
\begin{lstlisting}[language=piccolo]
jump nom_routine
\end{lstlisting}

~\\
$B_{CC}$ correspond à l’une des huit instructions assembleur citées ci dessus : elle occupe deux octets, mais sa compilation entraîne une erreur si le déplacement est trop important pour être codé. L'appel s'écrit par exemple :
\begin{lstlisting}[language=piccolo]
bz nom_routine
\end{lstlisting}


~\\
La forme conditionnelle de l'instruction \texttt{jump} nomme une des huit conditions $cc$ (voir ci-dessus). L'appel s'écrit par exemple :
\begin{lstlisting}[language=piccolo]
jump z nom_routine
\end{lstlisting}

Le code engendré par une instruction \texttt{jump} $cc$ peut occuper deux, quatre ou six octets en fonction de la distance entre l'instruction d'appel et la routine (\refTableau{codageInstructionJumpCC}). Piccolo choisit toujours le codage le plus court. 



\begin{table}[!ht]
  \centering
  \small
  \rowcolors{3}{}{\fondTableau}
  \begin{tabular}{llp{2.5cm}p{2.5cm}}
      & \multicolumn{3}{c}{\bf Code engendré}\\
    \textbf{Instruction Piccolo} & \textbf{2 octets} & \textbf{4 octets} & \textbf{6 octets}\\
    \hline
    \texttt{jump c routine} & \texttt{BC routine} & \texttt{BNC \$ + 4 bra routine} & \texttt{BNC \$ + 6 goto routine}\\
    \texttt{jump nc routine} & \texttt{BNC routine} & \texttt{BC ~\$ + 4 bra routine} & \texttt{BC ~\$ + 6 goto routine}\\
    \texttt{jump z routine} & \texttt{BZ routine} & \texttt{BNZ \$ + 4 bra routine} & \texttt{BNZ \$ + 6 goto routine}\\
    \texttt{jump nz routine} & \texttt{BNZ routine} & \texttt{BZ ~\$ + 4 bra routine} & \texttt{BZ ~\$ + 6 goto routine}\\
    \texttt{jump n routine} & \texttt{BN routine} & \texttt{BNN \$ + 4 bra routine} & \texttt{BNN \$ + 6 goto routine}\\
    \texttt{jump nn routine} & \texttt{BNN routine} & \texttt{BN ~\$ + 4 bra routine} & \texttt{BN ~\$ + 6 goto routine}\\
    \texttt{jump ov routine} & \texttt{BOV routine} & \texttt{BNOV \$ + 4 bra routine} & \texttt{BNOV \$ + 6 goto routine}\\
    \texttt{jump nov routine} & \texttt{BNOV routine} & \texttt{BOV ~\$ + 4 bra routine} & \texttt{BOV ~\$ + 6 goto routine}\\
    \hline
  \end{tabular}
  \caption{Codages possibles de l'instruction \texttt{jump} $cc$}
  \labelTableau{codageInstructionJumpCC}
\end{table}


\sectionLabel{Section \texttt{include}}{sectionInclude}

Une section \texttt{include} permet d'inclure un fichier contenant lui-même des sections telles que définies dans le \refTableauPage{sectionsPic18}.  Son format est le suivant :

\begin{lstlisting}[language=piccolo]
  include "chemin"
\end{lstlisting}

\texttt{chemin} est le chemin vers le fichier inclus, et est :
\begin{itemize}
  \item soit un chemin absolu (il commence par « \texttt{/} ») ;
  \item soit un chemin relatif par rapport au fichier source.
\end{itemize}








\sectionLabel{Section \texttt{data}}{sectionData}

La section \texttt{data} permet de définir des tableaux de données qui seront placés en Flash. Son format est le suivant :

\begin{lstlisting}[language=piccolo]
  data nom {element0, element1, ... }
\end{lstlisting}

\texttt{nom} est le nom donné au tableau. \texttt{element0}, \texttt{element1}, …, sont des expressions statiques pouvant s'écrire sur 16 bits. L'octet de poids faible de chaque valeur apparaît à une adresse paire, celui de poids fort en adresse impaire.

Pour accéder au tableau :
\begin{itemize}
  \item \texttt{nom} est utilisé en argument de l'instruction \texttt{ldataptr} (\refSubsectionPage{instructionLDATAPTR}) pour charger les registres \texttt{TBLPTRU}, \texttt{TBLPTRH} et \texttt{TBLPTRL} pour qu'ils désignent le début du tableau ;
  \item la constante \texttt{nom}\emph{\small{\_BYTE\_COUNT}} est définie à la valeur du nombre d'\emph{octets} du tableau : elle vaut donc le double du nombre d'éléments du tableau.
\end{itemize}



~\\
\textbf{Exemple.} Si on déclare :
\begin{lstlisting}[language=piccolo]
  data monTableau {0x1234, 0x5678}
\end{lstlisting}

Ceci engendre la séquence assembleur :

\begin{lstlisting}[language=assembleur]
data_monTableau:
  WORD 0x1234
  WORD 0x5678
\end{lstlisting}

Et la constante \texttt{monTableau\_BYTE\_COUNT} est définit et vaut 4.



\section{Instructions \emph{pic18}}

Ces instructions n'existent en Piccolo que pour les \emph{pic18}. Elles sont classées parmi les instructions dites \emph{structurées} car elles ne peuvent pas apparaître comme instruction associée à une \emph{instruction conditionnelle simple} (\refSectionPage{instructionConditionnelleSimple}).



\subsectionLabel{Instruction \texttt{ltblptr}}{instructionLTBLPTR}

Cette instruction permet de charger les registres \texttt{TBLPTRU}, \texttt{TBLPTRH} et \texttt{TBLPTRL} à partir d'une expression statique qui représente une adresse en Flash.

Son format est :
\begin{lstlisting}[language=piccolo]
  ltblptr adresse-en-flash
\end{lstlisting}

Le code engendré pour l'instruction est le suivant :
\begin{lstlisting}[language=assembleur]
  MOVLW (adresse-en-flash >> 16) & 0xFF
  MOVWF TBLPTRU
  MOVLW (adresse-en-flash >> 8) & 0xFF
  MOVWF TBLPTRH
  MOVLW adresse-en-flash & 0xFF
  MOVWF TBLPTRL
\end{lstlisting}

Le registre \texttt{WREG} est donc modifié par cette opération.

~\\
\textbf{Optimisation.} Si une valeur immédiate est 0, l'opération \texttt{CLRF} est utilisée ; si une valeur immédiate est 0xFF, l'opération \texttt{SETF} est utilisée. Par exemple, 
\begin{lstlisting}[language=piccolo]
  ltblptr 0x3FFF
\end{lstlisting}

Engendre le code :
\begin{lstlisting}[language=assembleur]
  CLRF TBLPTRU
  MOVLW 0x3F
  MOVWF TBLPTRH
  SETF TBLPTRL
\end{lstlisting}


~\\
\textbf{Exemple d'utilisation.} Associée à la constante \emph{ROM\_SIZE}, elle permet d'écrire une routine générique, valable pour tous les types de \emph{pic18}, qui renvoie dans \emph{WREG}, la somme des octets de la flash (\refSubsectionPage{exempleLTBLPTR-ROMSIZE}).


\subsectionLabel{Instruction \texttt{ldataptr}}{instructionLDATAPTR}

Cette instruction permet de charger les registres \texttt{TBLPTRU}, \texttt{TBLPTRH} et \texttt{TBLPTRL} qui représente l'adresse d'un élément de tableau en flash, défini par une section \texttt{data} (\refSectionPage{sectionData}).

Elle peut prendre deux formes.

~\\
\textbf{Première forme.}

\begin{lstlisting}[language=piccolo]
  ldataptr nom_section_data
\end{lstlisting}

Cette instruction charge les registres \texttt{TBLPTRU}, \texttt{TBLPTRH} et \texttt{TBLPTRL} pour qu'ils désignent l'octet de poids faible premier élément du tableau défini par la section \texttt{data nom\_section\_data}.

Le code engendré est le suivant :
\begin{lstlisting}[language=assembleur]
  MOVLW (nom_section_data >> 16) & 0xFF
  MOVWF TBLPTRU
  MOVLW (nom_section_data >> 8) & 0xFF
  MOVWF TBLPTRH
  MOVLW nom_section_data & 0xFF
  MOVWF TBLPTRL
\end{lstlisting}

Cette séquence n'est jamais optimisée, et \texttt{WREG} est toujours modifié.

~\\
\textbf{Seconde forme.}

\begin{lstlisting}[language=piccolo]
  ldataptr nom_section_data [indice_element]
\end{lstlisting}

Dans cette seconde forme, l'instruction charge les registres \texttt{TBLPTRU}, \texttt{TBLPTRH} et \texttt{TBLPTRL} pour qu'ils désignent l'octet de poids faible de l'élément \texttt{indice\_element} du tableau défini par la section \texttt{data nom\_section\_data}. Si \texttt{indice\_element} est nul, elle est équivalent à la première forme.

Le code engendré est le suivant :
\begin{lstlisting}[language=assembleur]
  MOVLW ((nom_section_data + 2 * indice_element) >> 16) & 0xFF
  MOVWF TBLPTRU
  MOVLW ((nom_section_data + 2 * indice_element) >> 8) & 0xFF
  MOVWF TBLPTRH
  MOVLW (nom_section_data + 2 * indice_element) & 0xFF
  MOVWF TBLPTRL
\end{lstlisting}

Cette séquence n'est jamais optimisée, et \texttt{WREG} est toujours modifié.




