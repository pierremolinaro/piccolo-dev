%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapter{Programmes pour pic18}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}




\section{Exemples de programmes pour pic18}

\subsection{Premier exemple : \emph{blink led}}

Ce simple programme est destiné à un 18F448 et fait clignoter à 1 Hz environ une led connectée au port \texttt{RE0}. Il programme donc \texttt{RE0} (broche 8) en sortie. La configuration suppose qu'il est connecté à une horloge externe à 40 MHz sur la broche \texttt{OSC1} (broche 13). 

Ce programme a l'allure suivante :
\begin{lstlisting}[language=piccolo]
pic18 blink_led "18F448" :
#------------ Configuration
configuration {
  ...
}
#------------ RAM
ram accessram {
  ...
}
#------------ Routine main
noreturn routine main bank:requires 0 {
  ...
}
#------------ Fin
end
\end{lstlisting}

L'en-tête indique qu'il s'agit d'un programme pour \emph{pic18}, qu'il s'appelle \emph{blink\_led}, et qu'il est destiné au micro-contrôleur 18F448. Ce corps de ce programme est constitué de trois sections, décrites dans la suite de cette section : configuration, ram, et routine \emph{main}. D'autres types de sections peuvent être définies, mais sont absentes de ce premier exemple. La \refSectionPage{structurePrgmPic18} donne une liste exhaustive des différentes sections d'un programme pour \emph{pic18}. 

La section \texttt{configuration} décrit les valeurs qui sont affectées aux \emph{bits de configuration} du micro-contrôleur. Les valeurs choisies pour cet exemple sont listées ci-dessous. Pour une description complète de cette section, nous invitons le lecteur à se reporter au \refChapterPage{configuration}.
\begin{lstlisting}[language=piccolo]
#------------ Configuration
configuration {
  OSC : "EC-OSC2 as RA6"
  OSCS : Disabled
  WDT : "Disabled-Controlled by SWDTEN bit"
  WDTPS : "1:128"
  STVR : Disabled
  LVP : Disabled
  CP_0 : Disabled
  CP_1 : Disabled
  CP_2 : Disabled
  CP_3 : Disabled
  WRT_1 : Disabled
  WRT_2 : Disabled
  WRT_3 : Disabled
  WRT_0 : Disabled
  EBTR_0 : Disabled
  EBTR_1 : Disabled
  EBTR_2 : Disabled
  EBTR_3 : Disabled
  BACKBUG : Disabled
  BODEN : Disabled
  BODENV : "4.5V"
  CPB : Disabled
  CPD : Disabled
  EBTRB : Disabled
  PUT : Enabled
  WRTB : Disabled
  WRTC : Disabled
  WRTD : Disabled
}
\end{lstlisting}


La section \texttt{ram} déclare les variables du programme. Ce type de section est complètement décrit au \refChapterPage{ram}. Le 18F448 possède plusieurs bancs mémoire, dont on obtient la composition en appelant \texttt{piccolo} avec l'option \texttt{-{}-memory=18F448} (voir \refSubsectionPage{exempleOptionMemory}) :


{\footnotesize \lstinputlisting[frame=l]{files-from-piccolo/memory-18F448.txt}}

Ainsi, le 18F448 possède quatre bancs mémoire : \emph{accessram}, \emph{gpr0}, \emph{gpr1} et \emph{gpr2}. En consultant la document du 18F448, on établit que le banc \emph{accessram} est accessible quel que soit \texttt{BSR}, que l'accès aux variables du banc \emph{gpr0} impose que \texttt{BSR} soit égal à 0, que l'accès aux variables du banc \emph{gpr1} impose que \texttt{BSR} soit égal à 1, etc.

Pour simplifier l'écriture de ce premier programme, on place donc les trois variables dont on a besoin dans le banc \emph{accessram} :
\begin{lstlisting}[language=piccolo]
#------------ RAM
ram accessram {
  byte compteurL
  byte compteurH
  byte compteurU
}
\end{lstlisting}

Cette écriture alloue les emplacements séquentiellement : \texttt{compteurL} sera à l'adresse 0, \texttt{compteurH} à l'adresse 1, et \texttt{compteurU} à l'adresse 2.

Il reste maintenant à décrire la routine \emph{main}. Un programme valide doit toujours contenir une routine nommée \emph{main} : c'est le point d'entrée de l'exécution à la mise sous tesion ou après un \emph{reset}. L'en-tête de la routine \emph{main} doit en outre comporter deux qualificatifs :
\begin{itemize}
  \item \texttt{noreturn} : ceci exprime que la routine doit se terminer par une boucle infinie, ou un branchement à une routine elle aussi sans retour ;
  \item \texttt{bank:requires 0} : ceci exprime que lors de l'appel, le registre \texttt{BSR} contient la valeur 0\footnote{\texttt{BSR} est initialisé à 0 à la mise sous tension ou lors d'un \emph{reset}.}, et que donc on pourrait utiliser des variables dans le banc \emph{gpr0} sans modifier \texttt{BSR}.
\end{itemize}

Dans le code de la routine, parmi les instructions assembleur, on trouve une instruction « \texttt{if} » structurée, dont les conditions cachent une utilisation de l’instruction \texttt{TSTFSZ}, à l'intérieur d'une boucle infinie implémentée par la construction \texttt{forever ... end}.

\begin{lstlisting}[language=piccolo]
#------------ Routine main
noreturn routine main bank:requires 0 {
#--- Aucune entree analogique
  movlw 7
  movwf ADCON1
#--- Programmer RE0 en sortie
  bcf  TRISE.0
#--- Initialiser les compteurs
  clrf compteurL
  clrf compteurH
  clrf compteurU
#--- Boucle infinie
  forever
    if (compteurL NZ)
      decf compteurL
    elsif (compteurH NZ)
      decf compteurH
      setf compteurL
    elsif (compteurU NZ)
      decf compteurU
      setf compteurH
      setf compteurL
    else
    #--- Reinitialiser les compteurs
      movlw  0x0F
      movwf  compteurU
      movlw  0x42
      movwf  compteurH
      movlw  0x40
      movwf  compteurL
    #--- Clignoter
      btg  PORTE.0
    end
  end
}
\end{lstlisting}

Pour terminer ce premier exemple, il est utile de jeter un coup d’œil sur le code assembleur engendré (option « \texttt{-S} »), à gauche sans optimisation, à droite avec optimisations grâce à l’option « \texttt{-O} ». L’optimisation gagne 4 instructions (le \texttt{bra main} initial, et la meilleure utilisation des trois occurrences de l’instruction \texttt{TSTFSZ}. Observez aussi l’optimisation des sauts (ne vous basez pas sur les noms des étiquettes, elles changent de signification avec l’optimisation).

\begin{multicols}{2}
\begin{lstlisting}[language=assembleur]
  ORG 0
  bra   main
main:
  movlw 0x7
  movwf ADCON1
  bcf  TRISE, 0
  clrf compteurL
  clrf compteurH
  clrf compteurU
_label_0:
  TSTFSZ compteurL
  bra _bcc_label_0
  bra _label_1
_bcc_label_0:
  decf compteurL, F
  bra   _label_2
_label_1:
  TSTFSZ compteurH
  bra _bcc_label_1
  bra _label_3
_bcc_label_1:
  decf compteurH, F
  setf compteurL
  bra   _label_4
_label_3:
  TSTFSZ compteurU
  bra _bcc_label_2
  bra _label_5
_bcc_label_2:
  decf compteurU, F
  setf compteurH
  setf compteurL
  bra   _label_6
_label_5:
  movlw 0xF
  movwf compteurU
  movlw 0x42
  movwf compteurH
  movlw 0x40
  movwf compteurL
  BTG  PORTE, 0
_label_6:
_label_4:
_label_2:
  bra   _label_0
\end{lstlisting}
\columnbreak
\begin{lstlisting}[language=assembleur]
  ORG 0
  movlw 0x7
  movwf ADCON1
  bcf  TRISE, 0
  clrf compteurL
  clrf compteurH
  clrf compteurU
_label_0:
  TSTFSZ compteurL
  bra _label_1
  TSTFSZ compteurH
  bra _label_3
  TSTFSZ compteurU
  bra _label_5
  movlw 0xF
  movwf compteurU
  movlw 0x42
  movwf compteurH
  movlw 0x40
  movwf compteurL
  BTG  PORTE, 0
  bra   _label_0
_label_5:
  decf compteurU, F
  setf compteurH
  setf compteurL
  bra   _label_0
_label_3:
  decf compteurH, F
  setf compteurL
  bra   _label_0
_label_1:
  decf compteurL, F
  bra   _label_0
\end{lstlisting}
\end{multicols}


\subsection{Deuxième exemple : \emph{blink led} sous interruption}

Ce simple programme fait clignoter à 4 Hz une led connectée au port \texttt{RE0}. Il programme donc \texttt{RE0} (broche 8) en sortie. La configuration suppose qu'il est connecté à une horloge externe à 40 MHz sur \texttt{OSC1} (broche 13). Un sous-programme d'interruption est déclenché toutes les 0,1 ms par le timer 2. Pour illustrer les instructions de gestion des bancs, les deux variables sont placées dans le banc 2. Supprimez ou déplacez les instructions « \texttt{banksel} », pour mettre en évidence les vérifications faites par le compilateur.

Le programme a l'allure suivante :
\begin{lstlisting}[language=piccolo]
pic18 blink_led_it "18F448" :
#------------ Configuration
configuration {
  ...
}
#------------ RAM
ram accessram {
  ...
}
#------------ Routine d'interruption
interrupt high fast {
  ...
}
#------------ Routine main
noreturn routine main bank:requires 0 {
  ...
}
#------------ Fin
end
\end{lstlisting}

Le code de configuration est le même que celui du premier exemple.


\begin{lstlisting}[language=piccolo]
ram gpr2 {
  byte compteurL
  byte compteurH
}
\end{lstlisting}
La section \texttt{ram} décrit l’attribution de la RAM du micro-contrôleur. Le nom \texttt{gpr2} est le nom du banc qui commence à l’adresse 0x100. Les adresses sont allouées séquentiellement : \texttt{compteurL} a pour adresse 0x100, et \texttt{compteurH} a pour adresse 0x101. Ces deux registres ne seront donc accessibles que via le registre \texttt{BSR}.


\begin{lstlisting}[language=piccolo]
interrupt high fast {
#--- Acquitter l'interruption du timer 2 
  bcf  PIR1.TMR2IF 
#--- Decompter le temps
  banksel 2 
  if (compteurL NZ)
    decf compteurL
  elsif (compteurH NZ)
    decf compteurH
    setf compteurL
  else
  #--- Reinitialiser les compteurs
    movlw  0x13
    movwf  compteurH
    movlw  0x87
    movwf  compteurL
  #--- Clignoter
    btg  PORTE.0
  end
}
\end{lstlisting}
Une section « \texttt{interrupt} » définit un sous-programme d’interruption. Il porte le nom « \texttt{high} », ce qui signifie qu’il est attaché au point d’entrée d’adresse 0x8. Il porte aussi le qualificatif « \texttt{fast} », ce qui signifie que l’instruction \texttt{retfie 1} sera engendrée pour effectuer le retour d’interruption.

Dans un programme plus complexe, il n’est pas possible de prévoir à la compilation la valeur de \texttt{BSR} quand une interruption survient. Aussi l’instruction « \texttt{banksel 2} » est obligatoire avant d’adresser les registres du compteur (essayez de la supprimer, le compilateur engendrera un message d'erreur).

\begin{lstlisting}[language=piccolo]
noreturn routine main bank:requires 0 {
#--- Aucune entree analogique
  movlw 7
  movwf ADCON1
#--- Programmer RE0 en sortie
  bcf  TRISE.0
#--- Initialiser les compteurs
  banksel 2
  clrf compteurL
  clrf compteurH
#--- Initialiser le Timer 2
#  Horloge de base : 10 MHz
#  Le Prescaler est fixe a 4 -> 2 500 kHz
#  PR2 est fixe a 250 -> 10 kHz
  movlw  250 - 1 # La periode est PR2 + 1
  movwf  PR2
  movlw  @T2CON (TOUTPS:0, TMR2ON:1, T2CKPS:1)
  movwf  T2CON  
#--- Autoriser les priorites d'interruption
  bsf  RCON.IPEN
#--- Autoriser l'interruption en provenance du Timer 0
  bsf  PIE1.TMR2IE
#--- Valider les its
  bsf  INTCON.GIEH
  bsf  INTCON.GIEL
#--- Boucle infinie
  forever
  end
}
\end{lstlisting}

Deux commentaires : ici aussi, l’instruction « \texttt{banksel 2} » est obligatoire avant d’adresser les registres du compteur (essayez de la supprimer…) ; tous les autres accès s’effectuant via l’acces bank, il n’est pas nécessaire de changer la valeur de \texttt{BSR}.

L’instruction
\begin{lstlisting}[language=piccolo]
  movlw  @T2CON (TOUTPS:0, TMR2ON:1, T2CKPS:1)
\end{lstlisting}
est particulière : elle permet de construire une valeur immédiate champ par champ (voir à §§).







\sectionLabel{Structure d’un programme pour pic18}{structurePrgmPic18}

Un programme Piccolo pour \emph{pic18} a la structure suivante :

\begin{lstlisting}[language=piccolo]
pic18 nom "nom_composant" :
  liste_de_sections
end
\end{lstlisting}


Dans l’en-tête :
\begin{itemize}
  \item le nom « \emph{nom} » est le nom du fichier (sans son extension) qui contient ce texte source ;
  \item le nom du composant « \emph{nom\_composant} » doit être exactement le nom de l’un des composants supportés (pour obtenir la liste des pic18 pris en charge, utiliser l’option « \texttt{-{}-pic18} », voir \refSubsectionPage{listePic18}).
\end{itemize}


Le corps du programme est constitué d’une liste non ordonnée de sections. Les sections disponibles sont listées dans le \refTableau{sectionsPic18}.
\begin{table}[ht]
  \centering
  \rowcolors{2}{\fondTableau}{}
  \begin{tabular}{p{5cm}lll}
    \textbf{Type de section} & \textbf{Mot-clé introductif} & \textbf{Référence}\\
    \hline
    Configuration & \texttt{configuration} & \refChapterPage{configuration}\\
    Définition de variable & \texttt{ram} & \refChapterPage{ram}\\
    Définition de constante & \texttt{const} & \refChapterPage{constante}\\
    Définition de routine pic18 & \texttt{routine} & \refSectionPage{routinePic18}\\
    Définition de routine d'interruption pic18 & \texttt{interrupt} & \refSectionPage{routineInterruptionPic18}\\
  \hline
  \end{tabular}
  \caption{Les sections d'un programme pour \emph{pic18}}
  \labelTableau{sectionsPic18}
\end{table}









\sectionLabel{Routines pic18}{routinePic18}

Les routines définissent le code exécutable de votre programme. L’une d’entre elles doit s’appeler \texttt{main} : c’est la routine qui s’exécute au démarrage. Il y a deux types de routine, les routines \emph{régulières} et les routines \emph{sans retour}.


L’ordre des déclarations des routines est quelconque, il est possible d’appeler une routine qui est déclarée après l’instruction d’appel. Simplement Piccolo engendrera leur code dans leur ordre d’apparition. 

~\\
\textbf{Routine et BSR.} Un problème important en assembleur est la gestion du registre de sélection de banc \texttt{BSR} : son utilisation correcte en assembleur est complètement à la charge du programmeur. Piccolo propose des instructions pour sécuriser son emploi : voir à §§.

~\\
\textbf{Liste d’instructions d’une routine.} Elle est structurée : Piccolo définit des instructions de sélection et de répétition : cela signifie que vous ne pouvez pas déclarer d’étiquette, ni utiliser des \texttt{bra} ni des \texttt{goto} pour effectuer des branchements à l’intérieur d’une routine.


\subsection{Routine régulière}

C'est un sous-programme. Une routine régulière peut ne comporter aucune instruction Piccolo, l'instruction \texttt{return} est implicitement ajoutée. Une routine régulière est déclarée par :
\begin{lstlisting}[language=piccolo]
routine maRoutine ... {
  ...
}
\end{lstlisting}

\texttt{maRoutine} est le nom de la routine, celui qui sera nommé dans un instruction d’appel de routine. Entre les accolades « \texttt{\{} » et « \texttt{\}} », apparaît la liste des instructions.

~\\
\textbf{Appel d’une routine régulière.} Utiliser \texttt{RCALL}, \texttt{CALL} ou \texttt{JSR}, comme indiqué à §§.

\subsection{Routine sans retour}

L’exécution ne revient pas jamais à l’appelant. Ce type de routine doit donc se terminer par des constructions particulières qui assurent le non-retour : une boucle infinie, un branchement (\texttt{bra}, Bcc, \texttt{goto} ou \texttt{jump}) vers une autre routine sans retour, un \texttt{bra} calculé ou un \texttt{goto} calculé vers d’autres routines sans retour.

Une routine sans retour doit être déclarée avec qualificatif « \texttt{noreturn} » :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine ... {
  ...
}
\end{lstlisting}

~\\
\textbf{Appel d’une routine sans retour.} Utiliser \texttt{bra}, \texttt{goto}, Bcc ou \texttt{jump}.


~\\
\textbf{Déclaration de la routine \texttt{main}.} Dans un programme, il doit exister une et une seule routine \texttt{main}, qui doit être déclarée comme suit :

\begin{lstlisting}[language=piccolo]
noreturn routine main bank:requires 0 {
   liste d'instructions
}

\end{lstlisting}

Le compilateur Piccolo insère à l’adresse zéro une instruction \texttt{bra} (ou \texttt{goto}) vers cette routine, de façon que la routine \texttt{main} soit exécutée au démarrage du micro-contrôleur. Le qualificatif « \texttt{bank:requires 0} » est exigé par le compilateur Piccolo car \texttt{BSR} est initialisé à zéro au démarrage du micro-contrôleur.


~\\
\textbf{Comment terminer une routine sans retour.} La dernière instruction de la liste des instructions d’une routine sans retour doit être :
\begin{itemize}
  \item un appel vers une autre routine sans retour, au moyen d’un \texttt{bra}, \texttt{goto}, Bcc ou \texttt{jump} ;
  \item un branchement calculé vers une routine parmi plusieurs, au moyen d’un \texttt{computed bra} ou d’un \texttt{computed goto} ;
  \item une instruction conditionnelle structurée, dont toutes les branches présentent comme dernière instruction les instructions d’appel d’un routine sans retour, un branchement calculé (comme évoqué ci-dessus), ou encore une instruction conditionnelle structurée, dont toutes les branches, etc.

\end{itemize}

Exemple simple : la dernière instruction est une boucle infinie :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  forever
    ...
  end
}
\end{lstlisting}

Exemple simple : la dernière instruction est un branchement vers une routine sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  bra autreRoutineSansRetour
}
\end{lstlisting}

La dernière instruction est un \texttt{computed bra} nommant les routines \texttt{r1}, \texttt{r2}, \texttt{r3} qui doivent être toutes les trois des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  ...
  computed [3] bra r1, r2, r3
}
\end{lstlisting}

La dernière instruction est un \texttt{if} dont aucune des branches ne se termine (\texttt{r1} est une routine sans retour) :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    bra r1
  else
    ...
    forever
      ...
    end
  end
}

\end{lstlisting}


La dernière instruction est un \texttt{if} dont la première branche se termine elle même par un \texttt{if} dont les deux branches se terminent par des branchements vers des routines sans retour :
\begin{lstlisting}[language=piccolo]
noreturn routine maRoutine {
  if (...)
    ...
    if (...)
      ...
      bra r1
    else
      ...
      bra r2
    end
  else
    ...
    bra r3
  end
}
\end{lstlisting}








\sectionLabel{Routines d'interruption}{routineInterruptionPic18}

Les \emph{pic18} acceptent deux niveaux d’interruption, le niveau haut (\texttt{high}), et le niveau faible (\texttt{low}) :
l’occurrence d’une interruption de niveau haut provoque un branchement à l’adresse 0x08 ;
l’occurrence d’une interruption de niveau faible provoque un branchement à l’adresse 0x18.

Durant la réponse à une interruption, PC est sauvé dans la pile, et les registres \texttt{WREG}, \texttt{STATUS} et \texttt{BSR} sont sauvés dans des registres cachés. Le retour d’interruption s’effectue par une instruction \texttt{retfie} ; si l’opérande 1 (pour \texttt{FAST}) est précisée (\texttt{retfie 1}), alors \texttt{WREG}, \texttt{STATUS} et \texttt{BSR} sont restitués à partir des registres cachés.

Si les deux interruptions sont activées (\emph{enabled}), Microchip précise que le retour par \texttt{retfie 1} ne peut pas être utilisée fiablement pour l’interruption de faible priorité : « \emph{If both low and high priority interrupts are enabled, the stack registers cannot be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten} ».

Nous allons voir dans la suite comment Piccolo gère cette situation.

En Piccolo, une routine d’interruption PIC 18 est décrite dans une section « \texttt{interrupt} » :

\begin{lstlisting}[language=piccolo]
interrupt nom ... {
 instructions
}
\end{lstlisting}

Seuls deux noms sont possibles : « \texttt{low} » pour l’interruption de faible priorité, et « \texttt{high} » pour l’interruption de haute priorité. Bien entendu, un nom ne peut apparaître qu’une seule fois, aussi un programme ne peut comporter qu'au plus deux routines d'interruption, qui peuvent apparaître dans un ordre quelconque.

Dans une routine d'interruption, toutes les instructions décrites sont disponibles, sauf les instructions qui sont sans retour : boucle infinie, \texttt{bra} (branchement vers une routine sans retour), etc.

L’instruction assembleur \texttt{retfie} n’existe pas en Piccolo : le compilateur l’insère automatiquement à la fin des routines d’interruption.



\subsection{Qualificatif \texttt{fast}}

En Piccolo, vous pouvez ajouter le qualificatif « \texttt{fast} » à l’en-tête d’une routine d’interruption :\begin{lstlisting}[language=piccolo]
interrupt nom fast { instructions}\end{lstlisting}
Avec ce qualificatif, l’instruction de retour engendrée par Piccolo est \texttt{retfie 1} (sans ce qualificatif, c’est \texttt{retfie 0}).Si les deux routines d’interruption \texttt{low} et \texttt{high} sont déclarées, et si la routine \texttt{high} est déclarée « \texttt{fast} », alors Piccolo considère comme une erreur de déclarer la routine \texttt{low} avec le qualificatif « \texttt{fast} ».






\subsection{Routine d'interruption et \texttt{BSR}}

\textbf{Routine déclarée avec « fast ».} Le contenu initial de \texttt{BSR}, au début de la routine d’interruption est inconnu. Il faut donc fixer sa valeur par une instruction « \texttt{banksel} » si besoin est. Comme le retour d’interruption restituera le contenu initial de \texttt{BSR}, il est inutile de le préserver par une construction « \texttt{banksave} ».\begin{lstlisting}[language=piccolo]
interrupt nom fast {  banksel 1  clrf varBank1 #  Variable declaree dans le banc 1}
\end{lstlisting}

~\\\textbf{Routine déclarée sans « fast ».} Le contenu initial de \texttt{BSR}, au début de la routine d’interruption est inconnu. Si il doit être utilisé, et comme le retour d’interruption ne restituera pas son contenu initial, il est indispensable de le préserver par une construction « \texttt{banksave} », nommant une variable \texttt{sauve\_bsr} déclarée dans le banc \texttt{accessram}. Il faut ensuite fixer sa valeur par une instruction « \texttt{banksel} ». \begin{lstlisting}[language=piccolo]
interrupt nom {  banksave sauve_bsr    banksel 1    clrf varBank1 #  Variable declaree dans le banc 1  end}\end{lstlisting}
Le compilateur Piccolo détectera l’oubli de la sauvegarde par « \texttt{banksave} », en émettant un message d’erreur.



