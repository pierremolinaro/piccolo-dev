%!TEX encoding = UTF-8 Unicode
%!TEX root = ../piccolo.tex

\cleardoublepage

\chapterLabel{Définition de variable}{ram}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}








\section{Comment est décrite la RAM ?}

Préalablement, vous devez savoir comment la mémoire RAM de votre micro-contrôleur est décrite par Piccolo. Pour cela, utiliser l'option « \texttt{--memory} » (ou sa version courte « \texttt{-M=} »), en nommant ensuite votre micro-contrôleur (voir \refSubsectionPage{exempleOptionMemory}).

\textcolor{red}{\bf Pour chaque micro-contrôleur, veuillez vérifier l'exactitude de ces renseignements en comparant les résultats fournis par Piccolo avec le \emph{data sheet} de Microchip. La description des micro-contrôleurs est obtenue automatiquement, et je n'ai pas vérifié individuellement chaque description.}



\subsection{Micro-contrôleur \emph{baseline}}

Par exemple, pour le 16F57, entrez la ligne de commande \texttt{piccolo -M=16F57}. Piccolo affiche alors les renseignements suivants :

\lstinputlisting[language=sortie]{files-from-piccolo/memory-16F57.txt}

Pour les micro-contrôleurs \emph{baseline}, l'accès direct est possible pour les registres dont l'adresse est comprise entre 0x0 et 0x1F : pour le 16F57, ceci comprend les registres spéciaux (non décrits ici, entre 0x0 et 0x07), le banc \piccolo{gprnobank}, et le banc \piccolo{gpr0}. Les trois deux autres bancs, \piccolo{gpr1}, \piccolo{gpr2} et \piccolo{gpr3}, ne sont accessibles que par adressage indirect via \assembleur{FSR}.

L'instruction \piccolo{banksel} n'est donc pas valide pour les \emph{baseline}.

\subsection{Micro-contrôleur \emph{mid-range}}

Par exemple, pour le 16F690, entrez la ligne de commande \texttt{piccolo -M=16F690}. Piccolo affiche alors les renseignements suivants :

\lstinputlisting[language=sortie]{files-from-piccolo/memory-16F690.txt}

Pour les micro-contrôleurs \emph{mid-range}, l'accès aux différents bancs est régi par les bits \assembleur{RP} du registre \assembleur{STATUS} : c'est le cas des trois premiers bancs \piccolo{gpr0} à \piccolo{gpr2}. Le dernier banc, \piccolo{gprnobnk}, est toujours accessible quelque soient les bits \assembleur{RP} du registre \assembleur{STATUS} car il apparaît en miroir dans tous les bancs.

En Piccolo, on ne manipule jamais directement les \assembleur{RP} du registre \assembleur{STATUS} : on utilise l'instruction \piccolo{banksel}. L'avantage est que celle-ci permet une vérification statique, à la compilation, de la sélection correcte des bancs.


\subsection{Micro-contrôleur \emph{pic18}}

Par exemple, pour le 18F448, entrez la ligne de commande \texttt{piccolo -M=18F448}. Piccolo affiche alors les renseignements suivants :

\lstinputlisting[language=sortie]{files-from-piccolo/memory-18F448.txt}

Le premier banc, \piccolo{accessram}, est toujours accessible directement sans utiliser la valeur du registre \assembleur{BSR}. Suivant le micro-contrôleur, ce banc occupe les 96 ou les 128 premiers octets de la RAM.

Ensuite, l'accès aux bancs \piccolo{gprX} imposent la valeur \texttt{X} au registre \assembleur{BSR}. Voir à ce sujet la \refSectionPage{instructionsGestionBancsMemoire} qui explique comment le registre \assembleur{BSR} est géré en Piccolo.

En Piccolo, on ne manipule jamais directement le registre \assembleur{BSR} : on utilise l'instruction \piccolo{banksel}. L'avantage est que celle-ci permet une vérification statique, à la compilation, de la sélection correcte des bancs.







\section{Les sections \texttt{ram}}

En Piccolo, les sections \piccolo{ram} décrivent l'attribution de la RAM. Leur syntaxe est la même pour les \emph{baseline}, les \emph{mid-range} et les \emph{pic18}. Dans un programme vous pouvez utiliser autant de sections \piccolo{ram} que vous voulez.

Voici un exemple :

\begin{lstlisting}[language=piccolo]
ram accessram {
  byte premiere ;
  byte deuxieme ;
  byte troisieme [5] ;
  byte quatrieme ;
}
\end{lstlisting}

Le mot clé \piccolo{ram} est suivi du nom du banc utilisé pour l'attribution. Ce nom doit être l'un des noms de bancs affichés par l'option \texttt{-{}-memory} (voir section précédente).

Ensuite, les variables déclarées sont servies dans leur ordre d'apparition.

Si la section ci-dessus est la première qui nomme \piccolo{accessram} (pour un \emph{pic18}, le banc \piccolo{accessram} commençe à l'adresse 0), la variable \piccolo{premiere} reçoit l'adresse 0, \piccolo{deuxieme} l'adresse 1, \piccolo{troisieme} l'adresse 2, et \piccolo{quatrieme} l'adresse 7 (\piccolo{troisieme} occupe 5 octets).

Vous pouvez déclarer autant de variables que vous voulez, à condition de ne pas dépasser la capacité du banc : le compilateur Piccolo émet alors un message d'erreur.

Les sections \piccolo{ram} ont un effet cumulatif : si vous déclarez plusieurs sections pour le même banc, Piccolo attribue les adresses dans l'ordre d'apparition des déclarations. Par exemple, les déclarations suivantes :

\begin{lstlisting}[language=piccolo]
ram accessram {
  byte premiere
  byte deuxieme
}
...
ram accessram {
  byte troisieme [5]
  byte quatrieme
}
\end{lstlisting}

ont le même effet que la déclaration précédente.

Dans cette situation aussi, le compilateur Piccolo émet un message d'erreur quand la capacité d'un banc est dépassée. 



\section{Déclaration \texttt{byte}}

Comme vous l'avez sûrement deviné à partir des exemples de la section précédente, la déclaration

\begin{lstlisting}[language=piccolo]
byte var 
\end{lstlisting}

déclare une variable \piccolo{var} occupant un octet. Vous pouvez aussi déclarer une variable occupant \piccolo{n} octets consécutifs en indiquant la dimension entre crochets :

\begin{lstlisting}[language=piccolo]
byte var [n]
\end{lstlisting}

\piccolo{n} doit être une constante littérale. Évidemment, \piccolo{n} doit être strictement positif. Si \piccolo{n} vaut 1, la déclaration est sémantiquement équivalente à la première forme.






\section{Nommage de bits dans une déclaration \texttt{byte}}

Vous pouvez nommer les bits individuels lors de la déclaration d'une variable, comme par exemple :

\begin{lstlisting}[language=piccolo]
byte var <-, A, b, -, d, e [2], ->
\end{lstlisting}

La déclaration est effectuée entre les délimiteurs \piccolo{<} et \piccolo{>}, et séparés par une virgule. Le premier bit déclaré est le bit de poids fort (7), le dernier le bit de poids faible (0).

Si vous ne voulez pas nommer un bit particulier, mettez le délimiteur \piccolo{-} : c'est le cas des bits 7, 4 et 0 dans l'exemple ci-dessus.

À un nom est associé le numéro du bit correspondant : ainsi \piccolo{A} est associé à 6, \piccolo{b} à 5, et \piccolo{d} à 3. \piccolo{e} est complété par une dimension, ce qui signifie que \piccolo{e[1]} prend la valeur 2, et \piccolo{e[0]} la valeur 1.

La déclaration doit toujours comprendre la définition des 8 bits, autrement dit à la dernière définition, juste avant le \piccolo{>}, est associé le numéro 0.

Les noms de bits sont locaux, c'est à dire que vous pouvez utiliser les mêmes noms dans des déclarations \piccolo{byte} différentes.

Enfin, vous pouvez combiner la présence d'une dimension explicite avec le nommage de bits :

\begin{lstlisting}[language=piccolo]
byte var [2] <-, A, b, -, d, e [2], ->
\end{lstlisting}

Dans ce cas, tous les octets du tableaux ont leurs bits nommés de la même façon.

Comment utiliser ces noms de bits ? Dans les conditions de l'instruction conditionnelle simple, les conditions élémentaires des instructions conditionnelles structurées et répétitive, dans les instructions \piccolo{bcf}, \piccolo{bsf} et \piccolo{btg} (voir la \refSubsectionPage{opBaselineAffectationBit} pour les \emph{baseline}, la \refSubsectionPage{opMidRangeAffectationBit} pour les \emph{mid-range} et la \refSubsectionPage{opPic18AffectationBit} pour les \emph{pic18}). 


\sectionLabel{Référence à un registre}{referenceRegistre}

De nombreuses instructions nomment un registre, qui peut être :
\begin{itemize}
  \item un registre spécial (dont vous pouvez avoir la liste grâce à l'option « \texttt{-{}-registers} ») ;
  \item une variable déclarée dans une section \piccolo{ram}.
\end{itemize}

En Piccolo, il suffit de nommer simplement le registre avec l'instruction, par exemple :
\begin{lstlisting}[language=piccolo]
clrf registre
\end{lstlisting}

Cette écriture ressemble à l'assembleur, mais il y a une différence fondamentale : le bit indiquant si l'adressage devra être fait via l'\emph{access bank} ou via le registre \assembleur{BSR} n'apparaît jamais dans l'instruction Piccolo. Lors de la génération de code, Piccolo fixera automatiquement la valeur de ce bit.

Par exemple, en supposant que \piccolo{varAccesBank} est accessible via l'\emph{access bank}, que \piccolo{varBank1} est dans le banc 1 et \piccolo{varBank2} dans le banc 2, on écrira en Piccolo :

\begin{lstlisting}[language=piccolo]
clrf varAccesBank
banksel 1
clrf varBank1
banksel 2
clrf varBank2
\end{lstlisting}

Contrairement à l'assembleur, l'oubli d'une instruction \piccolo{banksel} est détectée par le compilateur Piccolo.

Pour plus de précision sur le contrôle de \assembleur{BSR}, voir les pages consacrées au contrôle de \assembleur{BSR} en Piccolo.

Si une variable est déclarée avec une dimension, par exemple :
\begin{lstlisting}[language=piccolo]
ram ... { 
  byte maVariable [4]
}
\end{lstlisting}

Le premier élément du tableau est \piccolo{maVariable [0]}, et le dernier  \piccolo{maVariable [3]}.

On peut ainsi écrire :
\begin{lstlisting}[language=piccolo]
  clrf maVariable # Equivalent a clrf maVariable [0]
  clrf maVariable [3]
  clrf maVariable [4] # Erreur detectee par Piccolo
\end{lstlisting}











\sectionLabel{Déclaration \texttt{unused byte}}{sectionUnusedByte}

À partir de la version 3.0.2, Piccolo détecte les variables déclarées (par une déclaration \piccolo{byte}), et qui sont inutilisées. Un \emph{warning} est alors déclenché pour toute variable détectée inutilisée.

Par exemple :

\begin{lstlisting}[language=piccolo]
midrange exemple "12F683" :

ram gprnobnk {
  byte var # Cette variable est inutilisee
}

noreturn routine main bank:requires 0 {
  forever
  end
}
\end{lstlisting}


Pour inhiber ce \emph{warning}, il suffit d'indiquer explicitement que la variable \piccolo{var} est inutilisée, par la déclaration \piccolo{unused byte var} :

\begin{lstlisting}[language=piccolo]
midrange exemple "12F683" :

ram gprnobnk {
  byte var # Cette variable est inutilisee
}

unused byte var

noreturn routine main bank:requires 0 {
  forever
  end
}
\end{lstlisting}

Cette déclaration peut apparaître avant ou après la déclaration de la variable nommée. Si plusieurs variables sont concernées, on peut écrire plusieurs déclarations \piccolo{unused byte}, ou bien nommer plusieurs variables dans une même déclaration, en les séparant par des virgules :

\begin{lstlisting}[language=piccolo]
midrange exemple "12F683" :

unused byte var1

ram gprnobnk {
  byte var # Cette variable est inutilisee
  byte var1 # Cette variable est inutilisee
  byte var2 # Cette variable est inutilisee
}

unused byte var, var2

noreturn routine main bank:requires 0 {
  forever
  end
}
\end{lstlisting}


