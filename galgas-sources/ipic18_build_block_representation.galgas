

#----------------------------------------------------------------------------*

#!Register analysis

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpression
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?writeAccess:let @bool inWriteAccess
  !@ipic18_intermediate_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
  ?!@stringset ioUsedRegisters
{
  [self.mOffset eval !inRegisterTable !inConstantMap ?let @sint64 offset !?ioUsedRegisters]
  ioUsedRegisters += !self.mRegisterName.string
#--- Build assembly string
  var @string assemblyString = self.mRegisterName.string
  if offset > 0 then
    assemblyString += " + " + [[offset uint] hexString]
  end
#--- 
  var @uint registerAddress = 0
  [inRegisterTable searchKey
    !self.mRegisterName
    ?let registerAddressList
    ?let @uint size
    ?outBitSliceTable
    ?*
    ?let protection
  ]
  [inRegisterTable checkPrivateAccess !self.mRegisterName !write:inWriteAccess !protection]
#---
  if offset < 0 then
    error self.mEndOfOffsetExpression: "offset (" + offset + ") should be >= 0"
  elsif [offset uint] >= size then
    error self.mEndOfOffsetExpression: "this offset is too large: should be lower than " + [size string]
  end
#---
  var @bool found = false
  for (mValue) in  registerAddressList while not found do
    found = (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset))
    registerAddress = mValue
  end
  var @bool needsBSRaccess = false
  if not found then
    needsBSRaccess = true
    [registerAddressList first ?registerAddress]
    let @uint neededBank = registerAddress >> 8
    if (neededBank != inCurrentBank) then
      var @string errorMessage = "Accessing the '" + self.mRegisterName + "' needs the bank selection set to " + [neededBank string]
      if inCurrentBank == @uint. max then
        errorMessage += ", but current bank selection cannot be known"
      else
        errorMessage += ", but current bank selection is set to " + [inCurrentBank string]
      end
      error self.mRegisterName: errorMessage
    end
  end
#---
  outIPICregisterDescription = @ipic18_intermediate_registerExpression {
    !assemblyString
    !registerAddress + [offset uint]
    !needsBSRaccess
  }
}

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpressionWithoutCheckingBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?writeAccess:let @bool inWriteAccess
  !@ipic18_intermediate_registerExpressionWithoutBSRIndication outIPICregisterDescription
  ?!@stringset ioUsedRegisters
{
  ioUsedRegisters += !self.mRegisterName.string
#--- Build assembly string
  var @string assemblyString = self.mRegisterName.string
  [self.mOffset eval !inRegisterTable !inConstantMap ?let @sint64 offset !?ioUsedRegisters]
  if offset > 0 then
    assemblyString += " + " + [[offset uint] hexString]
  end
#--- 
  [inRegisterTable searchKey !self.mRegisterName ?let @uintlist registerAddressList ?let @uint size ?2* ?let protection]
  [inRegisterTable checkPrivateAccess !self.mRegisterName !write:inWriteAccess !protection]
  [registerAddressList first ?let @uint registerAddress]
#---
  if [offset uint] >= size then
    error self.mEndOfOffsetExpression: "this offset is too large: should be lower than " + [size string]
  end
#---
  outIPICregisterDescription = @ipic18_intermediate_registerExpressionWithoutBSRIndication {
    !assemblyString
    !registerAddress + [offset uint]
  }
}

#----------------------------------------------------------------------------*

method @registerExpression getRegisterAddress
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?writeAccess:let @bool inWriteAccess
  ?!@stringset ioUsedRegisters
  !@uint outRegisterAddress
{
  [inRegisterTable searchKey !self.mRegisterName ?let @uintlist registerAddressList ?let @uint size ?2* ?let protection]
  [inRegisterTable checkPrivateAccess !self.mRegisterName !write:inWriteAccess !protection]
#---
  [self.mOffset eval !inRegisterTable !inConstantMap ?let @sint64 offset !?ioUsedRegisters]
  if offset < 0 then
    error self.mEndOfOffsetExpression: "offset (" + offset + ") should be >= 0" : outRegisterAddress
  elsif [offset uint] >= size then
    error self.mEndOfOffsetExpression: "this offset is too large: should be lower than " + [size string] : outRegisterAddress
  else
    [registerAddressList first ?outRegisterAddress]
    outRegisterAddress = outRegisterAddress + [offset uint]
  end
}

#----------------------------------------------------------------------------*

#!Simple Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloSimpleInstruction analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction

#----------------------------------------------------------------------------*

override method @pic18Instruction_withNoOperand analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  outInstruction = @ipic18InstructionWithNoOperand {
    !self.mInstructionLocation
    !self.mKind}
}

#----------------------------------------------------------------------------*

override method @pic18Instruction_FDA analyzeSimpleInstruction
  ?let @uint inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
{
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:not self.m_W_isDestination
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  outInstruction = @ipic18_intermediate_instruction_FDA {
    !self.mInstructionLocation
    !self.mInstruction_FDA_base_code
    !IPICregisterDescription
    !self.m_W_isDestination
  }
}

#----------------------------------------------------------------------------*

override method @pic18Instruction_FA analyzeSimpleInstruction
  ?let @uint inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  let @FA_sequential_instruction_base_code code
  switch self.mFAinstruction
  case CLRF : code = @FA_sequential_instruction_base_code. CLRF
  case MOVWF : code = @FA_sequential_instruction_base_code. MOVWF
  case MULWF : code = @FA_sequential_instruction_base_code. MULWF
  case NEGF : code = @FA_sequential_instruction_base_code. NEGF
  case SETF : code = @FA_sequential_instruction_base_code. SETF
  case CPFSEQ, CPFSGT, CPFSLT, TSTFSZ :
    error @location. nowhere : "*** INTERNAL ERROR ***" : code
  end
  outInstruction = @ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !code
    !IPICregisterDescription}
}

#----------------------------------------------------------------------------*

override method @pic18Instruction_MOVFF analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  [self.mSourceRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpressionWithoutBSRIndication sourceIPICregisterDescription
    !?ioUsedRegisters
  ]
  [self.mDestinationRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpressionWithoutBSRIndication destinationIPICregisterDescription
    !?ioUsedRegisters
  ]
  outInstruction = @ipic18_intermediate_instruction_MOVFF {
    !self.mInstructionLocation
    !sourceIPICregisterDescription
    !destinationIPICregisterDescription}
}

#----------------------------------------------------*

override method @pic18Instruction_FBA analyzeSimpleInstruction
  ?let @uint inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?let @bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let @uint bitNumber
  ]
  outInstruction = @ipic18_intermediate_instruction_FBA {
    !self.mInstructionLocation
    !self.mBitOrientedOp
    !IPICregisterDescription
    !bitNumber}
}

#----------------------------------------------------*

override method @pic18Instruction_literalOperation analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  [self.mImmediatExpression eval !inRegisterTable !inConstantMap ?let @sint64 result !?ioUsedRegisters]
#---
   if (result > 255) | (result < -128) then
     error self.mInstructionLocation:"immediate value is evaluated as " + [result string] + " (should be between -128 and 255)"
   end
#---  
  outInstruction = @ipic18_intermediate_instruction_literalOperation {
    !self.mInstructionLocation
    !self.mLiteralInstruction
    ![result & 0x000000FF uint]}
}

#----------------------------------------------------*

override method @pic18Instruction_fnop analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  [self.mImmediatExpression eval !inRegisterTable !inConstantMap ?let @sint64 result !?ioUsedRegisters]
#---
   if (result > 0xFFF) | (result < 0) then
     error self.mInstructionLocation:"immediate value is evaluated as " + [result string] + " (should be between 0 and 4095)"
   end
#---  
  outInstruction = @ipic18_intermediate_instruction_FNOP {
    !self.mInstructionLocation
    ![result uint]}
}

#----------------------------------------------------*

override method @pic18Instruction_LFSR analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
  if self.mFSRindex.uint > 2 then
    error self.mFSRindex:"the LFSR register idx (" + [self.mFSRindex.uint string] + ") should be lower or equal to 2"
  end
#---
  [self.mImmediatExpression eval !inRegisterTable !inConstantMap ?let @sint64 result !?ioUsedRegisters]
#---
  if (result > 0xFFF) | (result < 0) then
    error self.mInstructionLocation:"immediate value is evaluated as " + [result string] + " (should be between 0 and 4095)"
  end
  outInstruction = @ipic18_intermediate_instruction_LFSR {
    !self.mInstructionLocation
    !self.mFSRindex
    ![result uint]}
}

#----------------------------------------------------*

override method @pic18Instruction_JSR analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let @bool isNoReturn ?let @uint requiredBank ?let @uint returnedBank ?let @bool preservesBank]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "is not defined"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if isNoReturn then
    error self.mTargetLabel:"a \"noreturn\" routine should be called with a BRA, GOTO, Bcc or JUMP instruction"
  end
  if not preservesBank then
    ioCurrentBank = returnedBank
    if inShouldPreserveBSR then
      error self.mTargetLabel:"the routine call should preserve bank selection"
    end
  end
#---
  outInstruction = @ipic18_intermediate_JSR {
    !self.mInstructionLocation
    !self.mTargetLabel
    !self.mKind}
}

#----------------------------------------------------------------------------*

#!Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloInstruction analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters

#----------------------------------------------------*

override method @pic18Instruction_checkbank analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  if self.mBankIndex > 15 then
    error self.mInstructionLocation:"Bank index should be <= 15"
  elsif ioCurrentBank == @uint. max then
    error self.mInstructionLocation:"checkbank fail: there is no selected bank"
  elsif ioCurrentBank != self.mBankIndex then
    error self.mInstructionLocation:"checkbank fail: the selected bank is " + ioCurrentBank + ", required bank is " + self.mBankIndex
  end
  ioCurrentBank = self.mBankIndex
}

#----------------------------------------------------*

override method @pic18Instruction_checknobank analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  if ioCurrentBank != @uint. max then
    error self.mInstructionLocation:"checknobank fail: the " + ioCurrentBank + " bank is selected"
    ioCurrentBank = @uint. max
  end
}

#----------------------------------------------------------------------------*

override method @pic18PiccoloSimpleInstruction analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  [self analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ?let @ipic18SequentialInstruction instruction
  ]
  ioGeneratedInstructionList += !instruction !@uint.max !0
}

#----------------------------------------------------*

override method @pic18Instruction_FOREVER analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  switch inRoutineKind
  case regularRoutine :
    error self.mInstructionLocation:"a regular routine does not accept the \"forever\" instruction"
  case noReturnRoutine : # ok
  case interruptRoutine :
    error self.mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction"
  end
  let @uint finalBank = ioCurrentBank
#--- Get loop label
  let loopLabel = @lstring { !".L" + ioLocalLabelIndex !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
#--- Store current block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18JumpTerminator { !self.mInstructionLocation !loopLabel !@jumpInstructionKind. ipicRelative}
    !@uint.max
    !0
  }
#--- Analyze instruction list
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
  ioBlockLabel = loopLabel
  analyzeInstructionList (
    !self.mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  )
#--- Check instruction list does not change bank
  if ioBlockLabel.string == "" then
    error self.mEndOfInstructionList:"\"forever\" instruction list execution is endless"
  else
    ioGeneratedBlockList += !@ipic18Block {
      !@uint. max # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !@ipic18JumpTerminator { !self.mInstructionLocation !loopLabel !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
   }
  end
#--- Check instruction list does not change bank
  if ioCurrentBank != finalBank then
    error self.mEndOfInstructionList:"\"forever\" instruction list does not leave bank selection unchanged"
  end
#--- Indicate next code is not reacheable
  ioBlockLabel = ["" nowhere]
}

#----------------------------------------------------*

override method @pic18Instruction_nobanksel analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  if inShouldPreserveBSR then
    error self.mInstructionLocation: "cannot use \"nobank\" here: bank selection should be preserved (use it in a \"banksave\" construct)"
  end
  ioCurrentBank = @uint. max
#--- Generates no code
}

#----------------------------------------------------*

override method @pic18Instruction_savebank analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
{
#--- Get values for BSR register
  let BSRregister = @registerExpression {
    ! @{ !"BSR" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [BSRregister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpressionWithoutBSRIndication BSR_IPICregisterDescription
    !?ioUsedRegisters
  ]
#--- Get values for register used for saving
  [self.mRegister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpressionWithoutBSRIndication save_IPICregisterDescription
    !?ioUsedRegisters
  ]
#--- Generate "MOVFF BSR, save_register" instruction
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_MOVFF {
    !self.mInstructionLocation
    !BSR_IPICregisterDescription
    !save_IPICregisterDescription
  }
  !@uint.max
  !0
#--- Generate instruction list
  var @uint finalBank = ioCurrentBank
  analyzeInstructionList (
    !self.mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?finalBank
    !false # Do not preserve bank now
    !inRoutineKind 
    !?ioUsedRegisters
  )
  if ioBlockLabel.string == "" then
    error self.mEndOfSaveBankInstruction:"useless saving: execution does not reach the end of \"savebank\" instruction list"
  end
#--- Generate "MOVFF save_register, BSR" instruction
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_MOVFF {
    !self.mInstructionLocation
    !save_IPICregisterDescription
    !BSR_IPICregisterDescription
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_repetitionStatique analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Solve immediat expression
  [self.mLowerBoundExpression eval !inRegisterTable !inConstantMap ?let @sint64 lowerBound !?ioUsedRegisters]
  [self.mUpperBoundExpression eval !inRegisterTable !inConstantMap ?let @sint64 upperBound !?ioUsedRegisters]
#---
  if lowerBound > upperBound then
    error self.mInstructionLocation: "lower bound (" + lowerBound + ") greater then upper bound (" + upperBound + ")"
  elsif (upperBound - lowerBound) > 0xFF_FFFF then
    error self.mInstructionLocation:"repeat count (" + (upperBound - lowerBound) + ") too large (should be <= 0xFF_FFFF)"
  end
#--- Generate instruction list (first pass, for lower bound)
  var @uint finalBank = ioCurrentBank
  var tempConstantMap = inConstantMap
  [!?tempConstantMap insertKey !self.mConstantName !lowerBound]
  analyzeInstructionList (
    !self.mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !tempConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?finalBank
    !true # Preserve bank now
    !inRoutineKind 
    !?ioUsedRegisters
  )
  if ioBlockLabel.string == "" then
    error self.mEndOfInstruction:"useless do: execution does not reach the end of enclosed instruction list"
  end
  if finalBank != ioCurrentBank then
    error self.mEndOfInstruction:"enclosed instruction list should not modify bank selection"
  end
#--- Generate instruction list (other passes)
  var idx = lowerBound + 1
  loop ([upperBound - lowerBound + 1 uint]) while (idx <= upperBound) && (@uint.errorCount == 0) do
    var constantMap = inConstantMap
    [!?constantMap insertKey !self.mConstantName !idx]
    analyzeInstructionList (
      !self.mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !constantMap
      !inMacroMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?ioCurrentBank
      !true # Preserve bank now
      !inRoutineKind 
      !?ioUsedRegisters
    )
    idx += 1
  end
}

#----------------------------------------------------*

override method @pic18Instruction_banksel analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  if inShouldPreserveBSR then
    error self.mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)"
  end
  if self.mBankIndex.uint > 15 then
    error self.mBankIndex:"selected bank idx should be lower or equal to 15"
    ioCurrentBank = @uint. max # No selected bank
  elsif self.mBankIndex.uint != ioCurrentBank then
    ioCurrentBank = self.mBankIndex.uint
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_MOVLB { !self.mInstructionLocation !self.mBankIndex} !@uint.max !0
  elsif self.mWarningOnUselessBanksel then
    warning self.mBankIndex:"useless instruction: the bank " + [ioCurrentBank string] + " is already selected"
  end
}

#----------------------------------------------------*

override method @pic18Instruction_banksel_register analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
{
  if inShouldPreserveBSR then
    error self.mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)"
  end
  [self.mRegisterExpression getRegisterAddress
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    !?ioUsedRegisters
    ?let registerAddress
  ]
#  let @uint registerAddress = [mRegisterExpression getRegisterAddress !inRegisterTable]
  let @uint newBank = registerAddress >> 8
  if ioCurrentBank != newBank then
    ioCurrentBank = newBank
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_MOVLB {
      !self.mInstructionLocation
      !@luint { !newBank !self.mRegisterExpression.mRegisterName.location}
    }
    !@uint.max
    !0
  elsif self.mWarningOnUselessBanksel then
    warning self.mRegisterExpression.mRegisterName:"useless instruction: the bank " + newBank + " is already selected"
  end
}

#----------------------------------------------------*

override method @pic18Instruction_TBLRD analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
{
  outInstruction = @ipic18_intermediate_instruction_TBLRD {
    !self.mInstructionLocation
    !self.mOption}
}

#----------------------------------------------------*

override method @pic18Instruction_TBLWT analyzeSimpleInstruction
  ?let @uint unused inAccessBankSplitOffset
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
{
  outInstruction = @ipic18_intermediate_instruction_TBLWT {
    !self.mInstructionLocation
    !self.mOption}
}

#----------------------------------------------------*

override method @pic18Instruction_MNOP analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#---
  if self.mOccurrenceFactor.uint == 0 then
    warning self.mOccurrenceFactor:"occurrence argument is zero: no generated code"
  end
#---
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_MNOP {
    !self.mInstructionLocation
    !self.mOccurrenceFactor
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_NOPBRA analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#---
  if self.mOccurrenceFactor.uint == 0 then
    warning self.mOccurrenceFactor:"occurrence argument is zero: no generated code"
  end
#---
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_NOPBRA {
    !self.mInstructionLocation
    !self.mOccurrenceFactor
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_LTBLPTR analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  [self.mImmediatExpression eval !inRegisterTable !inConstantMap ?let @sint64 result !?ioUsedRegisters]
#---
  if (result > 0xFF_FFFF) | (result < 0) then
    error self.mInstructionLocation:"immediate value is evaluated as " + [result string] + " (should be between 0 and 0xFF_FFFF)"
  end
  let @uint address = [result uint]
#--- Upper byte
  let TBLPTRU = @registerExpression {
    !@lstring { !"TBLPTRU" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?var @ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  let @uint upper = address >> 16
  if upper == 0 then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. CLRF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  elsif upper == 0xFF then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. SETF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  else
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_literalOperation {
      !self.mInstructionLocation
      !@literal_instruction_opcode. MOVLW
      !upper
    }
    !@uint.max
    !0
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. MOVWF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  end
#--- High byte
  let TBLPTRH = @registerExpression {
    !@lstring { !"TBLPTRH" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  let @uint high = (address >> 8) & 0xFF
  if high == 0 then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. CLRF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  elsif high == 0xFF then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. SETF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  else
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_literalOperation {
      !self.mInstructionLocation
      !@literal_instruction_opcode. MOVLW
      !high
    }
    !@uint.max
    !0
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. MOVWF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  end
#--- Low byte
  let TBLPTRL = @registerExpression {
    !@lstring {!"TBLPTRL" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  let @uint low = address & 0xFF
  if low == 0 then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. CLRF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  elsif low == 0xFF then
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. SETF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  else
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_literalOperation {
      !self.mInstructionLocation
      !@literal_instruction_opcode. MOVLW
      !low
    }
    !@uint.max
    !0
    ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
      !self.mInstructionLocation
      !@FA_sequential_instruction_base_code. MOVWF
      !outIPICregisterDescription
    }  
    !@uint.max
    !0
  end
}

#----------------------------------------------------*

override method @pic18Instruction_LDATA16PTR analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
{
  [inDataMap searchKey !self.mDataName ?let @uintlist data ?let isData8]
  if isData8 then
    error self.mDataName : "this data is a byte array; use ldata8ptr"
  end
#--- Check index
  if self.mDataIndex.uint >= [data count] then
    error self.mDataIndex: "index should be < " + [data count]
  end
#--- Upper byte
  let TBLPTRU = @registerExpression {
    !@lstring { !"TBLPTRU" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?var @ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint * 2
    !16
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
#--- High byte
  let TBLPTRH = @registerExpression {
    !@lstring {!"TBLPTRH" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint * 2
    !8
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
#--- Low byte
  let TBLPTRL = @registerExpression {
    !@lstring { !"TBLPTRL" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint * 2
    !0
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_LDATA8PTR analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
{
  [inDataMap searchKey !self.mDataName ?let @uintlist data ?let isData8]
  if not isData8 then
    error self.mDataName : "this data is a 16-bit word array; use ldata16ptr"
  end
#--- Check index
  if self.mDataIndex.uint >= ([data count] * 2) then
    error self.mDataIndex: "index should be < " + ([data count] * 2)
  end
#--- Upper byte
  let TBLPTRU = @registerExpression {
    !@lstring { !"TBLPTRU" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?var @ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint
    !16
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
#--- High byte
  let TBLPTRH = @registerExpression {
    !@lstring {!"TBLPTRH" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint
    !8
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
#--- Low byte
  let TBLPTRL = @registerExpression {
    !@lstring { !"TBLPTRL" !self.mInstructionLocation}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@ipic18_intermediate_MOV_LABEL_W {
    !self.mInstructionLocation
    !self.mDataName
    !self.mDataIndex.uint
    !0
  }
  !@uint.max
  !0
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_FA {
    !self.mInstructionLocation
    !@FA_sequential_instruction_base_code. MOVWF
    !outIPICregisterDescription
  }  
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_JUMP analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let @bool isNoReturn ?let @uint requiredBank ?* ?*]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "is not defined"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if not isNoReturn then
    error self.mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction"
  end
#--- Build block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18JumpTerminator { !self.mInstructionLocation !self.mTargetLabel !@jumpInstructionKind. ipicRelative}
    !@uint.max
    !0
  }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- No following code
  ioBlockLabel = ["" nowhere]
}

#----------------------------------------------------*

override method @pic18Instruction_computed_rcall analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
#---
  var @bool someReturnsBank = false
  var @uint returnedBankSelection = ioCurrentBank
  for (mValue) in  self.mTargetLabels do
    [inRoutineMap searchKey !mValue ?let @bool isNoReturn ?let @uint requiredBank ?let @uint returnedBank ?let @bool preservesBank]
    if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
      var @string errorMessage = "the routine '" + mValue + "' requires bank selection to be set to " + [requiredBank string]
      errorMessage += ", but bank selection "
      if ioCurrentBank == @uint. max then
        errorMessage += "is not defined"
      else
        errorMessage += "is set to " + [ioCurrentBank string]
      end
      error mValue: errorMessage
    end
    if isNoReturn then
      error mValue:"for being named in a computed rcall, the '" + mValue + "' routine should be declared without the \"noreturn\" qualifier"
    end
    if inShouldPreserveBSR & not preservesBank then
      error mValue:"the '" + mValue + "' routine should preserved bank selection"
    elsif (not inShouldPreserveBSR) & not preservesBank then
      if not someReturnsBank then
        returnedBankSelection = returnedBank
        someReturnsBank = true
      elsif returnedBankSelection != returnedBank then 
        var @string errorMessage = "the '" + mValue + "' routine returns "
        if returnedBank == @uint. max then
          errorMessage += "no bank selection"
        else
          errorMessage += "bank selection set to  "+ [returnedBank string]
        end
        errorMessage += ", but previous routine(s) return(s) "
        if returnedBankSelection == @uint. max then
          errorMessage += "no bank selection"
        else
          errorMessage += "bank selection set to  "+ [returnedBankSelection string]
        end
        error mValue: errorMessage
      end
    elsif (not inShouldPreserveBSR) & preservesBank then
    end
  end
#---
  ioCurrentBank = returnedBankSelection
#---
  [self.mSizeExpression eval !inRegisterTable !inConstantMap ?let @sint64 size !?ioUsedRegisters]
  if size < 2 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be greater or equal to 2"
  elsif size > 64 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be lower or equal to 64"
  elsif [size uint] != [self.mTargetLabels count] then
    error self.mInstructionLocation:"the routine name list length (" + [[self.mTargetLabels count] string] + ") should be equal to the computed range (" + [size string] + ")"
  end
#---
  var targetInstructionList =@ipic18SequentialInstructionList ()
  for (mValue) in  self.mTargetLabels do
    targetInstructionList += !@ipic18_intermediate_JSR {!mValue.location !mValue !@jumpInstructionKind. relative} !@uint.max !0
  end
#---
  ioGeneratedInstructionList += !@ipic18_intermediate_instruction_computed_rcall {
    !self.mInstructionLocation
    !targetInstructionList
    !self.mUsesRelativeCall
    
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_computed_goto analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#---
  for (mValue) in  self.mTargetLabels do
    [inRoutineMap searchKey !mValue ?let @bool isNoReturn ?let @uint requiredBank ?* ?*]
    if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
      var @string errorMessage = "the routine '" + mValue + "' requires bank selection to be set to " + [requiredBank string]
      errorMessage += ", but bank selection "
      if ioCurrentBank == @uint. max then
        errorMessage += "is not defined"
      else
        errorMessage += "is set to " + [ioCurrentBank string]
      end
      error mValue: errorMessage
    end
    if (@routineKind. regularRoutine != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed goto, the '" + mValue + "' routine should be declared with the \"noreturn\" qualifier"
  end
  end
  switch inRoutineKind
  case regularRoutine : #ok
  case noReturnRoutine : # ok
  case interruptRoutine :
    error self.mInstructionLocation:"an interrupt routine does not accept computed goto instruction"
  end
#---
  [self.mSizeExpression eval !inRegisterTable !inConstantMap ?let @sint64 size !?ioUsedRegisters]
  if size < 2 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be greater or equal to 2"
  elsif size > 64 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be lower or equal to 64"
  elsif [size uint] != [self.mTargetLabels count] then
    error self.mInstructionLocation:"the routine name list length (" + [[self.mTargetLabels count] string] + ") should be equal to the computed range (" + [size string] + ")"
  end
#--- Build block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18ComputedGotoTerminator {
      !self.mInstructionLocation
      !self.mTargetLabels
      !self.mUsesRelativeCall}
    !@uint.max
    !0
    }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- No following code
  ioBlockLabel = ["" nowhere]
}

#----------------------------------------------------*

override method @pic18Instruction_computed_bra analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#---
  var @bool allPreserveBankSetting = true
  var @bool allReturnBank = true
  var returnedBankValue =@uint.max
  for (mValue) in  self.mTargetLabels do
    [inRoutineMap searchKey !mValue ?let @bool isNoReturn ?let @uint requiredBank ?let @uint returnedBank ?let @bool preservesBank]
  #--- Check bank "requires"
    if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
      var @string errorMessage = "the routine '" + mValue + "' requires bank selection to be set to " + [requiredBank string]
      errorMessage += ", but bank selection "
      if ioCurrentBank == @uint. max then
        errorMessage += "is not defined"
      else
        errorMessage += "is set to " + [ioCurrentBank string]
      end
      error mValue: errorMessage
    end    
  #--- Check bank "preserved", "ensures"
    if preservesBank then
      allReturnBank = false
    elsif (returnedBankValue != @uint. max) & (returnedBankValue != returnedBank) then
      error mValue:"this routine ensures setting of bank '" + [returnedBank string] + "', but "
      + "previous routine(s) ensure setting of bank '" + [returnedBankValue string] + "'."
    else
      allPreserveBankSetting = false
      returnedBankValue = returnedBank
    end
    if (@routineKind. regularRoutine != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed bra from a regular routine, the '" + mValue + "' routine should be declared without any \"noreturn\" qualifier"
  end
  end
#---
  if allReturnBank & not allPreserveBankSetting then
    ioCurrentBank = returnedBankValue
  elsif (not allReturnBank) & not allPreserveBankSetting then
    error self.mInstructionLocation:"invoked routine should either all preserve bank, eihter return the same selected bank"
  end
  if inShouldPreserveBSR & not allPreserveBankSetting then
    error self.mInstructionLocation:"invoked routine(s) do(es) not preserve bank selection"
  end
#---
  switch inRoutineKind
  case regularRoutine :
  case noReturnRoutine : # ok
  case interruptRoutine :
    error self.mInstructionLocation:"an interrupt routine does not accept computed bra instruction"
  end
#---
  [self.mSizeExpression eval !inRegisterTable !inConstantMap ?let @sint64 size !?ioUsedRegisters]
  if size < 2 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be greater or equal to 2"
  elsif size > 128 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be lower or equal to 128"
  elsif [size uint] != [self.mTargetLabels count] then
    error self.mInstructionLocation:"the routine name list length (" + [[self.mTargetLabels count] string] + ") should be equal to the computed range (" + [size string] + ")"
  end
#--- Build block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18ComputedBraTerminator {
      !self.mInstructionLocation
      !self.mTargetLabels
      !self.mUsesRelativeCall}
    !@uint.max
    !0
    }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- No following code
  ioBlockLabel = ["" nowhere]
}

#----------------------------------------------------*

override method @pic18Instruction_computed_retlw analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  switch inRoutineKind
  case regularRoutine : # ok
  case noReturnRoutine :
    error self.mInstructionLocation:"a \"noreturn\" routine does not accept computed retlw instruction"
  case interruptRoutine :
    error self.mInstructionLocation:"an interrupt routine does not accept computed retlw instruction"
  end
#---
  [self.mSizeExpression eval !inRegisterTable !inConstantMap ?let @sint64 size !?ioUsedRegisters]
  if size < 2 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be greater or equal to 2"
  elsif size > 128 then
    error self.mInstructionLocation:"the computed range (" + [size string] + ") should be lower or equal to 128"
  elsif [size uint] != [self.mImmediateExpressionList count] then
    error self.mInstructionLocation:"the constant list length (" + [[self.mImmediateExpressionList count] string] + ") should be equal to the computed range (" + [size string] + ")"
  end
#--- 
  var literalValues =@uintlist ()
  for (mExpression *) in  self.mImmediateExpressionList do(idx)
    [mExpression eval !inRegisterTable !inConstantMap ?let @sint64 v !?ioUsedRegisters]
    if (v > 255) | (v < -128) then
      error self.mInstructionLocation:"immediate value with idx " + [idx string] + " is evaluated as " + [v string] + " (should be <= 255)"
    end
    literalValues += ![v & 0x000000FF uint]
  end
#--- Build block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18ComputedRETLWTerminator {
      !self.mInstructionLocation
      !literalValues
      !self.mUsesRelativeCall}
    !@uint.max
    !0
    }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- No following code
  ioBlockLabel = ["" nowhere]
}

#----------------------------------------------------*

override method @pic18Instruction_JUMPCC analyze
  ?let @uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @pic18_dataMap unused inDataMap
  ?let @constantMap unused  inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  [inRoutineMap searchKey !self.mTargetLabel ?let @bool isNoReturn ?let @uint requiredBank ?* ?*]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "is not defined"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if not isNoReturn then
    error self.mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction"
  end
#---
  let @conditionalBranchMode mode
  if self.mIsBcc then
    mode = @conditionalBranchMode. native
  else
    mode = @conditionalBranchMode. ipicBRA
  end
#--- Create the continuation label
  let label0 = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
#--- Build block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18ConditionalJumpTerminator {
      !self.mInstructionLocation
      !self.mConditionalBranch
      !self.mTargetLabel
      !mode
      !label0
      !mode}
    !@uint.max
    !0
    }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- Set label for following block
  ioBlockLabel = label0
}

#----------------------------------------------------*

override method @pic18Instruction_IF_BitTest analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Analyze condition
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?let @bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let @uint bitNumber
  ]
#--- Analyze embedded instruction
  var @uint currentBank = ioCurrentBank
  [self.mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ?let @ipic18SequentialInstruction embeddedInstruction
  ]
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error self.mEmbeddedInstruction.mInstructionLocation : "this instruction does not preserve bank setting"
  end
#--- Generate instruction
  ioGeneratedInstructionList += !@ipic18_skip_instruction_BitTestSkip {
    !self.mInstructionLocation
    !embeddedInstruction
    !self.mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_IF_FA_SEMI_COLON analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  let @ipic18_compare_register_instruction_base_code baseCode
  switch self.mOpCode
    case CPFSEQ : baseCode = @ipic18_compare_register_instruction_base_code. CPFSEQ
    case CPFSGT : baseCode = @ipic18_compare_register_instruction_base_code. CPFSGT
    case CPFSLT : baseCode = @ipic18_compare_register_instruction_base_code. CPFSLT
    case TSTFSZ : baseCode = @ipic18_compare_register_instruction_base_code. TSTFSZ
  end
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Analyze embedded instruction
  var @uint currentBank = ioCurrentBank
  [self.mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ?let @ipic18SequentialInstruction embeddedInstruction
  ]
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error self.mEmbeddedInstruction.mInstructionLocation : "this instruction does not preserve bank setting"
  end
#--- Generate instruction
  ioGeneratedInstructionList += !@ipic18_skip_instruction_compare_register {
    !self.mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_IF_IncDec analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap unused inMacroMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
#---
  let @skip_instruction_FDA_base_code baseCode
  if self.mIncrement & self.mSkipIfZero then
    baseCode = @skip_instruction_FDA_base_code. INCFSZ
  elsif self.mIncrement & not self.mSkipIfZero then
    baseCode = @skip_instruction_FDA_base_code. INFSNZ
  elsif (not self.mIncrement) & self.mSkipIfZero then
    baseCode = @skip_instruction_FDA_base_code. DECFSZ
  else
    baseCode = @skip_instruction_FDA_base_code. DCFSNZ
  end
#---
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Analyze embedded instruction
  var @uint currentBank = ioCurrentBank
  [self.mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ?let @ipic18SequentialInstruction embeddedInstruction
  ]
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error self.mEmbeddedInstruction.mInstructionLocation : "this instruction does not preserve bank setting"
  end
#--- Generate instruction
  ioGeneratedInstructionList += !@ipic18_skip_instruction_FDA {
    !self.mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
    !self.m_W_isDestination
  }
  !@uint.max
  !0
}

#----------------------------------------------------*

override method @pic18Instruction_structured_if analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Save bank settings
  var @uint elseBranchFinalBank = ioCurrentBank
  var @uint thenBranchFinalBank = ioCurrentBank
#--- Labels
  let conditionTrueLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
  let conditionFalseLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
  let exitLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
#---- Analyze condition
  [self.mIfCondition analyzeCondition
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !conditionFalseLabel
    !?ioUsedRegisters
    ?let @ipic18AbstractBlockTerminator testTerminator
  ]
#--- Save current block block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !testTerminator
    !@uint.max
    !0
  }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- Analyze 'then' instruction list
  ioBlockLabel = conditionTrueLabel
  analyzeInstructionList (
    !self.mThenInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?thenBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  )
  let @bool thenContinuesInSequence = ioBlockLabel.string != ""
  if thenContinuesInSequence then
    ioGeneratedBlockList += !@ipic18Block {
      !@uint. max # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !@ipic18JumpTerminator { !self.mInstructionLocation !exitLabel !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- Build block
  ioBlockLabel = conditionFalseLabel
  analyzeInstructionList (
    !self.mElseInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?elseBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  )
  let @bool elseContinuesInSequence = ioBlockLabel.string != ""
  if elseContinuesInSequence then
    ioGeneratedBlockList += !@ipic18Block {
      !@uint. max # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !@ipic18JumpTerminator { !self.mInstructionLocation !exitLabel !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#---
  if elseBranchFinalBank == thenBranchFinalBank then
    ioCurrentBank = elseBranchFinalBank
  else
    error self.mEndOfElsePartLocation:"This branch does not leave bank selection value as the first one does"
    elseBranchFinalBank = @uint. max # No available value for BSR
  end
#---
  if thenContinuesInSequence | elseContinuesInSequence then
    ioBlockLabel = exitLabel
  else
    ioBlockLabel = ["" nowhere]
  end
}

#----------------------------------------------------*

override method @pic18Instruction_macro analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
{
  [inMacroMap searchKey !self.mMacroName ?let constantNameList ?let instructionList]
  if [self.mExpressionList count] != [constantNameList count] then
    error self.mInstructionLocation
    : [[constantNameList count] string] + " argument(s) required"
  end
  var @constantMap constantMap = inConstantMap
  for (mExpression *) in self.mExpressionList, (constantName) in constantNameList do
    [mExpression eval !inRegisterTable !constantMap ?let @sint64 expressionValue !?ioUsedRegisters]
    [!?constantMap insertKey !constantName !expressionValue]
  end
#--- Analyze instruction list
  analyzeInstructionList (
    !instructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !constantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  )
}

#------------------------------------------------------------------------------*

override method @pic18Instruction_do_while analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Labels
  let startLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
  ioLocalLabelIndex += 1
#--- Save current block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18JumpTerminator { !self.mInstructionLocation !startLabel !@jumpInstructionKind. ipicRelative}
    !@uint.max
    !0
  }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- Repeated instruction list
  ioBlockLabel = startLabel
  var @uint repeatedBranchFinalBank = ioCurrentBank
  analyzeInstructionList (
    !self.mRepeatedInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !inMacroMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?repeatedBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  )
  let @bool repeatedInstructionsContinuesInSequence = ioBlockLabel.string != ""
  if ioCurrentBank != repeatedBranchFinalBank then
    error self.mEndOfRepeatedInstructionList:"This branch does not leave bank selection value unchanged"
  end
  if not repeatedInstructionsContinuesInSequence then
    error self.mEndOfRepeatedInstructionList:"This branch makes the next code unreachable"
  end
#--- While branches
  for (mCondition mInstructionList mEndOfPartLocation) in  self.mWhilePartList do
  #--- Labels
    let conditionTrueLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
    ioLocalLabelIndex += 1
   let conditionFalseLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mInstructionLocation} 
   ioLocalLabelIndex += 1
  #---- Analyze condition
    [mCondition analyzeCondition
      !inAccessBankSplitOffset
      !ioCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedBlockList
      !conditionTrueLabel
      !conditionFalseLabel
      !?ioUsedRegisters
      ?let @ipic18AbstractBlockTerminator testTerminator
    ]
    ioGeneratedBlockList += !@ipic18Block {
      !@uint. max # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !testTerminator
      !@uint.max
      !0
    }
    ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
    ioBlockLabel = conditionTrueLabel
    var @uint branchFinalBank = ioCurrentBank
    analyzeInstructionList (
      !mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !inMacroMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?branchFinalBank
      !inShouldPreserveBSR
      !inRoutineKind
      !?ioUsedRegisters
    )
    if ioCurrentBank != branchFinalBank then
      error mEndOfPartLocation:"This branch does not leave bank selection value unchanged"
    end
    if ioBlockLabel.string == "" then
      error mEndOfPartLocation:"This branch makes the next code unreachable"
    end
    ioGeneratedBlockList += !@ipic18Block {
      !@uint. max # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !@ipic18JumpTerminator { !self.mInstructionLocation !startLabel !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
    ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
    ioBlockLabel = conditionFalseLabel
  end
}

#----------------------------------------------------*

#!Block instruction

#----------------------------------------------------*

map @blockInstructionBlockMap {
  public var @pic18InstructionList mInstructionList
  public var @abstractBlockTerminationForBlockInstruction mBlockTerminaisonForBlockInstruction
  public var @location mEndOfBlock
  insert insertKey error message "the '%K' block is already declared"
  search searchKey error message "the '%K' block is not declared"
}

#----------------------------------------------------*

map @blockInitialBankSelectionMap {
  public var @uint mInitialBankSelection
  public var @string mSourceBlock
  insert insertKey error message "the '%K' block is already declared (internal error)"
  search searchKey error message "the '%K' block is not declared (internal error)"
}

#----------------------------------------------------*

abstract method @abstractBlockTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ?let @blockInstructionBlockMap inBlockMap
  ?let @string inCurrentBlockName
  ?let @uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration

#----------------------------------------------------*

override method @exitBlockTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset unused ioVisitedBlockSet
  ?let @blockInstructionBlockMap unused inBlockMap
  ?let @string inCurrentBlockName
  ?let @uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool unused ioContinueAccessibilityExploration {
  ioContinuesInSequence = true
  if [ioBlockInitialBankSelectionMap hasKey !"-"] then
    [ioBlockInitialBankSelectionMap searchKey !["-" nowhere] ?let @uint otherInitialBlockSetting ?let @string otherBlockName]
    if otherInitialBlockSetting != inInitialBlockSetting then
      error self.mLocation: "this block exits from block instruction and sets bank selection to "
      + if inInitialBlockSetting == @uint. max then "no bank" else [inInitialBlockSetting string] end
      + ", '" + otherBlockName + "' block also exits, but sets bank selection to "
      + if otherInitialBlockSetting == @uint. max then "no bank" else [otherInitialBlockSetting string] end
      + "; theses two settings should be the same"
    end
  else
    [!?ioBlockInitialBankSelectionMap insertKey !["-" nowhere] !inInitialBlockSetting !inCurrentBlockName]
  end
}

#----------------------------------------------------*

override method @gotoTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ?let @blockInstructionBlockMap inBlockMap
  ?let @string inCurrentBlockName
  ?let @uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool unused ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration {
  if not [ioVisitedBlockSet hasKey !self.mNextBlock.string] then
    ioVisitedBlockSet += !self.mNextBlock.string
    ioContinueAccessibilityExploration = true
    [inBlockMap searchKey !self.mNextBlock ?* ?* ?*]
    if [ioBlockInitialBankSelectionMap hasKey !self.mNextBlock.string] then
      [ioBlockInitialBankSelectionMap searchKey !self.mNextBlock ?let @uint otherInitialBlockSetting ?let @string otherBlockName]
      if otherInitialBlockSetting != inInitialBlockSetting then
        error self.mNextBlock: "this block goes to '" + self.mNextBlock + "' block and sets bank selection to "
        + if inInitialBlockSetting == @uint. max then "no bank" else [inInitialBlockSetting string] end
        + ", '" + otherBlockName + "' block goes to the same block, but sets bank selection to "
        + if otherInitialBlockSetting == @uint. max then "no bank" else [otherInitialBlockSetting string] end
        + "; theses two settings should be the same"
      end
    else
      [!?ioBlockInitialBankSelectionMap insertKey !self.mNextBlock !inInitialBlockSetting !inCurrentBlockName]
    end
  end
}

#----------------------------------------------------*

override method @testTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ?let @blockInstructionBlockMap inBlockMap
  ?let @string inCurrentBlockName
  ?let @uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration {
  [self.mTrueTermination addVisitedBlocks
    !?ioVisitedBlockSet 
    !inBlockMap 
    !inCurrentBlockName 
    !inInitialBlockSetting 
    !?ioBlockInitialBankSelectionMap 
    !?ioContinuesInSequence 
    !?ioContinueAccessibilityExploration
  ]
  [self.mFalseTermination addVisitedBlocks
    !?ioVisitedBlockSet
    !inBlockMap
    !inCurrentBlockName
    !inInitialBlockSetting
    !?ioBlockInitialBankSelectionMap
    !?ioContinuesInSequence
    !?ioContinueAccessibilityExploration
  ]
}

#----------------------------------------------------*

abstract method @abstractBlockTerminationForBlockInstruction generateBlock
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@stringset ioUsedRegisters
  ?let @string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator

#----------------------------------------------------*

override method @gotoTerminationForBlockInstruction generateBlock
  ?let @uint unused inAccessBankSplitOffset
  ?let @uint unused inCurrentBank
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?!@stringset unused ioUsedRegisters
  ?let @string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator {
  outTerminator = @ipic18JumpTerminator {
    !self.mNextBlock.location
    !@lstring { !inLabelForBlock + self.mNextBlock !self.mNextBlock.location}
    !@jumpInstructionKind. ipicRelative}
}

#----------------------------------------------------*

override method @exitBlockTerminationForBlockInstruction generateBlock
  ?let @uint unused inAccessBankSplitOffset
  ?let @uint unused inCurrentBank
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?!@stringset unused ioUsedRegisters
  ?let @string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator
{
  outTerminator = @ipic18JumpTerminator {
    !self.mLocation
    !@lstring { !inLabelForBlock + "_exit" !self.mLocation}
    !@jumpInstructionKind. ipicRelative
  }
}

#----------------------------------------------------*

override method @testTerminationForBlockInstruction generateBlock
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@stringset ioUsedRegisters
  ?let @string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator {
  let conditionTrueLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mLocation} 
  ioLocalLabelIndex += 1
  let conditionFalseLabel = @lstring { !".L" + [ioLocalLabelIndex string] !self.mLocation} 
  ioLocalLabelIndex += 1
#--- Generate condition
  [self.mCondition analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !conditionFalseLabel
    !?ioUsedRegisters
    ?outTerminator
  ]
#--- Generation true condition block
  [self.mTrueTermination generateBlock
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !?ioUsedRegisters
    !inLabelForBlock
    ?let @ipic18AbstractBlockTerminator trueTerminator
  ]
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !conditionTrueLabel
    !@ipic18SequentialInstructionList ()
    !trueTerminator
    !@uint.max
    !0
  }
#--- Generation false condition block
  [self.mFalseTermination generateBlock
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !?ioUsedRegisters
    !inLabelForBlock
    ?let @ipic18AbstractBlockTerminator falseTerminator
  ]
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !conditionFalseLabel
    !@ipic18SequentialInstructionList ()
    !falseTerminator
    !@uint.max
    !0
  }
}

#----------------------------------------------------*

override method @pic18Instruction_block analyze
  ?let @uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
{
#----------------- Block labels prefix
  let @string labelForBlock = ".L" + [ioLocalLabelIndex string] + "_" 
  ioLocalLabelIndex += 1
#---------------- Save current block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !@ipic18JumpTerminator {
      !self.mStartBlockName.location
      !@lstring { !labelForBlock + self.mStartBlockName !self.mStartBlockName.location}
      !@jumpInstructionKind. ipicRelative}
    !@uint.max
    !0
    }
  ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
#--- Compute block map
  var blockMap =@blockInstructionBlockMap ()
  for (mBlockName mInstructionList mBlockTerminaisonForBlockInstruction mEndOfBlock) in  self.mBlockList do
    [!?blockMap insertKey !mBlockName !mInstructionList !mBlockTerminaisonForBlockInstruction !mEndOfBlock]
  end
#--- Check start block is declared
  [blockMap searchKey !self.mStartBlockName ?* ?* ?*]
  var blockInitialBankSelectionMap =@blockInitialBankSelectionMap ()
  [!?blockInitialBankSelectionMap insertKey !self.mStartBlockName !ioCurrentBank !""]
#--- Compute block accessiblity
  var accessibleBlockSet =@stringset.setWithString{ !self.mStartBlockName.string}
  var handledBlockSet =@stringset ()
  var @bool continueAccessibilityExploration = true
  var @bool continuesInSequence = false
  loop( [self.mBlockList count] + 1) while continueAccessibilityExploration do
    continueAccessibilityExploration = false
    for currentBlockName in accessibleBlockSet - handledBlockSet do
      handledBlockSet += !currentBlockName
      [blockMap searchKey
        ![currentBlockName nowhere]
        ?let @pic18InstructionList instructionList
        ?let @abstractBlockTerminationForBlockInstruction blockTermination
        ?let @location endOfBlock
      ]
    #--- Generate code
      [blockInitialBankSelectionMap searchKey ![currentBlockName nowhere] ?var @uint currentBank ?*]
      ioBlockLabel = @lstring { !labelForBlock + currentBlockName ![blockMap locationForKey !currentBlockName]}
      analyzeInstructionList (
        !instructionList
        !?ioGeneratedBlockList
        !inAccessBankSplitOffset
        !inRoutineMap
        !inRegisterTable
        !inDataMap
        !inConstantMap
        !inMacroMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioBlockLabel
        !?ioListFileContents
        !?currentBank
        !inShouldPreserveBSR
        !inRoutineKind
        !?ioUsedRegisters
      )
      [blockTermination generateBlock
        !inAccessBankSplitOffset
        !currentBank
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedBlockList
        !?ioUsedRegisters
        !labelForBlock
        ?let @ipic18AbstractBlockTerminator terminator
      ]
      if ioBlockLabel.string == "" then
        error endOfBlock : "execution will not reach the end of the block, but endless block is not allowed"
      end
      ioGeneratedBlockList += !@ipic18Block {
        !@uint. max # relocatable
        !ioBlockLabel
        !ioGeneratedInstructionList
        !terminator
        !@uint.max
        !0
      }
      ioGeneratedInstructionList = @ipic18SequentialInstructionList ()
    #---
      [blockTermination addVisitedBlocks !?accessibleBlockSet !blockMap !currentBlockName !currentBank !?blockInitialBankSelectionMap !?continuesInSequence !?continueAccessibilityExploration]
    end
  end
#--- Useless blocks ?
  for (mBlockName * * *) in  self.mBlockList do
    if not [accessibleBlockSet hasKey !mBlockName.string] then
      warning mBlockName:"this block is not accessible from '" + self.mStartBlockName + "' block"
    end
  end
#---
  if continuesInSequence then
    ioBlockLabel = @lstring { !labelForBlock + "_exit" !self.mStartBlockName.location}
    [blockInitialBankSelectionMap searchKey !["-" nowhere] ?ioCurrentBank ?*]
  else
    ioBlockLabel = ["" nowhere]
  end
}

#----------------------------------------------------------------------------*

#!analyze condition

#----------------------------------------------------*

abstract method @pic18ConditionExpression analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator

#----------------------------------------------------*

override method @pic18BccInStructuredCondition analyzeCondition
  ?let @uint unused inAccessBankSplitOffset
  ?let @uint unused inCurrentBank
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused  inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset unused ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
#--- Save terminator of current block
  outCurrentBlockTerminator = @ipic18ConditionalJumpTerminator {
    !self.mConditionLocation
    !self.mCondition
    !inConditionTrueLabel
    !@conditionalBranchMode. native
    !inConditionFalseLabel
    !@conditionalBranchMode. native}
}

#----------------------------------------------------*

override method @pic18RegisterComparisonCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Handle comparison
  let @ipic18RegisterComparison ipicComparison
  let @bool complementaryBranch
  switch self.mComparison
  case equal :
    ipicComparison = @ipic18RegisterComparison. registerEqualsToW
    complementaryBranch = false
  case greater :
    ipicComparison = @ipic18RegisterComparison. registerGreaterThanW
    complementaryBranch = false
  case lower :
    ipicComparison = @ipic18RegisterComparison. registerLowerThanW
    complementaryBranch = false
  case greaterOrEqual :
    ipicComparison = @ipic18RegisterComparison. registerLowerThanW
    complementaryBranch = true
  case lowerOrEqual :
    ipicComparison = @ipic18RegisterComparison. registerGreaterThanW
    complementaryBranch = true
  case notEqual :
    ipicComparison = @ipic18RegisterComparison. registerEqualsToW
    complementaryBranch = true
  end
#--- Save terminator of current block
  let @location location = self.mRegisterExpression.mRegisterName.location
  if complementaryBranch then
    outCurrentBlockTerminator = @pic18RegisterComparisonTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription
      !ipicComparison}
  else
    outCurrentBlockTerminator = @pic18RegisterComparisonTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription
      !ipicComparison}
  end
}

#----------------------------------------------------*

override method @pic18IncDecRegisterInCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Save terminator of current block
  let @location location = self.mRegisterExpression.mRegisterName.location
  if self.mBranchIfZero then
    outCurrentBlockTerminator = @ipic18IncDecRegisterTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription
      !self.mIncrement
      !self.m_W_isDestination}
  else
    outCurrentBlockTerminator = @ipic18IncDecRegisterTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription
      !self.mIncrement
      !self.m_W_isDestination}
  end
}

#----------------------------------------------------*

override method @pic18RegisterTestCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Save terminator of current block
  let @location location = self.mRegisterExpression.mRegisterName.location
  if self.mBranchIfZero then
    outCurrentBlockTerminator = @pic18TestRegisterTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription}
  else
    outCurrentBlockTerminator = @pic18TestRegisterTerminator {
      !location
      !@ipic18JumpTerminator { !location !inConditionFalseLabel !@jumpInstructionKind. ipicRelative}
      !@ipic18JumpTerminator { !location !inConditionTrueLabel !@jumpInstructionKind. ipicRelative}
      !IPICregisterDescription}
  end
}

#----------------------------------------------------*

override method @pic18BitTestInStructuredCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
  [self.mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression IPICregisterDescription
    ?let @bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let @uint bitNumber
  ]
#--- Save terminator of current block
  let @location location = self.mRegisterExpression.mRegisterName.location
  outCurrentBlockTerminator = @pic18BitTestTerminator {
    !location
    !@ipic18JumpTerminator {!location !inConditionFalseLabel !@jumpInstructionKind.ipicRelative}
    !@ipic18JumpTerminator {!location !inConditionTrueLabel !@jumpInstructionKind.ipicRelative}
    !IPICregisterDescription
    !bitNumber
  }
}

#----------------------------------------------------*

override method @pic18NegateCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
  [self.mCondition analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionFalseLabel
    !inConditionTrueLabel
    !?ioUsedRegisters
    ?outCurrentBlockTerminator
  ]
}

#----------------------------------------------------*

override method @pic18AndCondition analyzeCondition
  ?let @uint inAccessBankSplitOffset
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @lstring inConditionTrueLabel
  ?let @lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator {
#--- Create an intermdiate label for handling true condition of left expression
  let conditionTrueLabel = @lstring { !".L" + [ioLocalLabelIndex string] !inConditionTrueLabel.location} 
  ioLocalLabelIndex += 1
#--- Left expression
  [self.mLeftExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !inConditionFalseLabel
    !?ioUsedRegisters
    ?outCurrentBlockTerminator
  ]
#--- Right expression
  [self.mRightExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionTrueLabel
    !inConditionFalseLabel
    !?ioUsedRegisters
    ?let @ipic18AbstractBlockTerminator secondTestBlockTerminator
  ]
#--- Create a new block
  ioGeneratedBlockList += !@ipic18Block {
    !@uint. max # relocatable
    !conditionTrueLabel
    !@ipic18SequentialInstructionList ()
    !secondTestBlockTerminator
    !@uint.max
    !0
  }
}

#----------------------------------------------------------------------------*

#! Routines

#----------------------------------------------------------------------------*

proc analyzeInstructionList
  ?let @pic18InstructionList inInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ?let @uint inAccessBankSplitOffset
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @pic18_dataMap inDataMap
  ?let @constantMap inConstantMap
  ?let @pic18MacroMap inMacroMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBSR
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  for (mInstruction) in  inInstructionList do
    if ioBlockLabel.string == "" then
      error mInstruction.mInstructionLocation : "Unreachable code"
      ioBlockLabel = ["?" nowhere]
    end
    [mInstruction analyze
      !inAccessBankSplitOffset
      !?ioGeneratedBlockList
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !inMacroMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?ioCurrentBank
      !inShouldPreserveBSR
      !inRoutineKind
      !?ioUsedRegisters
    ]
  end
}

#----------------------------------------------------------------------------*
#                                                                            *
#               A N A L Y Z E    D A T A    S E C T I O N                    *
#                                                                            *
#----------------------------------------------------------------------------*

proc pic18_analyze_data_sections
  ?let @dataList inDataDefinitionList
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@string ioListFileContents
  !@pic18_dataMap outDataMap
  ?!@constantMap ioConstantMap
  ?!@stringset ioUsedRegisters
{
  outDataMap = @()
  for (name valueList isData8) in  inDataDefinitionList
  before
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
    ioListFileContents += "*" + ["DATA DECLARATION" stringByLeftAndRightPadding !117 !' '] + "*\n"
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  do
    var @uintlist data = @()
    if isData8 then
      if ([valueList count] & 1) != 0 then
        error name : "the data8 byte count should be even"
      end
      ioListFileContents += "Data8 '" + name + "', " + ([valueList count] / 2)
        + " words (" + [valueList count] + " bytes).\n" 
      [!?ioConstantMap insertKey ! @{ !name.string + "_BYTE_COUNT" !name} ![[valueList count] sint64]]
      var @sint byte = 0
      for (expression errorLocation) in  valueList do (idx)
        [expression eval !inRegisterTable !inConstantMap ?let @sint64 value !?ioUsedRegisters]
        if value < 0 then
          error errorLocation: "data8 value is " + value + " (negative)"
        elsif value > 255 then
          error errorLocation: "data8 value is " + value + " (greater than 255"
        elsif (idx & 1) == 0 then
          byte = value
        else
          data += ![(value << 8) | byte uint]
        end
      end
    else
      ioListFileContents += "Data16 '" + name + "', " + [valueList count]
        + " words (" + [valueList count] * 2 + " bytes).\n" 
      [!?ioConstantMap insertKey ! @{ !name.string + "_BYTE_COUNT" !name} ![[valueList count] * 2 sint64]]
      for (mExpression mErrorLocation) in  valueList do
        [mExpression eval !inRegisterTable !inConstantMap ?let @sint64 value !?ioUsedRegisters]
        if value < 0 then
          error mErrorLocation: "data16 value is " + value + " (negative)"
        elsif value > 65535 then
          error mErrorLocation: "data16 value is " + value + " (greater than 2**16-1)"
        else
          data += ![value uint]
        end
      end
    end
    [!?outDataMap insertKey !name !data !isData8]
  end
}

#----------------------------------------------------------------------------*

proc build_ipic18_block_representation_list
  ?let @string inSourceFileName
  ?let @sint64 inROMSize
  ?let @pic18MacroMap inMacroMap
  ?let @routineDeclarationList inBootloaderRoutineDeclarationListForBootloaderImplementation
  ?let @routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ?let @luint inBootloaderReservedROMsize
  ?let @routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ?let @routineDeclarationList inUserRoutineDeclarationListForUserProgramImplementation
  ?let @uint inAccessBankSplitOffset
  ?let @registerTable inRegisterTable
  ?let @declaredByteMap inDeclaredByteMap
  ?let @pic18RoutineDefinitionList inRoutineDefinitionList
  ?let @programKind inProgramKind
  ?let @constantMap inConstantMap
  ?let @stringset inUsedRegisters
  ?let @dataList inDataList
  ?let @pic18InterruptDefinitionList inInterruptDefinitionList
  ?let @lstringlist inUnusedRegisterList
  ?let @ramBankTable inRamBank
  ?let @bool inHasHighInterrupt
  ?let @bool inHasLowInterrupt
  ?let @string inProcessorName
  ?let @registerTable inPredefinedRegisters
  ?let @actualConfigurationMap inActualConfigurationMap
  ?let @location inEndOfProgram
  ?!@string ioListFileContents
{
  var constantMap = inConstantMap
  var usedRegisters = inUsedRegisters
#-------------------------------- Build routine map
  var routineMap =@routineMap ()
  for (mRoutineName mRequiredBank mReturnedBank mPreservesBank mIsNoReturn) in  inUserRoutineDeclarationListForBootloaderImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn !mRequiredBank.uint !mReturnedBank.uint !mPreservesBank]
  end
  for (mRoutineName mRequiredBank mReturnedBank mPreservesBank mIsNoReturn) in  inBootloaderRoutineDeclarationListForUserProgramImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn !mRequiredBank.uint !mReturnedBank.uint !mPreservesBank]
  end
  for (mRoutineName mRequiredBank mReturnedBank mPreservesBank mIsNoReturn * *) in  inRoutineDefinitionList do
    if (mRequiredBank.uint != @uint. max) & (mRequiredBank.uint > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15"
    end
    if (mReturnedBank.uint != @uint. max) & (mReturnedBank.uint > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15"
    end
    [!?routineMap insertKey !mRoutineName !mIsNoReturn !mRequiredBank.uint !mReturnedBank.uint !mPreservesBank]
  end
#-------------------------------- Build constant map
#  var constantMap = @constantMap ()
##--- Add "ROM_SIZE" and "RAM_SIZE" constants
#  [!?constantMap insertKey !@lstring. new { !"ROM_SIZE" !@location.here} !inROMSize]
#  [!?constantMap insertKey !@lstring. new { !"RAM_SIZE" !@location.here} !inRAMSize]
##--- Add "BOOTLOADER_RESERVED_SIZE" constant
#  if inProgramKind != @programKind. regularProgram then
#    var bootloaderSizeString =@lstring.new{ !"BOOTLOADER_RESERVED_SIZE" !@location.here}
#    [!?constantMap insertKey !bootloaderSizeString ![[inBootloaderReservedROMsize uint] sint64]]
#  end
##--- Add declared constants
#  var usedRegisters = @stringset ()
#  for () in  inConstantDefinitionList do
#    [mExpression eval !inRegisterTable !constantMap ?let @sint64 result !?usedRegisters]
#    if [inRegisterTable hasKey ![mConstantName string]] then
#      error mConstantName: "'" + mConstantName + "' is already declared as ram register or special register"
#    else
#      [!?constantMap insertKey !mConstantName !result]
#    end
#  end
#-------------------------------- Analyze Data
  pic18_analyze_data_sections (
    !inDataList
    !inRegisterTable
    !constantMap
    !?ioListFileContents
    ?let @pic18_dataMap dataMap
    !?constantMap
    !?usedRegisters
  )
#-------------------------------- Print constant map
  print_constant_definition (
    !constantMap
    !?ioListFileContents
  )
#-------------------------------- Check the "main" routine is declared
  if inProgramKind != @programKind. userProgram then
    if [routineMap hasKey !"main"] then
      [routineMap searchKey !@lstring { !"main" !@location.here} ?let isNoReturn ?let requiredBank ?* ?*]
      if not isNoReturn then
        error @location.here :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main requiresbank 0\""
      end
      if requiredBank != 0 then
        error @location.here :"the \"main\" should be declared with \"requiresbank 0\" qualifier: \"noreturn main requiresbank 0\""
      end
    else
      error inEndOfProgram : "the program should declare the \"main\" routine"
    end
  end
#-------------------------------- Generate bootloader entry points for user program
  var generatedBlockList =@ipic18BlockList ()
  var @uint entryPoint = 0x04
  for (mRoutineName * * * *) in  inBootloaderRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += !@ipic18Block {
      !entryPoint
      !mRoutineName
      !@ipic18SequentialInstructionList ()
      !@ipic18ReturnTerminator { !@location. nowhere}
      !@uint.max
      !0
    }
    entryPoint = entryPoint + 4
    if entryPoint == 0x08 then
      entryPoint = 0x0C
    elsif entryPoint == 0x18 then
      entryPoint = 0x1C
    end
  end
#-------------------------------- Generate user program entry points for user program
  entryPoint = inBootloaderReservedROMsize.uint
  for (mRoutineName * * * *) in  inUserRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += !@ipic18Block {
      !entryPoint
      !["_entry_user_" + [entryPoint xString] nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !mRoutineName.location !mRoutineName !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
    entryPoint = entryPoint + 4
  end
#-------------------------------- At zero, generate 'jump main' block
  if inProgramKind != @programKind. userProgram then
    generatedBlockList += !@ipic18Block {
      !0
      ![".START" nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !@location. nowhere !["main" nowhere] !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
#-------------------------------- At 0x04, generate the first bootloader entry point (if any)
  var @routineDeclarationList tempBootloaderRoutineDeclarationList = inBootloaderRoutineDeclarationListForBootloaderImplementation
  if [tempBootloaderRoutineDeclarationList count] > 0 then
    [!?tempBootloaderRoutineDeclarationList popFirst ?let @lstring routineName ?* ?* ?* ?*]
    generatedBlockList += !@ipic18Block {
      !0x04
      !["_entry_bootloader_04" nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !routineName.location !routineName !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
#-------------------------------- At 0x08, generate 'bra _high_interrupt' instruction, if fast interrupt is defined
  if inHasHighInterrupt then
    generatedBlockList += !@ipic18Block {
      !0x08
      ![".HIGH_INTERRUPT" nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !@location. nowhere !["_high_interrupt" nowhere] !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
#-------------------------------- At 0x0C, 0x10, 0x14, generate the bootloader entry points (if they exists)
  entryPoint = 0x0C
  loop( [tempBootloaderRoutineDeclarationList count])
  while ([tempBootloaderRoutineDeclarationList count] > 0) & (entryPoint < 0x18) 
  do
    [!?tempBootloaderRoutineDeclarationList popFirst ?let @lstring routineName ?* ?* ?* ?*]
    generatedBlockList += !@ipic18Block {
      !entryPoint
      !["_entry_bootloader_" + [entryPoint xString] nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !routineName.location !routineName !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
    entryPoint = entryPoint + 0x4
  end
#-------------------------------- Generate JUMP to low interrupt (if any)
  if inHasLowInterrupt then
    generatedBlockList += !@ipic18Block {
      !0x18
      ![".LOW_INTERRUPT" nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !@location. nowhere !["_low_interrupt" nowhere] !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
  end
#-------------------------------- Generate entry points for remaining bootloader routines
  entryPoint = 0x1C
  for (mRoutineName * * * *) in  tempBootloaderRoutineDeclarationList do
    generatedBlockList += !@ipic18Block {
      !entryPoint
      !["_entry_bootloader_" + [entryPoint xString] nowhere]
      !@ipic18SequentialInstructionList ()
      !@ipic18JumpTerminator { !mRoutineName.location !mRoutineName !@jumpInstructionKind. ipicRelative}
      !@uint.max
      !0
    }
    entryPoint = entryPoint + 0x4
  end
#  drop tempBootloaderRoutineDeclarationList
#-------------------------------- Generate low interrupt routine (if any)
  var @uint localLabelIndex = 0
  if inHasLowInterrupt then
    for (mInterruptName mFastReturn mInstructionList mEndOfInterruptLocation) in  inInterruptDefinitionList do
      if mInterruptName.string == "low" then
        var currentBank =@uint.max # No bank
        var generatedInstructionList =@ipic18SequentialInstructionList ()
        var currentBlockLabel = @lstring { !"_low_interrupt" !mInterruptName.location}
        analyzeInstructionList (
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !inMacroMap
          !?localLabelIndex
          !?generatedInstructionList
          !?currentBlockLabel
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          !@routineKind. interruptRoutine
          !?usedRegisters
        )
        if currentBlockLabel.string == "" then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine"
        end
      #--- Enter last block
        generatedBlockList += !@ipic18Block {
          !@uint. max # relocatable
          !currentBlockLabel
          !generatedInstructionList
          !@ipic18RetfieTerminator { !mInterruptName.location !mFastReturn}
          !@uint.max
          !0
        }
      end
    end
  end
#-------------------------------- Generate high interrupt routine (if any)
  if inHasHighInterrupt then
    for (mInterruptName mFastReturn mInstructionList mEndOfInterruptLocation) in  inInterruptDefinitionList do
      if mInterruptName.string == "high" then
        var currentBank =@uint.max # No bank
        var generatedInstructionList =@ipic18SequentialInstructionList ()
        var currentBlockLabel = @lstring { !"_high_interrupt" !mInterruptName.location}
        analyzeInstructionList (
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !inMacroMap
          !?localLabelIndex
          !?generatedInstructionList
          !?currentBlockLabel
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          !@routineKind. interruptRoutine
          !?usedRegisters
        )
        if currentBlockLabel.string == "" then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine"
        end
      #--- Enter last block
        generatedBlockList += !@ipic18Block {
          !@uint. max # relocatable
          !currentBlockLabel
          !generatedInstructionList
          !@ipic18RetfieTerminator { !mInterruptName.location !true}
          !@uint.max
          !0
        }
      end
    end
  end
#-------------------------------- Generate routines
  for (mRoutineName mRequiredBank mReturnedBank mPreservesBank mIsNoReturn mInstructionList *) in  inRoutineDefinitionList do
    var @uint currentBank = mRequiredBank.uint
    let @routineKind routineKind
    if mIsNoReturn then
      routineKind = @routineKind. noReturnRoutine
    else
      routineKind = @routineKind. regularRoutine
    end
    var generatedInstructionList =@ipic18SequentialInstructionList ()
    var @lstring currentBlockLabel = mRoutineName
    analyzeInstructionList (
      !mInstructionList
      !?generatedBlockList
      !inAccessBankSplitOffset
      !routineMap
      !inRegisterTable
      !dataMap
      !constantMap
      !inMacroMap
      !?localLabelIndex
      !?generatedInstructionList
      !?currentBlockLabel
      !?ioListFileContents
      !?currentBank
      !mPreservesBank
      !routineKind
      !?usedRegisters
    )
    let @bool continuesInSequence = currentBlockLabel.string != ""
    #--- Enter last block
    if continuesInSequence then
      generatedBlockList += !@ipic18Block {
        !@uint. max # relocatable
        !currentBlockLabel
        !generatedInstructionList
        !@ipic18ReturnTerminator { !mRoutineName.location}
        !@uint.max
        !0
      }
    end
  #---
    if (not mIsNoReturn) & (mReturnedBank.uint != @uint. max) & (currentBank != mReturnedBank.uint) then
      error mRoutineName:"execution will not set bank selection to " + mReturnedBank.uint
    end
    if mIsNoReturn & continuesInSequence then
      error mRoutineName:"execution should not reach the end of a \"noreturn\" routine"
    end
  end
#-------------------------------- Add computed goto, rcall, ... utility routines
#  They wil be removed by optimizer if there are useless
#--- Description of register WREG
  let WREGregister = @registerExpression {
    !@lstring {!"WREG" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
   }
  [WREGregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    !constantMap
    !writeAccess:false
    ?let @ipic18_intermediate_registerExpression WREG_IPICregisterDescription
    ?*
    !?usedRegisters
  ]
#--- Description of register TOSL
  let TOSLregister = @registerExpression {
    !@lstring { !"TOSL" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TOSLregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    !constantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression TOSL_IPICregisterDescription
    ?*
    !?usedRegisters
  ]
#--- Description of register TOSH
  let TOSHregister = @registerExpression {
    !@lstring {!"TOSH" !.here} 
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TOSHregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    !constantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression TOSH_IPICregisterDescription
    ?*
    !?usedRegisters
  ]
#--- Description of register TOSU
  let TOSUregister = @registerExpression {
    !@lstring {!"TOSU" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [TOSUregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    !constantMap
    !writeAccess:true
    ?let @ipic18_intermediate_registerExpression TOSU_IPICregisterDescription
    ?*
    !?usedRegisters
  ]
#---
  let @ipic18SequentialInstruction ADDWF_WREG = @ipic18_intermediate_instruction_FDA {
    !@location.here
    !@pic18Instruction_FDA_base_code_AST. ADDWF
    !WREG_IPICregisterDescription
    !true} # ADDWF WREG, W

#--- computed_goto4
  let goto4Block = @ipic18Block {
    !@uint. max # Relocatable
    !["_computed_goto_4" nowhere]
    !@ipic18SequentialInstructionList. listWithValue { !ADDWF_WREG !@uint.max !0}
    !@ipic18JumpTerminator { !@location. nowhere !["_computed_goto_2" nowhere] !@jumpInstructionKind. ipicRelative}
    !@uint.max
    !0
  }
  generatedBlockList += !goto4Block
#--- computed_goto2
  var goto2InstructionList =@ipic18SequentialInstructionList ()
  goto2InstructionList += !ADDWF_WREG !@uint.max !0
  goto2InstructionList += !@ipic18_intermediate_instruction_FDA {
    !@location.here
    !@pic18Instruction_FDA_base_code_AST. ADDWF
    !TOSL_IPICregisterDescription
    !false}!@uint.max !0 # ADDWF TOSL, F
  goto2InstructionList += !@ipic18_intermediate_instruction_literalOperation {
    !@location.here
    !@literal_instruction_opcode. MOVLW
    !0}!@uint.max !0 # MOVLW 0
  goto2InstructionList += !@ipic18_intermediate_instruction_FDA {
    !@location.here
    !@pic18Instruction_FDA_base_code_AST. ADDWFC
    !TOSH_IPICregisterDescription
    !false}!@uint.max !0 # ADDWFC TOSH, F
  goto2InstructionList += !@ipic18_intermediate_instruction_FDA {
    !@location.here
    !@pic18Instruction_FDA_base_code_AST. ADDWFC
    !TOSU_IPICregisterDescription
    !false
    }
    !@uint.max
    !0 # ADDWFC TOSU, F
#--- computed_goto2
  let goto2Block = @ipic18Block {
    !@uint. max # Relocatable
    !["_computed_goto_2" nowhere]
    !goto2InstructionList
    !@ipic18ReturnTerminator { !@location. nowhere}
    !@uint.max
    !0
  }
  generatedBlockList += !goto2Block
#-------------------------------- Generate default user routines
  entryPoint = inBootloaderReservedROMsize.uint
  for (mRoutineName * mReturnedBank * mIsNoReturn) in  inUserRoutineDeclarationListForBootloaderImplementation do
    if mIsNoReturn then
      generatedBlockList += !@ipic18Block {
        !entryPoint
        !mRoutineName
        !@ipic18SequentialInstructionList ()
        !@ipic18JumpTerminator { !mRoutineName.location !mRoutineName !@jumpInstructionKind. ipicRelative}
        !@uint.max
        !0
      }
    else
      var instructionList =@ipic18SequentialInstructionList ()
      if mReturnedBank.uint != @uint. max then
        instructionList += !@ipic18_intermediate_instruction_MOVLB { !@location.here !mReturnedBank} !@uint.max !0
      end
      generatedBlockList += !@ipic18Block {
        !entryPoint
        !mRoutineName
        !instructionList
        !@ipic18ReturnTerminator { !@location. nowhere}
        !@uint.max
        !0
      }
      end
    entryPoint = entryPoint + 4
  end
#----------------------------------------------------------- Check declared bytes are used
  var unusedDeclarationUnicity =@stringset ()
  for (mValue) in  inUnusedRegisterList do
    if not [inRegisterTable hasKey !mValue.string] then
      error mValue : "the '" + mValue + "' byte is not declared"
    elsif [unusedDeclarationUnicity hasKey !mValue.string] then
      warning mValue : "the '" + mValue + "' byte is already declared as unused"
    elsif [usedRegisters hasKey !mValue.string] then
      warning mValue : "the '" + mValue + "' byte is declared as unused, but is used"
    end
    unusedDeclarationUnicity += !mValue.string
  end
  for (lkey) in  inDeclaredByteMap do
    if (not [usedRegisters hasKey !lkey.string]) & (not [unusedDeclarationUnicity hasKey !lkey.string]) then
      warning lkey : "the '" + lkey + "' byte is unused"
    end
  end
#----------------------------------------------------------- Display block list
  displayBlockList (!"INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList)
#----------------------------------------------------------- Optimize
  if @uint. errorCount == 0 then
    ipic18OptimizeBlocks ( !?ioListFileContents !?generatedBlockList )
    displayBlockList ( !"OPTIMIZED INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList )
  end
#----------------------------------------------------------- Optimize block ordering
  if @uint. errorCount == 0 then
    ipic18OptimizeBlockOrdering (
      !inSourceFileName
      !?ioListFileContents
      !?generatedBlockList
    )
  end
#----------------------------------------------------------- relative branch and jump resolution
  if @uint.errorCount == 0 then
    ipic18RelativesResolution (
      !?ioListFileContents
      !?generatedBlockList
    )
  end
#----------------------------------------------------------- Check and compute stack requirements
  if (@uint.errorCount == 0) & (inProgramKind != .userProgram) then
    ipic18StackComputations (
      !?ioListFileContents
      !generatedBlockList
    )
  end
#----------------------------------------------------------- Compute durations
  var @blockDurationMap blockDurationMap = @()
  if @uint.errorCount == 0 then
    ipic18DurationComputations (!?generatedBlockList ?blockDurationMap)
  end
#----------------------------------------------------------- Generate code
  if @uint.errorCount == 0 then
    ipic18GenerateCode (
      !inSourceFileName
      !inProgramKind
      !inBootloaderReservedROMsize.uint
      ![inROMSize uint]
      !inProcessorName
      !inPredefinedRegisters
      !inRegisterTable
      !dataMap
      !inActualConfigurationMap
      !?ioListFileContents
      !generatedBlockList
      ?let @uint usedROMsize
      ?let @generatedCodeMap unused generatedCodeMap
    )
  #----------------------------------------------------------- Print usage
    if @application.verboseOutput then
      var @string verboseMessage = "Resource usage:\n"
      verboseMessage += "  ROM, used " + [usedROMsize string]
      verboseMessage += " / " + inROMSize + " bytes ("
      verboseMessage += [(usedROMsize * 100) / inROMSize string] + "%)\n"
      for (lkey mFirstAddress mFirstFreeAddress mLastAddressPlusOne *) in inRamBank do
        let @uint bankSize = mLastAddressPlusOne - mFirstAddress
        let @uint usedSize = mFirstFreeAddress - mFirstAddress
        verboseMessage += "  Bank '" + lkey + "': "
        verboseMessage += [usedSize string] + " / "
        verboseMessage += [bankSize string] + " bytes ("
        verboseMessage += [(usedSize * 100) / bankSize string] + "%)\n"
      end
      print (!verboseMessage)
    end
  end
#----------------------------------------------------------- Compute durations
  if @uint.errorCount == 0 then
    ipic18PrintDurations (!?ioListFileContents !blockDurationMap)
  end
}

#----------------------------------------------------------------------------*

