
#!Terminator optimizeTerminator

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string unused inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
  if inBlockLabel != mLabel.string then
    [inSymbolTable searchKey !mLabel ?let @uint targetBlockIndex]
    let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
    if (targetBlock.mAddress == @uint. max) # Relocatable
     & ([targetBlock.mInstructionList length] == 0) # Empty block
     & (targetBlock.mTerminator is >= @ipic18SingleInstructionTerminator) then
      @bool optimize
      if (targetBlock.mTerminator is >= @ipic18JumpTerminator) then
        let @ipic18JumpTerminator candidate = ( targetBlock.mTerminator as @ipic18JumpTerminator)
        optimize = mLabel.string != [candidate mLabel].string
      else
        optimize = true
      end
      if optimize then 
        outOptimizedTerminator = targetBlock.mTerminator
        ioOptimizationDone = true
        ioListFileContents += "  [P] " + inBlockLabel + ": "
        ioListFileContents += [self terminatorDisplay !""]
        ioListFileContents += " -> "
        ioListFileContents += [outOptimizedTerminator terminatorDisplay !""]
        ioListFileContents += "\n"
      end
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
#---- Useless condition ?
  if mTargetLabelWhenTrue.string == mTargetLabelWhenFalse.string then
    outOptimizedTerminator = @ipic18JumpTerminator. new {
      !mInstructionLocation
      !mTargetLabelWhenFalse
      !@jumpInstructionKind. ipicRelative}
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by JUMP " + mTargetLabelWhenFalse + "\n"
    warning mInstructionLocation : "useless condition deleted"
  else
    @bool optimized = false
  #--- Optimize true label
    @lstring targetLabelWhenTrue = mTargetLabelWhenTrue
    if inBlockLabel != mTargetLabelWhenTrue.string then
      [inSymbolTable searchKey !mTargetLabelWhenTrue ?let @uint targetBlockIndex]
      let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
      if (targetBlock.mAddress == @uint. max) # Relocatable
       & ([targetBlock.mInstructionList length] == 0) # Empty block
       & (targetBlock.mTerminator is >= @ipic18JumpTerminator) then
        let @ipic18JumpTerminator jp = ( targetBlock.mTerminator as @ipic18JumpTerminator)
        targetLabelWhenTrue = [jp mLabel]
        optimized = true
        ioListFileContents += "  [P] " + inBlockLabel + ", jump optimization: "
        ioListFileContents += mTargetLabelWhenTrue.string
        ioListFileContents += " -> "
        ioListFileContents += targetLabelWhenTrue.string
        ioListFileContents += "\n"
      end
    end
  #--- Optimize false label
    @lstring targetLabelWhenFalse = mTargetLabelWhenFalse
    if inBlockLabel != mTargetLabelWhenFalse.string then
      [inSymbolTable searchKey !mTargetLabelWhenFalse ?let @uint targetBlockIndex]
      let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
      if (targetBlock.mAddress == @uint. max) # Relocatable
       & ([targetBlock.mInstructionList length] == 0) # Empty block
       & (targetBlock.mTerminator is >= @ipic18JumpTerminator) then
        let @ipic18JumpTerminator jp = ( targetBlock.mTerminator as @ipic18JumpTerminator)
        targetLabelWhenFalse = [jp mLabel]
        optimized = true
        ioListFileContents += "  [P] " + inBlockLabel + ", jump optimization: "
        ioListFileContents += mTargetLabelWhenFalse.string
        ioListFileContents += " -> "
        ioListFileContents += targetLabelWhenFalse.string
        ioListFileContents += "\n"
      end
    end
  #--- Optimized ?
    if optimized then
      ioOptimizationDone = true
      outOptimizedTerminator = @ipic18ConditionalJumpTerminator. new {
        !mInstructionLocation
        !mConditionalBranch
        !targetLabelWhenTrue
        !mBranchModeOnTrueLabel
        !targetLabelWhenFalse
        !mBranchModeOnFalseLabel}  
    else
      outOptimizedTerminator = self
    end
  end
}

#----------------------------------------------------------------------------*

method @ipic18AbstractConditionTerminator getOptimizedTerminators
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SingleInstructionTerminator outOptimizedTrueTerminator
  !@ipic18SingleInstructionTerminator outOptimizedFalseTerminator
  !@bool outIdenticalTerminators {
#---
  [mSingleInstructionTerminatorIfConditionTrue optimizeTerminator
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator optimizedTrueTerminator
  ]
  outOptimizedTrueTerminator = ( optimizedTrueTerminator as @ipic18SingleInstructionTerminator)
#---
  [mSingleInstructionTerminatorIfConditionFalse optimizeTerminator
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator optimizedFalseTerminator
  ]
  outOptimizedFalseTerminator = ( optimizedFalseTerminator as @ipic18SingleInstructionTerminator)
#---- Useless condition ?
  if (outOptimizedTrueTerminator is >= @ipic18ReturnTerminator) & (outOptimizedFalseTerminator is >= @ipic18ReturnTerminator) then
    outIdenticalTerminators = true
  elsif (outOptimizedTrueTerminator is >= @ipic18RetlwTerminator) & (outOptimizedFalseTerminator is >= @ipic18RetlwTerminator) then
    let @ipic18RetlwTerminator t = ( outOptimizedTrueTerminator as @ipic18RetlwTerminator)
    let @ipic18RetlwTerminator f = ( outOptimizedFalseTerminator as @ipic18RetlwTerminator)
    outIdenticalTerminators = [t mLiteralValue] == [f mLiteralValue]
  elsif (outOptimizedTrueTerminator is >= @ipic18JumpTerminator) & (outOptimizedFalseTerminator is >= @ipic18JumpTerminator) then
    let @ipic18JumpTerminator t = ( outOptimizedTrueTerminator as @ipic18JumpTerminator)
    let @ipic18JumpTerminator f = ( outOptimizedFalseTerminator as @ipic18JumpTerminator)
    outIdenticalTerminators = [t mLabel] == [f mLabel]
  else
    outIdenticalTerminators = false
  end
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  @bool optimization = false
#---
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = self
    error mInstructionLocation : "useless decf/incf condition should be replaced by decf/incf instruction"
  elsif optimization then
    outOptimizedTerminator = @ipic18IncDecRegisterTerminator. new {
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  @bool optimization = false
#---
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18BitTestTerminator. new {
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mBitNumber}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  @bool optimization = false
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18RegisterComparisonTerminator. new {
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mComparison}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  @bool optimization = false
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18TestRegisterTerminator. new {
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

#!Terminator enterTerminatorReferencedLabels

#----------------------------------------------------------------------------*

proc enterGoto2block
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !"_computed_goto_2"] then
    ioReferencedBlockSet += !"_computed_goto_2"
    [inSymbolTable searchKey !["_computed_goto_2" nowhere] ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

proc enterGoto4block
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !"_computed_goto_4"] then
    ioReferencedBlockSet += !"_computed_goto_4"
    [inSymbolTable searchKey !["_computed_goto_4" nowhere] ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto2block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto2block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for () in  mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue.string] then
      ioReferencedBlockSet += !mValue.string
      [inSymbolTable searchKey !mValue ?let @uint blockIndex]
      let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ]
    end 
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto4block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for () in  mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue.string] then
      ioReferencedBlockSet += !mValue.string
      [inSymbolTable searchKey !mValue ?let @uint blockIndex]
      let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ]
    end 
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !mLabel.string] then
    ioReferencedBlockSet += !mLabel.string
    [inSymbolTable searchKey !mLabel ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !mTargetLabelWhenTrue.string] then
    ioReferencedBlockSet += !mTargetLabelWhenTrue.string
    [inSymbolTable searchKey !mTargetLabelWhenTrue ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end
  if not [ioReferencedBlockSet hasKey !mTargetLabelWhenFalse.string] then
    ioReferencedBlockSet += !mTargetLabelWhenFalse.string
    [inSymbolTable searchKey !mTargetLabelWhenFalse ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end
}

#----------------------------------------------------------------------------*

override method @ipic18SingleInstructionTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet {
}

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [mSingleInstructionTerminatorIfConditionTrue enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet]
  [mSingleInstructionTerminatorIfConditionFalse enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet]
}

#----------------------------------------------------------------------------*

#!Instruction enterInstructionReferencedLabels

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet {
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !mTargetLabel.string] then
    ioReferencedBlockSet += !mTargetLabel.string
    [inSymbolTable searchKey !mTargetLabel ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto4block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for () in  mTargetInstructions do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]      
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction  enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [mEmbeddedInstruction enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
}

#----------------------------------------------------------------------------*

#!Instruction optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction optimizeInstruction
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @lstring unused inBlockLabel
  !@bool outOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outOptimizedInstruction = self
  outOptimizationDone = false
  outNOPsubstitution = false
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
{
  outOptimizedInstruction = self
  outOptimizationDone = false
  outNOPsubstitution = false
#---
  [inSymbolTable searchKey !mTargetLabel ?let @uint targetBlockIndex] 
  let @ipic18Block targetBloc = [inBlockList mBlockAtIndex !targetBlockIndex]  
#--- Remove empty routine calls
  if inOptimizeFlagStruct.mRemoveEmptyRoutine
   & ([targetBloc.mInstructionList length] == 0) # Empty block
   & (targetBloc.mAddress == @uint. max) # Relocatable
   & (targetBloc.mTerminator is >= @ipic18ReturnTerminator) then # Ends with RETURN
    outOptimizationDone = true
    ioListFileContents += "  [E] " + inBlockLabel + ": "
    ioListFileContents += "call to empty " + mTargetLabel + " routine deleted"
    ioListFileContents += "\n"
    outOptimizedInstruction = @ipic18InstructionWithNoOperand. new { !mInstructionLocation !@pic18InstructionWithNoOperandKind. NOP}
    outNOPsubstitution = true
#--- Replace call to a RETLW routine with a MOVLW instruction
  elsif inOptimizeFlagStruct.mJSRtoRETLWreplacedByMOVLW
       & ([targetBloc.mInstructionList length] == 0) # Empty Block
       & (targetBloc.mAddress == @uint. max) # Relocatable
       & (targetBloc.mTerminator is >= @ipic18RetlwTerminator) then # Ends with RETLW
    let @ipic18RetlwTerminator t = ( targetBloc.mTerminator as @ipic18RetlwTerminator)
    outOptimizationDone = true
    ioListFileContents += "  [R] " + inBlockLabel + ": "
    ioListFileContents += "call to RETLW " + mTargetLabel + " routine transformed to MOVLW"
    ioListFileContents += "\n"
    outOptimizedInstruction = @ipic18_intermediate_instruction_literalOperation. new {
      !mInstructionLocation
      !@literal_instruction_opcode. MOVLW
      ![t mLiteralValue]}
#--- Replace call to a single instruction routine with the routine instruction
  elsif inOptimizeFlagStruct.mJSRtoOneInstructionRoutineReplacedByInstruction
      & ([targetBloc.mInstructionList length] == 1) # One instruction bloc
      & (targetBloc.mAddress == @uint. max) # Relocatable
      & (targetBloc.mTerminator is >= @ipic18ReturnTerminator) then # Ends with Return
    outOptimizedInstruction = [targetBloc.mInstructionList mInstructionAtIndex !0]
    outOptimizationDone = true
    ioListFileContents += "  [I] " + inBlockLabel + ", "
    ioListFileContents += "call to single instruction routine " + mTargetLabel + " replaced by this single instruction"
    ioListFileContents += "\n"
  end    
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
{
  outOptimizationDone = false
  outNOPsubstitution = false
#---
  @ipic18SequentialInstructionList optimizedInstructionList = {}
  for () in  mTargetInstructions do
    @bool opt = false
    if (mInstruction is >= @ipic18_intermediate_JSR) then
      let @ipic18_intermediate_JSR jsr = ( mInstruction as @ipic18_intermediate_JSR)
      [inSymbolTable searchKey ![jsr mTargetLabel] ?let @uint targetBlockIndex] 
      let @ipic18Block targetBloc = [inBlockList mBlockAtIndex !targetBlockIndex]  
      if (targetBloc.mTerminator is >= @ipic18ReturnTerminator) # One instruction bloc
       & (targetBloc.mAddress == @uint. max) then # Relocatable bloc
        if inOptimizeFlagStruct.mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank
         & [targetBloc.mInstructionList length] == 0 then # Empty block, replace by NOP
          opt = true
          outOptimizationDone = true
          optimizedInstructionList += !@ipic18_intermediate_instruction_BLANK. new { ![jsr mInstructionLocation] !0} !@uint.max !0
          ioListFileContents += "  [e] " + inBlockLabel + ", "
          ioListFileContents += "JSR " + [jsr mTargetLabel] + " to empty routine replaced by BLANK 0"
          ioListFileContents += "\n"
        elsif inOptimizeFlagStruct.mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction
         & ([targetBloc.mInstructionList length] == 1) then # One instruction block
          let @ipic18SequentialInstruction inst = [targetBloc.mInstructionList mInstructionAtIndex !0]
          if [inst instructionSize] == 2 then # Instruction size == 2, perform replacement
            opt = true
            outOptimizationDone = true
            optimizedInstructionList += !inst !@uint.max !0
            ioListFileContents += "  [i] " + inBlockLabel + ", "
            ioListFileContents += "JSR " + [jsr mTargetLabel] + " to one instruction routine replaced by routine instruction"
            ioListFileContents += "\n"
          end
        end
      end
    end
    if not opt then
      optimizedInstructionList += !mInstruction !@uint.max !0
    end
  end
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_intermediate_instruction_computed_rcall. new {
      !mInstructionLocation
      !optimizedInstructionList
      !mUsesRCALL}
  else
    outOptimizedInstruction = self
  end  
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_BitTestSkip optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?var @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_BitTestSkip. new {
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mSkipIfSet
      !mRegisterDescription
      !mBitNumber}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_compare_register optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?var @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_compare_register. new {
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mCompareInstruction
      !mRegisterDescription}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_FDA optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?var @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_FDA. new {
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mInstruction_FDA_base_code
      !mRegisterDescription
      !m_W_isDestination}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

#!Instruction list optimization

#----------------------------------------------------------------------------*

proc instructionListOptimization
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @ipic18SequentialInstructionList inInstructionList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstructionList outOptimizedInstructionList {
  outOptimizationDone = false
  outOptimizedInstructionList = @ipic18SequentialInstructionList. emptyList
  for () in  inInstructionList do
    [mInstruction optimizeInstruction
      !inSymbolTable
      !inOptimizeFlagStruct
      !inBlockList
      !inBlockLabel
      ?let @bool optimizationDone
      !?ioListFileContents
      ?let @ipic18SequentialInstruction optimizedInstruction
      ?let @bool NOPsubstitution
    ]
    if optimizationDone then
      outOptimizationDone = true
    end
    if not NOPsubstitution then
      outOptimizedInstructionList += !optimizedInstruction !@uint.max !0
    end
  end
}

#----------------------------------------------------------------------------*

#!Block optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstructionList enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  for () in  self do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]  
  end
}

#----------------------------------------------------------------------------*

method @ipic18Block enterReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [mInstructionList enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
  [mTerminator enterTerminatorReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
}

#----------------------------------------------------------------------------*

method @ipic18Block optimize
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18Block outOptimizedBlock {
#----- Optimize instruction list
  instructionListOptimization (
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !mInstructionList
    !mLabel
    ?var @bool optimized
    !?ioListFileContents
    ?var @ipic18SequentialInstructionList optimizedInstructionList
  )
#--- Transform MOVLW k ; RETURN to RETLW
  @ipic18AbstractBlockTerminator optimizedTerminator = mTerminator
  if ([optimizedInstructionList length] > 0) & (mTerminator is >= @ipic18ReturnTerminator) then
    [optimizedInstructionList last ?let @ipic18SequentialInstruction lastInstruction ?2*]
    cast lastInstruction
    case == @ipic18_intermediate_instruction_literalOperation op :
      if inOptimizeFlagStruct.mMOVLWfollowedByRETreplacedByRETLW & ([op mLiteralInstruction] == @literal_instruction_opcode. MOVLW) then
        [!?optimizedInstructionList popLast ?3*]
        optimizedTerminator = @ipic18RetlwTerminator. new { ![op mInstructionLocation] ![op mLiteralValue]}
        optimized = true
        ioListFileContents += "  [M] " + mLabel + ": MOVLW k ; RETURN --> RETLW k\n"
      end
  #--- Transform JSR label ; RETURN to JUMP label
    case == @ipic18_intermediate_JSR jsr :
      if inOptimizeFlagStruct.mJSRfollowedByRETreplacedByJUMP then
        [!?optimizedInstructionList popLast ?3*]
        optimizedTerminator = @ipic18JumpTerminator.new {![jsr mInstructionLocation] ![jsr mTargetLabel] ![jsr mKind]}
        optimized = true
        ioListFileContents += "  [J] " + mLabel + ": JSR " + [jsr mTargetLabel] + " ; RETURN --> JUMP " + [jsr mTargetLabel] + "\n"
      end
  #--- Transform computed rcall ; RETURN to computed bra
#    case == @ipic18_intermediate_instruction_computed_rcall computedRCALL :
#      if inOptimizeFlagStruct.mComputedRCALLFollowedByRETURNreplacedByComputedBRA then
#        [!?optimizedInstructionList popLast ?*]
#        optimizedTerminator = @ipic18ComputedBraTerminator.new {
#          ![computedRCALL mInstructionLocation]
#          ![computedRCALL mTargetLabels]
#          ![computedRCALL mKind]
#         }
#        optimized = true
#        ioListFileContents += "  [J] " + mLabel + ": JSR " + [jsr mTargetLabel] + " ; RETURN --> JUMP " + [jsr mTargetLabel] + "\n"
#      end
    else
    end
  end
#--- Optimize terminator 
# DO NOT OPTIMIZE WHEN TERMINATOR HAS BEEN CHANGED IN PREVIOUS INSTRUCTIONS
  if not optimized then
    [mTerminator optimizeTerminator
      !inSymbolTable
      !inOptimizeFlagStruct
      !inBlockList
      !mLabel.string
      !?optimized
      !?ioListFileContents
      ?optimizedTerminator
    ]
  end
#--- Return optimized block
  if optimized then
    ioOptimizationDone = true
    outOptimizedBlock = @ipic18Block. new {
      !mAddress
      !mLabel
      !optimizedInstructionList
      !optimizedTerminator
      !@uint.max
      !0
    }
  else
    outOptimizedBlock = self
  end
}

#----------------------------------------------------------------------------*

#!optimizeFlagStruct

#----------------------------------------------------------------------------*

struct @optimizeFlagStruct {
 @bool mRemoveEmptyRoutine # [E]
 @bool mJSRtoRETLWreplacedByMOVLW # [R]
 @bool mJSRfollowedByRETreplacedByJUMP # [J]
 @bool mMOVLWfollowedByRETreplacedByRETLW # [M]
 @bool mJSRtoOneInstructionRoutineReplacedByInstruction # [I]
 @bool mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction # [i]
 @bool mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank # [e]
# @bool mComputedRCALLFollowedByRETURNreplacedByComputedBRA # [c]
}

#----------------------------------------------------------------------------*

getter @bool flagValue ->@string outResult {
  outResult = if self then "enabled" else "disabled" end
}

#----------------------------------------------------------------------------*

proc ipic18OptimizeBlocks
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList {
#--- Optimization flags
  let optimizeFlagStruct = @optimizeFlagStruct.new {
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'E'] # [E]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'R'] # [R]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'J'] # [J]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'M'] # [M]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'I'] # [I]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'i'] # [i]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'e'] # [e]
#    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'c'] # [c]
  }
#---
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  ioListFileContents += "*" + ["BLOCK REPRESENTATION OPTIMIZATION" stringByLeftAndRightPadding !117 !' '] + "*\n"
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  ioListFileContents += "Optimization flags:\n"
#  ioListFileContents += "  [c] computed RCALL followed by RETURN replaced by computed BRA: " + [optimizeFlagStruct.mComputedRCALLFollowedByRETURNreplacedByComputedBRA flagValue] + "\n"
  ioListFileContents += "  [D] Dead code elimination: always enabled\n"
  ioListFileContents += "  [E] Empty routine elimination: " + [optimizeFlagStruct.mRemoveEmptyRoutine flagValue] + "\n"
  ioListFileContents += "  [e] In Computed RCALL, empty routine call replaced by BLANK: " + [optimizeFlagStruct.mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank flagValue] + "\n"
  ioListFileContents += "  [I] Call to one instruction routine replaced by instruction: " + [optimizeFlagStruct.mJSRtoOneInstructionRoutineReplacedByInstruction flagValue] + "\n"
  ioListFileContents += "  [i] In Computed RCALL, rcall to one instruction routine replaced by instruction: " + [optimizeFlagStruct.mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction flagValue] + "\n"
  ioListFileContents += "  [J] JSR followed by RETURN replaced by JUMP: " + [optimizeFlagStruct.mJSRfollowedByRETreplacedByJUMP flagValue] + "\n"
  ioListFileContents += "  [M] MOVLW followed by RETURN replaced by RETLW: " + [optimizeFlagStruct.mMOVLWfollowedByRETreplacedByRETLW flagValue] + "\n"
  ioListFileContents += "  [P] JUMP propagation: always enabled\n"
  ioListFileContents += "  [R] Call to RETLW replaced by MOVLW: " + [optimizeFlagStruct.mJSRtoRETLWreplacedByMOVLW flagValue] + "\n"
  ioListFileContents += "  [U] Useless test elimination: always enabled\n"
  if @application.verboseOutput then
    message "Optimizations:\n"
  end
#--- Optimizations loops
  @bool optimizationDone = true
  @uint optimizationPass = 0
  loop( [ioGeneratedBlockList length] + 1)
  while optimizationDone & (@uint. errorCount == 0) do
    optimizationDone = false
    optimizationPass = optimizationPass + 1
    ioListFileContents += "\n--- Pass " + optimizationPass + " (" + [ioGeneratedBlockList length] + " blocks)\n"
    let @uint blockCountBeforeOptimization = [ioGeneratedBlockList length]
    if @application.verboseOutput then
      message "  Pass " + optimizationPass + " : " + blockCountBeforeOptimization + " blocks.\n"
    end
  #-------------------------------- Build label map
    var symbolTable =@symbolTableForBlockOptimization.emptyMap{}
    for () in  ioGeneratedBlockList do(blockIndex)
      [!?symbolTable insertKey !mBlock.mLabel !blockIndex]
    end
  #-------------------------------- Build referenced label set
    var referencedBlockSet =@stringset.emptySet{}
    for () in  ioGeneratedBlockList do
      if mBlock.mAddress != @uint. max then # Only absolute blocks
        [mBlock enterReferencedLabels
          !symbolTable
          !ioGeneratedBlockList
          !?referencedBlockSet
        ]
      end
    end
  #-------------------------------- Optimize blocks
    var optimizedBlockList =@ipic18BlockList.emptyList{}
    for () in  ioGeneratedBlockList do
      if [referencedBlockSet hasKey !mBlock.mLabel.string] | (mBlock.mAddress != @uint. max) then
        [mBlock optimize
          !symbolTable
          !optimizeFlagStruct
          !ioGeneratedBlockList
          !?optimizationDone
          !?ioListFileContents
          ?var @ipic18Block optimizedBlock
        ]
        optimizedBlockList += !optimizedBlock
      else
        ioListFileContents += "  [D] " + mBlock.mLabel + ": not referenced, deleted\n"
        optimizationDone = true
      end
    end
    ioGeneratedBlockList = optimizedBlockList
  end
  ioListFileContents += "  No optimization.\n\n"
  if @application.verboseOutput then
    message "\n"
  end
}

#----------------------------------------------------------------------------*


