
#!Terminator optimizeTerminator

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string unused inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
  if inBlockLabel != self.mLabel.string then
    [inSymbolTable searchKey !self.mLabel ?let @uint targetBlockIndex]
    let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
    if (targetBlock.mAddress == @uint. max) # Relocatable
     & ([targetBlock.mInstructionList length] == 0) # Empty block
     & (targetBlock.mTerminator is >= @ipic18SingleInstructionTerminator) then
      let @bool optimize
      if (targetBlock.mTerminator is >= @ipic18JumpTerminator) then
        let @ipic18JumpTerminator candidate = ( targetBlock.mTerminator as @ipic18JumpTerminator)
        optimize = self.mLabel.string != candidate.mLabel.string
      else
        optimize = true
      end
      if optimize then 
        outOptimizedTerminator = targetBlock.mTerminator
        ioOptimizationDone = true
        ioListFileContents += "  [P] " + inBlockLabel + ": "
        ioListFileContents += [self terminatorDisplay !""]
        ioListFileContents += " -> "
        ioListFileContents += [outOptimizedTerminator terminatorDisplay !""]
        ioListFileContents += "\n"
      end
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
{
#---- Useless condition ?
  if self.mTargetLabelWhenTrue.string == self.mTargetLabelWhenFalse.string then
    outOptimizedTerminator = @ipic18JumpTerminator.new {
      !self.mInstructionLocation
      !self.mTargetLabelWhenFalse
      !@jumpInstructionKind.ipicRelative
    }
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by JUMP " + self.mTargetLabelWhenFalse + "\n"
    warning self.mInstructionLocation : "useless condition deleted"
  else
    var @bool optimized = false
  #--- Optimize true label
    var @lstring targetLabelWhenTrue = self.mTargetLabelWhenTrue
    if inBlockLabel != self.mTargetLabelWhenTrue.string then
      [inSymbolTable searchKey !self.mTargetLabelWhenTrue ?let @uint targetBlockIndex]
      let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
      if targetBlock.mAddress == @uint.max, # Relocatable
             [targetBlock.mInstructionList length] == 0, # Empty block
             let targetBlockJumpTerminator = targetBlock.mTerminator as @ipic18JumpTerminator then
        targetLabelWhenTrue = targetBlockJumpTerminator.mLabel
        if self.mTargetLabelWhenTrue.string != targetLabelWhenTrue.string then
          optimized = true
          ioListFileContents += "  [P] " + inBlockLabel + ", jump optimization: "
          ioListFileContents += self.mTargetLabelWhenTrue.string
          ioListFileContents += " -> "
          ioListFileContents += targetLabelWhenTrue.string
          ioListFileContents += "\n"
        end
      end
    end
  #--- Optimize false label
    var @lstring targetLabelWhenFalse = self.mTargetLabelWhenFalse
    if inBlockLabel != self.mTargetLabelWhenFalse.string then
      [inSymbolTable searchKey !self.mTargetLabelWhenFalse ?let @uint targetBlockIndex]
      let @ipic18Block targetBlock = [inBlockList mBlockAtIndex !targetBlockIndex]
      if targetBlock.mAddress == @uint.max, # Relocatable
            [targetBlock.mInstructionList length] == 0, # Empty block
            let targetBlockJumpTerminator = targetBlock.mTerminator as @ipic18JumpTerminator then
         targetLabelWhenFalse = targetBlockJumpTerminator.mLabel
         if self.mTargetLabelWhenFalse.string != targetLabelWhenFalse.string then
          optimized = true
          ioListFileContents += "  [P] " + inBlockLabel + ", jump optimization: "
          ioListFileContents += self.mTargetLabelWhenFalse.string
          ioListFileContents += " -> "
          ioListFileContents += targetLabelWhenFalse.string
          ioListFileContents += "\n"
        end
      end
    end
  #--- Optimized ?
    if optimized then
      ioOptimizationDone = true
      outOptimizedTerminator = @ipic18ConditionalJumpTerminator. new {
        !self.mInstructionLocation
        !self.mConditionalBranch
        !targetLabelWhenTrue
        !self.mBranchModeOnTrueLabel
        !targetLabelWhenFalse
        !self.mBranchModeOnFalseLabel}  
    else
      outOptimizedTerminator = self
    end
  end
}

#----------------------------------------------------------------------------*

method @ipic18AbstractConditionTerminator getOptimizedTerminators
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SingleInstructionTerminator outOptimizedTrueTerminator
  !@ipic18SingleInstructionTerminator outOptimizedFalseTerminator
  !@bool outIdenticalTerminators
{
#---
  [self.mSingleInstructionTerminatorIfConditionTrue optimizeTerminator
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator optimizedTrueTerminator
  ]
  outOptimizedTrueTerminator = ( optimizedTrueTerminator as @ipic18SingleInstructionTerminator)
#---
  [self.mSingleInstructionTerminatorIfConditionFalse optimizeTerminator
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator optimizedFalseTerminator
  ]
  outOptimizedFalseTerminator = ( optimizedFalseTerminator as @ipic18SingleInstructionTerminator)
#---- Useless condition ?
  if (outOptimizedTrueTerminator is >= @ipic18ReturnTerminator) & (outOptimizedFalseTerminator is >= @ipic18ReturnTerminator) then
    outIdenticalTerminators = true
  elsif (outOptimizedTrueTerminator is >= @ipic18RetlwTerminator) & (outOptimizedFalseTerminator is >= @ipic18RetlwTerminator) then
    let @ipic18RetlwTerminator t = ( outOptimizedTrueTerminator as @ipic18RetlwTerminator)
    let @ipic18RetlwTerminator f = ( outOptimizedFalseTerminator as @ipic18RetlwTerminator)
    outIdenticalTerminators = t.mLiteralValue == f.mLiteralValue
  elsif (outOptimizedTrueTerminator is >= @ipic18JumpTerminator) & (outOptimizedFalseTerminator is >= @ipic18JumpTerminator) then
    let @ipic18JumpTerminator t = ( outOptimizedTrueTerminator as @ipic18JumpTerminator)
    let @ipic18JumpTerminator f = ( outOptimizedFalseTerminator as @ipic18JumpTerminator)
    outIdenticalTerminators = t.mLabel == f.mLabel
  else
    outIdenticalTerminators = false
  end
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  var @bool optimization = false
#---
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = self
    error self.mInstructionLocation : "useless decf/incf condition should be replaced by decf/incf instruction"
  elsif optimization then
    outOptimizedTerminator = @ipic18IncDecRegisterTerminator. new {
      !self.mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !self.mRegisterDescription
      !self.mIncrement
      !self.m_W_isDestination}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  var @bool optimization = false
#---
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning self.mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18BitTestTerminator. new {
      !self.mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !self.mRegisterDescription
      !self.mBitNumber}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  var @bool optimization = false
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning self.mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18RegisterComparisonTerminator. new {
      !self.mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !self.mRegisterDescription
      !self.mComparison}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  var @bool optimization = false
  [self getOptimizedTerminators
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ?let @ipic18SingleInstructionTerminator optimizedTrueTerminator
    ?let @ipic18SingleInstructionTerminator optimizedFalseTerminator
    ?let @bool identicalTerminators
  ]
  if identicalTerminators then
    outOptimizedTerminator = optimizedTrueTerminator
    ioOptimizationDone = true
    ioListFileContents += "  [U] " + inBlockLabel + ", useless terminator condition: replaced by " + [optimizedTrueTerminator terminatorDisplay !""] + "\n"
    warning self.mInstructionLocation : "useless condition deleted"
  elsif optimization then
    outOptimizedTerminator = @pic18TestRegisterTerminator. new {
      !self.mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !self.mRegisterDescription}
    ioOptimizationDone = true
  else
    outOptimizedTerminator = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator optimizeTerminator
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator {
  outOptimizedTerminator = self
}

#----------------------------------------------------------------------------*

#!Terminator enterTerminatorReferencedLabels

#----------------------------------------------------------------------------*

proc enterGoto2block
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !"_computed_goto_2"] then
    ioReferencedBlockSet += !"_computed_goto_2"
    [inSymbolTable searchKey !["_computed_goto_2" nowhere] ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

proc enterGoto4block
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !"_computed_goto_4"] then
    ioReferencedBlockSet += !"_computed_goto_4"
    [inSymbolTable searchKey !["_computed_goto_4" nowhere] ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto2block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto2block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for (mValue) in  self.mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue.string] then
      ioReferencedBlockSet += !mValue.string
      [inSymbolTable searchKey !mValue ?let @uint blockIndex]
      let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ]
    end 
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto4block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for (mValue) in  self.mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue.string] then
      ioReferencedBlockSet += !mValue.string
      [inSymbolTable searchKey !mValue ?let @uint blockIndex]
      let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ]
    end 
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !self.mLabel.string] then
    ioReferencedBlockSet += !self.mLabel.string
    [inSymbolTable searchKey !self.mLabel ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !self.mTargetLabelWhenTrue.string] then
    ioReferencedBlockSet += !self.mTargetLabelWhenTrue.string
    [inSymbolTable searchKey !self.mTargetLabelWhenTrue ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end
  if not [ioReferencedBlockSet hasKey !self.mTargetLabelWhenFalse.string] then
    ioReferencedBlockSet += !self.mTargetLabelWhenFalse.string
    [inSymbolTable searchKey !self.mTargetLabelWhenFalse ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end
}

#----------------------------------------------------------------------------*

override method @ipic18SingleInstructionTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet {
}

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator enterTerminatorReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [self.mSingleInstructionTerminatorIfConditionTrue enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet]
  [self.mSingleInstructionTerminatorIfConditionFalse enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet]
}

#----------------------------------------------------------------------------*

#!Instruction enterInstructionReferencedLabels

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet {
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  if not [ioReferencedBlockSet hasKey !self.mTargetLabel.string] then
    ioReferencedBlockSet += !self.mTargetLabel.string
    [inSymbolTable searchKey !self.mTargetLabel ?let @uint blockIndex]
    let @ipic18Block b = [inBlockList mBlockAtIndex !blockIndex]
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]
  end 
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  enterGoto4block (
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  )
  for (mInstruction * *) in  self.mTargetInstructions do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]      
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction  enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [self.mEmbeddedInstruction enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
}

#----------------------------------------------------------------------------*

#!Instruction optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction optimizeInstruction
  ?let @symbolTableForBlockOptimization unused inSymbolTable
  ?let @optimizeFlagStruct unused inOptimizeFlagStruct
  ?let @ipic18BlockList unused inBlockList
  ?let @lstring unused inBlockLabel
  !@bool outOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outOptimizedInstruction = self
  outOptimizationDone = false
  outNOPsubstitution = false
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
{
  outOptimizedInstruction = self
  outOptimizationDone = false
  outNOPsubstitution = false
#---
  [inSymbolTable searchKey !self.mTargetLabel ?let @uint targetBlockIndex] 
  let @ipic18Block targetBloc = [inBlockList mBlockAtIndex !targetBlockIndex]  
#--- Remove empty routine calls
  if inOptimizeFlagStruct.mRemoveEmptyRoutine
   & ([targetBloc.mInstructionList length] == 0) # Empty block
   & (targetBloc.mAddress == @uint. max) # Relocatable
   & (targetBloc.mTerminator is >= @ipic18ReturnTerminator) then # Ends with RETURN
    outOptimizationDone = true
    ioListFileContents += "  [E] " + inBlockLabel + ": "
    ioListFileContents += "call to empty " + self.mTargetLabel + " routine deleted"
    ioListFileContents += "\n"
    outOptimizedInstruction = @ipic18InstructionWithNoOperand. new { !self.mInstructionLocation !@pic18InstructionWithNoOperandKind. NOP}
    outNOPsubstitution = true
#--- Replace call to a RETLW routine with a MOVLW instruction
  elsif inOptimizeFlagStruct.mJSRtoRETLWreplacedByMOVLW
       & ([targetBloc.mInstructionList length] == 0) # Empty Block
       & (targetBloc.mAddress == @uint. max) # Relocatable
       & (targetBloc.mTerminator is >= @ipic18RetlwTerminator) then # Ends with RETLW
    let @ipic18RetlwTerminator t = ( targetBloc.mTerminator as @ipic18RetlwTerminator)
    outOptimizationDone = true
    ioListFileContents += "  [R] " + inBlockLabel + ": "
    ioListFileContents += "call to RETLW " + self.mTargetLabel + " routine transformed to MOVLW"
    ioListFileContents += "\n"
    outOptimizedInstruction = @ipic18_intermediate_instruction_literalOperation. new {
      !self.mInstructionLocation
      !@literal_instruction_opcode. MOVLW
      !t.mLiteralValue}
#--- Replace call to a single instruction routine with the routine instruction
  elsif inOptimizeFlagStruct.mJSRtoOneInstructionRoutineReplacedByInstruction
      & ([targetBloc.mInstructionList length] == 1) # One instruction bloc
      & (targetBloc.mAddress == @uint. max) # Relocatable
      & (targetBloc.mTerminator is >= @ipic18ReturnTerminator) then # Ends with Return
    outOptimizedInstruction = [targetBloc.mInstructionList mInstructionAtIndex !0]
    outOptimizationDone = true
    ioListFileContents += "  [I] " + inBlockLabel + ", "
    ioListFileContents += "call to single instruction routine " + self.mTargetLabel + " replaced by this single instruction"
    ioListFileContents += "\n"
  end    
}

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
{
  outOptimizationDone = false
  outNOPsubstitution = false
#---
  var @ipic18SequentialInstructionList optimizedInstructionList = {}
  for (mInstruction * *) in  self.mTargetInstructions do
    var @bool opt = false
    if (mInstruction is >= @ipic18_intermediate_JSR) then
      let @ipic18_intermediate_JSR jsr = ( mInstruction as @ipic18_intermediate_JSR)
      [inSymbolTable searchKey !jsr.mTargetLabel ?let @uint targetBlockIndex] 
      let @ipic18Block targetBloc = [inBlockList mBlockAtIndex !targetBlockIndex]  
      if (targetBloc.mTerminator is >= @ipic18ReturnTerminator) # One instruction bloc
       & (targetBloc.mAddress == @uint. max) then # Relocatable bloc
        if inOptimizeFlagStruct.mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank
         & [targetBloc.mInstructionList length] == 0 then # Empty block, replace by NOP
          opt = true
          outOptimizationDone = true
          optimizedInstructionList += !@ipic18_intermediate_instruction_BLANK. new { !jsr.mInstructionLocation !0} !@uint.max !0
          ioListFileContents += "  [e] " + inBlockLabel + ", "
          ioListFileContents += "JSR " + jsr.mTargetLabel + " to empty routine replaced by BLANK 0"
          ioListFileContents += "\n"
        elsif inOptimizeFlagStruct.mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction
         & ([targetBloc.mInstructionList length] == 1) then # One instruction block
          let @ipic18SequentialInstruction inst = [targetBloc.mInstructionList mInstructionAtIndex !0]
          if [inst instructionSize] == 2 then # Instruction size == 2, perform replacement
            opt = true
            outOptimizationDone = true
            optimizedInstructionList += !inst !@uint.max !0
            ioListFileContents += "  [i] " + inBlockLabel + ", "
            ioListFileContents += "JSR " + jsr.mTargetLabel + " to one instruction routine replaced by routine instruction"
            ioListFileContents += "\n"
          end
        end
      end
    end
    if not opt then
      optimizedInstructionList += !mInstruction !@uint.max !0
    end
  end
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_intermediate_instruction_computed_rcall. new {
      !self.mInstructionLocation
      !optimizedInstructionList
      !self.mUsesRCALL}
  else
    outOptimizedInstruction = self
  end  
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_BitTestSkip optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [self.mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?let @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_BitTestSkip. new {
      !self.mInstructionLocation
      !optimizedEmbeddedInstruction
      !self.mSkipIfSet
      !self.mRegisterDescription
      !self.mBitNumber}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_compare_register optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [self.mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?let @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_compare_register. new {
      !self.mInstructionLocation
      !optimizedEmbeddedInstruction
      !self.mCompareInstruction
      !self.mRegisterDescription}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_FDA optimizeInstruction
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution {
  outNOPsubstitution = false
#---
  [self.mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?let @ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ]
  if outOptimizationDone then
    outOptimizedInstruction = @ipic18_skip_instruction_FDA. new {
      !self.mInstructionLocation
      !optimizedEmbeddedInstruction
      !self.mInstruction_FDA_base_code
      !self.mRegisterDescription
      !self.m_W_isDestination}
  else
    outOptimizedInstruction = self
  end
}

#----------------------------------------------------------------------------*

#!Instruction list optimization

#----------------------------------------------------------------------------*

proc instructionListOptimization
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?let @ipic18SequentialInstructionList inInstructionList
  ?let @lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstructionList outOptimizedInstructionList {
  outOptimizationDone = false
  outOptimizedInstructionList = @ipic18SequentialInstructionList. emptyList
  for (mInstruction * *) in  inInstructionList do
    [mInstruction optimizeInstruction
      !inSymbolTable
      !inOptimizeFlagStruct
      !inBlockList
      !inBlockLabel
      ?let @bool optimizationDone
      !?ioListFileContents
      ?let @ipic18SequentialInstruction optimizedInstruction
      ?let @bool NOPsubstitution
    ]
    if optimizationDone then
      outOptimizationDone = true
    end
    if not NOPsubstitution then
      outOptimizedInstructionList += !optimizedInstruction !@uint.max !0
    end
  end
}

#----------------------------------------------------------------------------*

#!Block optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstructionList enterInstructionReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  for (mInstruction * *) in  self do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ]  
  end
}

#----------------------------------------------------------------------------*

method @ipic18Block enterReferencedLabels
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet {
  [self.mInstructionList enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
  [self.mTerminator enterTerminatorReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ]
}

#----------------------------------------------------------------------------*

method @ipic18Block optimize
  ?let @symbolTableForBlockOptimization inSymbolTable
  ?let @optimizeFlagStruct inOptimizeFlagStruct
  ?let @ipic18BlockList inBlockList
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18Block outOptimizedBlock {
#----- Optimize instruction list
  instructionListOptimization (
    !inSymbolTable
    !inOptimizeFlagStruct
    !inBlockList
    !self.mInstructionList
    !self.mLabel
    ?var @bool optimized
    !?ioListFileContents
    ?var @ipic18SequentialInstructionList optimizedInstructionList
  )
#--- Transform MOVLW k ; RETURN to RETLW
  var @ipic18AbstractBlockTerminator optimizedTerminator = self.mTerminator
  if ([optimizedInstructionList length] > 0) & (self.mTerminator is >= @ipic18ReturnTerminator) then
    [optimizedInstructionList last ?let @ipic18SequentialInstruction lastInstruction ?2*]
    if let op = lastInstruction as @ipic18_intermediate_instruction_literalOperation then
#    case == @ipic18_intermediate_instruction_literalOperation op :
      if inOptimizeFlagStruct.mMOVLWfollowedByRETreplacedByRETLW & (op.mLiteralInstruction == @literal_instruction_opcode. MOVLW) then
        [!?optimizedInstructionList popLast ?3*]
        optimizedTerminator = @ipic18RetlwTerminator. new { !op.mInstructionLocation !op.mLiteralValue}
        optimized = true
        ioListFileContents += "  [M] " + self.mLabel + ": MOVLW k ; RETURN --> RETLW k\n"
      end
  #--- Transform JSR label ; RETURN to JUMP label
    elsif let jsr = lastInstruction as @ipic18_intermediate_JSR then
#    case == @ipic18_intermediate_JSR jsr :
      if inOptimizeFlagStruct.mJSRfollowedByRETreplacedByJUMP then
        [!?optimizedInstructionList popLast ?3*]
        optimizedTerminator = @ipic18JumpTerminator.new {!jsr.mInstructionLocation !jsr.mTargetLabel !jsr.mKind}
        optimized = true
        ioListFileContents += "  [J] " + self.mLabel + ": JSR " + jsr.mTargetLabel + " ; RETURN --> JUMP " + jsr.mTargetLabel + "\n"
      end
  #--- Transform computed rcall ; RETURN to computed bra
#    case == @ipic18_intermediate_instruction_computed_rcall computedRCALL :
#      if inOptimizeFlagStruct.mComputedRCALLFollowedByRETURNreplacedByComputedBRA then
#        [!?optimizedInstructionList popLast ?*]
#        optimizedTerminator = @ipic18ComputedBraTerminator.new {
#          ![computedRCALL mInstructionLocation]
#          ![computedRCALL mTargetLabels]
#          ![computedRCALL mKind]
#         }
#        optimized = true
#        ioListFileContents += "  [J] " + mLabel + ": JSR " + [jsr mTargetLabel] + " ; RETURN --> JUMP " + [jsr mTargetLabel] + "\n"
#      end
    else
    end
  end
#--- Optimize terminator 
# DO NOT OPTIMIZE WHEN TERMINATOR HAS BEEN CHANGED IN PREVIOUS INSTRUCTIONS
  if not optimized then
    [self.mTerminator optimizeTerminator
      !inSymbolTable
      !inOptimizeFlagStruct
      !inBlockList
      !self.mLabel.string
      !?optimized
      !?ioListFileContents
      ?optimizedTerminator
    ]
  end
#--- Return optimized block
  if optimized then
    ioOptimizationDone = true
    outOptimizedBlock = @ipic18Block. new {
      !self.mAddress
      !self.mLabel
      !optimizedInstructionList
      !optimizedTerminator
      !@uint.max
      !0
    }
  else
    outOptimizedBlock = self
  end
}

#----------------------------------------------------------------------------*

#!optimizeFlagStruct

#----------------------------------------------------------------------------*

struct @optimizeFlagStruct {
 public var @bool mRemoveEmptyRoutine # [E]
 public var @bool mJSRtoRETLWreplacedByMOVLW # [R]
 public var @bool mJSRfollowedByRETreplacedByJUMP # [J]
 public var @bool mMOVLWfollowedByRETreplacedByRETLW # [M]
 public var @bool mJSRtoOneInstructionRoutineReplacedByInstruction # [I]
 public var @bool mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction # [i]
 public var @bool mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank # [e]
# @bool mComputedRCALLFollowedByRETURNreplacedByComputedBRA # [c]
}

#----------------------------------------------------------------------------*

getter @bool flagValue ->@string outResult {
  outResult = if self then "enabled" else "disabled" end
}

#----------------------------------------------------------------------------*

proc ipic18OptimizeBlocks
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList {
#--- Optimization flags
  let optimizeFlagStruct = @optimizeFlagStruct.new {
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'E'] # [E]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'R'] # [R]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'J'] # [J]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'M'] # [M]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'I'] # [I]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'i'] # [i]
    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'e'] # [e]
#    ![option piccolo_options.performOptimizations value] | [[option piccolo_options.optimizationFlags value] containsCharacter !'c'] # [c]
  }
#---
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  ioListFileContents += "*" + ["BLOCK REPRESENTATION OPTIMIZATION" stringByLeftAndRightPadding !117 !' '] + "*\n"
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  ioListFileContents += "Optimization flags:\n"
#  ioListFileContents += "  [c] computed RCALL followed by RETURN replaced by computed BRA: " + [optimizeFlagStruct.mComputedRCALLFollowedByRETURNreplacedByComputedBRA flagValue] + "\n"
  ioListFileContents += "  [D] Dead code elimination: always enabled\n"
  ioListFileContents += "  [E] Empty routine elimination: " + [optimizeFlagStruct.mRemoveEmptyRoutine flagValue] + "\n"
  ioListFileContents += "  [e] In Computed RCALL, empty routine call replaced by BLANK: " + [optimizeFlagStruct.mJSRtoEmptyRoutineInComputedRCALLreplacedByBlank flagValue] + "\n"
  ioListFileContents += "  [I] Call to one instruction routine replaced by instruction: " + [optimizeFlagStruct.mJSRtoOneInstructionRoutineReplacedByInstruction flagValue] + "\n"
  ioListFileContents += "  [i] In Computed RCALL, rcall to one instruction routine replaced by instruction: " + [optimizeFlagStruct.mJSRtoOneInstructionRoutineInComputedRCALLreplacedByInstruction flagValue] + "\n"
  ioListFileContents += "  [J] JSR followed by RETURN replaced by JUMP: " + [optimizeFlagStruct.mJSRfollowedByRETreplacedByJUMP flagValue] + "\n"
  ioListFileContents += "  [M] MOVLW followed by RETURN replaced by RETLW: " + [optimizeFlagStruct.mMOVLWfollowedByRETreplacedByRETLW flagValue] + "\n"
  ioListFileContents += "  [P] JUMP propagation: always enabled\n"
  ioListFileContents += "  [R] Call to RETLW replaced by MOVLW: " + [optimizeFlagStruct.mJSRtoRETLWreplacedByMOVLW flagValue] + "\n"
  ioListFileContents += "  [U] Useless test elimination: always enabled\n"
  if @application.verboseOutput then
    message "Optimizations:\n"
  end
#--- Optimizations loops
  var @bool optimizationDone = true
  var @uint optimizationPass = 0
  loop( [ioGeneratedBlockList length] + 1)
  while optimizationDone & (@uint. errorCount == 0) do
    optimizationDone = false
    optimizationPass = optimizationPass + 1
    ioListFileContents += "\n--- Pass " + optimizationPass + " (" + [ioGeneratedBlockList length] + " blocks)\n"
    let @uint blockCountBeforeOptimization = [ioGeneratedBlockList length]
    if @application.verboseOutput then
      message "  Pass " + optimizationPass + " : " + blockCountBeforeOptimization + " blocks.\n"
    end
  #-------------------------------- Build label map
    var symbolTable =@symbolTableForBlockOptimization.emptyMap{}
    for (mBlock) in  ioGeneratedBlockList do(blockIndex)
      [!?symbolTable insertKey !mBlock.mLabel !blockIndex]
    end
  #-------------------------------- Build referenced label set
    var referencedBlockSet =@stringset.emptySet{}
    for (mBlock) in  ioGeneratedBlockList do
      if mBlock.mAddress != @uint. max then # Only absolute blocks
        [mBlock enterReferencedLabels
          !symbolTable
          !ioGeneratedBlockList
          !?referencedBlockSet
        ]
      end
    end
  #-------------------------------- Optimize blocks
    var optimizedBlockList =@ipic18BlockList.emptyList{}
    for (mBlock) in  ioGeneratedBlockList do
      if [referencedBlockSet hasKey !mBlock.mLabel.string] | (mBlock.mAddress != @uint. max) then
        [mBlock optimize
          !symbolTable
          !optimizeFlagStruct
          !ioGeneratedBlockList
          !?optimizationDone
          !?ioListFileContents
          ?let @ipic18Block optimizedBlock
        ]
        optimizedBlockList += !optimizedBlock
      else
        ioListFileContents += "  [D] " + mBlock.mLabel + ": not referenced, deleted\n"
        optimizationDone = true
      end
    end
    ioGeneratedBlockList = optimizedBlockList
  end
  ioListFileContents += "  No optimization.\n\n"
  if @application.verboseOutput then
    message "\n"
  end
}

#----------------------------------------------------------------------------*


