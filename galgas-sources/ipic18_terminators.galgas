

#----------------------------------------------------------------------------*

#!Abstract readers

#----------------------------------------------------------------------------*

abstract getter @ipic18AbstractBlockTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string

#----------------------------------------------------------------------------*

abstract getter @ipic18AbstractBlockTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint

#----------------------------------------------------------------------------*

#!Terminator @ipic18ReturnTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETURN"
}

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    RETURN"
    !@uintlist. listWithValue { !0x0012}}
}

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ReturnTerminator)
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18RetfieTerminator

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETFIE"
  if mFastReturn then
    outResult += " FAST"
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    " + [self terminatorDisplay !inNextBlockLabel]
    !@uintlist. listWithValue { !if mFastReturn then 0x0011 else 0x0010 end}}
}

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18RetfieTerminator)
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18RetlwTerminator

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETLW " + [mLiteralValue hexString]
}

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    " +[self terminatorDisplay !inNextBlockLabel]
    !@uintlist. listWithValue { !0x0C00 | mLiteralValue}}
}

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
#  outResult = (inTerminator is == @ipic18RetlwTerminator)
#  if outResult then
#    let @ipic18RetlwTerminator t = ( inTerminator as @ipic18RetlwTerminator)
#    outResult = mLiteralValue == [t mLiteralValue]
#  end

  if let t = inTerminator as @ipic18RetlwTerminator then
    outResult = mLiteralValue == [t mLiteralValue]
  else
    outResult = false
  end
}

#----------------------------------------------------------------------------*

#!@ipic18JumpTerminator

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  if mLabel.string == inNextBlockLabel then
    outSize = 0
  else
    switch mKind
    case ipicRelative, relative :
      outSize = 2
    case absolute :
      outSize = 4
    end  
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
{
  if mLabel.string != inNextBlockLabel then
    switch mKind
    case ipicRelative, relative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !mLabel !inAddress) then
        ioOverflowMap += !inBlockLabel !mLabel.string
      end
    case absolute :
    end  
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if inNextBlockLabel != mLabel.string then
    switch mKind
    case ipicRelative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !mLabel !inAddress) then
        ioConversionCount ++
        ioListFileContents += "  " + inBlockLabel + ": JUMP " + mLabel + " --> GOTO " + mLabel + "\n"
        outModifiedTerminator = @ipic18JumpTerminator. new { !mInstructionLocation !mLabel !@jumpInstructionKind. absolute}
      end
    case relative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !mLabel !inAddress) then
        error mInstructionLocation: "displacement ("
        + pic18_BRA_RCALL_displacement (!inSymbolTable !mLabel !inAddress) + ") too large for BRA "
        + mLabel + " instruction (limited to [-1024, 1023])"
      end
    case absolute : # Allways ok
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  @string name
  switch mKind
    case ipicRelative : name = "JUMP "
    case relative     : name = "BRA "
    case absolute     : name = "GOTO "
  end
  if inNextBlockLabel == mLabel.string then
    outResult = "(" + name + mLabel + ")"
  else
    outResult = name + mLabel
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  if mLabel.string == inNextBlockLabel then
    outCode = @codeList. emptyList
  else
    [inSymbolTable searchKey !mLabel ?let @uint targetAddress]
    switch mKind
    case ipicRelative, relative :
      outCode = pic18_BRA_instruction_code (!inAddress !targetAddress !mLabel)
    case absolute :
      outCode = pic18_GOTO_instruction_code (!targetAddress !mLabel)
    end  
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
#  outResult = (inTerminator is == @ipic18JumpTerminator)
#  if outResult then
#    let @ipic18JumpTerminator t = ( inTerminator as @ipic18JumpTerminator)
#    outResult = (mLabel.string == [t mLabel].string) & (mKind == [t mKind])
#  end

  if let t = inTerminator as @ipic18JumpTerminator then
    outResult = (mLabel.string == [t mLabel].string) & (mKind == [t mKind])
  else
    outResult = false
  end
}

#----------------------------------------------------------------------------*

#!@ipic18AbstractConditionTerminator

#----------------------------------------------------------------------------*

override getter @ipic18AbstractConditionTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel]    
}

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  [mSingleInstructionTerminatorIfConditionTrue terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ]
  [mSingleInstructionTerminatorIfConditionFalse terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ]
}

#----------------------------------------------------------------------------*

#!Terminator @pic18RegisterComparisonTerminator

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]    
}

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = [mRegisterDescription mAssemblyString] + " "
  switch mComparison
  case registerEqualsToW :
    outResult += "=="
  case registerGreaterThanW :
    outResult += ">"
  case registerLowerThanW :
    outResult += "<"
  end
  outResult += " W ? "
  outResult += [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""]
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18RegisterComparisonTerminator. new {
      !mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mComparison}
  end
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode
{
  @uint binCode
  @string assemblyCode
  switch mComparison
  case registerEqualsToW :
    binCode = 0x6200
    assemblyCode = "    CPFSEQ"
  case registerGreaterThanW :
    binCode = 0x6400
    assemblyCode = "    CPFSGT"
  case registerLowerThanW :
    binCode = 0x6000
    assemblyCode = "    CPFSLT"
  end
  assemblyCode += " " + [mRegisterDescription mAssemblyString]
  binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
  if [mRegisterDescription mNeedsBSR] then
    binCode = binCode | 0x0100
    assemblyCode += ", BSR_ACCESS"
  end
  outCode = @codeList.listWithValue {
    !assemblyCode
    !@uintlist.listWithValue {!binCode}
  }
  [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ?let @codeList falseTerminatorCode
   ]
   outCode += falseTerminatorCode
  [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ?let @codeList trueTerminatorCode
   ]
   outCode += trueTerminatorCode
}

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18RegisterComparisonTerminator)
  if outResult then
    let @pic18RegisterComparisonTerminator t = ( inTerminator as @pic18RegisterComparisonTerminator)
    outResult = [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]]
    if outResult then
      outResult = [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]]
    end
    if outResult then
      outResult = mComparison == [t mComparison]
    end
    if outResult then
      outResult = [mRegisterDescription isEqualToRegister ![t mRegisterDescription]]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @pic18TestRegisterTerminator

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]    
}

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = [mRegisterDescription mAssemblyString]
  outResult += " Z ? "
  outResult += [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""]
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18TestRegisterTerminator. new {
      !mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !mRegisterDescription}
  end
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  @uint binCode = 0x6600
  @string assemblyCode = "    TSTFSZ " + [mRegisterDescription mAssemblyString]
  binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
  if [mRegisterDescription mNeedsBSR] then
    binCode = binCode | 0x0100
    assemblyCode += ", BSR_ACCESS"
  end
  outCode = @codeList. listWithValue {
    !assemblyCode
    !@uintlist. listWithValue { !binCode}}
#--- Generate complementary code (true terminator first terminator)
  [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ?let @codeList falseTerminatorCode
   ]
   outCode += falseTerminatorCode
  [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ?let @codeList trueTerminatorCode
   ]
   outCode += trueTerminatorCode
}

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18TestRegisterTerminator)
  if outResult then
    let @pic18TestRegisterTerminator t = ( inTerminator as @pic18TestRegisterTerminator)
    outResult = [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]]
    if outResult then
      outResult = [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]]
    end
    if outResult then
      outResult = [mRegisterDescription isEqualToRegister ![t mRegisterDescription]]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @pic18BitTestTerminator

#----------------------------------------------------------------------------*

override getter @pic18BitTestTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = [mRegisterDescription mAssemblyString] + "." + [mBitNumber string] + " ? "
  outResult += [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel]
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18BitTestTerminator. new {
      !mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mBitNumber}
  end
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode
{
  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode = 0xB000
    @string assemblyCode = "    BTFSC " + [mRegisterDescription mAssemblyString] + ", " + mBitNumber
    binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
    binCode = binCode | (mBitNumber << 9)
    if [mRegisterDescription mNeedsBSR] then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode = 0xA000
    @string assemblyCode = "    BTFSS " + [mRegisterDescription mAssemblyString] + ", " + mBitNumber
    binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
    binCode = binCode | (mBitNumber << 9)
    if [mRegisterDescription mNeedsBSR] then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ?let @codeList trueTerminatorCode
     ]
     outCode += trueTerminatorCode
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  end
}

#----------------------------------------------------------------------------*

override getter @pic18BitTestTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18BitTestTerminator)
  if outResult then
    let @pic18BitTestTerminator t = ( inTerminator as @pic18BitTestTerminator)
    outResult = [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]]
    if outResult then
      outResult = [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]]
    end
    if outResult then
      outResult = mBitNumber == [t mBitNumber]
    end
    if outResult then
      outResult = [mRegisterDescription isEqualToRegister ![t mRegisterDescription]]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18IncDecRegisterTerminator

#----------------------------------------------------------------------------*

override getter @ipic18IncDecRegisterTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  if mIncrement then
    outResult = "INCF "
  else
    outResult = "DECF "
  end
  outResult += [mRegisterDescription mAssemblyString]
  if m_W_isDestination then
    outResult += ", W"
  else
    outResult += ", F"
  end
  outResult += " Z ? "
  outResult += [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel]
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?var @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @ipic18IncDecRegisterTerminator. new {
      !mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination}
  end
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode =        if mIncrement then 0x3C00   else 0x2C00 end
    @string assemblyCode = if mIncrement then "    INCFSZ" else "    DECFSZ" end
    assemblyCode += " " + [mRegisterDescription mAssemblyString]
    binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
    if m_W_isDestination then
      assemblyCode += ", W"
    else
      binCode = binCode | 0x0200
      assemblyCode += ", F"
    end
    if [mRegisterDescription mNeedsBSR] then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode =        if mIncrement then 0x4800   else 0x4C00 end
    @string assemblyCode = if mIncrement then "    INFSNZ" else "    DCFSNZ" end
    assemblyCode += " " + [mRegisterDescription mAssemblyString]
    binCode = binCode | ([mRegisterDescription mRegisterAddress] & 255)
    if m_W_isDestination then
      assemblyCode += ", W"
    else
      binCode = binCode | 0x0200
      assemblyCode += ", F"
    end
    if [mRegisterDescription mNeedsBSR] then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ?let @codeList trueTerminatorCode
     ]
     outCode += trueTerminatorCode
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18IncDecRegisterTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18IncDecRegisterTerminator)
  if outResult then
    let @ipic18IncDecRegisterTerminator t = ( inTerminator as @ipic18IncDecRegisterTerminator)
    outResult = [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]]
    if outResult then
      outResult = [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]]
    end
    if outResult then
      outResult = mIncrement == [t mIncrement]
    end
    if outResult then
      outResult = m_W_isDestination == [t m_W_isDestination]
    end
    if outResult then
      outResult = [mRegisterDescription isEqualToRegister ![t mRegisterDescription]]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedRETLWTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 2 * [mLiteralValues length]
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED RETLW"
  for () in  mLiteralValues do
    outResult += " " + [mValue hexString]
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioConversionCount ++
      ioListFileContents += "  " + inBlockLabel + ": computed RETLW needs CALL _computed_goto_2\n"
      outModifiedTerminator = @ipic18ComputedRETLWTerminator. new { !mInstructionLocation !mLiteralValues !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2"
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto2label = ["_computed_goto_2" nowhere]
  [inSymbolTable searchKey !goto2label ?let @uint targetAddress]
  if mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto2label)
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto2label)
  end
  for () in  mLiteralValues do
    outCode +=
      !"    RETLW " + [mValue hexString]
      !@uintlist. listWithValue { !0x0C00 | mValue}
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedRETLWTerminator)
  if outResult then
    let @ipic18ComputedRETLWTerminator t = ( inTerminator as @ipic18ComputedRETLWTerminator)
    outResult = [mLiteralValues length] == [[t mLiteralValues] length]
    for () in  mLiteralValues, () t_ in  [t mLiteralValues] while outResult do
      outResult = mValue == t_mValue
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedGotoTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED GOTO "
  if mUsesRCALL then
    outResult += " (uses RCALL)"
  else
    outResult += " (uses CALL)"
  end
  for () in  mTargetLabels do
    outResult += " " + mValue
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 4 * [mTargetLabels length]
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioConversionCount ++
      ioListFileContents += "  " + inBlockLabel + ": computed GOTO needs CALL _computed_goto_4\n"
      outModifiedTerminator = @ipic18ComputedGotoTerminator. new { !mInstructionLocation !mTargetLabels !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_4" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_4"
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto4label = ["_computed_goto_4" nowhere]
  [inSymbolTable searchKey !goto4label ?let @uint targetAddress]
  if mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto4label)
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto4label)
  end
  for () in  mTargetLabels do
    [inSymbolTable searchKey !mValue ?let @uint targetLabelAddress]
    outCode += pic18_GOTO_instruction_code (!targetLabelAddress !mValue)
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedGotoTerminator)
  if outResult then
    let @ipic18ComputedGotoTerminator t = ( inTerminator as @ipic18ComputedGotoTerminator)
    outResult = [mTargetLabels length] == [[t mTargetLabels] length]
    for () in  mTargetLabels, () t_ in  [t mTargetLabels] while outResult do
      outResult = mValue.string == t_mValue.string
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedBraTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 2 * [mTargetLabels length]
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED BRA"
  for () in  mTargetLabels do
    outResult += " " + mValue
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  for () in  mTargetLabels do
    if not pic18_checkBRA_RCALL (!inSymbolTable !mValue !inAddress) then
      error mInstructionLocation: "displacement ("
      + pic18_BRA_RCALL_displacement (!inSymbolTable !mValue !inAddress) + ") too large for rcall "
      + mValue + " instruction (limited to [-1024, 1023])"
    end
  end
  outModifiedTerminator = self
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress ) then
      ioConversionCount ++
      ioListFileContents += "  " + inBlockLabel + ": computed RETLW needs CALL _computed_goto_2\n"
      outModifiedTerminator = @ipic18ComputedBraTerminator. new { !mInstructionLocation !mTargetLabels !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  @uint address
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2"
    end
    address = inAddress + 2
  else
    address = inAddress + 4
  end
  for () in  mTargetLabels do
    if not pic18_checkBRA_RCALL (!inSymbolTable !mValue !address) then
      ioOverflowMap += !inBlockLabel !mValue.string
    end
    address = address + 2
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto2label = ["_computed_goto_2" nowhere]
  [inSymbolTable searchKey !goto2label ?let @uint targetAddress]
  @uint address
  if mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto2label)
    address = inAddress + 2
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto2label)
    address = inAddress + 4
  end
  for () in  mTargetLabels do
    [inSymbolTable searchKey !mValue ?let @uint labelAddress]
    outCode += pic18_BRA_instruction_code (!address !labelAddress !mValue)
    address = address + 2
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedBraTerminator)
  if outResult then
    let @ipic18ComputedBraTerminator t = ( inTerminator as @ipic18ComputedBraTerminator)
    outResult = [mTargetLabels length] == [[t mTargetLabels] length]
    for () in  mTargetLabels, () t_ in  [t mTargetLabels] while outResult do
      outResult = mValue.string == t_mValue.string
    end
  end
}


#----------------------------------------------------------------------------*

#!Terminator @ipic18ConditionalBranchTerminator

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator terminatorDisplay
#  ??@string inNextBlockLabel
#  ->@string outResult
#:
#  switch mConditionalBranch
#  when bz : outResult := "Z" ;
#  when bn  : outResult := "N" ;
#  when bc :  outResult := "C" ;
#  when bov :  outResult := "OV" ;
#  when bnz : outResult := "NZ" ;
#  when bnn  : outResult := "NN" ;
#  when bnc :  outResult := "NC" ;
#  when bnov :  outResult := "NOV" ;
#  end switch ;
#  outResult .= " ? " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
#  outResult .= " : " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
#end reader ;

#----------------------------------------------------------------------------*

#override method @ipic18ConditionalBranchTerminator generateTerminatorCode
#  ??@uint inAddress
#  ??@symbolTableForRelativesResolution inSymbolTable
#  ??@string inNextBlockLabel
#  !@codeList outCode
#:
#  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionFalse is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : !Bcc F
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#    else # False terminator is not a jump : just skip it : Bcc T ; <<false terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#      [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  elsif [mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionTrue is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : Bcc T
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#    else # True terminator is not a jump : just skip it : !Bcc f ; <<true terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#      [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  else
#  
#  end if ;
#end method ;

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator isEqualToTerminator
#  ??@ipic18AbstractBlockTerminator inTerminator
#  -> @bool outResult
#:
#  outResult := (inTerminator is == @ipic18ConditionalBranchTerminator) ;
#  if outResult then
#    const @ipic18ConditionalBranchTerminator t := (cast inTerminator : @ipic18ConditionalBranchTerminator) ;
#    outResult := mConditionalBranch == [t mConditionalBranch] ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
#    end if ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
#    end if ;
#  end if ;
#end reader ;


#----------------------------------------------------------------------------*

#!Terminator @ipic18ConditionalJumpTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  switch mConditionalBranch
  case bz : outResult = "Z"
  case bn  : outResult = "N"
  case bc :  outResult = "C"
  case bov :  outResult = "OV"
  case bnz : outResult = "NZ"
  case bnn  : outResult = "NN"
  case bnc :  outResult = "NC"
  case bnov :  outResult = "NOV"
  end
  outResult += " ? "
  if mTargetLabelWhenTrue.string == inNextBlockLabel then
    outResult += "(" + mTargetLabelWhenTrue.string + ")"
  else
    outResult += mTargetLabelWhenTrue.string
  end
  outResult += " : "
  if mTargetLabelWhenFalse.string == inNextBlockLabel then
    outResult += "(" + mTargetLabelWhenFalse.string + ")"
  else
    outResult += mTargetLabelWhenFalse.string
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  @conditionalBranchMode branchModeOnFalseLabel = mBranchModeOnFalseLabel
  @conditionalBranchMode branchModeOnTrueLabel = mBranchModeOnTrueLabel
  if mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    case native : # !Bcc F
      if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenFalse !inAddress) then
        branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
        ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
      end
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2) then
        branchModeOnFalseLabel = @conditionalBranchMode. ipicGOTO
        ioListFileContents += "  " + inBlockLabel + ", terminator will use GOTO " + mTargetLabelWhenFalse + "\n"
      end
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end
  elsif mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    case native : # Bcc T
      if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
        branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
        ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
      end
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2) then
        branchModeOnTrueLabel = @conditionalBranchMode. ipicGOTO
        ioListFileContents += "  " + inBlockLabel + ", terminator will use GOTO " + mTargetLabelWhenTrue + "\n"
      end
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch mBranchModeOnFalseLabel
    case native :
      switch mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenFalse !inAddress) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+2) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenTrue + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
        end
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+4) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenFalse + "\n"
        end
      end
    case ipicGOTO :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenTrue + "\n"
        end
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+6) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
  if (branchModeOnFalseLabel == mBranchModeOnFalseLabel) & (branchModeOnTrueLabel == mBranchModeOnTrueLabel) then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @ipic18ConditionalJumpTerminator. new {
      !mInstructionLocation
      !mConditionalBranch
      !mTargetLabelWhenTrue
      !branchModeOnTrueLabel
      !mTargetLabelWhenFalse
      !branchModeOnFalseLabel}
    ioConversionCount ++
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    case native : # !Bcc F
      if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenFalse !inAddress) then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
      end
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2) then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
      end
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end
  elsif mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    case native : # Bcc T
      if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
      end
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2) then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
      end
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch mBranchModeOnFalseLabel
    case native :
      switch mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenFalse !inAddress) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+2) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
        end
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+4) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse.string
        end
      end
    case ipicGOTO :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        if not pic18_checkBCC (!inSymbolTable !mTargetLabelWhenTrue !inAddress) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
        end
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !mTargetLabelWhenTrue !inAddress+6) then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  if mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    case native  : outSize = 2  # !Bcc F
    case ipicBRA  : outSize = 4 # Bcc Z ; BRA F ; Z:
    case ipicGOTO : outSize = 6 # Bcc Z ; GOTO F ; Z:
    end
  elsif mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    case native   : outSize = 2 # Bcc T
    case ipicBRA  : outSize = 4 # !Bcc Z ; BRA T ; Z:
    case ipicGOTO : outSize = 6 # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch mBranchModeOnFalseLabel
    case native :
      switch mBranchModeOnTrueLabel
      case native, ipicBRA : outSize = 4 # !Bcc F ; BRA T
      case ipicGOTO : outSize = 6 # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch mBranchModeOnTrueLabel
      case native   : outSize = 4 # Bcc T ; BRA F
      case ipicBRA  : outSize = 6 # Bcc Z ; BRA F ; Z: BRA T
      case ipicGOTO : outSize = 8 # Bcc Z ; BRA F ; Z: GOTO T
      end
    case ipicGOTO :
      switch mBranchModeOnTrueLabel
      case native   : outSize = 6 # Bcc T ; GOTO F
      case ipicBRA  : outSize = 8 # Bcc Z ; GOTO F ; Z: BRA T
      case ipicGOTO : outSize = 10 # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  [inSymbolTable searchKey !mTargetLabelWhenTrue  ?let @uint trueTargetAddress]
  [inSymbolTable searchKey !mTargetLabelWhenFalse ?let @uint falseTargetAddress]
  let Zlabel = @lstring.new { !"_Bcc_" + [inAddress xString] !mInstructionLocation}
  if mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    case native : # !Bcc F
      outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true)
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !false)
      outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse)
      outCode += pic18_definition_label (!Zlabel)
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !false)
      outCode += pic18_GOTO_instruction_code (!falseTargetAddress !mTargetLabelWhenFalse)
      outCode += pic18_definition_label (!Zlabel)
    end
  elsif mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    case native : # Bcc T
      outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !false)
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true)
      outCode += pic18_BRA_instruction_code (!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue)
      outCode += pic18_definition_label (!Zlabel)
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true)
      outCode += pic18_GOTO_instruction_code (!trueTargetAddress !mTargetLabelWhenTrue)
      outCode += pic18_definition_label (!Zlabel)
    end
  else
    switch mBranchModeOnFalseLabel
    case native :
      switch mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue)
      case ipicGOTO : # !Bcc F ; GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !mTargetLabelWhenTrue)
      end
    case ipicBRA :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse)
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_BRA_instruction_code (!inAddress !trueTargetAddress !mTargetLabelWhenTrue)
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !mTargetLabelWhenTrue)
      end
    case ipicGOTO :
      switch mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !mTargetLabelWhenFalse)
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_BRA_instruction_code (!inAddress+6 !trueTargetAddress !mTargetLabelWhenTrue)
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !mTargetLabelWhenTrue)
      end
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ConditionalJumpTerminator)
  if outResult then
    let @ipic18ConditionalJumpTerminator t = ( inTerminator as @ipic18ConditionalJumpTerminator)
    outResult = mConditionalBranch == [t mConditionalBranch]
    if outResult then
      outResult = mTargetLabelWhenTrue.string == [t mTargetLabelWhenTrue].string
    end
    if outResult then
      outResult = mBranchModeOnTrueLabel == [t mBranchModeOnTrueLabel]
    end
    if outResult then
      outResult = mTargetLabelWhenFalse.string == [t mTargetLabelWhenFalse].string
    end
    if outResult then
      outResult = mBranchModeOnFalseLabel == [t mBranchModeOnFalseLabel]
    end
  end
}

#----------------------------------------------------------------------------*

