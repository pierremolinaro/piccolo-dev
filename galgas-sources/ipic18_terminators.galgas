

#----------------------------------------------------------------------------*

#!Abstract readers

#----------------------------------------------------------------------------*

abstract getter @ipic18AbstractBlockTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string

#----------------------------------------------------------------------------*

abstract getter @ipic18AbstractBlockTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint

#----------------------------------------------------------------------------*

#!Terminator @ipic18ReturnTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETURN"
}

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    RETURN"
    !@uintlist. listWithValue { !0x0012}}
}

#----------------------------------------------------------------------------*

override getter @ipic18ReturnTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ReturnTerminator)
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18RetfieTerminator

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETFIE"
  if self.mFastReturn then
    outResult += " FAST"
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    " + [self terminatorDisplay !inNextBlockLabel]
    !@uintlist. listWithValue { !if self.mFastReturn then 0x0011 else 0x0010 end}}
}

#----------------------------------------------------------------------------*

override getter @ipic18RetfieTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18RetfieTerminator)
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18RetlwTerminator

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "RETLW " + [self.mLiteralValue hexString]
}

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  outSize = 2
}

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator generateTerminatorCode
  ?let @uint unused inAddress
  ?let @symbolTableForRelativesResolution unused inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  outCode = @codeList. listWithValue {
    !"    " +[self terminatorDisplay !inNextBlockLabel]
    !@uintlist. listWithValue { !0x0C00 | self.mLiteralValue}}
}

#----------------------------------------------------------------------------*

override getter @ipic18RetlwTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
#  outResult = (inTerminator is == @ipic18RetlwTerminator)
#  if outResult then
#    let @ipic18RetlwTerminator t = ( inTerminator as @ipic18RetlwTerminator)
#    outResult = mLiteralValue == [t mLiteralValue]
#  end

  if let t = inTerminator as @ipic18RetlwTerminator then
    outResult = self.mLiteralValue == t.mLiteralValue
  else
    outResult = false
  end
}

#----------------------------------------------------------------------------*

#!@ipic18JumpTerminator

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  if self.mLabel.string == inNextBlockLabel then
    outSize = 0
  else
    switch self.mKind
    case ipicRelative, relative :
      outSize = 2
    case absolute :
      outSize = 4
    end  
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
{
  if self.mLabel.string != inNextBlockLabel then
    switch self.mKind
    case ipicRelative, relative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mLabel !inAddress) then
        ioOverflowMap += !inBlockLabel !self.mLabel.string
      end
    case absolute :
    end  
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if inNextBlockLabel != self.mLabel.string then
    switch self.mKind
    case ipicRelative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mLabel !inAddress) then
        ioConversionCount += 1
        ioListFileContents += "  " + inBlockLabel + ": JUMP " + self.mLabel + " --> GOTO " + self.mLabel + "\n"
        outModifiedTerminator = @ipic18JumpTerminator. new { !self.mInstructionLocation !self.mLabel !@jumpInstructionKind. absolute}
      end
    case relative :
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mLabel !inAddress) then
        error self.mInstructionLocation: "displacement ("
        + pic18_BRA_RCALL_displacement (!inSymbolTable !self.mLabel !inAddress) + ") too large for BRA "
        + self.mLabel + " instruction (limited to [-1024, 1023])"
      end
    case absolute : # Allways ok
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  let @string name
  switch self.mKind
    case ipicRelative : name = "JUMP "
    case relative     : name = "BRA "
    case absolute     : name = "GOTO "
  end
  if inNextBlockLabel == self.mLabel.string then
    outResult = "(" + name + self.mLabel + ")"
  else
    outResult = name + self.mLabel
  end
}

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  if self.mLabel.string == inNextBlockLabel then
    outCode = @codeList. emptyList
  else
    [inSymbolTable searchKey !self.mLabel ?let @uint targetAddress]
    switch self.mKind
    case ipicRelative, relative :
      outCode = pic18_BRA_instruction_code (!inAddress !targetAddress !self.mLabel)
    case absolute :
      outCode = pic18_GOTO_instruction_code (!targetAddress !self.mLabel)
    end  
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18JumpTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
#  outResult = (inTerminator is == @ipic18JumpTerminator)
#  if outResult then
#    let @ipic18JumpTerminator t = ( inTerminator as @ipic18JumpTerminator)
#    outResult = (mLabel.string == [t mLabel].string) & (mKind == [t mKind])
#  end

  if let t = inTerminator as @ipic18JumpTerminator then
    outResult = (self.mLabel.string == t.mLabel.string) & (self.mKind == t.mKind)
  else
    outResult = false
  end
}

#----------------------------------------------------------------------------*

#!@ipic18AbstractConditionTerminator

#----------------------------------------------------------------------------*

override getter @ipic18AbstractConditionTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [self.mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel]    
}

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  [self.mSingleInstructionTerminatorIfConditionTrue terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ]
  [self.mSingleInstructionTerminatorIfConditionFalse terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ]
}

#----------------------------------------------------------------------------*

#!Terminator @pic18RegisterComparisonTerminator

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [self.mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]    
}

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = self.mRegisterDescription.mAssemblyString + " "
  switch self.mComparison
  case registerEqualsToW :
    outResult += "=="
  case registerGreaterThanW :
    outResult += ">"
  case registerLowerThanW :
    outResult += "<"
  end
  outResult += " W ? "
  outResult += [self.mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [self.mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""]
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [self.mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [self.mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18RegisterComparisonTerminator. new {
      !self.mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !self.mRegisterDescription
      !self.mComparison}
  end
}

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode
{
  var @uint binCode
  var @string assemblyCode
  switch self.mComparison
  case registerEqualsToW :
    binCode = 0x6200
    assemblyCode = "    CPFSEQ"
  case registerGreaterThanW :
    binCode = 0x6400
    assemblyCode = "    CPFSGT"
  case registerLowerThanW :
    binCode = 0x6000
    assemblyCode = "    CPFSLT"
  end
  assemblyCode += " " + self.mRegisterDescription.mAssemblyString
  binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
  if self.mRegisterDescription.mNeedsBSR then
    binCode = binCode | 0x0100
    assemblyCode += ", BSR_ACCESS"
  end
  outCode = @codeList.listWithValue {
    !assemblyCode
    !@uintlist.listWithValue {!binCode}
  }
  [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ?let @codeList falseTerminatorCode
   ]
   outCode += falseTerminatorCode
  [self.mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [self.mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ?let @codeList trueTerminatorCode
   ]
   outCode += trueTerminatorCode
}

#----------------------------------------------------------------------------*

override getter @pic18RegisterComparisonTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18RegisterComparisonTerminator)
  if outResult then
    let @pic18RegisterComparisonTerminator t = ( inTerminator as @pic18RegisterComparisonTerminator)
    outResult = [self.mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionTrue]
    if outResult then
      outResult = [self.mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionFalse]
    end
    if outResult then
      outResult = self.mComparison == t.mComparison
    end
    if outResult then
      outResult = [self.mRegisterDescription isEqualToRegister !t.mRegisterDescription]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @pic18TestRegisterTerminator

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  outSize = 2
    + [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [self.mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]    
}

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = self.mRegisterDescription.mAssemblyString
  outResult += " Z ? "
  outResult += [self.mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [self.mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""]
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [self.mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [self.mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18TestRegisterTerminator. new {
      !self.mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !self.mRegisterDescription}
  end
}

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  var @uint binCode = 0x6600
  var @string assemblyCode = "    TSTFSZ " + self.mRegisterDescription.mAssemblyString
  binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
  if self.mRegisterDescription.mNeedsBSR then
    binCode = binCode | 0x0100
    assemblyCode += ", BSR_ACCESS"
  end
  outCode = @codeList. listWithValue {
    !assemblyCode
    !@uintlist. listWithValue { !binCode}}
#--- Generate complementary code (true terminator first terminator)
  [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ?let @codeList falseTerminatorCode
   ]
   outCode += falseTerminatorCode
  [self.mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [self.mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ?let @codeList trueTerminatorCode
   ]
   outCode += trueTerminatorCode
}

#----------------------------------------------------------------------------*

override getter @pic18TestRegisterTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18TestRegisterTerminator)
  if outResult then
    let @pic18TestRegisterTerminator t = ( inTerminator as @pic18TestRegisterTerminator)
    outResult = [self.mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionTrue]
    if outResult then
      outResult = [self.mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionFalse]
    end
    if outResult then
      outResult = [self.mRegisterDescription isEqualToRegister !t.mRegisterDescription]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @pic18BitTestTerminator

#----------------------------------------------------------------------------*

override getter @pic18BitTestTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  outResult = self.mRegisterDescription.mAssemblyString + "." + [self.mBitNumber string] + " ? "
  outResult += [self.mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [self.mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel]
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [self.mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [self.mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @pic18BitTestTerminator. new {
      !self.mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !self.mRegisterDescription
      !self.mBitNumber}
  end
}

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode
{
  if [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    var @uint binCode = 0xB000
    var @string assemblyCode = "    BTFSC " + self.mRegisterDescription.mAssemblyString + ", " + self.mBitNumber
    binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
    binCode = binCode | (self.mBitNumber << 9)
    if self.mRegisterDescription.mNeedsBSR then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  else
  #--- Generate complementary code (true terminator first terminator)
    var @uint binCode = 0xA000
    var @string assemblyCode = "    BTFSS " + self.mRegisterDescription.mAssemblyString + ", " + self.mBitNumber
    binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
    binCode = binCode | (self.mBitNumber << 9)
    if self.mRegisterDescription.mNeedsBSR then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [self.mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ?let @codeList trueTerminatorCode
     ]
     outCode += trueTerminatorCode
    [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  end
}

#----------------------------------------------------------------------------*

override getter @pic18BitTestTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @pic18BitTestTerminator)
  if outResult then
    let @pic18BitTestTerminator t = ( inTerminator as @pic18BitTestTerminator)
    outResult = [self.mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionTrue]
    if outResult then
      outResult = [self.mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionFalse]
    end
    if outResult then
      outResult = self.mBitNumber == t.mBitNumber
    end
    if outResult then
      outResult = [self.mRegisterDescription isEqualToRegister !t.mRegisterDescription]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18IncDecRegisterTerminator

#----------------------------------------------------------------------------*

override getter @ipic18IncDecRegisterTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  if self.mIncrement then
    outResult = "INCF "
  else
    outResult = "DECF "
  end
  outResult += self.mRegisterDescription.mAssemblyString
  if self.m_W_isDestination then
    outResult += ", W"
  else
    outResult += ", F"
  end
  outResult += " Z ? "
  outResult += [self.mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel]
  outResult += " : "
  outResult += [self.mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel]
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  let @uint n = ioConversionCount
  [self.mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ]
  [self.mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?let @ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ]
  if ioConversionCount == n then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @ipic18IncDecRegisterTerminator. new {
      !self.mInstructionLocation
      !( outModifiedTrueTerminator as @ipic18SingleInstructionTerminator)
      !( outModifiedFalseTerminator as @ipic18SingleInstructionTerminator)
      !self.mRegisterDescription
      !self.mIncrement
      !self.m_W_isDestination}
  end
}

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  if [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    var @uint binCode =        if self.mIncrement then 0x3C00   else 0x2C00 end
    var @string assemblyCode = if self.mIncrement then "    INCFSZ" else "    DECFSZ" end
    assemblyCode += " " + self.mRegisterDescription.mAssemblyString
    binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
    if self.m_W_isDestination then
      assemblyCode += ", W"
    else
      binCode = binCode | 0x0200
      assemblyCode += ", F"
    end
    if self.mRegisterDescription.mNeedsBSR then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  else
  #--- Generate complementary code (true terminator first terminator)
    var @uint binCode =        if self.mIncrement then 0x4800   else 0x4C00 end
    var @string assemblyCode = if self.mIncrement then "    INFSNZ" else "    DCFSNZ" end
    assemblyCode += " " + self.mRegisterDescription.mAssemblyString
    binCode = binCode | (self.mRegisterDescription.mRegisterAddress & 255)
    if self.m_W_isDestination then
      assemblyCode += ", W"
    else
      binCode = binCode | 0x0200
      assemblyCode += ", F"
    end
    if self.mRegisterDescription.mNeedsBSR then
      binCode = binCode | 0x0100
      assemblyCode += ", BSR_ACCESS"
    end
    outCode = @codeList. listWithValue {
      !assemblyCode
      !@uintlist. listWithValue { !binCode}}
    [self.mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ?let @codeList trueTerminatorCode
     ]
     outCode += trueTerminatorCode
    [self.mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [self.mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ?let @codeList falseTerminatorCode
     ]
     outCode += falseTerminatorCode
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18IncDecRegisterTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18IncDecRegisterTerminator)
  if outResult then
    let @ipic18IncDecRegisterTerminator t = ( inTerminator as @ipic18IncDecRegisterTerminator)
    outResult = [self.mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionTrue]
    if outResult then
      outResult = [self.mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator !t.mSingleInstructionTerminatorIfConditionFalse]
    end
    if outResult then
      outResult = self.mIncrement == t.mIncrement
    end
    if outResult then
      outResult = self.m_W_isDestination == t.m_W_isDestination
    end
    if outResult then
      outResult = [self.mRegisterDescription isEqualToRegister !t.mRegisterDescription]
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedRETLWTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if self.mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 2 * [self.mLiteralValues length]
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED RETLW"
  for (mValue) in  self.mLiteralValues do
    outResult += " " + [mValue hexString]
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if self.mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioConversionCount += 1
      ioListFileContents += "  " + inBlockLabel + ": computed RETLW needs CALL _computed_goto_2\n"
      outModifiedTerminator = @ipic18ComputedRETLWTerminator. new { !self.mInstructionLocation !self.mLiteralValues !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if self.mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2"
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto2label = ["_computed_goto_2" nowhere]
  [inSymbolTable searchKey !goto2label ?let @uint targetAddress]
  if self.mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto2label)
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto2label)
  end
  for (mValue) in  self.mLiteralValues do
    outCode +=
      !"    RETLW " + [mValue hexString]
      !@uintlist. listWithValue { !0x0C00 | mValue}
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedRETLWTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedRETLWTerminator)
  if outResult then
    let @ipic18ComputedRETLWTerminator t = ( inTerminator as @ipic18ComputedRETLWTerminator)
    outResult = [self.mLiteralValues length] == [t.mLiteralValues length]
    for (mValue) in  self.mLiteralValues, (t_mValue) in  t.mLiteralValues while outResult do
      outResult = mValue == t_mValue
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedGotoTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED GOTO "
  if self.mUsesRCALL then
    outResult += " (uses RCALL)"
  else
    outResult += " (uses CALL)"
  end
  for (mValue) in  self.mTargetLabels do
    outResult += " " + mValue
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if self.mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 4 * [self.mTargetLabels length]
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  outModifiedTerminator = self
  if self.mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioConversionCount += 1
      ioListFileContents += "  " + inBlockLabel + ": computed GOTO needs CALL _computed_goto_4\n"
      outModifiedTerminator = @ipic18ComputedGotoTerminator. new { !self.mInstructionLocation !self.mTargetLabels !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if self.mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_4" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_4"
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto4label = ["_computed_goto_4" nowhere]
  [inSymbolTable searchKey !goto4label ?let @uint targetAddress]
  if self.mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto4label)
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto4label)
  end
  for (mValue) in  self.mTargetLabels do
    [inSymbolTable searchKey !mValue ?let @uint targetLabelAddress]
    outCode += pic18_GOTO_instruction_code (!targetLabelAddress !mValue)
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedGotoTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedGotoTerminator)
  if outResult then
    let @ipic18ComputedGotoTerminator t = ( inTerminator as @ipic18ComputedGotoTerminator)
    outResult = [self.mTargetLabels length] == [t.mTargetLabels length]
    for (mValue) in  self.mTargetLabels, (t_mValue) in  t.mTargetLabels while outResult do
      outResult = mValue.string == t_mValue.string
    end
  end
}

#----------------------------------------------------------------------------*

#!Terminator @ipic18ComputedBraTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator terminatorSize
  ?let @string unused inNextBlockLabel
  -> @uint outSize {
  if self.mUsesRCALL then
    outSize = 2
  else
    outSize = 4
  end
  outSize = outSize + 2 * [self.mTargetLabels length]
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator terminatorDisplay
  ?let @string unused inNextBlockLabel
  ->@string outResult {
  outResult = "COMPUTED BRA"
  for (mValue) in  self.mTargetLabels do
    outResult += " " + mValue
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  for (mValue) in  self.mTargetLabels do
    if not pic18_checkBRA_RCALL (!inSymbolTable !mValue !inAddress) then
      error self.mInstructionLocation: "displacement ("
      + pic18_BRA_RCALL_displacement (!inSymbolTable !mValue !inAddress) + ") too large for rcall "
      + mValue + " instruction (limited to [-1024, 1023])"
    end
  end
  outModifiedTerminator = self
  if self.mUsesRCALL then
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress ) then
      ioConversionCount += 1
      ioListFileContents += "  " + inBlockLabel + ": computed RETLW needs CALL _computed_goto_2\n"
      outModifiedTerminator = @ipic18ComputedBraTerminator. new { !self.mInstructionLocation !self.mTargetLabels !false}
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  var @uint address
  if self.mUsesRCALL then  
    if not pic18_checkBRA_RCALL (!inSymbolTable !["_computed_goto_2" nowhere] !inAddress) then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2"
    end
    address = inAddress + 2
  else
    address = inAddress + 4
  end
  for (mValue) in  self.mTargetLabels do
    if not pic18_checkBRA_RCALL (!inSymbolTable !mValue !address) then
      ioOverflowMap += !inBlockLabel !mValue.string
    end
    address = address + 2
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string unused inNextBlockLabel
  !@codeList outCode {
  let @lstring goto2label = ["_computed_goto_2" nowhere]
  [inSymbolTable searchKey !goto2label ?let @uint targetAddress]
  var @uint address
  if self.mUsesRCALL then
    outCode = pic18_RCALL_instruction_code (!inAddress !targetAddress !goto2label)
    address = inAddress + 2
  else
    outCode = pic18_CALL_instruction_code (!targetAddress !goto2label)
    address = inAddress + 4
  end
  for (mValue) in  self.mTargetLabels do
    [inSymbolTable searchKey !mValue ?let @uint labelAddress]
    outCode += pic18_BRA_instruction_code (!address !labelAddress !mValue)
    address = address + 2
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ComputedBraTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ComputedBraTerminator)
  if outResult then
    let @ipic18ComputedBraTerminator t = ( inTerminator as @ipic18ComputedBraTerminator)
    outResult = [self.mTargetLabels length] == [t.mTargetLabels length]
    for (mValue) in  self.mTargetLabels, (t_mValue) in  t.mTargetLabels while outResult do
      outResult = mValue.string == t_mValue.string
    end
  end
}


#----------------------------------------------------------------------------*

#!Terminator @ipic18ConditionalBranchTerminator

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator terminatorDisplay
#  ??@string inNextBlockLabel
#  ->@string outResult
#:
#  switch mConditionalBranch
#  when bz : outResult := "Z" ;
#  when bn  : outResult := "N" ;
#  when bc :  outResult := "C" ;
#  when bov :  outResult := "OV" ;
#  when bnz : outResult := "NZ" ;
#  when bnn  : outResult := "NN" ;
#  when bnc :  outResult := "NC" ;
#  when bnov :  outResult := "NOV" ;
#  end switch ;
#  outResult .= " ? " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
#  outResult .= " : " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
#end reader ;

#----------------------------------------------------------------------------*

#override method @ipic18ConditionalBranchTerminator generateTerminatorCode
#  ??@uint inAddress
#  ??@symbolTableForRelativesResolution inSymbolTable
#  ??@string inNextBlockLabel
#  !@codeList outCode
#:
#  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionFalse is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : !Bcc F
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#    else # False terminator is not a jump : just skip it : Bcc T ; <<false terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#      [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  elsif [mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionTrue is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : Bcc T
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#    else # True terminator is not a jump : just skip it : !Bcc f ; <<true terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#      [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  else
#  
#  end if ;
#end method ;

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator isEqualToTerminator
#  ??@ipic18AbstractBlockTerminator inTerminator
#  -> @bool outResult
#:
#  outResult := (inTerminator is == @ipic18ConditionalBranchTerminator) ;
#  if outResult then
#    const @ipic18ConditionalBranchTerminator t := (cast inTerminator : @ipic18ConditionalBranchTerminator) ;
#    outResult := mConditionalBranch == [t mConditionalBranch] ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
#    end if ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
#    end if ;
#  end if ;
#end reader ;


#----------------------------------------------------------------------------*

#!Terminator @ipic18ConditionalJumpTerminator

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator terminatorDisplay
  ?let @string inNextBlockLabel
  ->@string outResult {
  switch self.mConditionalBranch
  case bz : outResult = "Z"
  case bn  : outResult = "N"
  case bc :  outResult = "C"
  case bov :  outResult = "OV"
  case bnz : outResult = "NZ"
  case bnn  : outResult = "NN"
  case bnc :  outResult = "NC"
  case bnov :  outResult = "NOV"
  end
  outResult += " ? "
  if self.mTargetLabelWhenTrue.string == inNextBlockLabel then
    outResult += "(" + self.mTargetLabelWhenTrue.string + ")"
  else
    outResult += self.mTargetLabelWhenTrue.string
  end
  outResult += " : "
  if self.mTargetLabelWhenFalse.string == inNextBlockLabel then
    outResult += "(" + self.mTargetLabelWhenFalse.string + ")"
  else
    outResult += self.mTargetLabelWhenFalse.string
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator performTerminatorRelativeBranchResolution
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator {
  var @conditionalBranchMode branchModeOnFalseLabel = self.mBranchModeOnFalseLabel
  var @conditionalBranchMode branchModeOnTrueLabel = self.mBranchModeOnTrueLabel
  if self.mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch self.mBranchModeOnFalseLabel
    case native : # !Bcc F
      if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress) then
        branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
        ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
      end
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress + 2) then
        branchModeOnFalseLabel = @conditionalBranchMode. ipicGOTO
        ioListFileContents += "  " + inBlockLabel + ", terminator will use GOTO " + self.mTargetLabelWhenFalse + "\n"
      end
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end
  elsif self.mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch self.mBranchModeOnTrueLabel
    case native : # Bcc T
      if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
        branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
        ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
      end
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress + 2) then
        branchModeOnTrueLabel = @conditionalBranchMode. ipicGOTO
        ioListFileContents += "  " + inBlockLabel + ", terminator will use GOTO " + self.mTargetLabelWhenTrue + "\n"
      end
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch self.mBranchModeOnFalseLabel
    case native :
      switch self.mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+2) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenTrue + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
        end
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+4) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          branchModeOnFalseLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenFalse + "\n"
        end
      end
    case ipicGOTO :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenTrue + "\n"
        end
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+6) then
          branchModeOnTrueLabel = @conditionalBranchMode. ipicBRA
          ioListFileContents += "  " + inBlockLabel + ", terminator will use BRA " + self.mTargetLabelWhenTrue + "\n"
        end
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
  if (branchModeOnFalseLabel == self.mBranchModeOnFalseLabel) & (branchModeOnTrueLabel == self.mBranchModeOnTrueLabel) then
    outModifiedTerminator = self
  else
    outModifiedTerminator = @ipic18ConditionalJumpTerminator. new {
      !self.mInstructionLocation
      !self.mConditionalBranch
      !self.mTargetLabelWhenTrue
      !branchModeOnTrueLabel
      !self.mTargetLabelWhenFalse
      !branchModeOnFalseLabel}
    ioConversionCount += 1
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator terminatorRelativeBranchOverflow
  ?let @uint inAddress
  ?let @string inBlockLabel
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap {
  if self.mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch self.mBranchModeOnFalseLabel
    case native : # !Bcc F
      if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress) then
        ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
      end
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress + 2) then
        ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
      end
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end
  elsif self.mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch self.mBranchModeOnTrueLabel
    case native : # Bcc T
      if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
        ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
      end
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress + 2) then
        ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
      end
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch self.mBranchModeOnFalseLabel
    case native :
      switch self.mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenFalse !inAddress) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+2) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
        end
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
        end
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+4) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenFalse!inAddress+2) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenFalse.string
        end
      end
    case ipicGOTO :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        if not pic18_checkBCC (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
        end
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL (!inSymbolTable !self.mTargetLabelWhenTrue !inAddress+6) then
          ioOverflowMap += !inBlockLabel !self.mTargetLabelWhenTrue.string
        end
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator terminatorSize
  ?let @string inNextBlockLabel
  -> @uint outSize {
  if self.mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch self.mBranchModeOnFalseLabel
    case native  : outSize = 2  # !Bcc F
    case ipicBRA  : outSize = 4 # Bcc Z ; BRA F ; Z:
    case ipicGOTO : outSize = 6 # Bcc Z ; GOTO F ; Z:
    end
  elsif self.mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch self.mBranchModeOnTrueLabel
    case native   : outSize = 2 # Bcc T
    case ipicBRA  : outSize = 4 # !Bcc Z ; BRA T ; Z:
    case ipicGOTO : outSize = 6 # !Bcc Z ; GOTO T ; Z:
    end
  else
    switch self.mBranchModeOnFalseLabel
    case native :
      switch self.mBranchModeOnTrueLabel
      case native, ipicBRA : outSize = 4 # !Bcc F ; BRA T
      case ipicGOTO : outSize = 6 # !Bcc F ; GOTO T
      end
    case ipicBRA :
      switch self.mBranchModeOnTrueLabel
      case native   : outSize = 4 # Bcc T ; BRA F
      case ipicBRA  : outSize = 6 # Bcc Z ; BRA F ; Z: BRA T
      case ipicGOTO : outSize = 8 # Bcc Z ; BRA F ; Z: GOTO T
      end
    case ipicGOTO :
      switch self.mBranchModeOnTrueLabel
      case native   : outSize = 6 # Bcc T ; GOTO F
      case ipicBRA  : outSize = 8 # Bcc Z ; GOTO F ; Z: BRA T
      case ipicGOTO : outSize = 10 # Bcc Z ; GOTO F ; Z: GOTO T
      end
    end
  end
}

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator generateTerminatorCode
  ?let @uint inAddress
  ?let @symbolTableForRelativesResolution inSymbolTable
  ?let @string inNextBlockLabel
  !@codeList outCode {
  [inSymbolTable searchKey !self.mTargetLabelWhenTrue  ?let @uint trueTargetAddress]
  [inSymbolTable searchKey !self.mTargetLabelWhenFalse ?let @uint falseTargetAddress]
  let Zlabel = @lstring.new { !"_Bcc_" + [inAddress xString] !self.mInstructionLocation}
  if self.mTargetLabelWhenTrue.string == inNextBlockLabel then
    switch self.mBranchModeOnFalseLabel
    case native : # !Bcc F
      outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !self.mTargetLabelWhenFalse !self.mConditionalBranch !true)
    case ipicBRA : # Bcc Z ; BRA F ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !self.mConditionalBranch !false)
      outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !self.mTargetLabelWhenFalse)
      outCode += pic18_definition_label (!Zlabel)
    case ipicGOTO : # Bcc Z ; GOTO F ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !self.mConditionalBranch !false)
      outCode += pic18_GOTO_instruction_code (!falseTargetAddress !self.mTargetLabelWhenFalse)
      outCode += pic18_definition_label (!Zlabel)
    end
  elsif self.mTargetLabelWhenFalse.string == inNextBlockLabel then
    switch self.mBranchModeOnTrueLabel
    case native : # Bcc T
      outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !self.mTargetLabelWhenTrue !self.mConditionalBranch !false)
    case ipicBRA : # !Bcc Z ; BRA T ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !self.mConditionalBranch !true)
      outCode += pic18_BRA_instruction_code (!inAddress+2 !trueTargetAddress !self.mTargetLabelWhenTrue)
      outCode += pic18_definition_label (!Zlabel)
    case ipicGOTO : # !Bcc Z ; GOTO T ; Z:
      outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !self.mConditionalBranch !true)
      outCode += pic18_GOTO_instruction_code (!trueTargetAddress !self.mTargetLabelWhenTrue)
      outCode += pic18_definition_label (!Zlabel)
    end
  else
    switch self.mBranchModeOnFalseLabel
    case native :
      switch self.mBranchModeOnTrueLabel
      case native, ipicBRA : # !Bcc F ; BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !self.mTargetLabelWhenFalse !self.mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !trueTargetAddress !self.mTargetLabelWhenTrue)
      case ipicGOTO : # !Bcc F ; GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !falseTargetAddress !self.mTargetLabelWhenFalse !self.mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !self.mTargetLabelWhenTrue)
      end
    case ipicBRA :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; BRA F
        outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !self.mTargetLabelWhenTrue !self.mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !self.mTargetLabelWhenFalse)
      case ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !self.mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !self.mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_BRA_instruction_code (!inAddress !trueTargetAddress !self.mTargetLabelWhenTrue)
      case ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 4 !Zlabel !self.mConditionalBranch !true)
        outCode += pic18_BRA_instruction_code (!inAddress+2 !falseTargetAddress !self.mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !self.mTargetLabelWhenTrue)
      end
    case ipicGOTO :
      switch self.mBranchModeOnTrueLabel
      case native   : # Bcc T ; GOTO F
        outCode = pic18_Bcc_instruction_code (!inAddress !trueTargetAddress !self.mTargetLabelWhenTrue !self.mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !self.mTargetLabelWhenFalse)
      case ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !self.mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !self.mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_BRA_instruction_code (!inAddress+6 !trueTargetAddress !self.mTargetLabelWhenTrue)
      case ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
        outCode = pic18_Bcc_instruction_code (!inAddress !inAddress + 6 !Zlabel !self.mConditionalBranch !true)
        outCode += pic18_GOTO_instruction_code (!falseTargetAddress !self.mTargetLabelWhenFalse)
        outCode += pic18_definition_label (!Zlabel)
        outCode += pic18_GOTO_instruction_code (!trueTargetAddress !self.mTargetLabelWhenTrue)
      end
    end
  end
}

#----------------------------------------------------------------------------*

override getter @ipic18ConditionalJumpTerminator isEqualToTerminator
  ?let @ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult {
  outResult = (inTerminator is == @ipic18ConditionalJumpTerminator)
  if outResult then
    let @ipic18ConditionalJumpTerminator t = ( inTerminator as @ipic18ConditionalJumpTerminator)
    outResult = self.mConditionalBranch == t.mConditionalBranch
    if outResult then
      outResult = self.mTargetLabelWhenTrue.string == t.mTargetLabelWhenTrue.string
    end
    if outResult then
      outResult = self.mBranchModeOnTrueLabel == t.mBranchModeOnTrueLabel
    end
    if outResult then
      outResult = self.mTargetLabelWhenFalse.string == t.mTargetLabelWhenFalse.string
    end
    if outResult then
      outResult = self.mBranchModeOnFalseLabel == t.mBranchModeOnFalseLabel
    end
  end
}

#----------------------------------------------------------------------------*

