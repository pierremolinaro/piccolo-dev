

#----------------------------------------------------------------------------*
#           INSTRUCTIONS USES GOTO OR CALL                                   *
#----------------------------------------------------------------------------*

method @midrange_instruction instructionUsesGOTOorCALL
  ?!@bool unused ioUsesGOTOorCALL {
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_FOREVER instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_structured_if instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_CALL instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_JSR instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_GOTO instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_JUMP instructionUsesGOTOorCALL
  ?!@bool ioUsesGOTOorCALL {
  ioUsesGOTOorCALL = true
}

#----------------------------------------------------------------------------*
#           DECOMPOSE STRUCTURED INSTRUCTIONS        *
#----------------------------------------------------------------------------*

abstract method @midrange_instruction build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters

#----------------------------------------------------------------------------*

proc handleMidrangeInstructionList
  ?let @midrange_instructionList inInstructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  !@bool outContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  outContinuesInSequence = true
  for (mInstruction) in  inInstructionList do
    if not outContinuesInSequence then
      error mInstruction.mInstructionLocation : "Unreachable code"
      outContinuesInSequence = true
    end
    [mInstruction build_midrange_ipic_instructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?ioCurrentBank
      !inShouldPreserveBank
      !?outContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
    ]
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_nobanksel build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  if inShouldPreserveBank then
    error self.mInstructionLocation: "cannot use \"nobank\" here: bank selection should be preserved (use it in a \"banksave\" construct)"
  end
  ioCurrentBank = @uint. max
#--- Generates no code
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_savebank build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Get values for STATUS register
  let STATUS_register = @registerExpression {
    ! @{!"STATUS" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  let @midrange_intermediate_registerExpression STATUS_IPICregisterDescription
  [STATUS_register resolveMidrangeAccess
    !inTotalBankCount
    !@uint. max # No selected bank
    !inRegisterTable
    !inConstantMap
    ?STATUS_IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Get values for register used for saving
  let @midrange_intermediate_registerExpression save_IPICregisterDescription
  [self.mRegister resolveMidrangeAccess
    !inTotalBankCount
    !@uint. max # No selected bank
    !inRegisterTable
    !inConstantMap
    ?save_IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#--- Generate "SWAPF STATUS, W" instruction
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD {
    !self.mInstructionLocation
    !@midrange_instruction_FD_base_code. SWAPF
    !STATUS_IPICregisterDescription
    !true}
#--- Generate "MOVWF SAVE_REG" instruction
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_F {
    !self.mInstructionLocation
    !@midrange_F_instruction_base_code. MOVWF
    !save_IPICregisterDescription}
#--- Generate instruction list
  var @uint finalBank = ioCurrentBank
  handleMidrangeInstructionList (
    !self.mInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?finalBank
    !false # Do not preserve bank now
    ?ioContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  )
  if not ioContinuesInSequence then
    error self.mEndOfSaveBankInstruction:"useless saving: execution does reach the end of \"savebank\" instruction list"
  end
#--- Generate "SWAPF SAVE_REG, W" instruction
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD {
    !self.mInstructionLocation
    !@midrange_instruction_FD_base_code. SWAPF
    !save_IPICregisterDescription
    !true}
#--- Generate "MOVWF STATUS" instruction
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_F {
    !self.mInstructionLocation
    !@midrange_F_instruction_base_code. MOVWF
    !STATUS_IPICregisterDescription}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_banksel build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  if inShouldPreserveBank then
    error self.mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)"
  end
#---
  let STATUS_register = @registerExpression {
    ! @{ !"STATUS" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  let @midrange_intermediate_registerExpression STATUS_IPICregisterDescription
  let @bitSliceTable bitSliceTable
  [STATUS_register resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?STATUS_IPICregisterDescription
    ?bitSliceTable
    !?ioUsedRegisters
  ]
  let RP = @lstring { !"RP" !self.mInstructionLocation}
  [bitSliceTable searchKey !RP ?let @uint rpIndex ?let @uint sliceSize]
  if sliceSize < [inTotalBankCount - 1 significantBitCount] then
    error self.mInstructionLocation: "internal error: sliceSize == " + [sliceSize string] + ", total bank count == " + [inTotalBankCount string]
  end
#---
  if self.mBankIndex.uint == ioCurrentBank then
    if self.mWarningOnUselessBanksel then
      warning self.mBankIndex:"useless instruction: the bank " + [ioCurrentBank string] + " is already selected"
    end
  elsif self.mBankIndex.uint >= inTotalBankCount then
    error self.mBankIndex:"the bank " + [self.mBankIndex.uint string] + " does not exist (the device has " + [inTotalBankCount string] + " bank(s))"
  elsif ioCurrentBank == @uint. max then # No currenly selected bank : set all bits
    var @uint shiftedBank = self.mBankIndex.uint
    var @uint idx = 0
    loop( sliceSize) while idx < sliceSize do
      let @midrange_bit_oriented_op op
      if ((shiftedBank & 1) == 0) then
        op = @midrange_bit_oriented_op. BCF
      else
        op = @midrange_bit_oriented_op. BSF
      end
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FB {
        !self.mInstructionLocation
        !op
        !STATUS_IPICregisterDescription
        !rpIndex + idx}
      idx += 1      
      shiftedBank = shiftedBank >> 1
    end
    ioCurrentBank = self.mBankIndex.uint
  else
    let @bool optimize = [option piccoloOptions.performOptimizations value]
    var @uint shiftedBank = self.mBankIndex.uint
    var @uint shiftedXorBank = self.mBankIndex.uint ^ ioCurrentBank
    var @uint idx = 0
    loop( sliceSize) while idx < sliceSize do
      let @midrange_bit_oriented_op op
      if ((shiftedBank & 1) == 0) then
        op = @midrange_bit_oriented_op. BCF
      else
        op = @midrange_bit_oriented_op. BSF
      end
      if ((shiftedXorBank & 1) != 0) | not optimize then
        ioGeneratedInstructionList += !@midrange_intermediate_instruction_FB {
          !self.mInstructionLocation
          !op
          !STATUS_IPICregisterDescription
          !rpIndex + idx}
      else
        ioListFileContents += "  line " + [[ioGeneratedInstructionList count] string]
        ioListFileContents += ": useless '" + [op mnemonic] + " STATUS, "
        ioListFileContents += [rpIndex + idx string] + "' not generated\n"
      end
      idx += 1      
      shiftedBank = shiftedBank >> 1
      shiftedXorBank = shiftedXorBank >> 1
    end
    ioCurrentBank = self.mBankIndex.uint
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_banksel_register build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  if inShouldPreserveBank then
    error self.mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)"
  end
#---
  let STATUS_register = @registerExpression {
    ! @{ !"STATUS" !.here}
    !@immediatInteger {! @{!0 !.here}}
    !.here
  }
  [STATUS_register resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let @midrange_intermediate_registerExpression STATUS_IPICregisterDescription
    ?let @bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ]
  let RP = @lstring { !"RP" !self.mInstructionLocation}
  [bitSliceTable searchKey !RP ?let @uint rpIndex ?let @uint sliceSize]
  if sliceSize < [inTotalBankCount - 1 significantBitCount] then
    error self.mInstructionLocation: "internal error: sliceSize == " + [sliceSize string] + ", total bank count == " + [inTotalBankCount string]
  end
#--- 
  [inRegisterTable searchKey
    !self.mRegister.mRegisterName
    ?let @uintlist registerAddressList
    ?let @uint size
    ?2*
    ?let protection
  ]
  [inRegisterTable checkPrivateAccess !self.mRegister.mRegisterName !write:false !protection]
  [registerAddressList first ?let @uint address]
  let @uint newBank = address >> 7
#---
  [self.mRegister.mOffset eval !inRegisterTable !inConstantMap ?let @sint64 offset !?ioUsedRegisters]
  if offset < 0 then
    error self.mRegister.mEndOfOffsetExpression : "index value (" + offset + ") should be <= 0 "
  elsif [offset uint] >= size then
    error self.mRegister.mEndOfOffsetExpression : "maximum index value is " + (size - 1)
  end
#---
  if newBank == ioCurrentBank then
    if self.mWarningOnUselessBanksel then
      warning self.mRegister.mRegisterName:"useless instruction: the bank " + [ioCurrentBank string] + " is already selected"
    end
  elsif newBank >= inTotalBankCount then
    error self.mRegister.mRegisterName:"the bank " + [newBank string] + " does not exist (the device has " + [inTotalBankCount string] + " bank(s))"
  elsif ioCurrentBank == @uint. max then # No currenly selected bank : set all bits
    var @uint shiftedBank = newBank
    var @uint idx = 0
    loop( sliceSize) while idx < sliceSize do
      let @midrange_bit_oriented_op op
      if ((shiftedBank & 1) == 0) then
        op = @midrange_bit_oriented_op. BCF
      else
        op = @midrange_bit_oriented_op. BSF
      end
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FB {
        !self.mInstructionLocation
        !op
        !STATUS_IPICregisterDescription
        !rpIndex + idx}
      idx += 1      
      shiftedBank = shiftedBank >> 1
    end
    ioCurrentBank = newBank
  else
    let @bool optimize = [option piccoloOptions.performOptimizations value]
    var @uint shiftedBank = newBank
    var @uint shiftedXorBank = newBank ^ ioCurrentBank
    var @uint idx = 0
    loop( sliceSize) while idx < sliceSize do
      let @midrange_bit_oriented_op op
      if ((shiftedBank & 1) == 0) then
        op = @midrange_bit_oriented_op. BCF
      else
        op = @midrange_bit_oriented_op. BSF
      end
      if ((shiftedXorBank & 1) != 0) | not optimize then
        ioGeneratedInstructionList += !@midrange_intermediate_instruction_FB {
          !self.mInstructionLocation
          !op
          !STATUS_IPICregisterDescription
          !rpIndex + idx}
      else
        ioListFileContents += "  line " + [[ioGeneratedInstructionList count] string]
        ioListFileContents += ": useless '" + [op mnemonic] + " STATUS, "
        ioListFileContents += [rpIndex + idx string] + "' not generated\n"
      end
      idx += 1      
      shiftedBank = shiftedBank >> 1
      shiftedXorBank = shiftedXorBank >> 1
    end
    ioCurrentBank = newBank
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_FD build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let @midrange_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD {
    !self.mInstructionLocation
    !self.mInstruction_FD_base_code
    !IPICregisterDescription
    !self.m_W_isDestination
  }
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_F build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  let @midrange_intermediate_registerExpression IPICregisterDescription
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_F {
    !self.mInstructionLocation
    !self.mFAinstruction
    !IPICregisterDescription
  }
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_FB build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
{
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let IPICregisterDescription
    ?let bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let bitNumber
  ]
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_FB {
    !self.mInstructionLocation
    !self.mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  }
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_JSR build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let isNoReturn ?let requiredBank ?let returnedBank ?let preservesBank]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "does contain any reliable value"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if isNoReturn then
    error self.mTargetLabel:"a \"noreturn\" routine should be called with a GOTO or JUMP instruction"
  end
  if not preservesBank then
    ioCurrentBank = returnedBank
  end
#---
  ioGeneratedInstructionList += !@midrange_intermediate_JSR {
    !self.mInstructionLocation
    !self.mTargetLabel
    !@midrange_call_goto_bit. noChange
    !@midrange_call_goto_bit. noChange}
}

#----------------------------------------------------*

override method @midrangeInstruction_checkbank build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  if self.mBankIndex > 15 then
    error self.mInstructionLocation:"Bank index should be <= 15"
  elsif ioCurrentBank == @uint. max then
    error self.mInstructionLocation:"checkbank fail: there is no selected bank"
  elsif ioCurrentBank != self.mBankIndex then
    error self.mInstructionLocation:"checkbank fail: the selected bank is " + ioCurrentBank + ", required bank is " + self.mBankIndex
  end
  ioCurrentBank = self.mBankIndex
}

#----------------------------------------------------*

override method @midrangeInstruction_checknobank build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  if ioCurrentBank != @uint. max then
    error self.mInstructionLocation:"checknobank fail: the " + ioCurrentBank + " bank is selected"
    ioCurrentBank = @uint. max
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_CALL build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let isNoReturn ?let requiredBank ?let returnedBank ?let preservesBank]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "does contain any reliable value"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if isNoReturn then
    error self.mTargetLabel:"a \"noreturn\" routine should be called with a GOTO or JUMP instruction"
  end
  if not preservesBank then
    ioCurrentBank = returnedBank
  end
#---
  ioGeneratedInstructionList += !@midrange_intermediate_CALL {
    !self.mInstructionLocation
    !self.mTargetLabel}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_JUMP build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let isNoReturn ?let requiredBank ?* ?*]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "does contain any reliable value"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if not isNoReturn then
    error self.mTargetLabel:"a regular routine should be called with a CALL or JSR instruction"
  end
  ioContinuesInSequence = false
#---
  ioGeneratedInstructionList += !@midrange_intermediate_JUMP {
    !self.mInstructionLocation
    !self.mTargetLabel
    !@midrange_call_goto_bit. noChange
    !@midrange_call_goto_bit. noChange}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_GOTO build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#--- Check instruction
  [inRoutineMap searchKey !self.mTargetLabel ?let isNoReturn ?let requiredBank ?* ?*]
  if (requiredBank != @uint. max) & (requiredBank != ioCurrentBank) then
    var @string errorMessage = "the routine '" + self.mTargetLabel + "' requires bank selection to be set to " + [requiredBank string]
    errorMessage += ", but bank selection "
    if ioCurrentBank == @uint. max then
      errorMessage += "does contain any reliable value"
    else
      errorMessage += "is set to " + [ioCurrentBank string]
    end
    error self.mTargetLabel:errorMessage
  end
  if not isNoReturn then
    error self.mTargetLabel:"a regular routine should be called with a CALL or JSR instruction"
  end
  ioContinuesInSequence = false
#---
  ioGeneratedInstructionList += !@midrange_intermediate_GOTO {
    !self.mInstructionLocation
    !self.mTargetLabel}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_CLRWDT build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_CLRWDT {
    !self.mInstructionLocation}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_CLRW build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_CLRW {
    !self.mInstructionLocation}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_NOP build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_NOP {
    !self.mInstructionLocation}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_SLEEP build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_SLEEP {
    !self.mInstructionLocation}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_literalOperation build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters {
  [self.mImmediatExpression eval !inRegisterTable !inConstantMap ?let @sint64 result !?ioUsedRegisters]
#---
   if (result > 255) | (result < -128) then
     error self.mInstructionLocation:"immediate value is evaluated as " + [result string] + " (should be betwween -128 and 255)"
   end
#---  
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_literalOperation {
    !self.mInstructionLocation
    !self.mLiteralInstruction
    ![result & 0x000000FF uint]}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_MNOP build_midrange_ipic_instructionList
  ?let @routineMap unused inRoutineMap
  ?let @registerTable unused inRegisterTable
  ?let @constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?let @uint unused inTotalBankCount
  ?!@uint unused ioCurrentBank
  ?let @bool unused inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters {
#---
  if self.mOccurrenceFactor.uint == 0 then
    warning self.mOccurrenceFactor:"occurrence argument is zero: no generated code"
  end
#---
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_MNOP {
    !self.mInstructionLocation
    !self.mOccurrenceFactor}
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_FOREVER build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  switch inRoutineKind
  case regularRoutine :
    error self.mInstructionLocation:"a regular routine does not accept the \"forever\" instruction"
  case noReturnRoutine : # ok
  case interruptRoutine :
    error self.mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction"
  end
#--- Check instruction list does not change bank
  var @uint finalBank = ioCurrentBank
  let @string label0 = ".L" + [ioLocalLabelIndex string] 
  ioLocalLabelIndex += 1
  ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label0 !self.mInstructionLocation} !true}
  handleMidrangeInstructionList (
    !self.mInstructionList 
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?finalBank
    !inShouldPreserveBank
    ?ioContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  )
  if ioCurrentBank != finalBank then
    error self.mEndOfInstructionList:"instruction list does not leave bank selection unchanged"
  end
#--- Generate JUMP to loop start
  ioGeneratedInstructionList += !@midrange_intermediate_GOTO {
    !self.mInstructionLocation
    !@lstring { !label0 !self.mInstructionLocation}}
#---
  ioContinuesInSequence = false
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_STATIC_REPEAT build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Solve immediat expression
  [self.mLowerBoundExpression eval !inRegisterTable !inConstantMap ?let @sint64 lowerBound !?ioUsedRegisters]
  [self.mUpperBoundExpression eval !inRegisterTable !inConstantMap ?let @sint64 upperBound !?ioUsedRegisters]
#---
  if lowerBound > upperBound then
    error self.mInstructionLocation: "lower bound (" + lowerBound + ") greater then upper bound (" + upperBound + ")"
  elsif (upperBound - lowerBound) > 0xFFFF then
    error self.mInstructionLocation:"repeat count (" + (upperBound - lowerBound) + ") too large (should be <= 0xFFFF)"
  end
#--- First pass (for lower bound
  var @uint finalBank = ioCurrentBank
  var tempConstantMap = inConstantMap
  [!?tempConstantMap insertKey !self.mConstantName !lowerBound]
  handleMidrangeInstructionList (
    !self.mInstructionList 
    !inRoutineMap
    !inRegisterTable
    !tempConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?finalBank
    !inShouldPreserveBank
    ?ioContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  )
  if ioCurrentBank != finalBank then
    error self.mEndOfInstruction:"enclosed instruction list does not leave bank selection unchanged"
  end
  if not ioContinuesInSequence then
    error self.mEndOfInstruction:"enclosed instruction list contains an endless loop"
  end
#--- Other passes
  var idx = lowerBound + 1
  loop ([upperBound - lowerBound + 1 uint]) while (idx <= upperBound) && (@uint.errorCount == 0) do
    var constantMap = inConstantMap
    [!?constantMap insertKey !self.mConstantName !idx]
    handleMidrangeInstructionList (
      !self.mInstructionList 
      !inRoutineMap
      !inRegisterTable
      !constantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?ioCurrentBank
      !inShouldPreserveBank
      ?ioContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
    )
    idx += 1
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_IF_BitTest build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let IPICregisterDescription
    ?let bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let bitNumber
  ]
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_BitTestSkip {
    !self.mInstructionLocation
    !self.mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  }
#--- Append Instruction
  var @bool unusedContinuesInSequence = true
  [self.mInstruction build_midrange_ipic_instructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?ioCurrentBank
    !inShouldPreserveBank
    !?unusedContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  ]
}

#----------------------------------------------------------------------------*

abstract method @midrange_conditionExpression buildIPICinstructionForCondition
  ?let @uint inTotalBankCount
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?let @bool inComplementaryBranch
  ?let @location inInstructionLocation
  ?let @string inTargetLabel
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@stringset ioUsedRegisters

#----------------------------------------------------------------------------*

abstract method @midrange_conditionExpression computeInstructionCountForCondition
  ?let @bool inComplementaryBranch
  !@uint outInstructionCount

#----------------------------------------------------------------------------*

override method @midrange_incDecRegisterInCondition buildIPICinstructionForCondition
  ?let @uint inTotalBankCount
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?let @bool inComplementaryBranch
  ?let @location inInstructionLocation
  ?let @string inTargetLabel
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@stringset ioUsedRegisters
{
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#---
  ioGeneratedInstructionList += !@midrange_intermediate_incDecRegisterInCondition {
    !inInstructionLocation
    !IPICregisterDescription
    !inTargetLabel
    !self.mIncrement
    !self.m_W_isDestination
    !self.mBranchIfZero ^ inComplementaryBranch}
}

#----------------------------------------------------------------------------*

override method @midrange_incDecRegisterInCondition computeInstructionCountForCondition
  ?let @bool inComplementaryBranch
  !@uint outInstructionCount {
  if self.mBranchIfZero ^ inComplementaryBranch then
    outInstructionCount = 3
  else
    outInstructionCount = 2
  end
}

#----------------------------------------------------------------------------*

override method @midrange_negateCondition buildIPICinstructionForCondition
  ?let @uint inTotalBankCount
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?let @bool inComplementaryBranch
  ?let @location inInstructionLocation
  ?let @string inTargetLabel
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@stringset ioUsedRegisters {
  [self.mCondition buildIPICinstructionForCondition
    !inTotalBankCount
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !not inComplementaryBranch
    !inInstructionLocation
    !inTargetLabel
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?ioUsedRegisters
  ]
}

#----------------------------------------------------------------------------*

override method @midrange_negateCondition computeInstructionCountForCondition
  ?let @bool inComplementaryBranch
  !@uint outInstructionCount {
  [self.mCondition computeInstructionCountForCondition
    !not inComplementaryBranch
    ?outInstructionCount
  ]
}

#----------------------------------------------------------------------------*

override method @midrange_andCondition buildIPICinstructionForCondition
  ?let @uint inTotalBankCount
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?let @bool inComplementaryBranch
  ?let @location inInstructionLocation
  ?let @string inTargetLabel
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@stringset ioUsedRegisters {
  if inComplementaryBranch then
    [self.mLeftExpression buildIPICinstructionForCondition
      !inTotalBankCount
      !inCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
    [self.mRightExpression buildIPICinstructionForCondition
      !inTotalBankCount
      !inCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
  else
    let @string label0 = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
    [self.mLeftExpression buildIPICinstructionForCondition
      !inTotalBankCount
      !inCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !label0
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
    [self.mRightExpression buildIPICinstructionForCondition
      !inTotalBankCount
      !inCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !false
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
    ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label0 !inInstructionLocation} !true}
  end
}

#----------------------------------------------------------------------------*

override method @midrange_andCondition computeInstructionCountForCondition
  ?let @bool inComplementaryBranch
  !@uint outInstructionCount {
  [self.mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?let countLeft
  ]
  [self.mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?let countRight
  ]
  outInstructionCount = countLeft + countRight
}

#----------------------------------------------------------------------------*

override method @midrange_bitTest_in_structured_if_condition buildIPICinstructionForCondition
  ?let @uint inTotalBankCount
  ?let @uint inCurrentBank
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?let @bool inComplementaryBranch
  ?let @location inInstructionLocation
  ?let @string inTargetLabel
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@stringset ioUsedRegisters {
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !inCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let IPICregisterDescription
    ?let bitSliceTable
    !?ioUsedRegisters
  ]
  [self.mBitNumber getBitNumber
    !inRegisterTable
    !inConstantMap
    !?ioUsedRegisters
    !bitSliceTable
    ?let bitNumber
  ]
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_BitTestSkip {
    !inInstructionLocation
    !inComplementaryBranch # mBTFSSinstruction ^ inComplementaryBranch
    !IPICregisterDescription
    !bitNumber
  }
  ioGeneratedInstructionList += !@midrange_intermediate_JUMP {
    !inInstructionLocation
    !@lstring {!inTargetLabel !inInstructionLocation}
    !@midrange_call_goto_bit.noChange
    !@midrange_call_goto_bit.noChange
  }
}

#----------------------------------------------------------------------------*

override method @midrange_bitTest_in_structured_if_condition computeInstructionCountForCondition
  ?let @bool unused inComplementaryBranch
  !@uint outInstructionCount {
  outInstructionCount = 2
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_structured_if build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
  var @bool generateComplementaryCondition = false
#--- Direct Test Instruction Count
  if [option piccoloOptions.performOptimizations value] then
    var @uint directCount ; [self.mIfCondition computeInstructionCountForCondition !true ?directCount]
    if [self.mElseInstructionList count] > 0 then
      directCount += 1
    end
    var @uint complementaryCount ; [self.mIfCondition computeInstructionCountForCondition !false ?complementaryCount]
    if [self.mThenInstructionList count] > 0 then
      complementaryCount += 1
    end
    if (complementaryCount < directCount) then
      generateComplementaryCondition = true
      ioListFileContents += "  line " + [[ioGeneratedInstructionList count] string] + ": generates complementary test (saves "
      + [directCount - complementaryCount string] + " instruction"
      if (directCount - complementaryCount) > 1 then
        ioListFileContents += "s"
      end
      ioListFileContents += ")\n"
    end
  end
  var @uint elseBranchFinalBank = ioCurrentBank
  var @uint thenBranchFinalBank = ioCurrentBank
  let @bool elseContinuesInSequence
  let @bool thenContinuesInSequence
  if generateComplementaryCondition then
  #---
    let @string label_nextCondition = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
    let @string label_endOfIfinstruction = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
  #--- Translate condition
    [self.mIfCondition buildIPICinstructionForCondition
      !inTotalBankCount
      !ioCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !false
      !self.mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
  #--- 'else' instructions
    handleMidrangeInstructionList (
      !self.mElseInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?elseBranchFinalBank
      !inShouldPreserveBank
      ?elseContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
    )
  #--- 'then' instructions
    if [self.mThenInstructionList count] > 0 then
      ioGeneratedInstructionList += !@midrange_intermediate_GOTO { !self.mInstructionLocation !@lstring { !label_endOfIfinstruction !self.mInstructionLocation}}
    end
    ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label_nextCondition !self.mInstructionLocation} !true}
    handleMidrangeInstructionList ( 
      !self.mThenInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?thenBranchFinalBank
      !inShouldPreserveBank
      ?thenContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
     )
    if [self.mThenInstructionList count] > 0 then
      ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label_endOfIfinstruction !self.mInstructionLocation} !true}
    end
  else
  #---
    let @string label_nextCondition = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
    let @string label_endOfIfinstruction = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
  #--- Translate condition
    [self.mIfCondition buildIPICinstructionForCondition
      !inTotalBankCount
      !ioCurrentBank
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !true
      !self.mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioUsedRegisters
    ]
  #--- 'then' instructions
    handleMidrangeInstructionList (
      !self.mThenInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?thenBranchFinalBank
      !inShouldPreserveBank
      ?thenContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
    )
  #--- 'else' instructions
    if [self.mElseInstructionList count] > 0 then
      ioGeneratedInstructionList += !@midrange_intermediate_GOTO { !self.mInstructionLocation !@lstring { !label_endOfIfinstruction !self.mInstructionLocation}}
    end
    ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label_nextCondition !self.mInstructionLocation} !true}
    handleMidrangeInstructionList (
      !self.mElseInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !inTotalBankCount
      !?elseBranchFinalBank
      !inShouldPreserveBank
      ?elseContinuesInSequence
      !inRoutineKind
      !?ioUsedRegisters
    )
    if [self.mElseInstructionList count] > 0 then
      ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !label_endOfIfinstruction !self.mInstructionLocation} !true}
    end
  end
  if elseBranchFinalBank == thenBranchFinalBank then
    ioCurrentBank = elseBranchFinalBank
  else
    error self.mEndOfElsePartLocation:"This branch does not leave bank selection value as the first one does"
    elseBranchFinalBank = @uint. max # No available value for bank selection
  end
#---
  ioContinuesInSequence = thenContinuesInSequence | elseContinuesInSequence
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_do_while build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#--- Generate label
  let @string labelInstructionBegin = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
#--- Define label
  ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !labelInstructionBegin !self.mInstructionLocation} !true}
#--- Repeated instructions
  var @uint finalBank = ioCurrentBank
  handleMidrangeInstructionList (
    !self.mRepeatedInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?finalBank
    !inShouldPreserveBank
    ?ioContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  )
  if ioCurrentBank != finalBank then
    error self.mEndOfRepeatedInstructionList:"This branch does not leave bank selection value unchanged"
  end
#--- while parts
  for (mCondition mInstructionList mEndOfPartLocation) in  self.mWhilePartList do
    if [mInstructionList count] == 0 then
      [mCondition buildIPICinstructionForCondition
        !inTotalBankCount
        !ioCurrentBank
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !false
        !self.mInstructionLocation
        !labelInstructionBegin
        !?ioGeneratedInstructionList
        !?ioListFileContents
        !?ioUsedRegisters
      ]
    else
      let @string nextBranchLabel = ".L" + [ioLocalLabelIndex string] ; ioLocalLabelIndex += 1
      [mCondition buildIPICinstructionForCondition
        !inTotalBankCount
        !ioCurrentBank
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !true
        !self.mInstructionLocation
        !nextBranchLabel
        !?ioGeneratedInstructionList
        !?ioListFileContents
        !?ioUsedRegisters
      ]
      var @uint bank = ioCurrentBank
      handleMidrangeInstructionList (
        !mInstructionList
        !inRoutineMap
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioListFileContents
        !inTotalBankCount
        !?bank
        !inShouldPreserveBank
        ?ioContinuesInSequence
        !inRoutineKind
        !?ioUsedRegisters
      )
      if ioCurrentBank != bank then
        error mEndOfPartLocation:"This branch does not leave bank selection value unchanged"
      end
      ioGeneratedInstructionList += !@midrange_intermediate_GOTO { !self.mInstructionLocation !@lstring { !labelInstructionBegin !self.mInstructionLocation}}
      ioGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !@lstring { !nextBranchLabel !self.mInstructionLocation} !true}
    end
  end
}

#----------------------------------------------------------------------------*

override method @midrange_instruction_IF_IncDec build_midrange_ipic_instructionList
  ?let @routineMap inRoutineMap
  ?let @registerTable inRegisterTable
  ?let @constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?let @uint inTotalBankCount
  ?!@uint ioCurrentBank
  ?let @bool inShouldPreserveBank
  ?!@bool unused ioContinuesInSequence
  ?let @routineKind inRoutineKind
  ?!@stringset ioUsedRegisters {
#---
  let @midrange_instruction_FD_base_code baseCode
  if self.mIncrement then
    baseCode = @midrange_instruction_FD_base_code. INCFSZ
  else
    baseCode = @midrange_instruction_FD_base_code. DECFSZ
  end
#---
  [self.mRegisterExpression resolveMidrangeAccess
    !inTotalBankCount
    !ioCurrentBank
    !inRegisterTable
    !inConstantMap
    ?let IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ]
#---
  ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD {
    !self.mInstructionLocation
    !baseCode
    !IPICregisterDescription
    !self.m_W_isDestination
  }
#---
  var @bool unusedContinuesInSequence = true
  [self.mInstruction build_midrange_ipic_instructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !inTotalBankCount
    !?ioCurrentBank
    !inShouldPreserveBank
    !?unusedContinuesInSequence
    !inRoutineKind
    !?ioUsedRegisters
  ]
}

#----------------------------------------------------------------------------*

proc build_midrange_assembly_instruction_list
  ?let @uint inTotalPageCount
  ?let @uint inTotalBankCount
  ?let @constantMap inConstantMap
#  ?let @sint inROMSize
  ?let @string inSharedRAMBankName
  ?let @registerTable inRegisterTable
  ?let @midrange_model inPiccoloModel
  ?let @bool inHasInterrupt
  !@midrange_intermediate_instructionList outGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@stringset ioUsedRegisters {
  var @string generationOptimizationMessages = ""
#-------------------------------- Build routine map
  var routineMap =@routineMap ()
  for (mRoutineName * mRequiredBank mReturnedBank mPreservesBank mIsNoReturn * *) in  inPiccoloModel.mRoutineDefinitionList do
    if (mRequiredBank.uint != @uint. max) & (mRequiredBank.uint > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15"
    end
    if (mReturnedBank.uint != @uint. max) & (mReturnedBank.uint > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15"
    end
    [!?routineMap insertKey !mRoutineName !mIsNoReturn !mRequiredBank.uint !mReturnedBank.uint !mPreservesBank]
  end
#-------------------------------- Build constant map
#  var constantMap =@constantMap ()
##--- Add "ROM_SIZE" constant
#  var romSizeString =@lstring.new{ !"ROM_SIZE" !@location.here}
#  [!?constantMap insertKey !romSizeString ![inROMSize sint64]]
##--- Add declared constants
#  for () in  [inPiccoloModel mConstantDefinitionList] do
#    [mExpression eval !inRegisterTable !constantMap ?let @sint64 result !?ioUsedRegisters]
#    if [inRegisterTable hasKey ![mConstantName string]] then
#      error mConstantName: "'" + mConstantName + "' is already declared as ram register or special register"
#    else
#      [!?constantMap insertKey !mConstantName !result]
#    end
#  end
#-------------------------------- Print constant map
  if [option piccoloOptions.ouputListingFile value] then
    print_constant_definition (
      !inConstantMap
      !?ioListFileContents
    )
  end
#-------------------------------- Check the "main" routine is declared
  if [routineMap hasKey !"main"] then
    [routineMap searchKey !@lstring { !"main" !@location.here} ?let @bool isNoReturn ?let @uint requiredBank ?* ?*]
    let @location mainDeclarationLocation = [routineMap locationForKey!"main"]
    if not isNoReturn then
      error mainDeclarationLocation :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main bank:requires 0\""
    end
    if requiredBank != 0 then
      error mainDeclarationLocation :"the \"main\" should be declared with \"requires:bank 0\" qualifier: \"noreturn main bank:requires 0\""
    end
  else
    error inPiccoloModel.mEndOfProgram: "the program should declare the \"main\" routine"
  end
#-------------------------------- Handle interrupt routine
  var @uint localLabelIndex = 0
  handleInterruptRoutine (
    !inPiccoloModel
    !inHasInterrupt
    !inRegisterTable
    !inSharedRAMBankName
    !routineMap
    !inTotalBankCount
    !inConstantMap
    !inTotalPageCount
    !?generationOptimizationMessages
    !?localLabelIndex
    !?ioListFileContents
    ?outGeneratedInstructionList
    !?ioUsedRegisters
  )
#-------------------------------- Check and translate routines
  var @uint currentPage = 0
  loop( inTotalPageCount) while currentPage < inTotalPageCount do
    var @bool orgGenerated = currentPage == 0 # No Org for first page
    for (mRoutineName mPage mRequiredBank mReturnedBank mPreservesBank mIsNoReturn mInstructionList *) in  inPiccoloModel.mRoutineDefinitionList do
      if mPage.uint == currentPage then
        if not orgGenerated then
          outGeneratedInstructionList += !@midrange_intermediate_pseudo_ORG { !currentPage * 2048}
          orgGenerated = true
        end
        var @uint currentBank = mRequiredBank.uint
        let @routineKind routineKind
        if mIsNoReturn then
          routineKind = @routineKind. noReturnRoutine
        else
          routineKind = @routineKind. regularRoutine
        end
        outGeneratedInstructionList += !@midrange_intermediate_pseudo_LABEL { !mRoutineName !true}
        handleMidrangeInstructionList (
          !mInstructionList
          !routineMap
          !inRegisterTable
          !inConstantMap
          !?localLabelIndex
          !?outGeneratedInstructionList
          !?generationOptimizationMessages
          !inTotalBankCount
          !?currentBank
          !mPreservesBank
          ?let continuesInSequence
          !routineKind
          !?ioUsedRegisters
        )
        if (not mIsNoReturn) & (mReturnedBank.uint != @uint. max) & (currentBank != mReturnedBank.uint) then
          error mRoutineName:"execution will not set bank selection to " + [mReturnedBank.uint string]
        end
        if mIsNoReturn & continuesInSequence then
          error mRoutineName:"execution should not reach the end of a \"noreturn\" routine"
        end
      #--- Add a RETURN instruction (if it is a regular routine)
        if not mIsNoReturn then
          outGeneratedInstructionList += !@midrange_intermediate_instruction_RETURN { !mRoutineName.location}
        end
      end
    end
    currentPage += 1
  end
#--- Output a listing ?
  if [option piccoloOptions.ouputListingFile value] then
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
    ioListFileContents += "*" + ["IPIC INSTRUCTION LIST" stringByLeftAndRightPadding !117 !' '] + "*\n"
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
    ioListFileContents += "Generated intermediate code:\n"
    var @uint idx = 0
    var @uint currentAddress = 0
    for (mInstruction) in  outGeneratedInstructionList do
      [mInstruction setCurrentAddress !?currentAddress]
      ioListFileContents += [[idx string] stringByLeftPadding !5 !' '] + ": "
      [mInstruction print !?ioListFileContents]
      ioListFileContents += "\n"
      idx += 1
    end
    ioListFileContents += "\n"
    ioListFileContents += "Minimum code size without optimization: " + [currentAddress string] + " instructions.\n\n"
  end
}

#----------------------------------------------------------------------------*

proc interruptRoutineShouldSavePCLATH
  ?let @midrange_model inPiccoloModel
  ?let @uint inTotalPageCount
  ?!@string ioListFileContents
  !@bool outShouldSavePCLATH {
  ioListFileContents += "PCLATH should be saved ?\n"
#--- Program uses several pages ?
  outShouldSavePCLATH = false
  for (* mPage * * * * * *) in  inPiccoloModel.mRoutineDefinitionList do
    if mPage.uint > 0 then
      outShouldSavePCLATH = true
    end
    if mPage.uint >= inTotalPageCount then
      error mPage:"invalid value ("+ [mPage.uint string] + "); the device has " + [inTotalPageCount string] + " 2k page(s) on rom"
    end
  end
  if not outShouldSavePCLATH then
    ioListFileContents += "  No, program uses only page 0.\n"
  end
#--- Evaluate if interrupt routine uses GOTO or CALL (need to save PCLATH ?)
  if outShouldSavePCLATH then
    outShouldSavePCLATH = false
    for (* mInstructionList * * *) in  inPiccoloModel.mInterruptDefinitionList while not outShouldSavePCLATH do
      for (mInstruction) in  mInstructionList while not outShouldSavePCLATH do
        [mInstruction instructionUsesGOTOorCALL !?outShouldSavePCLATH]
      end
    end
    if outShouldSavePCLATH then
      ioListFileContents += "  Yes, program uses several pages and interrupt routine use CALL or GOTO instruction.\n"
    else
      ioListFileContents += "  No, program uses several pages, but interrupt routine does not use CALL or GOTO instruction.\n"
    end
  end
  ioListFileContents += "\n"
}

#----------------------------------------------------------------------------*
#                                                                            *
#    H A N D L E    I N T E R R U P T    R O U T I N E                       *
#                                                                            *
#----------------------------------------------------------------------------*

proc handleInterruptRoutine
  ?let @midrange_model inPiccoloModel
  ?let @bool inHasInterrupt
  ?let @registerTable inRegisterTable
  ?let @string inSharedRAMBankName
  ?let @routineMap inRoutineMap
  ?let @uint inTotalBankCount
  ?let @constantMap inConstantMap
  ?let @uint inTotalPageCount
  ?!@string ioGenerationOptimizationMessages
  ?!@uint ioLocalLabelIndex
  ?!@string ioListFileContents
  !@midrange_intermediate_instructionList outGeneratedInstructionList
  ?!@stringset ioUsedRegisters {
#-------------------------------- Check and translate interrupt routine
  outGeneratedInstructionList = @midrange_intermediate_instructionList ()
#--- At zero, generate 'jump main' instruction
  outGeneratedInstructionList += !@midrange_intermediate_JUMP {
    !@location.here
    !@lstring { !"main" !@location.here}
    !@midrange_call_goto_bit. noChange
    !@midrange_call_goto_bit. noChange}
#---
  if inHasInterrupt then
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
    ioListFileContents += "*" + ["INTERRUPT ROUTINE" stringByLeftAndRightPadding !117 !' '] + "*\n"
    ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  #-------------------------------- Should save PCLATH ?
    interruptRoutineShouldSavePCLATH (
      !inPiccoloModel
      !inTotalPageCount
      !?ioListFileContents
      ?let @bool shouldSavePCLATH
    )
  #---
    outGeneratedInstructionList += !@midrange_intermediate_pseudo_ORG { !0x4}
    for (* mInstructionList mFirstSaveRegister mSecondSaveRegister mEndOfInterruptLocation) in  inPiccoloModel.mInterruptDefinitionList do
      if inSharedRAMBankName != "" then
        generateInterruptRoutineForControllerWithSharedRAM (
          !inTotalBankCount
          !inRegisterTable
          !mFirstSaveRegister
          !mSecondSaveRegister
          !shouldSavePCLATH
          !mInstructionList
          !inRoutineMap
          !inConstantMap
          !mEndOfInterruptLocation
          !?outGeneratedInstructionList
          !?ioLocalLabelIndex
          !?ioGenerationOptimizationMessages
          !?ioUsedRegisters
        )
      else
        generateInterruptRoutineForControllerWithoutSharedRAM (
          !inTotalBankCount
          !inRegisterTable
          !mFirstSaveRegister
          !mSecondSaveRegister
          !shouldSavePCLATH
          !mInstructionList
          !inRoutineMap
          !inConstantMap
          !mEndOfInterruptLocation
          !?outGeneratedInstructionList
          !?ioLocalLabelIndex
          !?ioGenerationOptimizationMessages
          !?ioUsedRegisters
        )
      end
    end
  end
}

#----------------------------------------------------------------------------*

proc generateInterruptRoutineForControllerWithSharedRAM
  ?let @uint inTotalBankCount
  ?let @registerTable inRegisterTable
  ?let @lstring inFirstSaveRegister
  ?let @lstring inSecondSaveRegister
  ?let @bool inNeedsToSavePCLATH
  ?let @midrange_instructionList inInterruptRoutineInstructionList
  ?let @routineMap inRoutineMap
  ?let @constantMap inConstantMap
  ?let @location inEndOfInterruptLocation
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@uint ioLocalLabelIndex
  ?!@string ioGenerationOptimizationMessages
  ?!@stringset ioUsedRegisters {
#--- Check firstSaveRegister register is defined in RAM, is accessible from any bank, and has a size of 1
  [inRegisterTable searchKey !inFirstSaveRegister ?@uintlist registerAddressList ?@uint size ?2* ?let firstProtection]
  [inRegisterTable checkPrivateAccess !inFirstSaveRegister !write:true !firstProtection]
  var @uint bankAccessibility = 0
  for (mValue) in  registerAddressList do
    bankAccessibility = bankAccessibility | (1 << (mValue >> 7))
  end
  if (bankAccessibility + 1) != (1 << inTotalBankCount) then
    error inFirstSaveRegister: "the '" + inFirstSaveRegister + "' variable cannot be accessed from any bank"
  end
  if size != 1 then
    error inFirstSaveRegister: "the '" + inFirstSaveRegister + "' variable size is " + [size string] + " (it should be 1)"
  end
#--- Check secondSaveRegister register is defined in RAM, is accessible from any bank, and has a size of 1
  [inRegisterTable searchKey ! inSecondSaveRegister ?registerAddressList ?size ?2* ?let secondProtection]
  [inRegisterTable checkPrivateAccess !inSecondSaveRegister !write:true !secondProtection]
  bankAccessibility = 0
  for (mValue) in  registerAddressList do
    bankAccessibility = bankAccessibility | (1 << (mValue >> 7))
  end
  if (bankAccessibility & 1) == 0 then
    error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable cannot be accessed from bank 0"
  end
  if inNeedsToSavePCLATH & (size != 2) then
    error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable size is " + [size string] + " (it should be 2)"
  elsif (not inNeedsToSavePCLATH) & (size != 1) then
    error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable size is " + [size string] + " (it should be 1)"
  end
#--- Generate save context instructions
  if @uint. errorCount == 0 then
    let first_register = @registerExpression {
      !inFirstSaveRegister
      !@immediatInteger {! @{!0 !.here}}
      !.here
    }
    [first_register resolveMidrangeAccess
      !inTotalBankCount
      !0
      !inRegisterTable
      !inConstantMap
      ?let first_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
    let second_register = @registerExpression {
      !inSecondSaveRegister
      !@immediatInteger {! @{!0 !.here}}
      !.here
    }
    [second_register resolveMidrangeAccess
      !inTotalBankCount
      !0 # Bank 0 is currently selected
      !inRegisterTable
      !inConstantMap
      ?let second_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
  #--- Get values for STATUS register
    let STATUS_register = @registerExpression {
      !@lstring { !"STATUS" !.here}
      !@immediatInteger {! @{!0 !.here}}
      !.here
    }
    [STATUS_register resolveMidrangeAccess
      !inTotalBankCount
      !@uint. max
      !inRegisterTable
      !inConstantMap
      ?let STATUS_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !first_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !STATUS_IPICregisterDescription !true}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. CLRF !STATUS_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !second_IPICregisterDescription}
    if inNeedsToSavePCLATH then
      let reg = @registerExpression {
        !inSecondSaveRegister
        !@immediatInteger {! @{!1 !.here}}
        !.here
       }
#      [@registerExpression. new { !inSecondSaveRegister !@luint. new { !1 !@location.here}} resolveMidrangeAccess
      [reg resolveMidrangeAccess
        !inTotalBankCount
        !0
        !inRegisterTable
        !inConstantMap
        ?let @midrange_intermediate_registerExpression register_for_saving_PCLATH_description
        ?*
        !?ioUsedRegisters
      ]
    #--- Get values for PCLATH register
      let PCLATH_register = @registerExpression {
        !@lstring { !"PCLATH" !@location.here}
        !@immediatInteger {! @{!0 !.here}}
        !.here
       }
      [PCLATH_register resolveMidrangeAccess
        !inTotalBankCount
        !@uint. max
        !inRegisterTable
        !inConstantMap
        ?let PCLATH_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. MOVF !PCLATH_IPICregisterDescription !true}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !register_for_saving_PCLATH_description}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. CLRF !PCLATH_IPICregisterDescription}
    end
  #--- Parse instruction list
    var @uint currentBank = 0 # Bank 0 is selected
    handleMidrangeInstructionList (
      !inInterruptRoutineInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioGenerationOptimizationMessages
      !inTotalBankCount
      !?currentBank
      !false # Preserve bank is not required
      ?let continuesInSequence
      !@routineKind. interruptRoutine
      !?ioUsedRegisters
    )
    if not continuesInSequence then
      error inEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine"
    end
    if inNeedsToSavePCLATH then
      let reg = @registerExpression {
        !inSecondSaveRegister
        !@immediatInteger {! @{!1 !.here}}
        !.here
       }
      [reg resolveMidrangeAccess
        !inTotalBankCount
        !0
        !inRegisterTable
        !inConstantMap
        ?let @midrange_intermediate_registerExpression register_for_saving_PCLATH_description
        ?*
        !?ioUsedRegisters
      ]
    #--- Get values for PCLATH register
      let PCLATH_register = @registerExpression {
        !@lstring { !"PCLATH" !@location.here}
        !@immediatInteger {! @{!0 !.here}}
        !.here
      }
      [PCLATH_register resolveMidrangeAccess
        !inTotalBankCount
        !@uint. max
        !inRegisterTable
        !inConstantMap
        ?let PCLATH_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. MOVF !register_for_saving_PCLATH_description !true}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !PCLATH_IPICregisterDescription}
    end
  #--- Restore context
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !second_IPICregisterDescription !true}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !STATUS_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !first_IPICregisterDescription !false}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !first_IPICregisterDescription !true}
  #--- Add REFFIE
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_RETFIE { !@location.here}
  end
}

#----------------------------------------------------------------------------*

proc generateInterruptRoutineForControllerWithoutSharedRAM
  ?let @uint inTotalBankCount
  ?let @registerTable inRegisterTable
  ?let @lstring inFirstSaveRegister
  ?let @lstring inSecondSaveRegister
  ?let @bool inNeedsToSavePCLATH
  ?let @midrange_instructionList inInterruptRoutineInstructionList
  ?let @routineMap inRoutineMap
  ?let @constantMap inConstantMap
  ?let @location inEndOfInterruptLocation
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@uint ioLocalLabelIndex
  ?!@string ioGenerationOptimizationMessages
  ?!@stringset ioUsedRegisters
{
#--- Check firstSaveRegister register is defined in RAM, is accessible from bank 0, and has a size of 1
  ioUsedRegisters ++= inFirstSaveRegister.string
  [inRegisterTable searchKey !inFirstSaveRegister ?var registerAddressList ?@uint size ?2* ?let firstProtection]
  [inRegisterTable checkPrivateAccess !inFirstSaveRegister !write:true !firstProtection]
  var @bool accessibleFromBank0 = false
  var @uint offset = 0 # Any value
  for (mValue) in  registerAddressList while not accessibleFromBank0 do
    offset = mValue & 0x7F
    accessibleFromBank0 = (mValue & 0xF80) == 0
  end
  if not accessibleFromBank0 then
    error inFirstSaveRegister: "the '" + inFirstSaveRegister + "' variable cannot be accessed from bank 0"
  end
  if inNeedsToSavePCLATH & (size != 3) then
    error inFirstSaveRegister: "the '" + inFirstSaveRegister + "' variable size is " + [size string] + " (it should be 3)"
  elsif (not inNeedsToSavePCLATH) & (size != 2) then
    error inFirstSaveRegister: "the '" + inFirstSaveRegister + "' variable size is " + [size string] + " (it should be 2)"
  end
#--- Check secondSaveRegister register is defined in RAM, is accessible from bank 1, and has a size of 1
  var @uintlist saveStatusRegisterAddressList = registerAddressList
  ioUsedRegisters ++= inSecondSaveRegister.string
  [inRegisterTable searchKey !inSecondSaveRegister ?registerAddressList ?size ?2* ?let secondProtection]
  [inRegisterTable checkPrivateAccess !inSecondSaveRegister !write:true !secondProtection]
  saveStatusRegisterAddressList = saveStatusRegisterAddressList + registerAddressList
  if size != 1 then
    error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable size is " + [size string] + " (it should be 1)"
  end
#--- Check the second save register is in bank 1 
  var @bool accessibleFromBank1 = false
  for (mValue) in  registerAddressList while not accessibleFromBank1 do
    accessibleFromBank1 = (mValue & 0xF80) == 0x80
  end
  if not accessibleFromBank1 then
    error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable cannot be accessed from bank 1"
  end
#--- Check offset of second save register in bank 1 == offset of first save register in bank 0
  var @bool offsetOk = true
  for (mValue) in  registerAddressList while offsetOk do
    offsetOk = offset == (mValue & 0x7F)
    if not offsetOk then
      error inSecondSaveRegister: "the '" + inSecondSaveRegister + "' variable has an offset equal to "
      + [mValue & 0x7F hexString] + ", while '" + inFirstSaveRegister + "' has an offset equal to "
      + [offset hexString] + " (tthe two offsets should be equal)"
    end
  end
#--- Generate save context instructions
  if @uint. errorCount == 0 then
    let first_register = @registerExpression {
      !inFirstSaveRegister
      !@immediatInteger {! @{!0 !.here}}
      !.here
    }
    [first_register resolveMidrangeAccess
      !inTotalBankCount
      !0
      !inRegisterTable
      !inConstantMap
      ?let first_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
    let first_register_second_byte = @registerExpression {
      !inFirstSaveRegister
      !@immediatInteger {! @{!1 !@location.here}}
      !.here
    }
    [first_register_second_byte resolveMidrangeAccess
      !inTotalBankCount
      !0
      !inRegisterTable
      !inConstantMap
      ?let first_reg_second_byte_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
  #--- Get values for STATUS register
    let STATUS_register = @registerExpression {
      !@lstring { !"STATUS" !@location.here}
      !@immediatInteger {! @{!0 !@location.here}}
      !.here
    }
    [STATUS_register resolveMidrangeAccess
      !inTotalBankCount
      !@uint. max
      !inRegisterTable
      !inConstantMap
      ?let STATUS_IPICregisterDescription
      ?*
      !?ioUsedRegisters
    ]
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF ! first_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !STATUS_IPICregisterDescription !true}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. CLRF !STATUS_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF ! first_reg_second_byte_IPICregisterDescription}
    if inNeedsToSavePCLATH then
      let first_register_third_byte = @registerExpression {
        !inFirstSaveRegister
        !@immediatInteger {! @{!0 !@location.here}}
        !.here
      }
      [first_register_third_byte resolveMidrangeAccess
        !inTotalBankCount
        !0
        !inRegisterTable
        !inConstantMap
        ?let first_var_third_byte_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
    #--- Get values for PCLATH register
      let PCLATH_register =@registerExpression {
        !@lstring { !"PCLATH" !@location.here}
        !@immediatInteger {! @{!0 !@location.here}}
        !.here
      }
      [PCLATH_register resolveMidrangeAccess
        !inTotalBankCount
        !@uint. max
        !inRegisterTable
        !inConstantMap
        ?let PCLATH_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. MOVF !PCLATH_IPICregisterDescription !true}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !first_var_third_byte_IPICregisterDescription}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. CLRF !PCLATH_IPICregisterDescription}
    end
  #--- Parse instruction list
    var @uint currentBank = 0 # Bank 0 is selected
    handleMidrangeInstructionList (
      !inInterruptRoutineInstructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioGenerationOptimizationMessages
      !inTotalBankCount
      !?currentBank
      !true # Preserve bank
      ?let continuesInSequence
      !@routineKind. interruptRoutine
      !?ioUsedRegisters
    )
    if not continuesInSequence then
      error inEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine"
    end
    if inNeedsToSavePCLATH then
      let first_register_third_byte = @registerExpression {
        !inFirstSaveRegister
        !@immediatInteger {! @{!2 !@location.here}}
        !.here
      }
      [first_register_third_byte resolveMidrangeAccess
        !inTotalBankCount
        !0
        !inRegisterTable
        !inConstantMap
        ?let @midrange_intermediate_registerExpression first_var_second_byte_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
    #--- Get values for PCLATH register
      let PCLATH_register = @registerExpression {
        !@lstring {!"PCLATH" !@location.here}
        !@immediatInteger {! @{!0 !@location.here}}
        !.here
      }
      let @midrange_intermediate_registerExpression PCLATH_IPICregisterDescription
      [PCLATH_register resolveMidrangeAccess
        !inTotalBankCount
        !@uint. max
        !inRegisterTable
        !inConstantMap
        ?PCLATH_IPICregisterDescription
        ?*
        !?ioUsedRegisters
      ]
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. MOVF !first_var_second_byte_IPICregisterDescription !true}
      ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !PCLATH_IPICregisterDescription}
    end
  #--- Restore context
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !first_reg_second_byte_IPICregisterDescription !true}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_F { !@location.here !@midrange_F_instruction_base_code. MOVWF !STATUS_IPICregisterDescription}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !first_IPICregisterDescription !false}
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_FD { !@location.here !@midrange_instruction_FD_base_code. SWAPF !first_IPICregisterDescription !true}
  #--- Add REFFIE
    ioGeneratedInstructionList += !@midrange_intermediate_instruction_RETFIE {!.here}
  end
}

#----------------------------------------------------------------------------*

