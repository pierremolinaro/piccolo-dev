

#----------------------------------------------------------------------------*

proc pic18BootloaderSpecificationAnalysis
  ?let @string inSourceFileName
  ?let @lstring inBootloaderName
  ?let @lstring inDeviceName
  ?let @routineDeclarationList inBootloaderRoutineDeclarationList
  ?let @bootloaderReservedRAMmap inBootloaderReservedRAMmap
  ?let @luint inReservedRomSize
  ?let @routineDeclarationList inUserRoutineDeclarationList
  ?let @ramDefinitionList inSharedRamDefinitionList
  !@string outListFileContents
  !@piccoloDeviceModel outPiccoloDeviceModel
  !@uint outAccessBankSplitOffset
  !@ramBankTable outRamBank
  !@registerTable outRegisterTable {
#-------------------------------- Check source file name
  @string sourceFileBaseName = [[inSourceFileName lastPathComponent] stringByDeletingPathExtension]
  if sourceFileBaseName != [inBootloaderName string] then
    error inBootloaderName: "the bootloader name ('" + inBootloaderName
    + "') should be identical to the file base name '" + sourceFileBaseName + "'"
  end
  outListFileContents = ""
#-------------------------------- Analyze Device
  parseDeviceDefinition ( !inDeviceName ? outPiccoloDeviceModel )
  switch [outPiccoloDeviceModel mProcessorType]
    case pic18_60 : outAccessBankSplitOffset = 0x60
    case pic18_80 : outAccessBankSplitOffset = 0x80
    case midrange : error inDeviceName: "a midrange device is not accepted here" : outAccessBankSplitOffset
    case baseline : error inDeviceName: "a baseline device is not accepted here" : outAccessBankSplitOffset
  end
#-------------------------------- Check reserved ROM size < microcontroller ROM size
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  outListFileContents += "*" + ["BOOTLOADER FOOTPRINT" stringByLeftAndRightPadding !117 !' '] + "*\n"
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  if [inReservedRomSize uint] >= [[outPiccoloDeviceModel mRomSize] uint] then
    error inReservedRomSize: "reserved size for bootloader ("
    + [[inReservedRomSize uint] string] + " bytes) is greater than ROM size ("
    + [[[outPiccoloDeviceModel mRomSize] uint] string] + " bytes) of "
    + inDeviceName + " micro controller" 
  end
  outListFileContents += "ROM size : " + [[inReservedRomSize uint] string] + " bytes.\n\n"
#-------------------------------- Check reserved RAM size <= microcontroller RAM size (in every bank)
  outRamBank = [outPiccoloDeviceModel mRamBankTable]
  for () in  inBootloaderReservedRAMmap do
    @uint firstAddress
    @uint firstFreeAddress # Mutable
    @uint lastAddressPlusOne
    @uintlist mirrorOffsetList
    [outRamBank searchKey !lkey ?firstAddress ?firstFreeAddress ?lastAddressPlusOne ?mirrorOffsetList]
    firstFreeAddress = firstFreeAddress + [mReservedSize uint]
    if (firstFreeAddress > lastAddressPlusOne) then
      error mReservedSize: "reserved size is greater than size of '" + lkey + "' bank ("
      + [lastAddressPlusOne - firstAddress string] + " bytes)"
    else
      [!?outRamBank setMFirstFreeAddressForKey !firstFreeAddress ![lkey string]]
      outListFileContents += "'" + lkey + "' RAM size : " + [[mReservedSize uint] string] + " bytes (from "
      + [firstAddress hexString] + " to " + [firstFreeAddress - 1 hexString] + ").\n\n"
    end
  end
#-------------------------------- Check bootloader routines
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  outListFileContents += "*" + ["BOOTLOADER ROUTINES" stringByLeftAndRightPadding !117 !' '] + "*\n"
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  outListFileContents += ["Routine" stringByLeftPadding !40 !' '] + " Entry point address\n"
  var routineNameSet =@stringset.emptySet{}
  @uint entryPointAddress = 0x4
  for () in  inBootloaderRoutineDeclarationList do
    if [routineNameSet hasKey ![mRoutineName string]] then
      error mRoutineName:"This routine is already declared"
    end
    routineNameSet += ![mRoutineName string]
    outListFileContents += [[mRoutineName string] stringByLeftPadding !40 !' '] + " " + [entryPointAddress hexString] + "\n"
    entryPointAddress = entryPointAddress + 4
    if entryPointAddress == 0x08 then
      entryPointAddress = 0x0C
    elsif entryPointAddress == 0x18 then
      entryPointAddress = 0x1C
    end
  end
  outListFileContents += "\n"
#-------------------------------- Check user program routines
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  outListFileContents += "*" + ["USER PROGRAM ROUTINES" stringByLeftAndRightPadding !117 !' '] + "*\n"
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
  outListFileContents += ["Routine" stringByLeftPadding !40 !' '] + " Entry point address\n"
  entryPointAddress = [inReservedRomSize uint]
  for () in  inUserRoutineDeclarationList do
    if [routineNameSet hasKey ![mRoutineName string]] then
      error mRoutineName:"This routine is already declared"
    end
    routineNameSet += ![mRoutineName string]
    outListFileContents += [[mRoutineName string] stringByLeftPadding !40 !' '] + " " + [entryPointAddress hexString] + "\n"
    entryPointAddress = entryPointAddress + 4
  end
  outListFileContents += "\n"
#-------------------------------- Check shared RAM
  outRegisterTable = [outPiccoloDeviceModel mRegisterTable]
  analyze_ram_sections (
    !"SHARED VARIABLES"
    !inSharedRamDefinitionList
    !?outRamBank
    ![outPiccoloDeviceModel mRegisterTable]
    !?outListFileContents
    !?outRegisterTable
    ?*
  )
  outListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
}

#----------------------------------------------------------------------------*

