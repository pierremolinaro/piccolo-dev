syntax pic18_syntax (piccolo_lexique) {

#----------------------------------------------------*

rule <configuration_definition>
  ?!@configDefinitionList ioConfigDefinitionList

rule <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList

rule <constant_definition>
  ?!@constantDefinitionList ioConstantDefinitionList

rule <immediate_expression>
  !@immediatExpression outExpression

rule <register_parsing>
  !@registerExpression outRegisterExpression

rule <optional_w_as_dest>
  !@bool out_W_isDestination

rule <bit_number_parsing>
  !@bitNumberExpression outBitNumber

#----------------------------------------------------*

rule <body>
  ?!@pic18InterruptDefinitionList interruptDefinitionList
  ?!@pic18RoutineDefinitionList routineDefinitionList
  ?!@pic18MacroDefinitionList ioMacroDefinitionList
  ?!@lstringlist unusedRoutineList
  ?!@lstringlist inlinedRoutineList
  ?!@ramDefinitionList ramDefinitionList
  ?!@lstringlist unusedRegisterList
  ?!@configDefinitionList configDefinitionList
  ?!@constantDefinitionList constantDefinitionList
  ?!@checkpicList ioCheckpicList
  ?!@dataList dataList
  ?!@bool needsComputedGoto2
  ?!@bool needsComputedGoto4
{
  repeat
  while
    $unused$
    $byte$
    repeat
      $identifier$ ?let @lstring unusedRegister
      unusedRegisterList += !unusedRegister
    while 
      $,$
    end
  while
    $unused$
    $routine$
    repeat
      $identifier$ ?let @lstring unusedRoutine
      unusedRoutineList += !unusedRoutine
    while 
      $,$
    end
  while
    $inline$
    repeat
      $identifier$ ?let @lstring inlinedRoutine
      inlinedRoutineList += !inlinedRoutine
    while 
      $,$
    end
  while
    <configuration_definition> !?configDefinitionList
  while
    <ram_definition> !?ramDefinitionList
  while
    <constant_definition> !?constantDefinitionList
  while
    <interrupt_definition>
      !?interruptDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
  while
    <routine_definition>
      !?routineDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
  while
    <data_definition> !?dataList
  while
    <checkpic_definition> !?ioCheckpicList
  while
    $include$
    $literal_string$ ?let @lstring includedFilePath
    grammar pic18_include_grammar (
      !?interruptDefinitionList
      !?routineDefinitionList
      !?ioMacroDefinitionList
      !?unusedRoutineList
      !?inlinedRoutineList
      !?ramDefinitionList
      !?unusedRegisterList
      !?configDefinitionList
      !?constantDefinitionList
      !?ioCheckpicList
      !?dataList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ) in includedFilePath
  while
    $macro$
    $identifier$ ?let macroName
    $($
    var @lstringlist constantNameList = ()
    repeat
      $identifier$ ?let constantName
      constantNameList += !constantName
    while
      $,$
    end
    $)$
    ${$
    var @labelMap labelMap = ()
    <instruction_list>
      ?let @pic18InstructionList instructionList
      !?needsComputedGoto2
      !?needsComputedGoto4
      !?labelMap
    $}$
    ioMacroDefinitionList +=
      !macroName
      !constantNameList
      !instructionList
  end
}

#----------------------------------------------------*

rule <checkpic_definition>
  ?!@checkpicList ioList {
  $checkpic$
  let @location loc = @location.here
  var valueList =@lstringlist ()
  repeat
    $literal_string$ ?let @lstring s
    valueList += !s
  while
    $,$
  end
  ioList += !loc !valueList
}
    
#----------------------------------------------------*

rule <data_definition> ?!@dataList ioDataList {
  select
    $data$
    warning .here : "obsolete keyword" fixit { replace "data16" }
  or
    $data16$
  end
  $identifier$ ?let @lstring dataName
  ${$
  var @immediatExpressionList valueList = ()
  repeat
    <immediate_expression> ?let @immediatExpression expression
    valueList += !expression !@location.here
  while
    $,$
  end
  $}$
  ioDataList += !dataName !valueList !false
}

#----------------------------------------------------*

rule <data_definition> ?!@dataList ioDataList {
  $data8$
  $identifier$ ?let @lstring dataName
  ${$
  var @immediatExpressionList valueList = ()
  repeat
    <immediate_expression> ?let @immediatExpression expression
    valueList += !expression !@location.here
  while
    $,$
  end
  $}$
  ioDataList += !dataName !valueList !true
}
    
#----------------------------------------------------*

rule <instruction_list>
  !@pic18InstructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
  ?!@labelMap ioLabelMap
{
  outInstructionList = @pic18InstructionList ()
  repeat
  while
    <simple_instruction> ?let @pic18PiccoloSimpleInstruction instruction
    outInstructionList += !instruction
  while
    <structured_instruction>
      ?let instruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    outInstructionList += !instruction
  end
}

#----------------------------------------------------*

rule <interrupt_definition>
  ?!@pic18InterruptDefinitionList ioInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
{
  $interrupt$
  $identifier$ ?let @lstring interruptName
  let @bool isFast
  select
    isFast = false
  or
    $fast$
    isFast = true
  end
  ${$
  var @labelMap labelMap = ()
  <instruction_list>
    ?let instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
    !?labelMap
  $}$
  ioInterruptDefinitionList += !interruptName !isFast !instructionList !@location.here
}

#----------------------------------------------------*

rule <routine_definition>
  ?!@pic18RoutineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4 {
  let @bool noreturn
  select
    noreturn = false
  or
    $noreturn$
    noreturn = true
  end
  $routine$
  $identifier$ ?let @lstring routineName indexing routineDefinition
  let @luint requiredBank
  let @luint returnedBank
  let @bool preservesBank
  select
    requiredBank = @luint.init { !@uint. max !@location.here}
    returnedBank = @luint.init { !@uint. max !@location.here}
    preservesBank = false
  or
    $bank$
    $:$
    select
      $preserved$
      if noreturn then
        error @location.here: "a \"noreturn\" routine cannot accept \"bank:preserved\" setting"
      end
      preservesBank = true
      requiredBank = @luint.init { !@uint. max !@location.here}
      returnedBank = @luint.init { !@uint. max !@location.here}
    or
      $requires$
      $integer$ ? requiredBank
      preservesBank = false
      select
        returnedBank = @luint.init { !@uint. max !@location.here}
      or
        $ensures$
        $integer$ ? returnedBank
        if noreturn then
          error @location.here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting"
        end
      end
    or
      $ensures$
      $integer$ ? returnedBank
      if noreturn then
        error @location.here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting"
      end
      preservesBank = false
      requiredBank = @luint.init { !@uint. max !@location.here}
    end
  end
  ${$
  var @labelMap labelMap = ()
  <instruction_list>
    ?let @pic18InstructionList instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
    !?labelMap
  $}$
  ioRoutineDefinitionList += !routineName !requiredBank !returnedBank !preservesBank !noreturn !instructionList !@location.here
}

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition {
  $!$
  <condition_factor> ?let condition
  outCondition = @pic18NegateCondition.init { !condition}
}

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition {
  <condition_expression> ? outCondition
}

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition {
  select
    let @bool isIncrement
    select
      $incf$ ; isIncrement = true
    or
      $decf$ ; isIncrement = false
    end
    <register_parsing> ?let registerExpression
    let @bool W_isDestination
    select
      W_isDestination = false
    or
      $,$ ; $w$ ; W_isDestination = true
    end
    $identifier$ ?let @lstring conditionString
    let @string condition = [conditionString.string uppercaseString]
    let @bool branchIfZero
    if condition == "Z" then
      branchIfZero = true
    elsif condition == "NZ" then
      branchIfZero = false
    else
      error conditionString: "invalid '" + conditionString
      + "' condition; valid ones are: 'z' and 'nz'"
      : branchIfZero
    end
    outCondition = @pic18IncDecRegisterInCondition.init {
      !registerExpression
      !isIncrement
      !W_isDestination
      !branchIfZero}
  or
    <register_parsing> ?let registerExpression
    let @pic18RegisterComparison comparison
    select
      $!=$ ; $w$ ; comparison = @pic18RegisterComparison. notEqual
    or
      $==$ ; $w$ ; comparison = @pic18RegisterComparison. equal
    or
      $<=$ ; $w$ ; comparison = @pic18RegisterComparison. lowerOrEqual
    or
      $>=$ ; $w$ ; comparison = @pic18RegisterComparison. greaterOrEqual
    or
      $<$ ; $w$ ; comparison = @pic18RegisterComparison. lower
    or
      $>$ ; $w$ ; comparison = @pic18RegisterComparison. greater
    end
    outCondition = @pic18RegisterComparisonCondition.init {
      !registerExpression
      !comparison}
  or
    <register_parsing> ?let registerExpression
    $.$
    <bit_number_parsing> ?let bitNumberExpression
    outCondition = @pic18BitTestInStructuredCondition.init {
      !registerExpression
      !bitNumberExpression
    }
  or
    <register_parsing> ?let registerName
    $identifier$ ?let @lstring conditionString
    let @string condition = [conditionString.string uppercaseString]
    let @bool branchIfZero
    if condition == "Z" then
      branchIfZero = true
    elsif condition == "NZ" then
      branchIfZero = false
    else
      error conditionString: "invalid '" + conditionString
      + "' condition; valid ones are: 'z' and 'nz'"
      : branchIfZero
    end
    outCondition = @pic18RegisterTestCondition.init { !registerName !branchIfZero}
  or
    let @conditional_branch conditional_branch
    $identifier$ ?let @lstring conditionString
    let @string condition = [conditionString.string uppercaseString]
    if condition == "Z" then
      conditional_branch = @conditional_branch. bz
    elsif condition == "NZ" then
      conditional_branch = @conditional_branch. bnz
    elsif condition == "NN" then
      conditional_branch = @conditional_branch. bnn
    elsif condition == "N" then
      conditional_branch = @conditional_branch. bn
    elsif condition == "C" then
      conditional_branch = @conditional_branch. bc
    elsif condition == "NC" then
      conditional_branch = @conditional_branch. bnc
    elsif condition == "OV" then
      conditional_branch = @conditional_branch. bov
    elsif condition == "NOV" then
      conditional_branch = @conditional_branch. bnov
    else
      error conditionString: "invalid '" + conditionString
      + "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      : conditional_branch
    end
    outCondition = @pic18BccInStructuredCondition.init { !conditionString.location !conditional_branch}
  end
}

#----------------------------------------------------*

rule <condition_expression>
  !@pic18ConditionExpression outCondition {
  $($
  <condition_term> ? outCondition
  repeat
  while
    $|$
    <condition_term> ?let c
    let @pic18ConditionExpression rc = @pic18NegateCondition.init { !c}
    let @pic18ConditionExpression lc = @pic18NegateCondition.init { !outCondition}
    outCondition = @pic18NegateCondition.init { !@pic18AndCondition.init { !lc !rc}}
  end
  $)$
}

#----------------------------------------------------*

rule <condition_term>
  !@pic18ConditionExpression outCondition {
  <condition_factor> ? outCondition
  repeat
  while
    $&$
    <condition_factor> ?let @pic18ConditionExpression c
    outCondition = @pic18AndCondition.init { !outCondition !c}
  end
}

#----------------------------------------------------*

rule <block_termination>
  !@abstractBlockTerminationForBlockInstruction outBlockTermination {
  $-$
  outBlockTermination = @exitBlockTerminationForBlockInstruction.init { !@location.here}
}

#----------------------------------------------------*

rule <block_termination>
  !@abstractBlockTerminationForBlockInstruction outBlockTermination {
  $identifier$ ?let @lstring nextBlockName
  outBlockTermination = @gotoTerminationForBlockInstruction.init { !nextBlockName}
}

#----------------------------------------------------*

rule <block_termination>
  !@abstractBlockTerminationForBlockInstruction outBlockTermination {
  let @location location = @location.here
   <condition_expression> ?let @pic18ConditionExpression condition
   $?$
   <block_termination> ?let @abstractBlockTerminationForBlockInstruction terminationIfTrue
   $:$
   <block_termination> ?let @abstractBlockTerminationForBlockInstruction terminationIfFalse
   outBlockTermination = @testTerminationForBlockInstruction.init { !condition !terminationIfTrue !terminationIfFalse !location}
}

#----------------------------------------------------*

rule <structured_instruction>
  !@pic18PiccoloInstruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
  ?!@labelMap ioLabelMap
{
  select
    $switch$
    let @lstring switchLabel
    select
      switchLabel = .init {!"" !.here}
    or
      $label$ ?switchLabel
      [!?ioLabelMap insertKey !switchLabel]
    end
    let instructionLocation = @location.here
    $w$
    var @pic18SwitchInstructionCaseList caseList = ()
    repeat
      $case$
      let @lstring caseLabel
      select
        caseLabel = .init {!"" !.here}
      or
        $label$ ?caseLabel
      end
      if switchLabel.string != caseLabel.string then
        error caseLabel : "'case' label does not match 'switch' label, it should be "
           + (if switchLabel.string != "" then switchLabel.string else "empty" end)
      end 
      let @location caseLocation = @location.here
      var caseExpressionList =@pic18CaseExpressionList ()
      repeat
        select
          <immediate_expression> ?let @immediatExpression caseExpression
          caseExpressionList += !@pic18SimpleConstantCaseItem.init { !caseExpression !@location.here}
        or
          $[$
          <immediate_expression> ?let @immediatExpression minExpression
          $,$
          <immediate_expression> ?let @immediatExpression maxExpression
          $]$
          caseExpressionList += !@pic18IntervalCaseItem.init { !minExpression !maxExpression !@location.here}
        end
      while
        $,$
      end
      $:$
      <instruction_list>
        ?let @pic18InstructionList instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
        !?ioLabelMap
      caseList += !caseLocation !caseExpressionList !instructionList
    while
    end
    let @pic18InstructionList elseInstructionList
    let @location elseLocation
    select
      elseLocation = @location.here
      elseInstructionList = @pic18InstructionList ()
    or
      $else$
      let @lstring elseLabel
      select
        elseLabel = .init {!"" !.here}
      or
        $label$ ?elseLabel
      end
      if switchLabel.string != elseLabel.string then
        error elseLabel : "'else' label does not match 'switch' label, it should be "
           + (if switchLabel.string != "" then switchLabel.string else "empty" end)
      end 
      elseLocation = @location.here
      <instruction_list>
        ?elseInstructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
        !?ioLabelMap
    end
    outInstruction = @pic18Instruction_switch.init {
      !instructionLocation
      !caseList
      !elseLocation
      !elseInstructionList}
    $end$
    let @lstring endSwitchLabel
    select
      endSwitchLabel = .init {!"" !.here}
    or
      $label$ ?endSwitchLabel
    end
    if switchLabel.string != endSwitchLabel.string then
      error switchLabel : "'end' label does not match 'switch' label, it should be "
         + (if switchLabel.string != "" then switchLabel.string else "empty" end)
    end 
  or
    $block$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring startBlockName
    $:$
    var blockList =@pic18BlockInstructionBlockList ()
    repeat
      $identifier$ ?let @lstring blockName
      ${$
      <instruction_list>
        ?let @pic18InstructionList instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
        !?ioLabelMap
      $}$
      let @location endOfBlock = @location.here
      <block_termination> ?let @abstractBlockTerminationForBlockInstruction blockTermination
      blockList += !blockName !instructionList !blockTermination !endOfBlock
    while
    end    
    outInstruction = @pic18Instruction_block.init {
      !instructionLocation
      !startBlockName
      !blockList
      !@location.here}
    $end$
  or
    $do$
    let @lstring doLabel
    select
      doLabel = .init {!"" !.here}
    or
      $label$ ?doLabel
      [!?ioLabelMap insertKey !doLabel]
    end
    let instructionLocation = @location.here
    $($
    $identifier$ ?let constantName
    $:$
    <immediate_expression> ?let @immediatExpression lowBoundExpression
    $...$
    <immediate_expression> ?let @immediatExpression highBoundExpression
    $)$
    <instruction_list>
      ?let @pic18InstructionList instructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    outInstruction = @pic18Instruction_repetitionStatique.init {
      !instructionLocation
      !constantName
      !lowBoundExpression
      !highBoundExpression
      !instructionList
      !@location.here
    }
    $end$
    let @lstring endDoLabel
    select
      endDoLabel = .init {!"" !.here}
    or
      $label$ ?endDoLabel
    end
    if doLabel.string != endDoLabel.string then
      error endDoLabel : "'end' label does not match 'do' label, it should be "
         + (if doLabel.string != "" then doLabel.string else "empty" end)
    end 
  or
    $checkbank$
    $integer$ ?let @luint bankIndex
    outInstruction = @pic18Instruction_checkbank.init { !bankIndex.location !bankIndex.uint}
  or
    $checknobank$
    outInstruction = @pic18Instruction_checknobank.init { !@location.here}
  or
    select
      $ldataptr$
      warning .here : "obsolete keyword" fixit { replace "ldata16ptr" }
    or
      $ldata16ptr$
    end
    let @location instructionLocation = .here
    $identifier$ ?let @lstring dataName
    $[$
    $integer$ ?let @luint dataIndex
    $]$
    outInstruction = @pic18Instruction_LDATA16PTR.init { !instructionLocation !dataName !dataIndex}
  or
    $ldata8ptr$
    let @location instructionLocation = .here
    $identifier$ ?let @lstring dataName
    $[$
    $integer$ ?let @luint dataIndex
    $]$
    outInstruction = @pic18Instruction_LDATA8PTR.init { !instructionLocation !dataName !dataIndex}
  or
    $ltblptr$
    let @location instructionLocation = @location.here
    <immediate_expression> ?let @immediatExpression expression
    outInstruction = @pic18Instruction_LTBLPTR.init { !instructionLocation !expression}
  or
    $banksel$
    let @location instructionLocation = @location.here
    $integer$ ?let @luint bank
    let @bool warningOnUselessBanksel
    select
      warningOnUselessBanksel = true
    or
      $,$
      $*$
      warningOnUselessBanksel = false
    end
    outInstruction = @pic18Instruction_banksel.init { ! instructionLocation !bank !warningOnUselessBanksel}
  or
    $banksel$
    let @location instructionLocation = @location.here
    <register_parsing> ?let @registerExpression register
    let @bool warningOnUselessBanksel
    select
      warningOnUselessBanksel = true
    or
      $,$
      $*$
      warningOnUselessBanksel = false
    end
    outInstruction = @pic18Instruction_banksel_register.init { !instructionLocation !register !warningOnUselessBanksel}
  or
    $nobank$
    outInstruction = @pic18Instruction_nobanksel.init { !@location.here}
  or
    $banksave$
    let @location instructionLocation = @location.here
    <register_parsing> ?let @registerExpression register
    <instruction_list>
      ?let @pic18InstructionList instructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    $end$
    outInstruction = @pic18Instruction_savebank.init {
      !instructionLocation
      !register
      !instructionList
      !@location.here
    }
  or
    $computed$
    let @location instructionLocation = @location.here
    $[$
    <immediate_expression> ?let sizeExpression
    $]$
    select
      $retlw$
      var argumentList =@immediatExpressionList ()
      repeat
        <immediate_expression> ?let expression
        argumentList += !expression !@location.here
      while
        $,$
      end
      outInstruction = @pic18Instruction_computed_retlw.init {
        !instructionLocation
        !sizeExpression
        !argumentList
        !true}
      ioNeedsComputedGoto2 = true
    or
      $bra$
      var argumentList =@lstringlist ()
      repeat
        $identifier$ ?let @lstring targetRoutine indexing routineCall
        argumentList += ! targetRoutine
      while
        $,$
     end
       outInstruction = @pic18Instruction_computed_bra.init {
        !instructionLocation
        !sizeExpression
        !argumentList
        !true}
      ioNeedsComputedGoto2 = true
    or
      $goto$
      var argumentList =@lstringlist ()
      repeat
        $identifier$ ?let @lstring targetRoutine indexing routineCall
        argumentList += ! targetRoutine
      while
        $,$
      end
      outInstruction = @pic18Instruction_computed_goto.init {
        !instructionLocation
        !sizeExpression
        !argumentList
        !true}
      ioNeedsComputedGoto4 = true
    or
      $rcall$
      var argumentList =@lstringlist ()
      repeat
        $identifier$ ?let @lstring targetRoutine indexing routineCall
        argumentList += ! targetRoutine
      while
        $,$
      end
      outInstruction = @pic18Instruction_computed_rcall.init {
        !instructionLocation
        !sizeExpression
        !argumentList
        !true}
      ioNeedsComputedGoto4 = true
    end
  or
    $forever$
    let @lstring foreverLabel
    select
      foreverLabel = .init {!"" !.here}
    or
      $label$ ?foreverLabel
      [!?ioLabelMap insertKey !foreverLabel]
    end
    let instructionLocation = @location.here
    <instruction_list>
      ?let instructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    $end$
    let @lstring endForeverLabel
    select
      endForeverLabel = .init {!"" !.here}
    or
      $label$ ?endForeverLabel
    end
    if foreverLabel.string != endForeverLabel.string then
      error endForeverLabel : "'end' label does not match 'fovever' label, it should be "
         + (if foreverLabel.string != "" then foreverLabel.string else "empty" end)
    end 
    outInstruction = @pic18Instruction_FOREVER.init {
      !instructionLocation
      !instructionList
      !@location.here
    }
  or
    $if$
    let @location instructionLocation = @location.here
    <register_parsing> ?let registerName
    let @if_semi_colon_op opCode
    select
      $!=$ ; $w$ ; opCode = @if_semi_colon_op. CPFSEQ
    or
      $<=$ ; $w$ ; opCode = @if_semi_colon_op. CPFSGT
    or
      $>=$ ; $w$ ; opCode = @if_semi_colon_op. CPFSLT
    or
      $identifier$ ?let @lstring conditionString
      let @string condition = [conditionString.string uppercaseString]
      if condition != "NZ" then
        error conditionString:"invalid '" + condition + "' condition; it should be 'nz'"
      end
      opCode = @if_semi_colon_op. TSTFSZ
    end
    $:$
    <simple_instruction> ?let @pic18PiccoloSimpleInstruction instruction
    outInstruction = @pic18Instruction_IF_FA_SEMI_COLON.init {
      !instructionLocation
      !instruction
      !opCode
      !registerName}
  or
    $if$
    let @location instructionLocation = @location.here
    let @registerExpression registerName
    let @bitNumberExpression bitNumber
    let @bool skipIfSet
    select
      $!$
      <register_parsing> ?registerName
      $.$
      <bit_number_parsing> ?bitNumber
      skipIfSet = true
    or
      <register_parsing> ?registerName
      $.$
      <bit_number_parsing> ?bitNumber
      skipIfSet = false
    end
    $:$
    <simple_instruction> ?let @pic18PiccoloSimpleInstruction instruction
    outInstruction = @pic18Instruction_IF_BitTest.init {
      !instructionLocation
      !instruction
      !skipIfSet
      !registerName
      !bitNumber
    }
  or
    $if$
    let @location instructionLocation = @location.here
    let @bool increment
    select
      $decf$ ; increment = false
    or
      $incf$ ; increment = true
    end
    <register_parsing> ?let registerName
    let @bool w_isTarget
    select
      w_isTarget = false
    or
      $,$ ; $w$ ; w_isTarget = true
    end
    let @bool skipIfZero
    $identifier$ ?let @lstring conditionString
    let @string condition = [conditionString.string uppercaseString]
    if condition == "Z" then
      skipIfZero = false
    elsif condition == "NZ" then
      skipIfZero = true
    else
      error conditionString:"invalid '" + condition + "' condition; it should be 'z' or 'nz'" : skipIfZero
    end
    $:$
    <simple_instruction> ?let @pic18PiccoloSimpleInstruction instruction
    outInstruction = @pic18Instruction_IF_IncDec.init {
      !instructionLocation
      !instruction
      !increment
      !skipIfZero
      !registerName
      !w_isTarget}
  or
    $if$
    let @lstring ifLabel
    select
      ifLabel = .init {!"" !.here}
    or
      $label$ ?ifLabel
      [!?ioLabelMap insertKey !ifLabel]
    end
    <structured_if_instruction>
      !ifLabel
      ?outInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    $end$
    let @lstring endIfLabel
    select
      endIfLabel = .init {!"" !.here}
    or
      $label$ ?endIfLabel
    end
    if ifLabel.string != endIfLabel.string then
      error endIfLabel : "'end' label does not match 'if' label, it should be "
         + (if ifLabel.string != "" then ifLabel.string else "empty" end)
    end 
  or
    $do$
    let @lstring doLabel
    select
      doLabel = .init {!"" !.here}
    or
      $label$ ?doLabel
      [!?ioLabelMap insertKey !doLabel]
    end
    let @location instructionLocation = @location.here
    <instruction_list>
      ?let repeatedInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    let endOfRepeatedInstructionList = @location.here
    var whilePartList =@pic18DoWhilePartList ()
    repeat
      $while$
      let @lstring whileLabel
      select
        whileLabel = .init {!"" !.here}
      or
        $label$ ?whileLabel
      end
      if doLabel.string != whileLabel.string then
        error whileLabel : "'while' label does not match 'do' label, it should be "
           + (if doLabel.string != "" then doLabel.string else "empty" end)
      end 
      <condition_expression> ?let whileCondition
      <instruction_list>
        ?let instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
        !?ioLabelMap
      whilePartList += !whileCondition !instructionList !@location.here
    while
    end
    $end$
    let @lstring endDoLabel
    select
      endDoLabel = .init {!"" !.here}
    or
      $label$ ?endDoLabel
    end
    if doLabel.string != endDoLabel.string then
      error endDoLabel : "'end' label does not match 'do' label, it should be "
         + (if doLabel.string != "" then doLabel.string else "empty" end)
    end 
    outInstruction = @pic18Instruction_do_while.init {
      !instructionLocation
      !repeatedInstructionList
      !endOfRepeatedInstructionList
      !whilePartList
    }
  or
    $mnop$
    let @location instructionLocation = @location.here
    $integer$ ?let @luint occurrenceFactor
    outInstruction = @pic18Instruction_MNOP.init { !instructionLocation !occurrenceFactor}
  or
    $nopbra$
    let instructionLocation = @location.here
    $integer$ ?let @luint occurrenceFactor
    outInstruction = @pic18Instruction_NOPBRA.init {!instructionLocation !occurrenceFactor}
  or
    let @conditional_branch condition
    select
      $bc$ ; condition = @conditional_branch. bc
    or
      $bnc$ ; condition = @conditional_branch. bnc
    or
      $bn$ ; condition = @conditional_branch. bn
    or
      $bnn$ ; condition = @conditional_branch. bnn
    or
      $bov$ ; condition = @conditional_branch. bov
    or
      $bnov$ ; condition = @conditional_branch. bnov
    or
      $bz$ ; condition = @conditional_branch. bz
    or
      $bnz$ ; condition = @conditional_branch. bnz
    end
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JUMPCC.init {
      !instructionLocation
      !targetLabelName
      !condition
      !true}
  or
    $jump$
    let @location instructionLocation = @location.here
    let @conditional_branch conditional_branch
    $identifier$ ?let @lstring conditionString
    let @string condition = [conditionString.string uppercaseString]
    if condition == "Z" then
      conditional_branch = @conditional_branch. bz
    elsif condition == "NZ" then
      conditional_branch = @conditional_branch. bnz
    elsif condition == "NN" then
      conditional_branch = @conditional_branch. bnn
    elsif condition == "N" then
      conditional_branch = @conditional_branch. bn
    elsif condition == "C" then
      conditional_branch = @conditional_branch. bc
    elsif condition == "NC" then
      conditional_branch = @conditional_branch. bnc
    elsif condition == "OV" then
      conditional_branch = @conditional_branch. bov
    elsif condition == "NOV" then
      conditional_branch = @conditional_branch. bnov
    else
      error conditionString: "invalid '" + conditionString
      + "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      : conditional_branch
    end
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JUMPCC.init {
      !instructionLocation
      !targetLabelName
      !conditional_branch
      !false}
  or
    $jump$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JUMP.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind. ipicRelative}
  or
    $goto$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JUMP.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind. absolute}
  or
    $bra$
    let instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JUMP.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind.relative
    }
  or
    $macro$
    $identifier$ ?let macroName
    $($
    var @immediatExpressionList immediatExpressionList = ()
    repeat
      <immediate_expression> ?let @immediatExpression constantExpression
      immediatExpressionList += !constantExpression !.here
    while
      $,$
    end
    $)$
    outInstruction = @pic18Instruction_macro.init {
      !macroName.location
      !macroName
      !immediatExpressionList
    }
  end
}

#----------------------------------------------------*

rule <structured_if_instruction>
  ?let @lstring ifLabel
  !@pic18PiccoloInstruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
  ?!@labelMap ioLabelMap
{
  let @location instructionLocation = @location.here
  <condition_expression> ?let structured_if_condition
  <instruction_list>
    ?let thenInstructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
    !?ioLabelMap
  var @pic18InstructionList elseInstructionList
  select
    elseInstructionList = @pic18InstructionList ()
  or
    $elsif$
    let @lstring elsifIfLabel
    select
      elsifIfLabel = .init {!"" !.here}
    or
      $label$ ?elsifIfLabel
    end
    if ifLabel.string != elsifIfLabel.string then
      error elsifIfLabel : "'elsif' label does not match 'if' label, it should be "
         + (if ifLabel.string != "" then ifLabel.string else "empty" end)
    end 
    <structured_if_instruction>
      !ifLabel
      ?let elsifPartInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
    elseInstructionList = @pic18InstructionList ()
    elseInstructionList += !elsifPartInstruction
  or
    $else$
    let @lstring elsifLabel
    select
      elsifLabel = .init {!"" !.here}
    or
      $label$ ?elsifLabel
    end
    if ifLabel.string != elsifLabel.string then
      error elsifLabel : "'else' label does not match 'if' label, it should be "
         + (if ifLabel.string != "" then ifLabel.string else "empty" end)
    end 
    <instruction_list>
      ?elseInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
      !?ioLabelMap
  end
  let @location endOfElsePartLocation = @location.here
  outInstruction = @pic18Instruction_structured_if.init {
    !instructionLocation
    !structured_if_condition
    !thenInstructionList
    !elseInstructionList
    !endOfElsePartLocation}
}

#----------------------------------------------------*

rule <simple_instruction> !@pic18PiccoloSimpleInstruction outInstruction {
  select
    let @pic18Instruction_FDA_base_code_AST baseCode
    select
      $addwf$
      baseCode = .ADDWF
    or
      $addwfc$
      baseCode = .ADDWFC
    or
      $andwf$
      baseCode = .ANDWF
    or
      $comf$
      baseCode = .COMF
    or
      $decf$
      baseCode = .DECF
    or
      $incf$
      baseCode = .INCF
    or
      $iorwf$
      baseCode = .IORWF
    or
      $movf$
      baseCode = .MOVF
    or
      $rlcf$
      baseCode = .RLCF
    or
      $rlncf$
      baseCode = .RLNCF
    or
      $rrcf$
      baseCode = .RRCF
    or
      $rrncf$
      baseCode = .RRNCF
    or
      $subfwb$
      baseCode = .SUBFWB
    or
      $subwf$
      baseCode = .SUBWF
    or
      $subwfb$
      baseCode = .SUBWFB
    or
      $swapf$
      baseCode = .SWAPF
    or
      $xorwf$
      baseCode = .XORWF
    end
    let @location instructionLocation = .here
    <register_parsing> ?let registerName
    <optional_w_as_dest> ?let W_isDestination
    outInstruction = @pic18Instruction_FDA.init {
      !instructionLocation
      !baseCode
      !registerName
      !W_isDestination
    }
  #--- Emit a warning if instruction is "movf" and W is not destination
    if (baseCode == .MOVF) && not W_isDestination then
      warning instructionLocation :  "This instruction does not move data, it only sets flags. "
        "Use 'movf *, reg' instead of 'movf reg' to suppress this warning" 
    end
  or
    $movf$
    let @location instructionLocation = .here
    $*$
    $,$
    <register_parsing> ?let registerName
    outInstruction = @pic18Instruction_FDA.init {
      !instructionLocation
      !.MOVF
      !registerName
      !false # W is not destination
    }
  or
    let @FA_instruction_base_code FAinstruction
    select
      $clrf$
      FAinstruction = @FA_instruction_base_code. CLRF
    or
      $movwf$
      FAinstruction = @FA_instruction_base_code. MOVWF
    or
      $mulwf$
      FAinstruction = @FA_instruction_base_code. MULWF
    or
      $negf$
      FAinstruction = @FA_instruction_base_code. NEGF
    or
      $setf$
      FAinstruction = @FA_instruction_base_code. SETF
    end
    let @location instructionLocation = @location.here
    <register_parsing> ?let registerName
    outInstruction = @pic18Instruction_FA.init {
      !instructionLocation
      !FAinstruction
      !registerName}
  or
    $movff$
    let @location instructionLocation = @location.here
    <register_parsing> ?let sourceRegisterName
    $,$
    <register_parsing> ?let destinationRegisterName
    outInstruction = @pic18Instruction_MOVFF.init {
      !instructionLocation
      !sourceRegisterName
      !destinationRegisterName}
  or
    let @bit_oriented_op bitOrientedOp
    select
      $bcf$ ; bitOrientedOp = @bit_oriented_op. BCF
    or
      $bsf$ ; bitOrientedOp = @bit_oriented_op. BSF
    or
      $btg$ ; bitOrientedOp = @bit_oriented_op. BTG
    end
    let @location instructionLocation = @location.here
    <register_parsing> ?let @registerExpression registerName
    $.$
    <bit_number_parsing> ?let @bitNumberExpression bitNumber
    outInstruction = @pic18Instruction_FBA.init {
      !instructionLocation
      !bitOrientedOp
      !registerName
      !bitNumber
    }
  or
    $jsr$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JSR.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind. ipicRelative}
  or
    $call$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JSR.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind. absolute}
  or
    $rcall$
    let @location instructionLocation = @location.here
    $identifier$ ?let @lstring targetLabelName indexing routineCall
    outInstruction = @pic18Instruction_JSR.init {
      !instructionLocation
      !targetLabelName
      !@jumpInstructionKind. relative}
  or
    $clrwdt$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. CLRWDT}
  or
    $daw$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. DAW}
  or
    $nop$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. NOP}
  or
    $pop$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. POP}
  or
    $push$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. PUSH}
  or
    $reset$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. RESET}
  or
    $sleep$
    outInstruction = @pic18Instruction_withNoOperand.init { !@location.here !@pic18InstructionWithNoOperandKind. SLEEP}
  or
    $fnop$
    let @location instructionLocation = @location.here
    <immediate_expression> ?let @immediatExpression expression
    outInstruction = @pic18Instruction_fnop.init {
      !instructionLocation
      !expression}
  or
    let @literal_instruction_opcode literalInstruction
    select
      $addlw$ ; literalInstruction = @literal_instruction_opcode. ADDLW
    or
      $andlw$ ; literalInstruction = @literal_instruction_opcode. ANDLW
    or
      $iorlw$ ; literalInstruction = @literal_instruction_opcode. IORLW
    or
      $movlw$ ; literalInstruction = @literal_instruction_opcode. MOVLW
    or
      $mullw$ ; literalInstruction = @literal_instruction_opcode. MULLW
    or
      $sublw$ ; literalInstruction = @literal_instruction_opcode. SUBLW
    or
      $xorlw$ ; literalInstruction = @literal_instruction_opcode. XORLW
    end
    let @location instructionLocation = @location.here
    <immediate_expression> ?let @immediatExpression expression
    outInstruction = @pic18Instruction_literalOperation.init {
      !instructionLocation
      !literalInstruction
      !expression}
  or
    $lfsr$
    let @location instructionLocation = @location.here
    $integer$ ?let @luint FSRindex
    $,$
    <immediate_expression> ?let expression
    outInstruction = @pic18Instruction_LFSR.init { !instructionLocation !FSRindex !expression}
  or
    $tblrd$
    let @location instructionLocation = @location.here
    let @tableAccessOption accessOption
    select
      $*$
      accessOption = @tableAccessOption. simpleAccess
    or
      $*+$
      accessOption = @tableAccessOption. postIncrement
    or
      $*-$
      accessOption = @tableAccessOption. postDecrement
    or
      $+*$
      accessOption = @tableAccessOption. preIncrement
    end
    outInstruction = @pic18Instruction_TBLRD.init { !instructionLocation !accessOption}
  or
    $tblwt$
    let @location instructionLocation = @location.here
    let @tableAccessOption accessOption
    select
      $*$
      accessOption = @tableAccessOption. simpleAccess
    or
      $*+$
      accessOption = @tableAccessOption. postIncrement
    or
      $*-$
      accessOption = @tableAccessOption. postDecrement
    or
      $+*$
      accessOption = @tableAccessOption. preIncrement
    end
    outInstruction = @pic18Instruction_TBLWT.init { !instructionLocation !accessOption}
  end
}

#----------------------------------------------------*

}