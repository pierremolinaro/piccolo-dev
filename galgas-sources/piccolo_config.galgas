

#----------------------------------------------------------------------------*

map @configFieldMap {
  public var @lstring mRegisterName
  public var @luint mMaskValue
  public var @lstring mDescription
  public var @fieldSettingMap mFieldSettingMap
  insert insertKey error message "the '%K' configuration field is already declared in %L"
  search searchKey error message "the '%K' configuration field is not declared"
}

#----------------------------------------------------*

proc actualBuildConfig
 ?let @configRegisterMap inConfigRegisterMap
 ?let @configDefinitionList inConfigDefinitionList
 ?!@string ioListFileContents
 !@actualConfigurationMap outActualConfigurationMap {
#--- From config description of device, build dictionary of all settings
# This should succeed, since absence of potentiel setting name conflict has been
# checked when parsing device definition string.
  outActualConfigurationMap = @actualConfigurationMap. emptyMap
  var configFieldMap =@configFieldMap.emptyMap{}
  for (lkey mRegisterAddress mRegisterWidth mConfigRegisterMaskMap *) in  inConfigRegisterMap do
    var @uint defaultValue = (1 << mRegisterWidth.uint) - 1
    [!? outActualConfigurationMap insertKey !lkey !mRegisterAddress.uint !defaultValue]
    var @lstring registerName = lkey
    for (other_lkey other_mMaskValue other_mDescription other_mFieldSettingMap) in  mConfigRegisterMaskMap do
      [!?configFieldMap insertKey !other_lkey !registerName !other_mMaskValue !other_mDescription !other_mFieldSettingMap]
    end
  end
#--- Analyze config parts
  var actualSettingNameSet =@stringset.emptySet{}
  for (* mSettingList) in  inConfigDefinitionList do
    for (mSettingName mSettingValue) in  mSettingList do
      if [actualSettingNameSet hasKey !mSettingName.string] then
        error mSettingName: "the '" + mSettingName + "' setting is already defined"
      end
      actualSettingNameSet += !mSettingName.string
      var @lstring registerName
      var @luint maskValue
      var @lstring settingDescription
      var @fieldSettingMap fieldSettingMap
      [configFieldMap searchKey !mSettingName ?registerName ?maskValue ?settingDescription ?fieldSettingMap]
      if [fieldSettingMap hasKey !mSettingValue.string] then
        var @uint settingValue
        var @uint settingMask
        [fieldSettingMap searchKey !mSettingValue ?settingValue ?settingMask]
        var @uint registerValue
        [outActualConfigurationMap searchKey !registerName ?* ?registerValue]
        registerValue = (registerValue & ~ settingMask) | settingValue
        [!?outActualConfigurationMap setMRegisterValueForKey !registerValue !registerName.string]
      elsif [fieldSettingMap count] > 0 then
        let errorMessage = "the '" + mSettingValue + "' value is not defined for configuration setting '"
        + mSettingName + "'"
        var @stringlist replacementSuggestions = {}
        for (lkey * *) in  fieldSettingMap do
          replacementSuggestions += !"\"" + lkey + "\""
        end
        error mSettingValue: errorMessage fixit { replace replacementSuggestions }
      end
    end
  end
#--- Check if all settings are actually defined
  let @stringset notDefinedSetting = [configFieldMap keySet] - actualSettingNameSet
  if [notDefinedSetting count] > 0 then
    var @string errorMessage = "the following configuration settings are not defined:"
    for (key) in  notDefinedSetting do
      errorMessage += "\n-  " + key
    end
    error @location.here : errorMessage
  end
#--- Display conguration information in log file
  for (lkey mRegisterAddress mRegisterValue) in  outActualConfigurationMap do
    ioListFileContents += "Register '" + lkey + "' at " + [mRegisterAddress hexString] + " set to " + [mRegisterValue hexString] + "\n"
    var @configRegisterMaskMap configRegisterMaskMap
    [inConfigRegisterMap searchKey !lkey ?* ?* ?configRegisterMaskMap ?*]
    for (others_lkey others_mMaskValue * others_mFieldSettingMap) in  configRegisterMaskMap do
      var @lstring settingName = others_lkey
      for (second_lkey second_mValue *) in  others_mFieldSettingMap do
        if (mRegisterValue & others_mMaskValue.uint) == second_mValue then
          ioListFileContents += "  setting '" + settingName + "' set to " + [second_mValue hexString] + " (\"" + second_lkey + "\")\n"
        end
      end
    end
    ioListFileContents += "\n"
  end
#--- Detect illegal configurations
  for (lkey * mRegisterValue) in  outActualConfigurationMap do
    var @illegalMaskList illegalMaskList
    [inConfigRegisterMap searchKey !lkey ?* ?* ?* ?illegalMaskList]
     for (mIllegalValue mIllegalMask mDescription) in  illegalMaskList do
      if (mRegisterValue & mIllegalMask.uint) == mIllegalValue.uint then
        error @location.here:"illegal setting for '" + lkey + "' register: " + mDescription
        ioListFileContents += "*** ILLEGAL SETTING for register '" + lkey + "' ***\n"
        ioListFileContents += "  message: " + mDescription + "\n\n"
      end
    end
  end
}

#----------------------------------------------------*

proc buildConfig
 ?let @configRegisterMap inConfigRegisterMap
 ?let @configDefinitionList inConfigDefinitionList
 ?!@string ioListFileContents
 !@actualConfigurationMap outActualConfigurationMap {
#--- Log
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  ioListFileContents += "*" + ["MICROCONTROLLER CONFIGURATION" stringByLeftAndRightPadding !117 !' '] + "*\n"
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
#--- 
  if [inConfigDefinitionList length] > 0 then
    actualBuildConfig (
      !inConfigRegisterMap
      !inConfigDefinitionList
      !?ioListFileContents
      ?outActualConfigurationMap
    )
  else
    outActualConfigurationMap = @actualConfigurationMap. emptyMap
    ioListFileContents += "No configuration.\n\n"
  end
}

#----------------------------------------------------*

