//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'generic_metamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 20th, 2009, at 16h18'18"                     *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "generic_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "generic_metamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_bitSliceTable'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_bitSliceTable::e_bitSliceTable (void) :
mSliceIndex (),
mSliceSize () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@bitSliceTable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_bitSliceTable::
elementOf_GGS_bitSliceTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_bitSliceTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_bitSliceTable::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSliceIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSliceSize.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_bitSliceTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_bitSliceTable * ptr = dynamic_cast <const elementOf_GGS_bitSliceTable *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mSliceIndex.operator_isEqual (ptr->mInfo.mSliceIndex)).boolValue ()
           && (mInfo.mSliceSize.operator_isEqual (ptr->mInfo.mSliceSize)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_bitSliceTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_bitSliceTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_bitSliceTable * info = (e_bitSliceTable *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_bitSliceTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_bitSliceTable * info = (e_bitSliceTable *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_bitSliceTable GGS_bitSliceTable::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bitSliceTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_bitSliceTable info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bitSliceTable::
operator_isEqual (const GGS_bitSliceTable & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bitSliceTable::
operator_isNotEqual (const GGS_bitSliceTable & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_bitSliceTable info  ;
    info.mSliceIndex = inParameter0 ;
    info.mSliceSize = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mSliceIndex ;
    outParameter1 = node->mInfo.mSliceSize ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_bitSliceTable::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_bitSliceTable::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_bitSliceTable::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bitSliceTable GGS_bitSliceTable::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_bitSliceTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bitSliceTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitSliceTable GGS_bitSliceTable::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitSliceTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bitSliceTable::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @bitSliceTable " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_bitSliceTable::cEnumerator::_mSliceIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSliceIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_bitSliceTable::cEnumerator::_mSliceSize (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSliceSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_registerExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerExpression::
cPtr_registerExpression (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mRegisterName (argument_0),
mOffset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerExpression * GGS_registerExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerExpression * ptr = dynamic_cast <const cPtr_registerExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterName.operator_isEqual (ptr->mRegisterName).boolValue ()
         && mOffset.operator_isEqual (ptr->mOffset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerExpression:"
           << mRegisterName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOffset.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerExpression (& typeid (cPtr_registerExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerExpression::galgasRTTI (void) const {
  return & gClassInfoFor__registerExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_registerExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_registerExpression (mRegisterName, mOffset COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_registerExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_registerExpression GGS_registerExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerExpression *> (inPointer) != NULL)
      : (typeid (cPtr_registerExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_registerExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression GGS_registerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerExpression result ;
  macroMyNew (result.mPointer, cPtr_registerExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_registerExpression::
reader_mRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_registerExpression::
reader_mOffset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerExpression::actualTypeName (void) const {
  return "registerExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_registerExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__registerExpression ("registerExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_declarationInRam'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_declarationInRam::
cPtr_declarationInRam (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_declarationInRam * GGS_declarationInRam::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_declarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_declarationInRam *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_declarationInRam::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@declarationInRam:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_declarationInRam::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_declarationInRam::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_declarationInRam (& typeid (cPtr_declarationInRam), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_declarationInRam::galgasRTTI (void) const {
  return & gClassInfoFor__declarationInRam ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_declarationInRam'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_declarationInRam::
GGS_declarationInRam (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRam::
GGS_declarationInRam (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_declarationInRam GGS_declarationInRam::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_declarationInRam result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_declarationInRam *> (inPointer) != NULL)
      : (typeid (cPtr_declarationInRam) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_declarationInRam (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_declarationInRam),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_declarationInRam::actualTypeName (void) const {
  return "declarationInRam" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_declarationInRam::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__declarationInRam ("declarationInRam") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_byteDeclarationInRam'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_byteDeclarationInRam::
cPtr_byteDeclarationInRam (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bitSliceTable & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_declarationInRam (THERE),
mName (argument_0),
mSize (argument_1),
mBitSliceTable (argument_2),
mBitDefinitionString (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_byteDeclarationInRam * GGS_byteDeclarationInRam::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_byteDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_byteDeclarationInRam *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_byteDeclarationInRam::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_byteDeclarationInRam * ptr = dynamic_cast <const cPtr_byteDeclarationInRam *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mSize.operator_isEqual (ptr->mSize).boolValue ()
         && mBitSliceTable.operator_isEqual (ptr->mBitSliceTable).boolValue ()
         && mBitDefinitionString.operator_isEqual (ptr->mBitDefinitionString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_byteDeclarationInRam::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@byteDeclarationInRam:"
           << mName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSize.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitSliceTable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitDefinitionString.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_byteDeclarationInRam::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_byteDeclarationInRam::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_byteDeclarationInRam (& typeid (cPtr_byteDeclarationInRam), & typeid (cPtr_declarationInRam), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_byteDeclarationInRam::galgasRTTI (void) const {
  return & gClassInfoFor__byteDeclarationInRam ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_byteDeclarationInRam::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_byteDeclarationInRam (mName, mSize, mBitSliceTable, mBitDefinitionString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_byteDeclarationInRam'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_byteDeclarationInRam::
GGS_byteDeclarationInRam (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_byteDeclarationInRam::
GGS_byteDeclarationInRam (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_byteDeclarationInRam GGS_byteDeclarationInRam::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_byteDeclarationInRam result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_byteDeclarationInRam *> (inPointer) != NULL)
      : (typeid (cPtr_byteDeclarationInRam) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_byteDeclarationInRam (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_byteDeclarationInRam),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_byteDeclarationInRam GGS_byteDeclarationInRam::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_bitSliceTable & argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_byteDeclarationInRam result ;
  macroMyNew (result.mPointer, cPtr_byteDeclarationInRam (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_byteDeclarationInRam::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_byteDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_byteDeclarationInRam *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_byteDeclarationInRam::
reader_mSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_byteDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_byteDeclarationInRam *) mPointer)->mSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitSliceTable  GGS_byteDeclarationInRam::
reader_mBitSliceTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitSliceTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_byteDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_byteDeclarationInRam *) mPointer)->mBitSliceTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_byteDeclarationInRam::
reader_mBitDefinitionString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_byteDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_byteDeclarationInRam *) mPointer)->mBitDefinitionString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_byteDeclarationInRam::actualTypeName (void) const {
  return "byteDeclarationInRam" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__byteDeclarationInRam ("byteDeclarationInRam", gClassInfoFor__declarationInRam) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@declarationInRamList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_declarationInRamList::
elementOf_GGS_declarationInRamList (const GGS_declarationInRam & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mDeclarationInRAM (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_declarationInRamList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_declarationInRamList * ptr = dynamic_cast <const elementOf_GGS_declarationInRamList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclarationInRAM.operator_isEqual (ptr->mDeclarationInRAM).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_declarationInRamList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclarationInRAM.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@declarationInRamList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalAppendValues (const GGS_declarationInRam & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalPrependValues (const GGS_declarationInRam & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_addAssign_operation (const GGS_declarationInRam & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
operator_concat (const GGS_declarationInRamList & inOperand) const {
  GGS_declarationInRamList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
dotAssign_operation (const GGS_declarationInRamList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_declarationInRamList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_declarationInRam  p_0 = p->mDeclarationInRAM ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_declarationInRam & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mDeclarationInRAM
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_emptyList (void) {
  GGS_declarationInRamList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_listWithValue (const GGS_declarationInRam & argument_0) {
  GGS_declarationInRamList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
internalSubListWithRange (GGS_declarationInRamList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mDeclarationInRAM) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_declarationInRamList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@declarationInRamList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_first (C_Compiler & inLexique,
              GGS_declarationInRam & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarationInRAM ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_last (C_Compiler & inLexique,
             GGS_declarationInRam & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarationInRAM ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_declarationInRam & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarationInRAM ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popLast (C_Compiler & inLexique,
                GGS_declarationInRam & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarationInRAM ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRam  GGS_declarationInRamList::
reader_mDeclarationInRAMAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_declarationInRam  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclarationInRAM ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_setMDeclarationInRAMAtIndex (C_Compiler & inLexique,
                              const GGS_declarationInRam  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclarationInRAM = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_declarationInRam  & GGS_declarationInRamList::cEnumerator::_mDeclarationInRAM (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclarationInRAM ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@commonBranchList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_commonBranchList::
elementOf_GGS_commonBranchList (const GGS_declarationInRamList & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mDeclarations (argument_0),
mEndOfBranchLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_commonBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_commonBranchList * ptr = dynamic_cast <const elementOf_GGS_commonBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclarations.operator_isEqual (ptr->mDeclarations).boolValue ()
         && mEndOfBranchLocation.operator_isEqual (ptr->mEndOfBranchLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_commonBranchList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclarations.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfBranchLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@commonBranchList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_commonBranchList::
_internalAppendValues (const GGS_declarationInRamList & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
_internalPrependValues (const GGS_declarationInRamList & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
_addAssign_operation (const GGS_declarationInRamList & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_commonBranchList GGS_commonBranchList::
operator_concat (const GGS_commonBranchList & inOperand) const {
  GGS_commonBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
dotAssign_operation (const GGS_commonBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_commonBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_declarationInRamList  p_0 = p->mDeclarations ;
          GGS_location  p_1 = p->mEndOfBranchLocation ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_declarationInRamList & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mDeclarations,
                                ptr->mEndOfBranchLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_commonBranchList  GGS_commonBranchList::
constructor_emptyList (void) {
  GGS_commonBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_commonBranchList  GGS_commonBranchList::
constructor_listWithValue (const GGS_declarationInRamList & argument_0,
                                const GGS_location & argument_1) {
  GGS_commonBranchList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
internalSubListWithRange (GGS_commonBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mDeclarations, ptr->mEndOfBranchLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_commonBranchList GGS_commonBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_commonBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_commonBranchList GGS_commonBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_commonBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_commonBranchList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@commonBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
method_first (C_Compiler & inLexique,
              GGS_declarationInRamList & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarations ;
    _out_1 = ptr->mEndOfBranchLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
method_last (C_Compiler & inLexique,
             GGS_declarationInRamList & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarations ;
    _out_1 = ptr->mEndOfBranchLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_declarationInRamList & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarations ;
    _out_1 = ptr->mEndOfBranchLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_declarationInRamList & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclarations ;
    _out_1 = ptr->mEndOfBranchLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_commonBranchList::
reader_mDeclarationsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclarations ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_commonBranchList::
reader_mEndOfBranchLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfBranchLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
modifier_setMDeclarationsAtIndex (C_Compiler & inLexique,
                              const GGS_declarationInRamList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclarations = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_commonBranchList::
modifier_setMEndOfBranchLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfBranchLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_declarationInRamList  & GGS_commonBranchList::cEnumerator::_mDeclarations (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclarations ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_commonBranchList::cEnumerator::_mEndOfBranchLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfBranchLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_commonDeclarationInRam'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_commonDeclarationInRam::
cPtr_commonDeclarationInRam (const GGS_commonBranchList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_declarationInRam (THERE),
mBranchList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_commonDeclarationInRam * GGS_commonDeclarationInRam::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_commonDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_commonDeclarationInRam *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_commonDeclarationInRam::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_commonDeclarationInRam * ptr = dynamic_cast <const cPtr_commonDeclarationInRam *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mBranchList.operator_isEqual (ptr->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_commonDeclarationInRam::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@commonDeclarationInRam:"
           << mBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_commonDeclarationInRam::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_commonDeclarationInRam::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_commonDeclarationInRam (& typeid (cPtr_commonDeclarationInRam), & typeid (cPtr_declarationInRam), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_commonDeclarationInRam::galgasRTTI (void) const {
  return & gClassInfoFor__commonDeclarationInRam ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_commonDeclarationInRam::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_commonDeclarationInRam (mBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_commonDeclarationInRam'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_commonDeclarationInRam::
GGS_commonDeclarationInRam (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_commonDeclarationInRam::
GGS_commonDeclarationInRam (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_commonDeclarationInRam GGS_commonDeclarationInRam::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_commonDeclarationInRam result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_commonDeclarationInRam *> (inPointer) != NULL)
      : (typeid (cPtr_commonDeclarationInRam) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_commonDeclarationInRam (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_commonDeclarationInRam),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_commonDeclarationInRam GGS_commonDeclarationInRam::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_commonBranchList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_commonDeclarationInRam result ;
  macroMyNew (result.mPointer, cPtr_commonDeclarationInRam (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_commonBranchList  GGS_commonDeclarationInRam::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_commonBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_commonDeclarationInRam *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_commonDeclarationInRam *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_commonDeclarationInRam::actualTypeName (void) const {
  return "commonDeclarationInRam" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__commonDeclarationInRam ("commonDeclarationInRam", gClassInfoFor__declarationInRam) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@ramDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ramDefinitionList::
elementOf_GGS_ramDefinitionList (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mBankName (argument_0),
mDeclaration (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ramDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ramDefinitionList * ptr = dynamic_cast <const elementOf_GGS_ramDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mBankName.operator_isEqual (ptr->mBankName).boolValue ()
         && mDeclaration.operator_isEqual (ptr->mDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ramDefinitionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBankName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclaration.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@ramDefinitionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
operator_concat (const GGS_ramDefinitionList & inOperand) const {
  GGS_ramDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
dotAssign_operation (const GGS_ramDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ramDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mBankName ;
          GGS_declarationInRamList  p_1 = p->mDeclaration ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_declarationInRamList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mBankName,
                                ptr->mDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_emptyList (void) {
  GGS_ramDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  GGS_ramDefinitionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
internalSubListWithRange (GGS_ramDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mBankName, ptr->mDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ramDefinitionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@ramDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_declarationInRamList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mBankName ;
    _out_1 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_declarationInRamList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mBankName ;
    _out_1 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_declarationInRamList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mBankName ;
    _out_1 = ptr->mDeclaration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_declarationInRamList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mBankName ;
    _out_1 = ptr->mDeclaration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ramDefinitionList::
reader_mBankNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBankName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_ramDefinitionList::
reader_mDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMBankNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBankName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_declarationInRamList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ramDefinitionList::cEnumerator::_mBankName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBankName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_declarationInRamList  & GGS_ramDefinitionList::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@configSettingList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_configSettingList::
elementOf_GGS_configSettingList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSettingName (argument_0),
mSettingValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_configSettingList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_configSettingList * ptr = dynamic_cast <const elementOf_GGS_configSettingList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSettingName.operator_isEqual (ptr->mSettingName).boolValue ()
         && mSettingValue.operator_isEqual (ptr->mSettingValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_configSettingList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSettingName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSettingValue.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@configSettingList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_configSettingList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_configSettingList GGS_configSettingList::
operator_concat (const GGS_configSettingList & inOperand) const {
  GGS_configSettingList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
dotAssign_operation (const GGS_configSettingList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_configSettingList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSettingName ;
          GGS_lstring  p_1 = p->mSettingValue ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSettingName,
                                ptr->mSettingValue
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_configSettingList  GGS_configSettingList::
constructor_emptyList (void) {
  GGS_configSettingList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configSettingList  GGS_configSettingList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_configSettingList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
internalSubListWithRange (GGS_configSettingList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mSettingName, ptr->mSettingValue) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_configSettingList GGS_configSettingList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_configSettingList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configSettingList GGS_configSettingList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_configSettingList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_configSettingList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@configSettingList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSettingName ;
    _out_1 = ptr->mSettingValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSettingName ;
    _out_1 = ptr->mSettingValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSettingName ;
    _out_1 = ptr->mSettingValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSettingName ;
    _out_1 = ptr->mSettingValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_configSettingList::
reader_mSettingNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSettingName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_configSettingList::
reader_mSettingValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSettingValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
modifier_setMSettingNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSettingName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configSettingList::
modifier_setMSettingValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSettingValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configSettingList::cEnumerator::_mSettingName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSettingName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configSettingList::cEnumerator::_mSettingValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSettingValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@configDefinitionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_configDefinitionList::
elementOf_GGS_configDefinitionList (const GGS_location & argument_0,
                                const GGS_configSettingList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mDefinitionLocation (argument_0),
mSettingList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_configDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_configDefinitionList * ptr = dynamic_cast <const elementOf_GGS_configDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDefinitionLocation.operator_isEqual (ptr->mDefinitionLocation).boolValue ()
         && mSettingList.operator_isEqual (ptr->mSettingList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_configDefinitionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefinitionLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSettingList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@configDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_configSettingList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_configSettingList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
_addAssign_operation (const GGS_location & argument_0,
                                const GGS_configSettingList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_configDefinitionList GGS_configDefinitionList::
operator_concat (const GGS_configDefinitionList & inOperand) const {
  GGS_configDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
dotAssign_operation (const GGS_configDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_configDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mDefinitionLocation ;
          GGS_configSettingList  p_1 = p->mSettingList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_configSettingList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mDefinitionLocation,
                                ptr->mSettingList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_configDefinitionList  GGS_configDefinitionList::
constructor_emptyList (void) {
  GGS_configDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configDefinitionList  GGS_configDefinitionList::
constructor_listWithValue (const GGS_location & argument_0,
                                const GGS_configSettingList & argument_1) {
  GGS_configDefinitionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
internalSubListWithRange (GGS_configDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mDefinitionLocation, ptr->mSettingList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_configDefinitionList GGS_configDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_configDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configDefinitionList GGS_configDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_configDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_configDefinitionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@configDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_location & _out_0,
              GGS_configSettingList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDefinitionLocation ;
    _out_1 = ptr->mSettingList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_location & _out_0,
             GGS_configSettingList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDefinitionLocation ;
    _out_1 = ptr->mSettingList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_location & _out_0,
                 GGS_configSettingList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDefinitionLocation ;
    _out_1 = ptr->mSettingList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_location & _out_0,
                GGS_configSettingList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDefinitionLocation ;
    _out_1 = ptr->mSettingList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_configDefinitionList::
reader_mDefinitionLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDefinitionLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configSettingList  GGS_configDefinitionList::
reader_mSettingListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_configSettingList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSettingList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
modifier_setMDefinitionLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDefinitionLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configDefinitionList::
modifier_setMSettingListAtIndex (C_Compiler & inLexique,
                              const GGS_configSettingList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSettingList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_configDefinitionList::cEnumerator::_mDefinitionLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDefinitionLocation ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_configSettingList  & GGS_configDefinitionList::cEnumerator::_mSettingList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSettingList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_immediatExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatExpression::
cPtr_immediatExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatExpression * GGS_immediatExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_immediatExpression::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@immediatExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatExpression (& typeid (cPtr_immediatExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatExpression::galgasRTTI (void) const {
  return & gClassInfoFor__immediatExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_immediatExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatExpression::
GGS_immediatExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression::
GGS_immediatExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatExpression GGS_immediatExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatExpression *> (inPointer) != NULL)
      : (typeid (cPtr_immediatExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatExpression::actualTypeName (void) const {
  return "immediatExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_immediatExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__immediatExpression ("immediatExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@immediatExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_immediatExpressionList::
elementOf_GGS_immediatExpressionList (const GGS_immediatExpression & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_immediatExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_immediatExpressionList * ptr = dynamic_cast <const elementOf_GGS_immediatExpressionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_immediatExpressionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@immediatExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
_internalAppendValues (const GGS_immediatExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
_internalPrependValues (const GGS_immediatExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
_addAssign_operation (const GGS_immediatExpression & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList GGS_immediatExpressionList::
operator_concat (const GGS_immediatExpressionList & inOperand) const {
  GGS_immediatExpressionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
dotAssign_operation (const GGS_immediatExpressionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_immediatExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_immediatExpression  p_0 = p->mExpression ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_immediatExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList  GGS_immediatExpressionList::
constructor_emptyList (void) {
  GGS_immediatExpressionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList  GGS_immediatExpressionList::
constructor_listWithValue (const GGS_immediatExpression & argument_0) {
  GGS_immediatExpressionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
internalSubListWithRange (GGS_immediatExpressionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList GGS_immediatExpressionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_immediatExpressionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList GGS_immediatExpressionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_immediatExpressionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_immediatExpressionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@immediatExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
method_first (C_Compiler & inLexique,
              GGS_immediatExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
method_last (C_Compiler & inLexique,
             GGS_immediatExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_immediatExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_immediatExpression & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatExpressionList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_immediatExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatExpressionList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_immediatExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_immediatExpression  & GGS_immediatExpressionList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_immediatInteger'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatInteger::
cPtr_immediatInteger (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatInteger * GGS_immediatInteger::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatInteger *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatInteger *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatInteger::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatInteger * ptr = dynamic_cast <const cPtr_immediatInteger *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatInteger::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatInteger:"
           << mValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatInteger::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatInteger::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatInteger (& typeid (cPtr_immediatInteger), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatInteger::galgasRTTI (void) const {
  return & gClassInfoFor__immediatInteger ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatInteger::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatInteger (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_immediatInteger'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatInteger::
GGS_immediatInteger (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatInteger::
GGS_immediatInteger (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatInteger GGS_immediatInteger::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatInteger result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatInteger *> (inPointer) != NULL)
      : (typeid (cPtr_immediatInteger) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatInteger (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatInteger),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatInteger GGS_immediatInteger::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_immediatInteger result ;
  macroMyNew (result.mPointer, cPtr_immediatInteger (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_immediatInteger::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatInteger *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatInteger *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatInteger::actualTypeName (void) const {
  return "immediatInteger" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatInteger ("immediatInteger", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_immediatRegister'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatRegister::
cPtr_immediatRegister (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mRegister (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatRegister * GGS_immediatRegister::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatRegister *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatRegister *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatRegister::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatRegister * ptr = dynamic_cast <const cPtr_immediatRegister *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegister.operator_isEqual (ptr->mRegister).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatRegister::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatRegister:"
           << mRegister.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatRegister::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatRegister::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatRegister (& typeid (cPtr_immediatRegister), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatRegister::galgasRTTI (void) const {
  return & gClassInfoFor__immediatRegister ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatRegister::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatRegister (mRegister COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_immediatRegister'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatRegister::
GGS_immediatRegister (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatRegister::
GGS_immediatRegister (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatRegister GGS_immediatRegister::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatRegister result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatRegister *> (inPointer) != NULL)
      : (typeid (cPtr_immediatRegister) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatRegister (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatRegister),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatRegister GGS_immediatRegister::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_immediatRegister result ;
  macroMyNew (result.mPointer, cPtr_immediatRegister (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_immediatRegister::
reader_mRegister (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatRegister *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatRegister *) mPointer)->mRegister ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatRegister::actualTypeName (void) const {
  return "immediatRegister" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatRegister ("immediatRegister", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatAdd'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatAdd::
cPtr_immediatAdd (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatAdd * GGS_immediatAdd::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAdd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatAdd *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatAdd::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatAdd * ptr = dynamic_cast <const cPtr_immediatAdd *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatAdd::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatAdd:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatAdd::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatAdd::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatAdd (& typeid (cPtr_immediatAdd), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatAdd::galgasRTTI (void) const {
  return & gClassInfoFor__immediatAdd ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatAdd::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatAdd (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatAdd'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatAdd::
GGS_immediatAdd (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatAdd::
GGS_immediatAdd (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatAdd GGS_immediatAdd::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatAdd result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatAdd *> (inPointer) != NULL)
      : (typeid (cPtr_immediatAdd) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatAdd (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatAdd),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatAdd GGS_immediatAdd::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatAdd result ;
  macroMyNew (result.mPointer, cPtr_immediatAdd (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatAdd::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAdd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatAdd *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatAdd::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAdd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatAdd *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatAdd::actualTypeName (void) const {
  return "immediatAdd" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatAdd ("immediatAdd", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatSub'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatSub::
cPtr_immediatSub (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatSub * GGS_immediatSub::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSub *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatSub *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatSub::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatSub * ptr = dynamic_cast <const cPtr_immediatSub *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatSub::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatSub:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatSub::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatSub::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatSub (& typeid (cPtr_immediatSub), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatSub::galgasRTTI (void) const {
  return & gClassInfoFor__immediatSub ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatSub::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatSub (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatSub'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatSub::
GGS_immediatSub (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatSub::
GGS_immediatSub (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatSub GGS_immediatSub::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatSub result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatSub *> (inPointer) != NULL)
      : (typeid (cPtr_immediatSub) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatSub (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatSub),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatSub GGS_immediatSub::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatSub result ;
  macroMyNew (result.mPointer, cPtr_immediatSub (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatSub::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSub *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatSub *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatSub::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSub *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatSub *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatSub::actualTypeName (void) const {
  return "immediatSub" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatSub ("immediatSub", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatMul'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatMul::
cPtr_immediatMul (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatMul * GGS_immediatMul::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMul *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatMul *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatMul::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatMul * ptr = dynamic_cast <const cPtr_immediatMul *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatMul::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatMul:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatMul::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatMul::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatMul (& typeid (cPtr_immediatMul), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatMul::galgasRTTI (void) const {
  return & gClassInfoFor__immediatMul ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatMul::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatMul (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatMul'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatMul::
GGS_immediatMul (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatMul::
GGS_immediatMul (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatMul GGS_immediatMul::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatMul result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatMul *> (inPointer) != NULL)
      : (typeid (cPtr_immediatMul) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatMul (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatMul),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatMul GGS_immediatMul::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatMul result ;
  macroMyNew (result.mPointer, cPtr_immediatMul (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatMul::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMul *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatMul *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatMul::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMul *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatMul *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatMul::actualTypeName (void) const {
  return "immediatMul" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatMul ("immediatMul", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatDiv'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatDiv::
cPtr_immediatDiv (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatDiv * GGS_immediatDiv::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatDiv *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatDiv *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatDiv::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatDiv * ptr = dynamic_cast <const cPtr_immediatDiv *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatDiv::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatDiv:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatDiv::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatDiv::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatDiv (& typeid (cPtr_immediatDiv), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatDiv::galgasRTTI (void) const {
  return & gClassInfoFor__immediatDiv ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatDiv::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatDiv (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatDiv'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatDiv::
GGS_immediatDiv (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatDiv::
GGS_immediatDiv (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatDiv GGS_immediatDiv::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatDiv result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatDiv *> (inPointer) != NULL)
      : (typeid (cPtr_immediatDiv) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatDiv (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatDiv),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatDiv GGS_immediatDiv::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatDiv result ;
  macroMyNew (result.mPointer, cPtr_immediatDiv (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatDiv::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatDiv *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatDiv *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatDiv::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatDiv *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatDiv *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatDiv::actualTypeName (void) const {
  return "immediatDiv" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatDiv ("immediatDiv", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatMod'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatMod::
cPtr_immediatMod (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatMod * GGS_immediatMod::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatMod *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatMod::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatMod * ptr = dynamic_cast <const cPtr_immediatMod *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatMod::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatMod:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatMod::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatMod::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatMod (& typeid (cPtr_immediatMod), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatMod::galgasRTTI (void) const {
  return & gClassInfoFor__immediatMod ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatMod::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatMod (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatMod'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatMod::
GGS_immediatMod (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatMod::
GGS_immediatMod (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatMod GGS_immediatMod::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatMod result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatMod *> (inPointer) != NULL)
      : (typeid (cPtr_immediatMod) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatMod (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatMod),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatMod GGS_immediatMod::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatMod result ;
  macroMyNew (result.mPointer, cPtr_immediatMod (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatMod::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatMod *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatMod::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatMod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatMod *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatMod::actualTypeName (void) const {
  return "immediatMod" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatMod ("immediatMod", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatOr'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatOr::
cPtr_immediatOr (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatOr * GGS_immediatOr::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatOr *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatOr::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatOr * ptr = dynamic_cast <const cPtr_immediatOr *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatOr::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatOr:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatOr::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatOr::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatOr (& typeid (cPtr_immediatOr), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatOr::galgasRTTI (void) const {
  return & gClassInfoFor__immediatOr ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatOr::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatOr (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatOr'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatOr::
GGS_immediatOr (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatOr::
GGS_immediatOr (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatOr GGS_immediatOr::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatOr result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatOr *> (inPointer) != NULL)
      : (typeid (cPtr_immediatOr) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatOr (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatOr),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatOr GGS_immediatOr::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatOr result ;
  macroMyNew (result.mPointer, cPtr_immediatOr (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatOr::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatOr *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatOr::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatOr *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatOr::actualTypeName (void) const {
  return "immediatOr" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatOr ("immediatOr", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatAnd'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatAnd::
cPtr_immediatAnd (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatAnd * GGS_immediatAnd::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatAnd *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatAnd::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatAnd * ptr = dynamic_cast <const cPtr_immediatAnd *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatAnd::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatAnd:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatAnd::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatAnd::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatAnd (& typeid (cPtr_immediatAnd), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatAnd::galgasRTTI (void) const {
  return & gClassInfoFor__immediatAnd ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatAnd::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatAnd (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatAnd'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatAnd::
GGS_immediatAnd (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatAnd::
GGS_immediatAnd (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatAnd GGS_immediatAnd::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatAnd result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatAnd *> (inPointer) != NULL)
      : (typeid (cPtr_immediatAnd) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatAnd (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatAnd),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatAnd GGS_immediatAnd::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatAnd result ;
  macroMyNew (result.mPointer, cPtr_immediatAnd (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatAnd::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatAnd *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatAnd::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatAnd *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatAnd::actualTypeName (void) const {
  return "immediatAnd" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatAnd ("immediatAnd", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_immediatXor'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatXor::
cPtr_immediatXor (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatXor * GGS_immediatXor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatXor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatXor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatXor::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatXor * ptr = dynamic_cast <const cPtr_immediatXor *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatXor::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatXor:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatXor::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatXor::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatXor (& typeid (cPtr_immediatXor), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatXor::galgasRTTI (void) const {
  return & gClassInfoFor__immediatXor ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatXor::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatXor (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_immediatXor'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatXor::
GGS_immediatXor (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatXor::
GGS_immediatXor (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatXor GGS_immediatXor::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatXor result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatXor *> (inPointer) != NULL)
      : (typeid (cPtr_immediatXor) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatXor (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatXor),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatXor GGS_immediatXor::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatXor result ;
  macroMyNew (result.mPointer, cPtr_immediatXor (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatXor::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatXor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatXor *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatXor::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatXor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatXor *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatXor::actualTypeName (void) const {
  return "immediatXor" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatXor ("immediatXor", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_immediatLeftShift'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatLeftShift::
cPtr_immediatLeftShift (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatLeftShift * GGS_immediatLeftShift::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLeftShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatLeftShift *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatLeftShift::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatLeftShift * ptr = dynamic_cast <const cPtr_immediatLeftShift *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatLeftShift::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatLeftShift:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatLeftShift::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatLeftShift::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatLeftShift (& typeid (cPtr_immediatLeftShift), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatLeftShift::galgasRTTI (void) const {
  return & gClassInfoFor__immediatLeftShift ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatLeftShift::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatLeftShift (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_immediatLeftShift'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatLeftShift::
GGS_immediatLeftShift (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatLeftShift::
GGS_immediatLeftShift (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatLeftShift GGS_immediatLeftShift::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatLeftShift result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatLeftShift *> (inPointer) != NULL)
      : (typeid (cPtr_immediatLeftShift) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatLeftShift (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatLeftShift),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatLeftShift GGS_immediatLeftShift::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatLeftShift result ;
  macroMyNew (result.mPointer, cPtr_immediatLeftShift (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLeftShift::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLeftShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLeftShift *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLeftShift::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLeftShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLeftShift *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatLeftShift::actualTypeName (void) const {
  return "immediatLeftShift" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatLeftShift ("immediatLeftShift", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_immediatRightShift'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatRightShift::
cPtr_immediatRightShift (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatRightShift * GGS_immediatRightShift::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatRightShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatRightShift *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatRightShift::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatRightShift * ptr = dynamic_cast <const cPtr_immediatRightShift *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatRightShift::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatRightShift:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatRightShift::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatRightShift::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatRightShift (& typeid (cPtr_immediatRightShift), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatRightShift::galgasRTTI (void) const {
  return & gClassInfoFor__immediatRightShift ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatRightShift::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatRightShift (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_immediatRightShift'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatRightShift::
GGS_immediatRightShift (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatRightShift::
GGS_immediatRightShift (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatRightShift GGS_immediatRightShift::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatRightShift result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatRightShift *> (inPointer) != NULL)
      : (typeid (cPtr_immediatRightShift) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatRightShift (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatRightShift),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatRightShift GGS_immediatRightShift::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatRightShift result ;
  macroMyNew (result.mPointer, cPtr_immediatRightShift (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatRightShift::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatRightShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatRightShift *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatRightShift::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatRightShift *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatRightShift *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatRightShift::actualTypeName (void) const {
  return "immediatRightShift" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatRightShift ("immediatRightShift", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_immediatEqualTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatEqualTest::
cPtr_immediatEqualTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatEqualTest * GGS_immediatEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatEqualTest * ptr = dynamic_cast <const cPtr_immediatEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatEqualTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatEqualTest (& typeid (cPtr_immediatEqualTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatEqualTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_immediatEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatEqualTest::
GGS_immediatEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatEqualTest::
GGS_immediatEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatEqualTest GGS_immediatEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatEqualTest GGS_immediatEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatEqualTest result ;
  macroMyNew (result.mPointer, cPtr_immediatEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatEqualTest::actualTypeName (void) const {
  return "immediatEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatEqualTest ("immediatEqualTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_immediatNotEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatNotEqualTest::
cPtr_immediatNotEqualTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatNotEqualTest * GGS_immediatNotEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatNotEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatNotEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatNotEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatNotEqualTest * ptr = dynamic_cast <const cPtr_immediatNotEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatNotEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatNotEqualTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatNotEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatNotEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatNotEqualTest (& typeid (cPtr_immediatNotEqualTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatNotEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatNotEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatNotEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatNotEqualTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_immediatNotEqualTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatNotEqualTest::
GGS_immediatNotEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatNotEqualTest::
GGS_immediatNotEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatNotEqualTest GGS_immediatNotEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatNotEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatNotEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatNotEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatNotEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatNotEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatNotEqualTest GGS_immediatNotEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatNotEqualTest result ;
  macroMyNew (result.mPointer, cPtr_immediatNotEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatNotEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatNotEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatNotEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatNotEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatNotEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatNotEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatNotEqualTest::actualTypeName (void) const {
  return "immediatNotEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatNotEqualTest ("immediatNotEqualTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_immediatGreaterTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatGreaterTest::
cPtr_immediatGreaterTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatGreaterTest * GGS_immediatGreaterTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatGreaterTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatGreaterTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatGreaterTest * ptr = dynamic_cast <const cPtr_immediatGreaterTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatGreaterTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatGreaterTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatGreaterTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatGreaterTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatGreaterTest (& typeid (cPtr_immediatGreaterTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatGreaterTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatGreaterTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatGreaterTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatGreaterTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_immediatGreaterTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatGreaterTest::
GGS_immediatGreaterTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatGreaterTest::
GGS_immediatGreaterTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatGreaterTest GGS_immediatGreaterTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatGreaterTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatGreaterTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatGreaterTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatGreaterTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatGreaterTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatGreaterTest GGS_immediatGreaterTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatGreaterTest result ;
  macroMyNew (result.mPointer, cPtr_immediatGreaterTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatGreaterTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatGreaterTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatGreaterTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatGreaterTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatGreaterTest::actualTypeName (void) const {
  return "immediatGreaterTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatGreaterTest ("immediatGreaterTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_immediatGreaterOrEqualTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatGreaterOrEqualTest::
cPtr_immediatGreaterOrEqualTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatGreaterOrEqualTest * GGS_immediatGreaterOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatGreaterOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatGreaterOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatGreaterOrEqualTest * ptr = dynamic_cast <const cPtr_immediatGreaterOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatGreaterOrEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatGreaterOrEqualTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatGreaterOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatGreaterOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatGreaterOrEqualTest (& typeid (cPtr_immediatGreaterOrEqualTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatGreaterOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatGreaterOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatGreaterOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatGreaterOrEqualTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_immediatGreaterOrEqualTest'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatGreaterOrEqualTest::
GGS_immediatGreaterOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatGreaterOrEqualTest::
GGS_immediatGreaterOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatGreaterOrEqualTest GGS_immediatGreaterOrEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatGreaterOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatGreaterOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatGreaterOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatGreaterOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatGreaterOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatGreaterOrEqualTest GGS_immediatGreaterOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatGreaterOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_immediatGreaterOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatGreaterOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatGreaterOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatGreaterOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatGreaterOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatGreaterOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatGreaterOrEqualTest::actualTypeName (void) const {
  return "immediatGreaterOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatGreaterOrEqualTest ("immediatGreaterOrEqualTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_immediatLowerTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatLowerTest::
cPtr_immediatLowerTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatLowerTest * GGS_immediatLowerTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatLowerTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatLowerTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatLowerTest * ptr = dynamic_cast <const cPtr_immediatLowerTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatLowerTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatLowerTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatLowerTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatLowerTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatLowerTest (& typeid (cPtr_immediatLowerTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatLowerTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatLowerTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatLowerTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatLowerTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_immediatLowerTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatLowerTest::
GGS_immediatLowerTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatLowerTest::
GGS_immediatLowerTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatLowerTest GGS_immediatLowerTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatLowerTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatLowerTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatLowerTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatLowerTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatLowerTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatLowerTest GGS_immediatLowerTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatLowerTest result ;
  macroMyNew (result.mPointer, cPtr_immediatLowerTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLowerTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLowerTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLowerTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLowerTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatLowerTest::actualTypeName (void) const {
  return "immediatLowerTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatLowerTest ("immediatLowerTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_immediatLowerOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatLowerOrEqualTest::
cPtr_immediatLowerOrEqualTest (const GGS_immediatExpression & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatLowerOrEqualTest * GGS_immediatLowerOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatLowerOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatLowerOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatLowerOrEqualTest * ptr = dynamic_cast <const cPtr_immediatLowerOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatLowerOrEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatLowerOrEqualTest:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatLowerOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatLowerOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatLowerOrEqualTest (& typeid (cPtr_immediatLowerOrEqualTest), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatLowerOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__immediatLowerOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatLowerOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatLowerOrEqualTest (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_immediatLowerOrEqualTest'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatLowerOrEqualTest::
GGS_immediatLowerOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatLowerOrEqualTest::
GGS_immediatLowerOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatLowerOrEqualTest GGS_immediatLowerOrEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatLowerOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatLowerOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_immediatLowerOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatLowerOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatLowerOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatLowerOrEqualTest GGS_immediatLowerOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0,
                 const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatLowerOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_immediatLowerOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLowerOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLowerOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatLowerOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatLowerOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatLowerOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatLowerOrEqualTest::actualTypeName (void) const {
  return "immediatLowerOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatLowerOrEqualTest ("immediatLowerOrEqualTest", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_immediatNegate'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatNegate::
cPtr_immediatNegate (const GGS_immediatExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatNegate * GGS_immediatNegate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatNegate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatNegate * ptr = dynamic_cast <const cPtr_immediatNegate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatNegate::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatNegate:"
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatNegate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatNegate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatNegate (& typeid (cPtr_immediatNegate), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatNegate::galgasRTTI (void) const {
  return & gClassInfoFor__immediatNegate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatNegate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatNegate (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_immediatNegate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatNegate::
GGS_immediatNegate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatNegate::
GGS_immediatNegate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatNegate GGS_immediatNegate::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatNegate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatNegate *> (inPointer) != NULL)
      : (typeid (cPtr_immediatNegate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatNegate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatNegate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatNegate GGS_immediatNegate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_immediatNegate result ;
  macroMyNew (result.mPointer, cPtr_immediatNegate (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatNegate::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatNegate *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatNegate::actualTypeName (void) const {
  return "immediatNegate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatNegate ("immediatNegate", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_immediatComplement'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatComplement::
cPtr_immediatComplement (const GGS_immediatExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatComplement * GGS_immediatComplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatComplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatComplement * ptr = dynamic_cast <const cPtr_immediatComplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatComplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatComplement:"
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatComplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatComplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatComplement (& typeid (cPtr_immediatComplement), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatComplement::galgasRTTI (void) const {
  return & gClassInfoFor__immediatComplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatComplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatComplement (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_immediatComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatComplement::
GGS_immediatComplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatComplement::
GGS_immediatComplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatComplement GGS_immediatComplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatComplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatComplement *> (inPointer) != NULL)
      : (typeid (cPtr_immediatComplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatComplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatComplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatComplement GGS_immediatComplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_immediatExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_immediatComplement result ;
  macroMyNew (result.mPointer, cPtr_immediatComplement (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatComplement::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatComplement *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatComplement::actualTypeName (void) const {
  return "immediatComplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatComplement ("immediatComplement", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@immediatSliceExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_immediatSliceExpressionList::
elementOf_GGS_immediatSliceExpressionList (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSliceName (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_immediatSliceExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_immediatSliceExpressionList * ptr = dynamic_cast <const elementOf_GGS_immediatSliceExpressionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSliceName.operator_isEqual (ptr->mSliceName).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_immediatSliceExpressionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSliceName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@immediatSliceExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_immediatExpression & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_immediatExpression & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList GGS_immediatSliceExpressionList::
operator_concat (const GGS_immediatSliceExpressionList & inOperand) const {
  GGS_immediatSliceExpressionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
dotAssign_operation (const GGS_immediatSliceExpressionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_immediatSliceExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSliceName ;
          GGS_immediatExpression  p_1 = p->mExpression ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_immediatExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSliceName,
                                ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList  GGS_immediatSliceExpressionList::
constructor_emptyList (void) {
  GGS_immediatSliceExpressionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList  GGS_immediatSliceExpressionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1) {
  GGS_immediatSliceExpressionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
internalSubListWithRange (GGS_immediatSliceExpressionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mSliceName, ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList GGS_immediatSliceExpressionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_immediatSliceExpressionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList GGS_immediatSliceExpressionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_immediatSliceExpressionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_immediatSliceExpressionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@immediatSliceExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_immediatExpression & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSliceName ;
    _out_1 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_immediatExpression & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSliceName ;
    _out_1 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_immediatExpression & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSliceName ;
    _out_1 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_immediatExpression & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSliceName ;
    _out_1 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_immediatSliceExpressionList::
reader_mSliceNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSliceName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_immediatSliceExpressionList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_immediatExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
modifier_setMSliceNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSliceName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_immediatSliceExpressionList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_immediatExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_immediatSliceExpressionList::cEnumerator::_mSliceName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSliceName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_immediatExpression  & GGS_immediatSliceExpressionList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_immediatSlice'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_immediatSlice::
cPtr_immediatSlice (const GGS_lstring & argument_0,
                                const GGS_immediatSliceExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_immediatExpression (THERE),
mRegisterName (argument_0),
mSliceExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_immediatSlice * GGS_immediatSlice::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSlice *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_immediatSlice *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_immediatSlice::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_immediatSlice * ptr = dynamic_cast <const cPtr_immediatSlice *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterName.operator_isEqual (ptr->mRegisterName).boolValue ()
         && mSliceExpressionList.operator_isEqual (ptr->mSliceExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_immediatSlice::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@immediatSlice:"
           << mRegisterName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSliceExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_immediatSlice::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_immediatSlice::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_immediatSlice (& typeid (cPtr_immediatSlice), & typeid (cPtr_immediatExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_immediatSlice::galgasRTTI (void) const {
  return & gClassInfoFor__immediatSlice ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_immediatSlice::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_immediatSlice (mRegisterName, mSliceExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_immediatSlice'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_immediatSlice::
GGS_immediatSlice (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_immediatSlice::
GGS_immediatSlice (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_immediatSlice GGS_immediatSlice::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_immediatSlice result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_immediatSlice *> (inPointer) != NULL)
      : (typeid (cPtr_immediatSlice) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_immediatSlice (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_immediatSlice),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatSlice GGS_immediatSlice::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_immediatSliceExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_immediatSlice result ;
  macroMyNew (result.mPointer, cPtr_immediatSlice (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_immediatSlice::
reader_mRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSlice *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatSlice *) mPointer)->mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatSliceExpressionList  GGS_immediatSlice::
reader_mSliceExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatSliceExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_immediatSlice *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_immediatSlice *) mPointer)->mSliceExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_immediatSlice::actualTypeName (void) const {
  return "immediatSlice" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__immediatSlice ("immediatSlice", gClassInfoFor__immediatExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@constantDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constantDefinitionList::
elementOf_GGS_constantDefinitionList (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantName (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constantDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_constantDefinitionList * ptr = dynamic_cast <const elementOf_GGS_constantDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constantDefinitionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@constantDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_immediatExpression & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_immediatExpression & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_constantDefinitionList GGS_constantDefinitionList::
operator_concat (const GGS_constantDefinitionList & inOperand) const {
  GGS_constantDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
dotAssign_operation (const GGS_constantDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_constantDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_immediatExpression  p_1 = p->mExpression ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_immediatExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mConstantName,
                                ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_constantDefinitionList  GGS_constantDefinitionList::
constructor_emptyList (void) {
  GGS_constantDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantDefinitionList  GGS_constantDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_immediatExpression & argument_1) {
  GGS_constantDefinitionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
internalSubListWithRange (GGS_constantDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mConstantName, ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_constantDefinitionList GGS_constantDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_constantDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantDefinitionList GGS_constantDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_constantDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constantDefinitionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@constantDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_immediatExpression & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_immediatExpression & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_immediatExpression & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_immediatExpression & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantDefinitionList::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_constantDefinitionList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_immediatExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constantDefinitionList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_immediatExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_constantDefinitionList::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_immediatExpression  & GGS_constantDefinitionList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_actualConfigurationMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_actualConfigurationMap::e_actualConfigurationMap (void) :
mRegisterAddress (),
mRegisterValue () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@actualConfigurationMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualConfigurationMap::
elementOf_GGS_actualConfigurationMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_actualConfigurationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualConfigurationMap::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRegisterAddress.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRegisterValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualConfigurationMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_actualConfigurationMap * ptr = dynamic_cast <const elementOf_GGS_actualConfigurationMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRegisterAddress.operator_isEqual (ptr->mInfo.mRegisterAddress)).boolValue ()
           && (mInfo.mRegisterValue.operator_isEqual (ptr->mInfo.mRegisterValue)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_actualConfigurationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_actualConfigurationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_actualConfigurationMap * info = (e_actualConfigurationMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_actualConfigurationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_actualConfigurationMap * info = (e_actualConfigurationMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_actualConfigurationMap GGS_actualConfigurationMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_actualConfigurationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_actualConfigurationMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualConfigurationMap::
operator_isEqual (const GGS_actualConfigurationMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualConfigurationMap::
operator_isNotEqual (const GGS_actualConfigurationMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_actualConfigurationMap info  ;
    info.mRegisterAddress = inParameter0 ;
    info.mRegisterValue = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegisterAddress ;
    outParameter1 = node->mInfo.mRegisterValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
modifier_setMRegisterValueForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (isBuilt () && inValue.isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRegisterValueForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRegisterValue = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_actualConfigurationMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_actualConfigurationMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_actualConfigurationMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_actualConfigurationMap GGS_actualConfigurationMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_actualConfigurationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_actualConfigurationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualConfigurationMap GGS_actualConfigurationMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualConfigurationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualConfigurationMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @actualConfigurationMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_actualConfigurationMap::cEnumerator::_mRegisterAddress (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterAddress ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_actualConfigurationMap::cEnumerator::_mRegisterValue (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberExpression::
cPtr_bitNumberExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberExpression * GGS_bitNumberExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_bitNumberExpression::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@bitNumberExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberExpression (& typeid (cPtr_bitNumberExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberExpression::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bitNumberExpression GGS_bitNumberExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberExpression *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bitNumberExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberExpression::actualTypeName (void) const {
  return "bitNumberExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_bitNumberExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__bitNumberExpression ("bitNumberExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_bitNumberLiteralValue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLiteralValue::
cPtr_bitNumberLiteralValue (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLiteralValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLiteralValue * GGS_bitNumberLiteralValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLiteralValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLiteralValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLiteralValue * ptr = dynamic_cast <const cPtr_bitNumberLiteralValue *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mBitNumberLiteralValue.operator_isEqual (ptr->mBitNumberLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLiteralValue::
method_display (C_Compiler & inLexique,
                                GGS_string& var_cas_ioString COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioString.dotAssign_operation (mBitNumberLiteralValue.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (261)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (261))) ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLiteralValue::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLiteralValue:"
           << mBitNumberLiteralValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLiteralValue (& typeid (cPtr_bitNumberLiteralValue), & typeid (cPtr_bitNumberExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLiteralValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLiteralValue ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bitNumberLiteralValue::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bitNumberLiteralValue (mBitNumberLiteralValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_bitNumberLiteralValue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLiteralValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLiteralValue) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bitNumberLiteralValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLiteralValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLiteralValue (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLiteralValue::
reader_mBitNumberLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLiteralValue *) mPointer)->mBitNumberLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLiteralValue::actualTypeName (void) const {
  return "bitNumberLiteralValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLiteralValue ("bitNumberLiteralValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberLabelValue'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLabelValue::
cPtr_bitNumberLabelValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLabelValue (argument_0),
mBitNumberIndexValue (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLabelValue * GGS_bitNumberLabelValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLabelValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLabelValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLabelValue * ptr = dynamic_cast <const cPtr_bitNumberLabelValue *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mBitNumberLabelValue.operator_isEqual (ptr->mBitNumberLabelValue).boolValue ()
         && mBitNumberIndexValue.operator_isEqual (ptr->mBitNumberIndexValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLabelValue::
method_display (C_Compiler & inLexique,
                                GGS_string& var_cas_ioString COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioString.dotAssign_operation (mBitNumberLabelValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (271))) ;
  var_cas_ioString.appendCString (" [") ;
  var_cas_ioString.dotAssign_operation (mBitNumberIndexValue.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (271)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (271))) ;
  var_cas_ioString.appendCString ("]") ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLabelValue::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLabelValue:"
           << mBitNumberLabelValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumberIndexValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLabelValue (& typeid (cPtr_bitNumberLabelValue), & typeid (cPtr_bitNumberExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLabelValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLabelValue ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bitNumberLabelValue::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bitNumberLabelValue (mBitNumberLabelValue, mBitNumberIndexValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberLabelValue'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLabelValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLabelValue) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bitNumberLabelValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLabelValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLabelValue (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_bitNumberLabelValue::
reader_mBitNumberLabelValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberLabelValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLabelValue::
reader_mBitNumberIndexValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberIndexValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLabelValue::actualTypeName (void) const {
  return "bitNumberLabelValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLabelValue ("bitNumberLabelValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*

