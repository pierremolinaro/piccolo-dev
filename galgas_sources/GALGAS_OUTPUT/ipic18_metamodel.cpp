//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'ipic18_metamodel.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      july 17th, 2009, at 18h43'15"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "ipic18_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "ipic18_metamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of 'ipic_registerExpressionWithoutBSRIndication' struct   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_registerExpressionWithoutBSRIndication::GGS_ipic_registerExpressionWithoutBSRIndication (void) :
mAssemblyString (),
mRegisterAddress () {
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpressionWithoutBSRIndication::~GGS_ipic_registerExpressionWithoutBSRIndication (void) {
}

//---------------------------------------------------------------------------*

void GGS_ipic_registerExpressionWithoutBSRIndication::drop (void) {
  mAssemblyString.drop () ;
  mRegisterAddress.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_ipic_registerExpressionWithoutBSRIndication::isBuilt (void) const {
  return mAssemblyString.isBuilt ()
    && mRegisterAddress.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpressionWithoutBSRIndication::
operator_isEqual (const GGS_ipic_registerExpressionWithoutBSRIndication & inOperand) const {
  return mAssemblyString.operator_isEqual (inOperand.mAssemblyString)
    .operator_and (mRegisterAddress.operator_isEqual (inOperand.mRegisterAddress)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpressionWithoutBSRIndication::
operator_isNotEqual (const GGS_ipic_registerExpressionWithoutBSRIndication & inOperand) const {
  return mAssemblyString.operator_isNotEqual (inOperand.mAssemblyString)
    .operator_or (mRegisterAddress.operator_isNotEqual (inOperand.mRegisterAddress)) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpressionWithoutBSRIndication GGS_ipic_registerExpressionWithoutBSRIndication::
constructor_new (const GGS_string& argument_0,
                 const GGS_uint & argument_1) {
  GGS_ipic_registerExpressionWithoutBSRIndication result ;
  result.mAssemblyString = argument_0 ;
  result.mRegisterAddress = argument_1 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_registerExpressionWithoutBSRIndication::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @ipic_registerExpressionWithoutBSRIndication" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAssemblyString " ;
    _s << mAssemblyString.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRegisterAddress " ;
    _s << mRegisterAddress.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of 'ipic_registerExpression' struct             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_registerExpression::GGS_ipic_registerExpression (void) :
mAssemblyString (),
mRegisterAddress (),
mNeedsBSR () {
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression::~GGS_ipic_registerExpression (void) {
}

//---------------------------------------------------------------------------*

void GGS_ipic_registerExpression::drop (void) {
  mAssemblyString.drop () ;
  mRegisterAddress.drop () ;
  mNeedsBSR.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_ipic_registerExpression::isBuilt (void) const {
  return mAssemblyString.isBuilt ()
    && mRegisterAddress.isBuilt ()
    && mNeedsBSR.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpression::
operator_isEqual (const GGS_ipic_registerExpression & inOperand) const {
  return mAssemblyString.operator_isEqual (inOperand.mAssemblyString)
    .operator_and (mRegisterAddress.operator_isEqual (inOperand.mRegisterAddress))
    .operator_and (mNeedsBSR.operator_isEqual (inOperand.mNeedsBSR)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpression::
operator_isNotEqual (const GGS_ipic_registerExpression & inOperand) const {
  return mAssemblyString.operator_isNotEqual (inOperand.mAssemblyString)
    .operator_or (mRegisterAddress.operator_isNotEqual (inOperand.mRegisterAddress))
    .operator_or (mNeedsBSR.operator_isNotEqual (inOperand.mNeedsBSR)) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_registerExpression::
constructor_new (const GGS_string& argument_0,
                 const GGS_uint & argument_1,
                 const GGS_bool& argument_2) {
  GGS_ipic_registerExpression result ;
  result.mAssemblyString = argument_0 ;
  result.mRegisterAddress = argument_1 ;
  result.mNeedsBSR = argument_2 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_registerExpression::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @ipic_registerExpression" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAssemblyString " ;
    _s << mAssemblyString.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRegisterAddress " ;
    _s << mRegisterAddress.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsBSR " ;
    _s << mNeedsBSR.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@registerExpression.resolveAccess'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__registerExpression__resolveAccess (C_Compiler & inLexique,
                                const cPtr_registerExpression * operand_671,
                                const GGS_uint   var_cas_inAccessBankSplitOffset,
                                const GGS_uint   var_cas_inCurrentBank,
                                const GGS_registerTable   var_cas_inRegisterTable,
                                GGS_ipic_registerExpression & var_cas_outIPICregisterDescription,
                                GGS_bitSliceTable  & var_cas_outBitSliceTable
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_671 != NULL) {
    GGS_string var_cas_assemblyString ;
    var_cas_assemblyString = operand_671->mRegisterName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
    if (((operand_671->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (32))).operator_strictSup (GGS_uint (0U))).isBuiltAndTrue ()) {
      var_cas_assemblyString.appendCString (" + ") ;
      var_cas_assemblyString.dotAssign_operation (operand_671->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (33)).reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (33))) ;
    }
    GGS_uintlist  var_cas_registerAddressList ;
    GGS_uint  var_cas_size ;
    GGS_uint  var_cas_registerAddress ;
    var_cas_registerAddress = GGS_uint (0U) ;
    GGS_string automatic_var_0 ;
    const GGS_registerTable  temp_1150 = var_cas_inRegisterTable ;
    if (temp_1150.isBuilt ()) {
      temp_1150 (HERE)->method_searchKey (inLexique, operand_671->mRegisterName, var_cas_registerAddressList, var_cas_size, var_cas_outBitSliceTable, automatic_var_0 COMMA_SOURCE_FILE_AT_LINE (39)) ;
    }
    if (((operand_671->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (41))).operator_strictSup (var_cas_size)).isBuiltAndTrue ()) {
      operand_671->mOffset.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("this offset is too large: should be lower than ")).operator_concat (var_cas_size.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (42))) COMMA_SOURCE_FILE_AT_LINE (43)) ;
    }
    GGS_bool var_cas_found ;
    var_cas_found = GGS_bool (false) ;
    {
      GGS_uintlist::cEnumerator enumerator_1411 (var_cas_registerAddressList, true) ;
      const GGS_uintlist::cElement * operand_1411 = NULL ;
      while (((operand_1411 = enumerator_1411.nextObject ()))
          && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
        macroValidPointer (operand_1411) ;
        var_cas_found = ((operand_1411->mValue).operator_strictInf (var_cas_inAccessBankSplitOffset)).operator_or ((operand_1411->mValue).operator_supOrEqual (GGS_uint (3840U).add_operation (inLexique, var_cas_inAccessBankSplitOffset COMMA_SOURCE_FILE_AT_LINE (47)))) ;
        var_cas_registerAddress = operand_1411->mValue ;
      }
    }
    GGS_bool var_cas_needsBSRaccess ;
    var_cas_needsBSRaccess = GGS_bool (false) ;
    if (((var_cas_found).operator_not ()).isBuiltAndTrue ()) {
      var_cas_needsBSRaccess = GGS_bool (true) ;
      const GGS_uintlist  temp_1691 = var_cas_registerAddressList ;
      if (temp_1691.isBuilt ()) {
        temp_1691 (HERE)->method_first (inLexique, var_cas_registerAddress COMMA_SOURCE_FILE_AT_LINE (53)) ;
      }
      GGS_uint  var_cas_neededBank ;
      var_cas_neededBank = var_cas_registerAddress.right_shift_operation (inLexique, GGS_uint (8U) COMMA_SOURCE_FILE_AT_LINE (54)) ;
      if (((var_cas_neededBank).operator_isNotEqual (var_cas_inCurrentBank)).isBuiltAndTrue ()) {
        GGS_string var_cas_errorMessage ;
        var_cas_errorMessage = (((GGS_string ("Accessing the '")).operator_concat (operand_671->mRegisterName)).operator_concat (GGS_string ("' needs the bank selection set to "))).operator_concat (var_cas_neededBank.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (56))) ;
        if (((var_cas_inCurrentBank).operator_isEqual (GGS_uint ::constructor_max (inLexique COMMA_HERE))).isBuiltAndTrue ()) {
          var_cas_errorMessage.appendCString (", but current bank selection cannot be known") ;
        }else{
          var_cas_errorMessage.appendCString (", but current bank selection is set to ") ;
          var_cas_errorMessage.dotAssign_operation (var_cas_inCurrentBank.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (60))) ;
        }
        operand_671->mRegisterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (63)) ;
      }
    }
    var_cas_outIPICregisterDescription = GGS_ipic_registerExpression::constructor_new (var_cas_assemblyString, var_cas_registerAddress.add_operation (inLexique, operand_671->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (68)) COMMA_SOURCE_FILE_AT_LINE (68)), var_cas_needsBSRaccess) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@registerExpression.resolveAccess'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__registerExpression__resolveAccess> gDispatchTableForMethod__registerExpression__resolveAccess ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__registerExpression__resolveAccess (typeCategoryMethod__registerExpression__resolveAccess inRoutine,
                     const sint32 inClassID) {
  gDispatchTableForMethod__registerExpression__resolveAccess.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__registerExpression__resolveAccess
findCategoryMethod__registerExpression__resolveAccess (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__registerExpression__resolveAccess result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__registerExpression__resolveAccess.count ()) {
    result = gDispatchTableForMethod__registerExpression__resolveAccess (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__registerExpression__resolveAccess (superClassPtr) ;
      gDispatchTableForMethod__registerExpression__resolveAccess.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@registerExpression.resolveAccessWithoutCheckingBank'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__registerExpression__resolveAccessWithoutCheckingBank (C_Compiler & inLexique,
                                const cPtr_registerExpression * operand_2509,
                                const GGS_registerTable   var_cas_inRegisterTable,
                                GGS_ipic_registerExpressionWithoutBSRIndication & var_cas_outIPICregisterDescription
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_2509 != NULL) {
    GGS_string var_cas_assemblyString ;
    var_cas_assemblyString = operand_2509->mRegisterName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (80)) ;
    if (((operand_2509->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (81))).operator_strictSup (GGS_uint (0U))).isBuiltAndTrue ()) {
      var_cas_assemblyString.appendCString (" + ") ;
      var_cas_assemblyString.dotAssign_operation (operand_2509->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (82)).reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (82))) ;
    }
    GGS_uintlist  var_cas_registerAddressList ;
    GGS_uint  var_cas_size ;
    GGS_bitSliceTable  automatic_var_1 ;
    GGS_string automatic_var_2 ;
    const GGS_registerTable  temp_2884 = var_cas_inRegisterTable ;
    if (temp_2884.isBuilt ()) {
      temp_2884 (HERE)->method_searchKey (inLexique, operand_2509->mRegisterName, var_cas_registerAddressList, var_cas_size, automatic_var_1, automatic_var_2 COMMA_SOURCE_FILE_AT_LINE (87)) ;
    }
    GGS_uint  var_cas_registerAddress ;
    const GGS_uintlist  temp_2990 = var_cas_registerAddressList ;
    if (temp_2990.isBuilt ()) {
      temp_2990 (HERE)->method_first (inLexique, var_cas_registerAddress COMMA_SOURCE_FILE_AT_LINE (89)) ;
    }
    if (((operand_2509->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (91))).operator_strictSup (var_cas_size)).isBuiltAndTrue ()) {
      operand_2509->mOffset.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("this offset is too large: should be lower than ")).operator_concat (var_cas_size.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92))) COMMA_SOURCE_FILE_AT_LINE (93)) ;
    }
    var_cas_outIPICregisterDescription = GGS_ipic_registerExpressionWithoutBSRIndication::constructor_new (var_cas_assemblyString, var_cas_registerAddress.add_operation (inLexique, operand_2509->mOffset.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (97)) COMMA_SOURCE_FILE_AT_LINE (97))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@registerExpression.resolveAccessWithoutCheckingBank'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank> gDispatchTableForMethod__registerExpression__resolveAccessWithoutCheckingBank ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank (typeCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank inRoutine,
                     const sint32 inClassID) {
  gDispatchTableForMethod__registerExpression__resolveAccessWithoutCheckingBank.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank
findCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__registerExpression__resolveAccessWithoutCheckingBank.count ()) {
    result = gDispatchTableForMethod__registerExpression__resolveAccessWithoutCheckingBank (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank (superClassPtr) ;
      gDispatchTableForMethod__registerExpression__resolveAccessWithoutCheckingBank.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_ipic18_instruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction::
cPtr_ipic18_instruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction * GGS_ipic18_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_setCurrentAddress (C_Compiler & inLexique,
                                GGS_uint & var_cas_ioCurrentAddress COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint  var_cas_length ;
  method_instructionLength (inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (109)) ;
  var_cas_ioCurrentAddress = var_cas_ioCurrentAddress.add_operation (inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (110)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_isLABELorORG (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_isNULL (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsNULL COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsNULL = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_isSkippingInstruction (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsSkipping = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
method_enterReferencedLabel (C_Compiler & /* inLexique */,
                                GGS_stringset & /* var_cas_ioReferencedLabelSet */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction (& typeid (cPtr_ipic18_instruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_ipic18_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction::
GGS_ipic18_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction::
GGS_ipic18_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction GGS_ipic18_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction::actualTypeName (void) const {
  return "ipic18_instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_ipic18_instruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__ipic18_instruction ("ipic18_instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@ipic18_instructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ipic18_instructionList::
elementOf_GGS_ipic18_instructionList (const GGS_ipic18_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ipic18_instructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ipic18_instructionList * ptr = dynamic_cast <const elementOf_GGS_ipic18_instructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ipic18_instructionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@ipic18_instructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
_internalAppendValues (const GGS_ipic18_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
_internalPrependValues (const GGS_ipic18_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
_addAssign_operation (const GGS_ipic18_instruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ipic18_instructionList GGS_ipic18_instructionList::
operator_concat (const GGS_ipic18_instructionList & inOperand) const {
  GGS_ipic18_instructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
dotAssign_operation (const GGS_ipic18_instructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ipic18_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ipic18_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_ipic18_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ipic18_instructionList  GGS_ipic18_instructionList::
constructor_emptyList (void) {
  GGS_ipic18_instructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instructionList  GGS_ipic18_instructionList::
constructor_listWithValue (const GGS_ipic18_instruction & argument_0) {
  GGS_ipic18_instructionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
internalSubListWithRange (GGS_ipic18_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ipic18_instructionList GGS_ipic18_instructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ipic18_instructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instructionList GGS_ipic18_instructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ipic18_instructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic18_instructionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@ipic18_instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
method_first (C_Compiler & inLexique,
              GGS_ipic18_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
method_last (C_Compiler & inLexique,
             GGS_ipic18_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_ipic18_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_ipic18_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction  GGS_ipic18_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_ipic18_instruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic18_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_ipic18_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ipic18_instruction  & GGS_ipic18_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_NULL'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_NULL::
cPtr_ipic_NULL (LOCATION_ARGS)
:cPtr_ipic18_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_NULL * GGS_ipic_NULL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_NULL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_NULL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_NULL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("-") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_isNULL (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsNULL COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsNULL = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ipic_NULL:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_NULL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_NULL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_NULL (& typeid (cPtr_ipic_NULL), & typeid (cPtr_ipic18_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_NULL::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_NULL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_NULL'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_NULL::
GGS_ipic_NULL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_NULL::
GGS_ipic_NULL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_NULL GGS_ipic_NULL::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_NULL result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_NULL *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_NULL) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_NULL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_NULL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_ipic_NULL * gSingleton_ipic_NULL = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_ipic_NULL (void) {
  macroDetachPointer (gSingleton_ipic_NULL, cPtr_ipic_NULL) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_NULL GGS_ipic_NULL::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_NULL result ;
  if (NULL == gSingleton_ipic_NULL) {
    macroMyNew (gSingleton_ipic_NULL, cPtr_ipic_NULL (THERE)) ;
    registerReleaseRoutine (cleanUp_ipic_NULL) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_ipic_NULL) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_NULL::actualTypeName (void) const {
  return "ipic_NULL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_NULL ("ipic_NULL", gClassInfoFor__ipic18_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ipic_pseudo_ORG'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_pseudo_ORG::
cPtr_ipic_pseudo_ORG (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic18_instruction (THERE),
mOrigin (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_pseudo_ORG * GGS_ipic_pseudo_ORG::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_pseudo_ORG *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_pseudo_ORG::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_pseudo_ORG * ptr = dynamic_cast <const cPtr_ipic_pseudo_ORG *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOrigin.operator_isEqual (ptr->mOrigin).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_setCurrentAddress (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_ioCurrentAddress COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioCurrentAddress = mOrigin ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("ORG ") ;
  var_cas_ioListFileContents.dotAssign_operation (mOrigin.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (171))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_isLABELorORG (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_pseudo_ORG:"
           << mOrigin.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_ORG::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_ORG::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_pseudo_ORG (& typeid (cPtr_ipic_pseudo_ORG), & typeid (cPtr_ipic18_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_pseudo_ORG::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_pseudo_ORG ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_pseudo_ORG::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_pseudo_ORG (mOrigin COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ipic_pseudo_ORG'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG::
GGS_ipic_pseudo_ORG (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG::
GGS_ipic_pseudo_ORG (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_pseudo_ORG GGS_ipic_pseudo_ORG::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_ORG result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_pseudo_ORG *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_pseudo_ORG) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_pseudo_ORG (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_pseudo_ORG),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG GGS_ipic_pseudo_ORG::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_ORG result ;
  macroMyNew (result.mPointer, cPtr_ipic_pseudo_ORG (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic_pseudo_ORG::
reader_mOrigin (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_pseudo_ORG *) mPointer)->mOrigin ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_pseudo_ORG::actualTypeName (void) const {
  return "ipic_pseudo_ORG" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_pseudo_ORG ("ipic_pseudo_ORG", gClassInfoFor__ipic18_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ipic_pseudo_LABEL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_pseudo_LABEL::
cPtr_ipic_pseudo_LABEL (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic18_instruction (THERE),
mLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_pseudo_LABEL * GGS_ipic_pseudo_LABEL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_pseudo_LABEL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_pseudo_LABEL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_pseudo_LABEL * ptr = dynamic_cast <const cPtr_ipic_pseudo_LABEL *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLabel.operator_isEqual (ptr->mLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("LABEL ") ;
  var_cas_ioListFileContents.dotAssign_operation (mLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_isLABELorORG (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_pseudo_LABEL:"
           << mLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_LABEL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_LABEL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_pseudo_LABEL (& typeid (cPtr_ipic_pseudo_LABEL), & typeid (cPtr_ipic18_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_pseudo_LABEL::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_pseudo_LABEL ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_pseudo_LABEL::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_pseudo_LABEL (mLabel COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ipic_pseudo_LABEL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL::
GGS_ipic_pseudo_LABEL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL::
GGS_ipic_pseudo_LABEL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_pseudo_LABEL GGS_ipic_pseudo_LABEL::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_LABEL result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_pseudo_LABEL) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_pseudo_LABEL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_pseudo_LABEL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL GGS_ipic_pseudo_LABEL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_LABEL result ;
  macroMyNew (result.mPointer, cPtr_ipic_pseudo_LABEL (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_pseudo_LABEL::
reader_mLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_pseudo_LABEL *) mPointer)->mLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_pseudo_LABEL::actualTypeName (void) const {
  return "ipic_pseudo_LABEL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_pseudo_LABEL ("ipic_pseudo_LABEL", gClassInfoFor__ipic18_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_actualInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_actualInstruction::
cPtr_ipic_actualInstruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic18_instruction (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_actualInstruction * GGS_ipic_actualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_actualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_actualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ipic_actualInstruction::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (2U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_actualInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_actualInstruction:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_actualInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_actualInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_actualInstruction (& typeid (cPtr_ipic_actualInstruction), & typeid (cPtr_ipic18_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_actualInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_actualInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_actualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_actualInstruction::
GGS_ipic_actualInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_actualInstruction::
GGS_ipic_actualInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_actualInstruction GGS_ipic_actualInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_actualInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_actualInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_actualInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_actualInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_actualInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ipic_actualInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_actualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_actualInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_actualInstruction::actualTypeName (void) const {
  return "ipic_actualInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_actualInstruction ("ipic_actualInstruction", gClassInfoFor__ipic18_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_FDA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_FDA::
cPtr_ipic18_instruction_FDA (const GGS_location & argument_0,
                                const GGS_instruction_FDA_base_code& argument_1,
                                const GGS_ipic_registerExpression& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mInstruction_FDA_base_code (argument_1),
mRegisterDescription (argument_2),
m_W_isDestination (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_FDA * GGS_ipic18_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_FDA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_FDA * ptr = dynamic_cast <const cPtr_ipic18_instruction_FDA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstruction_FDA_base_code.operator_isEqual (ptr->mInstruction_FDA_base_code).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && m_W_isDestination.operator_isEqual (ptr->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FDA::
method_getBaseCode (C_Compiler & inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFDAinstructionBaseCode (inLexique,  mInstruction_FDA_base_code,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (216)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FDA::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.dotAssign_operation (mInstruction_FDA_base_code.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (221))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (221))) ;
  if ((m_W_isDestination).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (", W") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FDA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_FDA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction_FDA_base_code.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_FDA (& typeid (cPtr_ipic18_instruction_FDA), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_FDA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_FDA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_FDA (mInstructionLocation, mInstruction_FDA_base_code, mRegisterDescription, m_W_isDestination COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_FDA'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FDA::
GGS_ipic18_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FDA::
GGS_ipic18_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_FDA GGS_ipic18_instruction_FDA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FDA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FDA GGS_ipic18_instruction_FDA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instruction_FDA_base_code& argument_1,
                 const GGS_ipic_registerExpression& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FDA result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_FDA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA_base_code GGS_ipic18_instruction_FDA::
reader_mInstruction_FDA_base_code (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction_FDA_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FDA *) mPointer)->mInstruction_FDA_base_code ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic18_instruction_FDA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FDA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_FDA::actualTypeName (void) const {
  return "ipic18_instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_FDA ("ipic18_instruction_FDA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getFAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFAinstructionBaseCode (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outBaseCode = GGS_uint (27136U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSEQ:
    {
    var_cas_outBaseCode = GGS_uint (25088U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outBaseCode = GGS_uint (25600U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outBaseCode = GGS_uint (24576U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outBaseCode = GGS_uint (28160U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outBaseCode = GGS_uint (512U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outBaseCode = GGS_uint (27648U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outBaseCode = GGS_uint (26624U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outBaseCode = GGS_uint (26112U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "FAinstructionIsSkippingInstruction"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_FAinstructionIsSkippingInstruction (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_bool & var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_FAinstructionIsSkippingInstruction at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outIsSkipping = GGS_bool (false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSEQ:
    {
    var_cas_outIsSkipping = GGS_bool (true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outIsSkipping = GGS_bool (true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outIsSkipping = GGS_bool (true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outIsSkipping = GGS_bool (false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outIsSkipping = GGS_bool (false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outIsSkipping = GGS_bool (false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outIsSkipping = GGS_bool (false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outIsSkipping = GGS_bool (true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_FAinstructionIsSkippingInstruction\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic18_instruction_FA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_FA::
cPtr_ipic18_instruction_FA (const GGS_location & argument_0,
                                const GGS_FA_instruction_base_code& argument_1,
                                const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFAinstruction (argument_1),
mRegisterDescription (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_FA * GGS_ipic18_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_FA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_FA * ptr = dynamic_cast <const cPtr_ipic18_instruction_FA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mFAinstruction.operator_isEqual (ptr->mFAinstruction).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FA::
method_getBaseCode (C_Compiler & inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFAinstructionBaseCode (inLexique,  mFAinstruction,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (273)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FA::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.dotAssign_operation (mFAinstruction.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (278))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (278))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FA::
method_isSkippingInstruction (C_Compiler & inLexique,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_FAinstructionIsSkippingInstruction (inLexique,  mFAinstruction,  var_cas_outIsSkipping COMMA_SOURCE_FILE_AT_LINE (283)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_FA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFAinstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_FA (& typeid (cPtr_ipic18_instruction_FA), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_FA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_FA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_FA (mInstructionLocation, mFAinstruction, mRegisterDescription COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic18_instruction_FA'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FA::
GGS_ipic18_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FA::
GGS_ipic18_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_FA GGS_ipic18_instruction_FA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FA GGS_ipic18_instruction_FA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_FA_instruction_base_code& argument_1,
                 const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FA result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_FA (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_FA_instruction_base_code GGS_ipic18_instruction_FA::
reader_mFAinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_FA_instruction_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FA *) mPointer)->mFAinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic18_instruction_FA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_FA::actualTypeName (void) const {
  return "ipic18_instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_FA ("ipic18_instruction_FA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_MOVFF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_MOVFF::
cPtr_ipic18_instruction_MOVFF (const GGS_location & argument_0,
                                const GGS_ipic_registerExpressionWithoutBSRIndication& argument_1,
                                const GGS_ipic_registerExpressionWithoutBSRIndication& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mSourceRegisterDescription (argument_1),
mDestinationRegisterDescription (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_MOVFF * GGS_ipic18_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_MOVFF * ptr = dynamic_cast <const cPtr_ipic18_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSourceRegisterDescription.operator_isEqual (ptr->mSourceRegisterDescription).boolValue ()
         && mDestinationRegisterDescription.operator_isEqual (ptr->mDestinationRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MOVFF::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MOVFF::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("MOVFF ") ;
  var_cas_ioListFileContents.dotAssign_operation (mSourceRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (300))) ;
  var_cas_ioListFileContents.appendCString (", ") ;
  var_cas_ioListFileContents.dotAssign_operation (mDestinationRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (300))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MOVFF::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_MOVFF:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_MOVFF (& typeid (cPtr_ipic18_instruction_MOVFF), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_MOVFF ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_MOVFF::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_MOVFF (mInstructionLocation, mSourceRegisterDescription, mDestinationRegisterDescription COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_MOVFF'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVFF::
GGS_ipic18_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVFF::
GGS_ipic18_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_MOVFF GGS_ipic18_instruction_MOVFF::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MOVFF result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVFF GGS_ipic18_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpressionWithoutBSRIndication& argument_1,
                 const GGS_ipic_registerExpressionWithoutBSRIndication& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_MOVFF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpressionWithoutBSRIndication GGS_ipic18_instruction_MOVFF::
reader_mSourceRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpressionWithoutBSRIndication  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_MOVFF *) mPointer)->mSourceRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpressionWithoutBSRIndication GGS_ipic18_instruction_MOVFF::
reader_mDestinationRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpressionWithoutBSRIndication  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_MOVFF *) mPointer)->mDestinationRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_MOVFF::actualTypeName (void) const {
  return "ipic18_instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_MOVFF ("ipic18_instruction_MOVFF", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getBitOrientedOpBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBitOrientedOpBaseCode (C_Compiler &,
                                const GGS_bit_oriented_op  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBitOrientedOpBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_bit_oriented_op::enum_BCF:
    {
    var_cas_outBaseCode = GGS_uint (36864U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BSF:
    {
    var_cas_outBaseCode = GGS_uint (32768U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTG:
    {
    var_cas_outBaseCode = GGS_uint (28672U) ;
    }
    break ;
  case GGS_bit_oriented_op::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBitOrientedOpBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_FBA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_FBA::
cPtr_ipic18_instruction_FBA (const GGS_location & argument_0,
                                const GGS_bit_oriented_op& argument_1,
                                const GGS_ipic_registerExpression& argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mBitOrientedOp (argument_1),
mRegisterDescription (argument_2),
mBitNumber (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_FBA * GGS_ipic18_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_FBA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_FBA * ptr = dynamic_cast <const cPtr_ipic18_instruction_FBA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBitOrientedOp.operator_isEqual (ptr->mBitOrientedOp).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && mBitNumber.operator_isEqual (ptr->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FBA::
method_getBaseCode (C_Compiler & inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getBitOrientedOpBaseCode (inLexique,  mBitOrientedOp,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (322)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FBA::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.dotAssign_operation (mBitOrientedOp.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (327))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (327))) ;
  var_cas_ioListFileContents.appendCString (", ") ;
  var_cas_ioListFileContents.dotAssign_operation (mBitNumber.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (327))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_FBA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_FBA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitOrientedOp.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_FBA (& typeid (cPtr_ipic18_instruction_FBA), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_FBA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_FBA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_FBA (mInstructionLocation, mBitOrientedOp, mRegisterDescription, mBitNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_FBA'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FBA::
GGS_ipic18_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FBA::
GGS_ipic18_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_FBA GGS_ipic18_instruction_FBA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FBA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_FBA GGS_ipic18_instruction_FBA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bit_oriented_op& argument_1,
                 const GGS_ipic_registerExpression& argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_FBA result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_FBA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bit_oriented_op GGS_ipic18_instruction_FBA::
reader_mBitOrientedOp (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bit_oriented_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FBA *) mPointer)->mBitOrientedOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic18_instruction_FBA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FBA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic18_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_FBA::actualTypeName (void) const {
  return "ipic18_instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_FBA ("ipic18_instruction_FBA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic18_instruction_BitTestSkip'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_BitTestSkip::
cPtr_ipic18_instruction_BitTestSkip (const GGS_location & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_ipic_registerExpression& argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mSkipIfSet (argument_1),
mRegisterDescription (argument_2),
mBitNumber (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_BitTestSkip * GGS_ipic18_instruction_BitTestSkip::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_BitTestSkip *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_BitTestSkip *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_BitTestSkip::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_BitTestSkip * ptr = dynamic_cast <const cPtr_ipic18_instruction_BitTestSkip *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSkipIfSet.operator_isEqual (ptr->mSkipIfSet).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && mBitNumber.operator_isEqual (ptr->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_BitTestSkip::
method_getBaseCode (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outBaseCode = GGS_uint (40960U) ;
  }else{
    var_cas_outBaseCode = GGS_uint (45056U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_BitTestSkip::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString ("BTFSS") ;
  }else{
    var_cas_ioListFileContents.appendCString ("BTFSC") ;
  }
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (354))) ;
  var_cas_ioListFileContents.appendCString (", ") ;
  var_cas_ioListFileContents.dotAssign_operation (mBitNumber.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (354))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_BitTestSkip::
method_isSkippingInstruction (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsSkipping = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_BitTestSkip::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_BitTestSkip:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfSet.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_BitTestSkip::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_BitTestSkip::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_BitTestSkip (& typeid (cPtr_ipic18_instruction_BitTestSkip), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_BitTestSkip::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_BitTestSkip ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_BitTestSkip::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_BitTestSkip (mInstructionLocation, mSkipIfSet, mRegisterDescription, mBitNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic18_instruction_BitTestSkip'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_BitTestSkip::
GGS_ipic18_instruction_BitTestSkip (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_BitTestSkip::
GGS_ipic18_instruction_BitTestSkip (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_BitTestSkip GGS_ipic18_instruction_BitTestSkip::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_BitTestSkip result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_BitTestSkip *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_BitTestSkip) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_BitTestSkip (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_BitTestSkip),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_BitTestSkip GGS_ipic18_instruction_BitTestSkip::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_ipic_registerExpression& argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_BitTestSkip result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_BitTestSkip (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_BitTestSkip::
reader_mSkipIfSet (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_BitTestSkip *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_BitTestSkip *) mPointer)->mSkipIfSet ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic18_instruction_BitTestSkip::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_BitTestSkip *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_BitTestSkip *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic18_instruction_BitTestSkip::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_BitTestSkip *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_BitTestSkip *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_BitTestSkip::actualTypeName (void) const {
  return "ipic18_instruction_BitTestSkip" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_BitTestSkip ("ipic18_instruction_BitTestSkip", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'condionalBranchMode' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_condionalBranchMode::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_isEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_isNotEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_infOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_supOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_strictInf (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
operator_strictSup (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_condionalBranchMode::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @condionalBranchMode" ;
  switch (mValue) {
  case enum_ipicBRA:
    s << " ipicBRA>" ;
    break ;
  case enum_ipicGOTO:
    s << " ipicGOTO>" ;
    break ;
  case enum_ipicNative:
    s << " ipicNative>" ;
    break ;
  case enum_native:
    s << " native>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_ipic18_instruction_conditionalBranch'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_conditionalBranch::
cPtr_ipic18_instruction_conditionalBranch (const GGS_location & argument_0,
                                const GGS_condionalBranchMode& argument_1,
                                const GGS_conditional_branch& argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mBranchMode (argument_1),
mConditionalBranch (argument_2),
mTargetLabel (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_conditionalBranch * GGS_ipic18_instruction_conditionalBranch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_conditionalBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_conditionalBranch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_conditionalBranch * ptr = dynamic_cast <const cPtr_ipic18_instruction_conditionalBranch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBranchMode.operator_isEqual (ptr->mBranchMode).boolValue ()
         && mConditionalBranch.operator_isEqual (ptr->mConditionalBranch).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_conditionalBranch::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mBranchMode.enumValue ()) {
  case GGS_condionalBranchMode::enum_native:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_condionalBranchMode::enum_ipicNative:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_condionalBranchMode::enum_ipicBRA:
    {
    var_cas_outLength = GGS_uint (4U) ;
    }
    break ;
  case GGS_condionalBranchMode::enum_ipicGOTO:
    {
    var_cas_outLength = GGS_uint (6U) ;
    }
    break ;
  case GGS_condionalBranchMode::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_conditionalBranch::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("JUMP ") ;
  var_cas_ioListFileContents.dotAssign_operation (mConditionalBranch.reader_condition (inLexique COMMA_SOURCE_FILE_AT_LINE (392))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_conditionalBranch::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (402))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_conditionalBranch::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_conditionalBranch:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchMode.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConditionalBranch.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_conditionalBranch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_conditionalBranch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_conditionalBranch (& typeid (cPtr_ipic18_instruction_conditionalBranch), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_conditionalBranch::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_conditionalBranch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_conditionalBranch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_conditionalBranch (mInstructionLocation, mBranchMode, mConditionalBranch, mTargetLabel COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_ipic18_instruction_conditionalBranch'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_conditionalBranch::
GGS_ipic18_instruction_conditionalBranch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_conditionalBranch::
GGS_ipic18_instruction_conditionalBranch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_conditionalBranch GGS_ipic18_instruction_conditionalBranch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_conditionalBranch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_conditionalBranch *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_conditionalBranch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_conditionalBranch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_conditionalBranch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_conditionalBranch GGS_ipic18_instruction_conditionalBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_condionalBranchMode& argument_1,
                 const GGS_conditional_branch& argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_conditionalBranch result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_conditionalBranch (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_condionalBranchMode GGS_ipic18_instruction_conditionalBranch::
reader_mBranchMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_condionalBranchMode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_conditionalBranch *) mPointer)->mBranchMode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_ipic18_instruction_conditionalBranch::
reader_mConditionalBranch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_conditionalBranch *) mPointer)->mConditionalBranch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic18_instruction_conditionalBranch::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_conditionalBranch *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_conditionalBranch::actualTypeName (void) const {
  return "ipic18_instruction_conditionalBranch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_conditionalBranch ("ipic18_instruction_conditionalBranch", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_JUMP'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_JUMP::
cPtr_ipic_JUMP (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_JUMP * GGS_ipic_JUMP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_JUMP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_JUMP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_JUMP * ptr = dynamic_cast <const cPtr_ipic_JUMP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_outLength = GGS_uint (4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_outLength = GGS_uint (4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_ioListFileContents.appendCString ("JUMP ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_ioListFileContents.appendCString ("JUMP ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_ioListFileContents.appendCString ("BRA ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_ioListFileContents.appendCString ("GOTO ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (437))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_JUMP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_JUMP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_JUMP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_JUMP (& typeid (cPtr_ipic_JUMP), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_JUMP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_JUMP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_JUMP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_JUMP (mInstructionLocation, mTargetLabel, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_JUMP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_JUMP::
GGS_ipic_JUMP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JUMP::
GGS_ipic_JUMP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_JUMP GGS_ipic_JUMP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_JUMP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_JUMP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_JUMP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_JUMP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_JUMP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JUMP GGS_ipic_JUMP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_JUMP result ;
  macroMyNew (result.mPointer, cPtr_ipic_JUMP (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_JUMP::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JUMP *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_ipic_JUMP::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JUMP *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_JUMP::actualTypeName (void) const {
  return "ipic_JUMP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_JUMP ("ipic_JUMP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_JSR'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_JSR::
cPtr_ipic_JSR (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_JSR * GGS_ipic_JSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_JSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_JSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_JSR * ptr = dynamic_cast <const cPtr_ipic_JSR *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_outLength = GGS_uint (4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_outLength = GGS_uint (2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_outLength = GGS_uint (4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_ioListFileContents.appendCString ("JSR ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_ioListFileContents.appendCString ("JSR ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_ioListFileContents.appendCString ("RCALL ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_ioListFileContents.appendCString ("CALL ") ;
    var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (468))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_JSR:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_JSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_JSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_JSR (& typeid (cPtr_ipic_JSR), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_JSR::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_JSR ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_JSR::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_JSR (mInstructionLocation, mTargetLabel, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_JSR'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_JSR::
GGS_ipic_JSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JSR::
GGS_ipic_JSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_JSR GGS_ipic_JSR::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_JSR result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_JSR *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_JSR) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_JSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_JSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JSR GGS_ipic_JSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_JSR result ;
  macroMyNew (result.mPointer, cPtr_ipic_JSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_JSR::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JSR *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_ipic_JSR::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JSR *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_JSR::actualTypeName (void) const {
  return "ipic_JSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_JSR ("ipic_JSR", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_CLRWDT'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_CLRWDT::
cPtr_ipic18_instruction_CLRWDT (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_CLRWDT * GGS_ipic18_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_CLRWDT * ptr = dynamic_cast <const cPtr_ipic18_instruction_CLRWDT *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_CLRWDT::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("CLRWDT") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_CLRWDT::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_CLRWDT:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_CLRWDT (& typeid (cPtr_ipic18_instruction_CLRWDT), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_CLRWDT::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_CLRWDT (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_CLRWDT'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_CLRWDT::
GGS_ipic18_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_CLRWDT::
GGS_ipic18_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_CLRWDT GGS_ipic18_instruction_CLRWDT::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_CLRWDT result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_CLRWDT GGS_ipic18_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_CLRWDT result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_CLRWDT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_CLRWDT::actualTypeName (void) const {
  return "ipic18_instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_CLRWDT ("ipic18_instruction_CLRWDT", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_DAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_DAW::
cPtr_ipic18_instruction_DAW (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_DAW * GGS_ipic18_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_DAW * ptr = dynamic_cast <const cPtr_ipic18_instruction_DAW *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_DAW::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("DAW") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_DAW::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_DAW:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_DAW (& typeid (cPtr_ipic18_instruction_DAW), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_DAW ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_DAW::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_DAW (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_DAW'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_DAW::
GGS_ipic18_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_DAW::
GGS_ipic18_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_DAW GGS_ipic18_instruction_DAW::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_DAW result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_DAW GGS_ipic18_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_DAW result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_DAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_DAW::actualTypeName (void) const {
  return "ipic18_instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_DAW ("ipic18_instruction_DAW", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_NOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_NOP::
cPtr_ipic18_instruction_NOP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_NOP * GGS_ipic18_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_NOP * ptr = dynamic_cast <const cPtr_ipic18_instruction_NOP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_NOP::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("NOP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_NOP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_NOP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_NOP (& typeid (cPtr_ipic18_instruction_NOP), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_NOP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_NOP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_NOP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_NOP'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_NOP::
GGS_ipic18_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_NOP::
GGS_ipic18_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_NOP GGS_ipic18_instruction_NOP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_NOP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_NOP GGS_ipic18_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_NOP result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_NOP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_NOP::actualTypeName (void) const {
  return "ipic18_instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_NOP ("ipic18_instruction_NOP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_POP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_POP::
cPtr_ipic18_instruction_POP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_POP * GGS_ipic18_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_POP * ptr = dynamic_cast <const cPtr_ipic18_instruction_POP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_POP::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("POP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_POP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_POP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_POP (& typeid (cPtr_ipic18_instruction_POP), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_POP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_POP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_POP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_POP'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_POP::
GGS_ipic18_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_POP::
GGS_ipic18_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_POP GGS_ipic18_instruction_POP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_POP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_POP GGS_ipic18_instruction_POP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_POP result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_POP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_POP::actualTypeName (void) const {
  return "ipic18_instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_POP ("ipic18_instruction_POP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_PUSH'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_PUSH::
cPtr_ipic18_instruction_PUSH (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_PUSH * GGS_ipic18_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_PUSH * ptr = dynamic_cast <const cPtr_ipic18_instruction_PUSH *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_PUSH::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("PUSH") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_PUSH::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_PUSH:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_PUSH (& typeid (cPtr_ipic18_instruction_PUSH), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_PUSH ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_PUSH::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_PUSH (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_PUSH'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_PUSH::
GGS_ipic18_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_PUSH::
GGS_ipic18_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_PUSH GGS_ipic18_instruction_PUSH::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_PUSH result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_PUSH GGS_ipic18_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_PUSH result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_PUSH (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_PUSH::actualTypeName (void) const {
  return "ipic18_instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_PUSH ("ipic18_instruction_PUSH", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_RESET'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_RESET::
cPtr_ipic18_instruction_RESET (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_RESET * GGS_ipic18_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_RESET * ptr = dynamic_cast <const cPtr_ipic18_instruction_RESET *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RESET::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("RESET") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RESET::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_RESET:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_RESET (& typeid (cPtr_ipic18_instruction_RESET), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_RESET ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_RESET::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_RESET (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_RESET'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RESET::
GGS_ipic18_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RESET::
GGS_ipic18_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_RESET GGS_ipic18_instruction_RESET::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RESET result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RESET GGS_ipic18_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RESET result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_RESET (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_RESET::actualTypeName (void) const {
  return "ipic18_instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_RESET ("ipic18_instruction_RESET", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_RETURN'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_RETURN::
cPtr_ipic18_instruction_RETURN (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_RETURN * GGS_ipic18_instruction_RETURN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_RETURN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_RETURN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_RETURN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_RETURN * ptr = dynamic_cast <const cPtr_ipic18_instruction_RETURN *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETURN::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("RETURN") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETURN::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETURN::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_RETURN:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RETURN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RETURN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_RETURN (& typeid (cPtr_ipic18_instruction_RETURN), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_RETURN::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_RETURN ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_RETURN::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_RETURN (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_RETURN'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETURN::
GGS_ipic18_instruction_RETURN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETURN::
GGS_ipic18_instruction_RETURN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_RETURN GGS_ipic18_instruction_RETURN::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RETURN result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_RETURN *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_RETURN) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_RETURN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_RETURN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETURN GGS_ipic18_instruction_RETURN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RETURN result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_RETURN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_RETURN::actualTypeName (void) const {
  return "ipic18_instruction_RETURN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_RETURN ("ipic18_instruction_RETURN", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_RETFIE'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_RETFIE::
cPtr_ipic18_instruction_RETFIE (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFastReturn (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_RETFIE * GGS_ipic18_instruction_RETFIE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_RETFIE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_RETFIE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_RETFIE * ptr = dynamic_cast <const cPtr_ipic18_instruction_RETFIE *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mFastReturn.operator_isEqual (ptr->mFastReturn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETFIE::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("RETFIE") ;
  if ((mFastReturn).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (" FAST") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETFIE::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_RETFIE::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_RETFIE:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFastReturn.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RETFIE::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_RETFIE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_RETFIE (& typeid (cPtr_ipic18_instruction_RETFIE), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_RETFIE::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_RETFIE ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_RETFIE::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_RETFIE (mInstructionLocation, mFastReturn COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_RETFIE'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETFIE::
GGS_ipic18_instruction_RETFIE (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETFIE::
GGS_ipic18_instruction_RETFIE (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_RETFIE GGS_ipic18_instruction_RETFIE::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RETFIE result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_RETFIE *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_RETFIE) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_RETFIE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_RETFIE),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_RETFIE GGS_ipic18_instruction_RETFIE::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_RETFIE result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_RETFIE (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_RETFIE::
reader_mFastReturn (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_RETFIE *) mPointer)->mFastReturn ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_RETFIE::actualTypeName (void) const {
  return "ipic18_instruction_RETFIE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_RETFIE ("ipic18_instruction_RETFIE", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_SLEEP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_SLEEP::
cPtr_ipic18_instruction_SLEEP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_SLEEP * GGS_ipic18_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_SLEEP * ptr = dynamic_cast <const cPtr_ipic18_instruction_SLEEP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_SLEEP::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("SLEEP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_SLEEP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_SLEEP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_SLEEP (& typeid (cPtr_ipic18_instruction_SLEEP), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_SLEEP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_SLEEP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_SLEEP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_SLEEP'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_SLEEP::
GGS_ipic18_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_SLEEP::
GGS_ipic18_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_SLEEP GGS_ipic18_instruction_SLEEP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_SLEEP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_SLEEP GGS_ipic18_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_SLEEP result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_SLEEP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_SLEEP::actualTypeName (void) const {
  return "ipic18_instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_SLEEP ("ipic18_instruction_SLEEP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "getLiteralInstructionBaseCode"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getLiteralInstructionBaseCode (C_Compiler &,
                                const GGS_literal_instruction_opcode  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getLiteralInstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_literal_instruction_opcode::enum_ADDLW:
    {
    var_cas_outBaseCode = GGS_uint (3840U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_ANDLW:
    {
    var_cas_outBaseCode = GGS_uint (2816U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_IORLW:
    {
    var_cas_outBaseCode = GGS_uint (2304U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MOVLW:
    {
    var_cas_outBaseCode = GGS_uint (3584U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MULLW:
    {
    var_cas_outBaseCode = GGS_uint (3328U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_RETLW:
    {
    var_cas_outBaseCode = GGS_uint (3072U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_SUBLW:
    {
    var_cas_outBaseCode = GGS_uint (2048U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_XORLW:
    {
    var_cas_outBaseCode = GGS_uint (2560U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getLiteralInstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_ipic18_instruction_literalOperation'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_literalOperation::
cPtr_ipic18_instruction_literalOperation (const GGS_location & argument_0,
                                const GGS_literal_instruction_opcode& argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mLiteralInstruction (argument_1),
mLiteralValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_literalOperation * GGS_ipic18_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_literalOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_literalOperation * ptr = dynamic_cast <const cPtr_ipic18_instruction_literalOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLiteralInstruction.operator_isEqual (ptr->mLiteralInstruction).boolValue ()
         && mLiteralValue.operator_isEqual (ptr->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_literalOperation::
method_getBaseCode (C_Compiler & inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getLiteralInstructionBaseCode (inLexique,  mLiteralInstruction,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (597)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_literalOperation::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.dotAssign_operation (mLiteralInstruction.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (602))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mLiteralValue.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (602))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_literalOperation::
method_nextInstructionIsReachable (C_Compiler & inLexique,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = (mLiteralInstruction).operator_isNotEqual (GGS_literal_instruction_opcode::constructor_RETLW (inLexique COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_literalOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_literalOperation:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_literalOperation (& typeid (cPtr_ipic18_instruction_literalOperation), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_literalOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_literalOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_literalOperation (mInstructionLocation, mLiteralInstruction, mLiteralValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_ipic18_instruction_literalOperation'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_literalOperation::
GGS_ipic18_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_literalOperation::
GGS_ipic18_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_literalOperation GGS_ipic18_instruction_literalOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_literalOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_literalOperation GGS_ipic18_instruction_literalOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_literal_instruction_opcode& argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_literalOperation result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_literalOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literal_instruction_opcode GGS_ipic18_instruction_literalOperation::
reader_mLiteralInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_literal_instruction_opcode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_literalOperation *) mPointer)->mLiteralInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic18_instruction_literalOperation::
reader_mLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_literalOperation *) mPointer)->mLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_literalOperation::actualTypeName (void) const {
  return "ipic18_instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_literalOperation ("ipic18_instruction_literalOperation", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_LFSR'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_LFSR::
cPtr_ipic18_instruction_LFSR (const GGS_location & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFSRindex (argument_1),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_LFSR * GGS_ipic18_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_LFSR * ptr = dynamic_cast <const cPtr_ipic18_instruction_LFSR *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mFSRindex.operator_isEqual (ptr->mFSRindex).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_LFSR::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_LFSR::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("LFSR ") ;
  var_cas_ioListFileContents.dotAssign_operation (mFSRindex.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (623)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (623))) ;
  var_cas_ioListFileContents.appendCString (", ") ;
  var_cas_ioListFileContents.dotAssign_operation (mValue.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (623))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_LFSR::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_LFSR:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFSRindex.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_LFSR (& typeid (cPtr_ipic18_instruction_LFSR), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_LFSR ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_LFSR::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_LFSR (mInstructionLocation, mFSRindex, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_LFSR'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_LFSR::
GGS_ipic18_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_LFSR::
GGS_ipic18_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_LFSR GGS_ipic18_instruction_LFSR::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_LFSR result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_LFSR GGS_ipic18_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_LFSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic18_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic18_instruction_LFSR::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_LFSR *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_LFSR::actualTypeName (void) const {
  return "ipic18_instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_LFSR ("ipic18_instruction_LFSR", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_MOVLB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_MOVLB::
cPtr_ipic18_instruction_MOVLB (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mBankIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_MOVLB * GGS_ipic18_instruction_MOVLB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_MOVLB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_MOVLB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_MOVLB * ptr = dynamic_cast <const cPtr_ipic18_instruction_MOVLB *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBankIndex.operator_isEqual (ptr->mBankIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MOVLB::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("MOVLB ") ;
  var_cas_ioListFileContents.dotAssign_operation (mBankIndex.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (634)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (634))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MOVLB::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_MOVLB:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBankIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MOVLB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MOVLB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_MOVLB (& typeid (cPtr_ipic18_instruction_MOVLB), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_MOVLB::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_MOVLB ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_MOVLB::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_MOVLB (mInstructionLocation, mBankIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_MOVLB'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVLB::
GGS_ipic18_instruction_MOVLB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVLB::
GGS_ipic18_instruction_MOVLB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_MOVLB GGS_ipic18_instruction_MOVLB::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MOVLB result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_MOVLB *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_MOVLB) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_MOVLB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_MOVLB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MOVLB GGS_ipic18_instruction_MOVLB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MOVLB result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_MOVLB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic18_instruction_MOVLB::
reader_mBankIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_MOVLB *) mPointer)->mBankIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_MOVLB::actualTypeName (void) const {
  return "ipic18_instruction_MOVLB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_MOVLB ("ipic18_instruction_MOVLB", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_TBLRD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_TBLRD::
cPtr_ipic18_instruction_TBLRD (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_TBLRD * GGS_ipic18_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_TBLRD * ptr = dynamic_cast <const cPtr_ipic18_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOption.operator_isEqual (ptr->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_TBLRD::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("TBLRD ") ;
  var_cas_ioListFileContents.dotAssign_operation (mOption.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (645))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_TBLRD::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_TBLRD:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_TBLRD (& typeid (cPtr_ipic18_instruction_TBLRD), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_TBLRD ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_TBLRD::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_TBLRD (mInstructionLocation, mOption COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_TBLRD'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLRD::
GGS_ipic18_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLRD::
GGS_ipic18_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_TBLRD GGS_ipic18_instruction_TBLRD::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_TBLRD result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLRD GGS_ipic18_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_TBLRD (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_ipic18_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_TBLRD::actualTypeName (void) const {
  return "ipic18_instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_TBLRD ("ipic18_instruction_TBLRD", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ipic18_instruction_TBLWT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_TBLWT::
cPtr_ipic18_instruction_TBLWT (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_TBLWT * GGS_ipic18_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_TBLWT * ptr = dynamic_cast <const cPtr_ipic18_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOption.operator_isEqual (ptr->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_TBLWT::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("TBLWT ") ;
  var_cas_ioListFileContents.dotAssign_operation (mOption.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (656))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_TBLWT::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_TBLWT:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_TBLWT (& typeid (cPtr_ipic18_instruction_TBLWT), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_TBLWT ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_TBLWT::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_TBLWT (mInstructionLocation, mOption COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ipic18_instruction_TBLWT'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLWT::
GGS_ipic18_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLWT::
GGS_ipic18_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_TBLWT GGS_ipic18_instruction_TBLWT::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_TBLWT result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_TBLWT GGS_ipic18_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_TBLWT (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_ipic18_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_TBLWT::actualTypeName (void) const {
  return "ipic18_instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_TBLWT ("ipic18_instruction_TBLWT", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic18_instruction_MNOP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_MNOP::
cPtr_ipic18_instruction_MNOP (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOccurrenceFactor (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_MNOP * GGS_ipic18_instruction_MNOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_MNOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_MNOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_MNOP * ptr = dynamic_cast <const cPtr_ipic18_instruction_MNOP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOccurrenceFactor.operator_isEqual (ptr->mOccurrenceFactor).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MNOP::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mOccurrenceFactor.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (666)).multiply_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (666)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MNOP::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("MNOP ") ;
  var_cas_ioListFileContents.dotAssign_operation (mOccurrenceFactor.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (671)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (671))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_MNOP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_MNOP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOccurrenceFactor.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MNOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_MNOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_MNOP (& typeid (cPtr_ipic18_instruction_MNOP), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_MNOP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_MNOP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_MNOP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_MNOP (mInstructionLocation, mOccurrenceFactor COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic18_instruction_MNOP'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MNOP::
GGS_ipic18_instruction_MNOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MNOP::
GGS_ipic18_instruction_MNOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_MNOP GGS_ipic18_instruction_MNOP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MNOP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_MNOP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_MNOP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_MNOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_MNOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_MNOP GGS_ipic18_instruction_MNOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_MNOP result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_MNOP (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic18_instruction_MNOP::
reader_mOccurrenceFactor (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_MNOP *) mPointer)->mOccurrenceFactor ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_MNOP::actualTypeName (void) const {
  return "ipic18_instruction_MNOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_MNOP ("ipic18_instruction_MNOP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic18_instruction_computed_retlw'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_computed_retlw::
cPtr_ipic18_instruction_computed_retlw (const GGS_location & argument_0,
                                const GGS_uintlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mLiteralValues (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_computed_retlw * GGS_ipic18_instruction_computed_retlw::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_computed_retlw *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_computed_retlw::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_computed_retlw * ptr = dynamic_cast <const cPtr_ipic18_instruction_computed_retlw *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLiteralValues.operator_isEqual (ptr->mLiteralValues).boolValue ()
         && mUsesRCALL.operator_isEqual (ptr->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_retlw::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mLiteralValues.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (683)).multiply_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (683)).add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (683)) ;
  if (((mUsesRCALL).operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (685)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_retlw::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("COMPUTED RETLW ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.appendCString (" (uses CALL)") ;
  }
  {
    GGS_uintlist::cEnumerator enumerator_20521 (mLiteralValues, true) ;
    const GGS_uintlist::cElement * operand_20521 = NULL ;
    while (((operand_20521 = enumerator_20521.nextObject ()))) {
      macroValidPointer (operand_20521) ;
      var_cas_ioListFileContents.appendCString (", ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_20521->mValue.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (698))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_retlw::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_retlw::
method_enterReferencedLabel (C_Compiler & /* inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string ("_computed_goto_2")) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_retlw::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_computed_retlw:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValues.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_retlw::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_retlw::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_computed_retlw (& typeid (cPtr_ipic18_instruction_computed_retlw), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_computed_retlw::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_computed_retlw ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_computed_retlw::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_computed_retlw (mInstructionLocation, mLiteralValues, mUsesRCALL COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic18_instruction_computed_retlw'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_retlw::
GGS_ipic18_instruction_computed_retlw (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_retlw::
GGS_ipic18_instruction_computed_retlw (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_computed_retlw GGS_ipic18_instruction_computed_retlw::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_retlw result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_computed_retlw *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_computed_retlw) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_computed_retlw (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_computed_retlw),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_retlw GGS_ipic18_instruction_computed_retlw::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uintlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_retlw result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_computed_retlw (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintlist  GGS_ipic18_instruction_computed_retlw::
reader_mLiteralValues (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uintlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_retlw *) mPointer)->mLiteralValues ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_computed_retlw::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_retlw *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_computed_retlw::actualTypeName (void) const {
  return "ipic18_instruction_computed_retlw" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_computed_retlw ("ipic18_instruction_computed_retlw", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic18_instruction_computed_bra'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_computed_bra::
cPtr_ipic18_instruction_computed_bra (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_computed_bra * GGS_ipic18_instruction_computed_bra::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_computed_bra *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_computed_bra::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_computed_bra * ptr = dynamic_cast <const cPtr_ipic18_instruction_computed_bra *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mUsesRCALL.operator_isEqual (ptr->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_bra::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (719)).multiply_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (719)).add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (719)) ;
  if (((mUsesRCALL).operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (721)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_bra::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("COMPUTED BRA ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.appendCString (" (uses CALL)") ;
  }
  {
    GGS_lstringlist::cEnumerator enumerator_21532 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_21532 = NULL ;
    while (((operand_21532 = enumerator_21532.nextObject ()))) {
      macroValidPointer (operand_21532) ;
      var_cas_ioListFileContents.appendCString (", ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_21532->mValue) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_bra::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_bra::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string ("_computed_goto_2")) ;
  {
    GGS_lstringlist::cEnumerator enumerator_21879 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_21879 = NULL ;
    while (((operand_21879 = enumerator_21879.nextObject ()))) {
      macroValidPointer (operand_21879) ;
      var_cas_ioReferencedLabelSet._addAssign_operation (operand_21879->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (745))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_bra::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_computed_bra:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_bra::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_bra::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_computed_bra (& typeid (cPtr_ipic18_instruction_computed_bra), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_computed_bra::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_computed_bra ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_computed_bra::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_computed_bra (mInstructionLocation, mTargetLabels, mUsesRCALL COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic18_instruction_computed_bra'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_bra::
GGS_ipic18_instruction_computed_bra (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_bra::
GGS_ipic18_instruction_computed_bra (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_computed_bra GGS_ipic18_instruction_computed_bra::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_bra result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_computed_bra *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_computed_bra) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_computed_bra (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_computed_bra),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_bra GGS_ipic18_instruction_computed_bra::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_bra result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_computed_bra (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_ipic18_instruction_computed_bra::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_bra *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_computed_bra::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_bra *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_computed_bra::actualTypeName (void) const {
  return "ipic18_instruction_computed_bra" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_computed_bra ("ipic18_instruction_computed_bra", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic18_instruction_computed_goto'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_computed_goto::
cPtr_ipic18_instruction_computed_goto (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_computed_goto * GGS_ipic18_instruction_computed_goto::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_computed_goto *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_computed_goto::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_computed_goto * ptr = dynamic_cast <const cPtr_ipic18_instruction_computed_goto *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mUsesRCALL.operator_isEqual (ptr->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_goto::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (758)).multiply_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (758)).add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (758)) ;
  if (((mUsesRCALL).operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (760)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_goto::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("COMPUTED GOTO ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.appendCString (" (uses CALL)") ;
  }
  {
    GGS_lstringlist::cEnumerator enumerator_22629 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_22629 = NULL ;
    while (((operand_22629 = enumerator_22629.nextObject ()))) {
      macroValidPointer (operand_22629) ;
      var_cas_ioListFileContents.appendCString (", ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_22629->mValue) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_goto::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_goto::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string ("_computed_goto_4")) ;
  {
    GGS_lstringlist::cEnumerator enumerator_22976 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_22976 = NULL ;
    while (((operand_22976 = enumerator_22976.nextObject ()))) {
      macroValidPointer (operand_22976) ;
      var_cas_ioReferencedLabelSet._addAssign_operation (operand_22976->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (784))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_goto::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_computed_goto:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_goto::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_goto::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_computed_goto (& typeid (cPtr_ipic18_instruction_computed_goto), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_computed_goto::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_computed_goto ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_computed_goto::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_computed_goto (mInstructionLocation, mTargetLabels, mUsesRCALL COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic18_instruction_computed_goto'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_goto::
GGS_ipic18_instruction_computed_goto (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_goto::
GGS_ipic18_instruction_computed_goto (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_computed_goto GGS_ipic18_instruction_computed_goto::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_goto result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_computed_goto *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_computed_goto) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_computed_goto (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_computed_goto),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_goto GGS_ipic18_instruction_computed_goto::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_goto result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_computed_goto (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_ipic18_instruction_computed_goto::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_goto *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_computed_goto::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_goto *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_computed_goto::actualTypeName (void) const {
  return "ipic18_instruction_computed_goto" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_computed_goto ("ipic18_instruction_computed_goto", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic18_instruction_computed_rcall'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic18_instruction_computed_rcall::
cPtr_ipic18_instruction_computed_rcall (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mEndOfInstructionLabel (argument_2),
mUsesRCALL (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic18_instruction_computed_rcall * GGS_ipic18_instruction_computed_rcall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic18_instruction_computed_rcall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic18_instruction_computed_rcall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic18_instruction_computed_rcall * ptr = dynamic_cast <const cPtr_ipic18_instruction_computed_rcall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mEndOfInstructionLabel.operator_isEqual (ptr->mEndOfInstructionLabel).boolValue ()
         && mUsesRCALL.operator_isEqual (ptr->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_rcall::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (798)).multiply_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (798)) ;
  if (((mUsesRCALL).operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (800)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_rcall::
method_displayIPICinstruction (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("COMPUTED RCALL ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString ("(uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.appendCString ("(uses CALL)") ;
  }
  {
    GGS_lstringlist::cEnumerator enumerator_23757 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_23757 = NULL ;
    while (((operand_23757 = enumerator_23757.nextObject ()))) {
      macroValidPointer (operand_23757) ;
      var_cas_ioListFileContents.appendCString (", ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_23757->mValue) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_rcall::
method_nextInstructionIsReachable (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_rcall::
method_enterReferencedLabel (C_Compiler & inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string ("_computed_goto_4")) ;
  {
    GGS_lstringlist::cEnumerator enumerator_24104 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_24104 = NULL ;
    while (((operand_24104 = enumerator_24104.nextObject ()))) {
      macroValidPointer (operand_24104) ;
      var_cas_ioReferencedLabelSet._addAssign_operation (operand_24104->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (825))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic18_instruction_computed_rcall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic18_instruction_computed_rcall:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfInstructionLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_rcall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic18_instruction_computed_rcall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic18_instruction_computed_rcall (& typeid (cPtr_ipic18_instruction_computed_rcall), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic18_instruction_computed_rcall::galgasRTTI (void) const {
  return & gClassInfoFor__ipic18_instruction_computed_rcall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic18_instruction_computed_rcall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic18_instruction_computed_rcall (mInstructionLocation, mTargetLabels, mEndOfInstructionLabel, mUsesRCALL COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic18_instruction_computed_rcall'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_rcall::
GGS_ipic18_instruction_computed_rcall (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_rcall::
GGS_ipic18_instruction_computed_rcall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic18_instruction_computed_rcall GGS_ipic18_instruction_computed_rcall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_rcall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic18_instruction_computed_rcall *> (inPointer) != NULL)
      : (typeid (cPtr_ipic18_instruction_computed_rcall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic18_instruction_computed_rcall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic18_instruction_computed_rcall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic18_instruction_computed_rcall GGS_ipic18_instruction_computed_rcall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic18_instruction_computed_rcall result ;
  macroMyNew (result.mPointer, cPtr_ipic18_instruction_computed_rcall (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_ipic18_instruction_computed_rcall::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_rcall *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic18_instruction_computed_rcall::
reader_mEndOfInstructionLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_rcall *) mPointer)->mEndOfInstructionLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic18_instruction_computed_rcall::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic18_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic18_instruction_computed_rcall *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic18_instruction_computed_rcall::actualTypeName (void) const {
  return "ipic18_instruction_computed_rcall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic18_instruction_computed_rcall ("ipic18_instruction_computed_rcall", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_jump_test_register'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_jump_test_register::
cPtr_ipic_jump_test_register (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mBranchIfZero (argument_3),
mUsesBra (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_jump_test_register * GGS_ipic_jump_test_register::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_jump_test_register *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_jump_test_register::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_jump_test_register * ptr = dynamic_cast <const cPtr_ipic_jump_test_register *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mBranchIfZero.operator_isEqual (ptr->mBranchIfZero).boolValue ()
         && mUsesBra.operator_isEqual (ptr->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (2U) ;
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (842)) ;
  }
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (845)) ;
  }else{
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (847)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("JUMP ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (853))) ;
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (" Z") ;
  }else{
    var_cas_ioListFileContents.appendCString (" NZ") ;
  }
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_enterReferencedLabel (C_Compiler & /* inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_jump_test_register:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_jump_test_register::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_jump_test_register::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_jump_test_register (& typeid (cPtr_ipic_jump_test_register), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_jump_test_register::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_jump_test_register ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_jump_test_register::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_jump_test_register (mInstructionLocation, mRegisterDescription, mTargetLabel, mBranchIfZero, mUsesBra COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_jump_test_register'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register::
GGS_ipic_jump_test_register (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register::
GGS_ipic_jump_test_register (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_jump_test_register GGS_ipic_jump_test_register::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_jump_test_register result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_jump_test_register *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_jump_test_register) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_jump_test_register (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_jump_test_register),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register GGS_ipic_jump_test_register::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_jump_test_register result ;
  macroMyNew (result.mPointer, cPtr_ipic_jump_test_register (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_jump_test_register::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_jump_test_register::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_jump_test_register::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_jump_test_register::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_jump_test_register::actualTypeName (void) const {
  return "ipic_jump_test_register" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_jump_test_register ("ipic_jump_test_register", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic_incDecRegisterInCondition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_incDecRegisterInCondition::
cPtr_ipic_incDecRegisterInCondition (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_bool& argument_5,
                                const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mIncrement (argument_3),
m_W_isDestination (argument_4),
mBranchIfZero (argument_5),
mUsesBra (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_incDecRegisterInCondition * GGS_ipic_incDecRegisterInCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_incDecRegisterInCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_incDecRegisterInCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_incDecRegisterInCondition * ptr = dynamic_cast <const cPtr_ipic_incDecRegisterInCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mIncrement.operator_isEqual (ptr->mIncrement).boolValue ()
         && m_W_isDestination.operator_isEqual (ptr->m_W_isDestination).boolValue ()
         && mBranchIfZero.operator_isEqual (ptr->mBranchIfZero).boolValue ()
         && mUsesBra.operator_isEqual (ptr->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_instructionLength (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = GGS_uint (4U) ;
  }else{
    var_cas_outLength = GGS_uint (6U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("JUMP ") ;
  if ((mIncrement).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString ("INCF ") ;
  }else{
    var_cas_ioListFileContents.appendCString ("DECF ") ;
  }
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (894))) ;
  if ((m_W_isDestination).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString (", W ") ;
  }
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.appendCString ("Z") ;
  }else{
    var_cas_ioListFileContents.appendCString ("NZ") ;
  }
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_enterReferencedLabel (C_Compiler & /* inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_incDecRegisterInCondition:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIncrement.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_incDecRegisterInCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_incDecRegisterInCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_incDecRegisterInCondition (& typeid (cPtr_ipic_incDecRegisterInCondition), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_incDecRegisterInCondition::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_incDecRegisterInCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_incDecRegisterInCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_incDecRegisterInCondition (mInstructionLocation, mRegisterDescription, mTargetLabel, mIncrement, m_W_isDestination, mBranchIfZero, mUsesBra COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic_incDecRegisterInCondition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition::
GGS_ipic_incDecRegisterInCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition::
GGS_ipic_incDecRegisterInCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_incDecRegisterInCondition GGS_ipic_incDecRegisterInCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_incDecRegisterInCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_incDecRegisterInCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_incDecRegisterInCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_incDecRegisterInCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition GGS_ipic_incDecRegisterInCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_bool& argument_4,
                 const GGS_bool& argument_5,
                 const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_incDecRegisterInCondition result ;
  macroMyNew (result.mPointer, cPtr_ipic_incDecRegisterInCondition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_incDecRegisterInCondition::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_incDecRegisterInCondition::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mIncrement (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mIncrement ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_incDecRegisterInCondition::actualTypeName (void) const {
  return "ipic_incDecRegisterInCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_incDecRegisterInCondition ("ipic_incDecRegisterInCondition", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic_registerComparisonCondition'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_registerComparisonCondition::
cPtr_ipic_registerComparisonCondition (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_registerComparison& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mComparison (argument_3),
mUsesBra (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_registerComparisonCondition * GGS_ipic_registerComparisonCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_registerComparisonCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_registerComparisonCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_registerComparisonCondition * ptr = dynamic_cast <const cPtr_ipic_registerComparisonCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRegisterDescription.operator_isEqual (ptr->mRegisterDescription).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mComparison.operator_isEqual (ptr->mComparison).boolValue ()
         && mUsesBra.operator_isEqual (ptr->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_usesIntermediateBRA (C_Compiler & /* inLexique */,
                                GGS_bool& var_cas_outUses COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mComparison.enumValue ()) {
  case GGS_registerComparison::enum_notEqual:
    {
    var_cas_outUses = GGS_bool (false) ;
    }
    break ;
  case GGS_registerComparison::enum_equal:
    {
    var_cas_outUses = GGS_bool (true) ;
    }
    break ;
  case GGS_registerComparison::enum_greaterOrEqual:
    {
    var_cas_outUses = GGS_bool (false) ;
    }
    break ;
  case GGS_registerComparison::enum_greater:
    {
    var_cas_outUses = GGS_bool (true) ;
    }
    break ;
  case GGS_registerComparison::enum_lowerOrEqual:
    {
    var_cas_outUses = GGS_bool (false) ;
    }
    break ;
  case GGS_registerComparison::enum_lower:
    {
    var_cas_outUses = GGS_bool (true) ;
    }
    break ;
  case GGS_registerComparison::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_instructionLength (C_Compiler & inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool var_cas_usesIntermediateBRA ;
  method_usesIntermediateBRA (inLexique, var_cas_usesIntermediateBRA COMMA_SOURCE_FILE_AT_LINE (932)) ;
  if ((var_cas_usesIntermediateBRA).isBuiltAndTrue ()) {
    var_cas_outLength = GGS_uint (4U) ;
  }else{
    var_cas_outLength = GGS_uint (2U) ;
  }
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (939)) ;
  }else{
    var_cas_outLength = var_cas_outLength.add_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (941)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_displayIPICinstruction (C_Compiler & inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.appendCString ("JUMP ") ;
  var_cas_ioListFileContents.dotAssign_operation (mRegisterDescription.reader_mAssemblyString (inLexique COMMA_SOURCE_FILE_AT_LINE (948))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mComparison.reader_mnemonic (inLexique COMMA_SOURCE_FILE_AT_LINE (949))) ;
  var_cas_ioListFileContents.appendCString (" ") ;
  var_cas_ioListFileContents.dotAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_enterReferencedLabel (C_Compiler & /* inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_registerComparisonCondition:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mComparison.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_registerComparisonCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_registerComparisonCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_registerComparisonCondition (& typeid (cPtr_ipic_registerComparisonCondition), & typeid (cPtr_ipic_actualInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_registerComparisonCondition::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_registerComparisonCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ipic_registerComparisonCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ipic_registerComparisonCondition (mInstructionLocation, mRegisterDescription, mTargetLabel, mComparison, mUsesBra COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic_registerComparisonCondition'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition::
GGS_ipic_registerComparisonCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition::
GGS_ipic_registerComparisonCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ipic_registerComparisonCondition GGS_ipic_registerComparisonCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_registerComparisonCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_registerComparisonCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ipic_registerComparisonCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_registerComparisonCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition GGS_ipic_registerComparisonCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_registerComparison& argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_registerComparisonCondition result ;
  macroMyNew (result.mPointer, cPtr_ipic_registerComparisonCondition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_registerComparisonCondition::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_registerComparisonCondition::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparison GGS_ipic_registerComparisonCondition::
reader_mComparison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerComparison  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mComparison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerComparisonCondition::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_registerComparisonCondition::actualTypeName (void) const {
  return "ipic_registerComparisonCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_registerComparisonCondition ("ipic_registerComparisonCondition", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_ipic18_metamodel (void) {
 enterCategoryMethod__registerExpression__resolveAccess (category_method__registerExpression__resolveAccess, gClassInfoFor__registerExpression.slotID ()) ;
 enterCategoryMethod__registerExpression__resolveAccessWithoutCheckingBank (category_method__registerExpression__resolveAccessWithoutCheckingBank, gClassInfoFor__registerExpression.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_ipic18_metamodel (prologueRoutineFor_ipic18_metamodel,
                                   NULL) ;

//---------------------------------------------------------------------------*

