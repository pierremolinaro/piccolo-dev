//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'ipic_metamodel.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      july 30th, 2008, at 15h55'10"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "ipic_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "ipic_metamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ipic_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction::
cPtr_ipic_instruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction * GGS_ipic_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_setCurrentAddress (C_Compiler & _inLexique,
                                GGS_uint & var_cas_ioCurrentAddress COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint  var_cas_length ;
  method_instructionLength (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (13)) ;
  var_cas_ioCurrentAddress = var_cas_ioCurrentAddress._add_operation (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (14)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_isLABELorORG (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_isNULL (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsNULL COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsNULL = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_isSkippingInstruction (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsSkipping = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
method_enterReferencedLabel (C_Compiler & /* _inLexique */,
                                GGS_stringset & /* var_cas_ioReferencedLabelSet */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction (& typeid (cPtr_ipic_instruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ipic_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction::
GGS_ipic_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction::
GGS_ipic_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction GGS_ipic_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction::actualTypeName (void) const {
  return "ipic_instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_ipic_instruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__ipic_instruction ("ipic_instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@ipic_instructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ipic_instructionList::
elementOf_GGS_ipic_instructionList (const GGS_ipic_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ipic_instructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ipic_instructionList * _p = dynamic_cast <const elementOf_GGS_ipic_instructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ipic_instructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@ipic_instructionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
_internalAppendValues (const GGS_ipic_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
_internalPrependValues (const GGS_ipic_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
_addAssign_operation (const GGS_ipic_instruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ipic_instructionList GGS_ipic_instructionList::
_operator_concat (const GGS_ipic_instructionList & inOperand) const {
  GGS_ipic_instructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
_dotAssign_operation (const GGS_ipic_instructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ipic_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ipic_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_ipic_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ipic_instructionList  GGS_ipic_instructionList::
constructor_emptyList (void) {
  GGS_ipic_instructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instructionList  GGS_ipic_instructionList::
constructor_listWithValue (const GGS_ipic_instruction & argument_0) {
  GGS_ipic_instructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
internalSubListWithRange (GGS_ipic_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ipic_instructionList GGS_ipic_instructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ipic_instructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instructionList GGS_ipic_instructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ipic_instructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_instructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ipic_instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
method_first (C_Compiler & _inLexique,
              GGS_ipic_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
method_last (C_Compiler & _inLexique,
             GGS_ipic_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_ipic_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_ipic_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction  GGS_ipic_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_ipic_instruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ipic_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_ipic_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ipic_instruction  & GGS_ipic_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_NULL'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_NULL::
cPtr_ipic_NULL (LOCATION_ARGS)
:cPtr_ipic_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_NULL * GGS_ipic_NULL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_NULL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_NULL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_NULL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("-") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
method_isNULL (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsNULL COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsNULL = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_NULL::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ipic_NULL:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_NULL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_NULL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_NULL (& typeid (cPtr_ipic_NULL), & typeid (cPtr_ipic_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_NULL::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_NULL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_NULL'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_NULL::
GGS_ipic_NULL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_NULL::
GGS_ipic_NULL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_NULL GGS_ipic_NULL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_NULL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_NULL *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_NULL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_NULL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_NULL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_ipic_NULL * gSingleton_ipic_NULL = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_ipic_NULL (void) {
  macroDetachPointer (gSingleton_ipic_NULL, cPtr_ipic_NULL) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_NULL GGS_ipic_NULL::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_NULL result ;
  if (NULL == gSingleton_ipic_NULL) {
    macroMyNew (gSingleton_ipic_NULL, cPtr_ipic_NULL (THERE)) ;
    registerReleaseRoutine (cleanUp_ipic_NULL) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_ipic_NULL) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_NULL::actualTypeName (void) const {
  return "ipic_NULL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_NULL ("ipic_NULL", gClassInfoFor__ipic_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ipic_pseudo_ORG'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_pseudo_ORG::
cPtr_ipic_pseudo_ORG (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_instruction (THERE),
mOrigin (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_pseudo_ORG * GGS_ipic_pseudo_ORG::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_pseudo_ORG *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_pseudo_ORG::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_pseudo_ORG * _p = dynamic_cast <const cPtr_ipic_pseudo_ORG *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOrigin._operator_isEqual (_p->mOrigin).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_setCurrentAddress (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_ioCurrentAddress COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioCurrentAddress = mOrigin ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("ORG ") ;
  var_cas_ioListFileContents._dotAssign_operation (mOrigin.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (75))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
method_isLABELorORG (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_ORG::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_pseudo_ORG:"
           << mOrigin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_ORG::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_ORG::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_pseudo_ORG (& typeid (cPtr_ipic_pseudo_ORG), & typeid (cPtr_ipic_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_pseudo_ORG::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_pseudo_ORG ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ipic_pseudo_ORG'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG::
GGS_ipic_pseudo_ORG (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG::
GGS_ipic_pseudo_ORG (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_pseudo_ORG GGS_ipic_pseudo_ORG::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_ORG _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_pseudo_ORG *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_pseudo_ORG) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_pseudo_ORG (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_pseudo_ORG),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_ORG GGS_ipic_pseudo_ORG::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_ORG result ;
  macroMyNew (result.mPointer, cPtr_ipic_pseudo_ORG (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic_pseudo_ORG::
reader_mOrigin (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_pseudo_ORG *) mPointer)->mOrigin ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_pseudo_ORG::actualTypeName (void) const {
  return "ipic_pseudo_ORG" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_pseudo_ORG ("ipic_pseudo_ORG", gClassInfoFor__ipic_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ipic_pseudo_LABEL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_pseudo_LABEL::
cPtr_ipic_pseudo_LABEL (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_instruction (THERE),
mLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_pseudo_LABEL * GGS_ipic_pseudo_LABEL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_pseudo_LABEL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_pseudo_LABEL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_pseudo_LABEL * _p = dynamic_cast <const cPtr_ipic_pseudo_LABEL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLabel._operator_isEqual (_p->mLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("LABEL ") ;
  var_cas_ioListFileContents._dotAssign_operation (mLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
method_isLABELorORG (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsLABELorORG COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsLABELorORG = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_pseudo_LABEL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_pseudo_LABEL:"
           << mLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_LABEL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_pseudo_LABEL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_pseudo_LABEL (& typeid (cPtr_ipic_pseudo_LABEL), & typeid (cPtr_ipic_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_pseudo_LABEL::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_pseudo_LABEL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ipic_pseudo_LABEL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL::
GGS_ipic_pseudo_LABEL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL::
GGS_ipic_pseudo_LABEL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_pseudo_LABEL GGS_ipic_pseudo_LABEL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_LABEL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_pseudo_LABEL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_pseudo_LABEL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_pseudo_LABEL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_pseudo_LABEL GGS_ipic_pseudo_LABEL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_pseudo_LABEL result ;
  macroMyNew (result.mPointer, cPtr_ipic_pseudo_LABEL (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_pseudo_LABEL::
reader_mLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_pseudo_LABEL *) mPointer)->mLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_pseudo_LABEL::actualTypeName (void) const {
  return "ipic_pseudo_LABEL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_pseudo_LABEL ("ipic_pseudo_LABEL", gClassInfoFor__ipic_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_actualInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_actualInstruction::
cPtr_ipic_actualInstruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_instruction (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_actualInstruction * GGS_ipic_actualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_actualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_actualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ipic_actualInstruction::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 2U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_actualInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_actualInstruction:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_actualInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_actualInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_actualInstruction (& typeid (cPtr_ipic_actualInstruction), & typeid (cPtr_ipic_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_actualInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_actualInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_actualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_actualInstruction::
GGS_ipic_actualInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_actualInstruction::
GGS_ipic_actualInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_actualInstruction GGS_ipic_actualInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_actualInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_actualInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_actualInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_actualInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_actualInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ipic_actualInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_actualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_actualInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_actualInstruction::actualTypeName (void) const {
  return "ipic_actualInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_actualInstruction ("ipic_actualInstruction", gClassInfoFor__ipic_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of 'ipic_registerExpression' struct             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_registerExpression::GGS_ipic_registerExpression (void) :
mAssemblyString (),
mRegisterAddress (),
mNeedsBSR () {
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression::~GGS_ipic_registerExpression (void) {
}

//---------------------------------------------------------------------------*

void GGS_ipic_registerExpression::_drop (void) {
  mAssemblyString._drop () ;
  mRegisterAddress._drop () ;
  mNeedsBSR._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_ipic_registerExpression::_isBuilt (void) const {
  return mAssemblyString._isBuilt ()
    && mRegisterAddress._isBuilt ()
    && mNeedsBSR._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpression::
_operator_isEqual (const GGS_ipic_registerExpression & inOperand) const {
  return mAssemblyString._operator_isEqual (inOperand.mAssemblyString)
    ._operator_and (mRegisterAddress._operator_isEqual (inOperand.mRegisterAddress))
    ._operator_and (mNeedsBSR._operator_isEqual (inOperand.mNeedsBSR)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerExpression::
_operator_isNotEqual (const GGS_ipic_registerExpression & inOperand) const {
  return mAssemblyString._operator_isNotEqual (inOperand.mAssemblyString)
    ._operator_or (mRegisterAddress._operator_isNotEqual (inOperand.mRegisterAddress))
    ._operator_or (mNeedsBSR._operator_isNotEqual (inOperand.mNeedsBSR)) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_registerExpression::
constructor_new (const GGS_string& argument_0,
                 const GGS_uint & argument_1,
                 const GGS_bool& argument_2) {
  GGS_ipic_registerExpression result ;
  result.mAssemblyString = argument_0 ;
  result.mRegisterAddress = argument_1 ;
  result.mNeedsBSR = argument_2 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_registerExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @ipic_registerExpression" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAssemblyString " ;
    _s << mAssemblyString.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRegisterAddress " ;
    _s << mRegisterAddress.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsBSR " ;
    _s << mNeedsBSR.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_FDA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_FDA::
cPtr_ipic_instruction_FDA (const GGS_location & argument_0,
                                const GGS_instruction_FDA_base_code& argument_1,
                                const GGS_ipic_registerExpression& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mInstruction_FDA_base_code (argument_1),
mRegisterDescription (argument_2),
m_W_isDestination (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_FDA * GGS_ipic_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_FDA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_FDA * _p = dynamic_cast <const cPtr_ipic_instruction_FDA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction_FDA_base_code._operator_isEqual (_p->mInstruction_FDA_base_code).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FDA::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFDAinstructionBaseCode (_inLexique,  mInstruction_FDA_base_code,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (127)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FDA::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents._dotAssign_operation (mInstruction_FDA_base_code.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (133))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (133))) ;
  if ((m_W_isDestination).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (", W") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FDA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_FDA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction_FDA_base_code.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_FDA (& typeid (cPtr_ipic_instruction_FDA), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_FDA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_FDA'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_FDA::
GGS_ipic_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FDA::
GGS_ipic_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_FDA GGS_ipic_instruction_FDA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FDA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FDA GGS_ipic_instruction_FDA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instruction_FDA_base_code& argument_1,
                 const GGS_ipic_registerExpression& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FDA result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_FDA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA_base_code GGS_ipic_instruction_FDA::
reader_mInstruction_FDA_base_code (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction_FDA_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FDA *) mPointer)->mInstruction_FDA_base_code ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_FDA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FDA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_FDA::actualTypeName (void) const {
  return "ipic_instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_FDA ("ipic_instruction_FDA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getFAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFAinstructionBaseCode (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27136U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSEQ:
    {
    var_cas_outBaseCode = GGS_uint (true, 25088U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outBaseCode = GGS_uint (true, 25600U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outBaseCode = GGS_uint (true, 24576U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 28160U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 512U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27648U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outBaseCode = GGS_uint (true, 26624U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 26112U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "FAinstructionIsSkippingInstruction"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_FAinstructionIsSkippingInstruction (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_bool & var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_FAinstructionIsSkippingInstruction at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSEQ:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_FAinstructionIsSkippingInstruction\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_ipic_instruction_FA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_FA::
cPtr_ipic_instruction_FA (const GGS_location & argument_0,
                                const GGS_FA_instruction_base_code& argument_1,
                                const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFAinstruction (argument_1),
mRegisterDescription (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_FA * GGS_ipic_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_FA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_FA * _p = dynamic_cast <const cPtr_ipic_instruction_FA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFAinstruction._operator_isEqual (_p->mFAinstruction).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FA::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFAinstructionBaseCode (_inLexique,  mFAinstruction,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (184)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FA::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents._dotAssign_operation (mFAinstruction.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (190))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (190))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FA::
method_isSkippingInstruction (C_Compiler & _inLexique,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_FAinstructionIsSkippingInstruction (_inLexique,  mFAinstruction,  var_cas_outIsSkipping COMMA_SOURCE_FILE_AT_LINE (194)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_FA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFAinstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_FA (& typeid (cPtr_ipic_instruction_FA), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_FA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_ipic_instruction_FA'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_FA::
GGS_ipic_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FA::
GGS_ipic_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_FA GGS_ipic_instruction_FA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FA GGS_ipic_instruction_FA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_FA_instruction_base_code& argument_1,
                 const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FA result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_FA (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_FA_instruction_base_code GGS_ipic_instruction_FA::
reader_mFAinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_FA_instruction_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FA *) mPointer)->mFAinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_FA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_FA::actualTypeName (void) const {
  return "ipic_instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_FA ("ipic_instruction_FA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_MOVFF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_MOVFF::
cPtr_ipic_instruction_MOVFF (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mSourceRegisterDescription (argument_1),
mDestinationRegisterDescription (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_MOVFF * GGS_ipic_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_MOVFF * _p = dynamic_cast <const cPtr_ipic_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mSourceRegisterDescription._operator_isEqual (_p->mSourceRegisterDescription).boolValue ()
         && mDestinationRegisterDescription._operator_isEqual (_p->mDestinationRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVFF::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVFF::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("MOVFF ") ;
  var_cas_ioListFileContents._dotAssign_operation (mSourceRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (212))) ;
  var_cas_ioListFileContents.writeString (", ") ;
  var_cas_ioListFileContents._dotAssign_operation (mDestinationRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (212))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVFF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_MOVFF:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_MOVFF (& typeid (cPtr_ipic_instruction_MOVFF), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_MOVFF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_MOVFF'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVFF::
GGS_ipic_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVFF::
GGS_ipic_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_MOVFF GGS_ipic_instruction_MOVFF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVFF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVFF GGS_ipic_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_MOVFF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_MOVFF::
reader_mSourceRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_MOVFF *) mPointer)->mSourceRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_MOVFF::
reader_mDestinationRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_MOVFF *) mPointer)->mDestinationRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_MOVFF::actualTypeName (void) const {
  return "ipic_instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_MOVFF ("ipic_instruction_MOVFF", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getBitOrientedOpBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBitOrientedOpBaseCode (C_Compiler &,
                                const GGS_bit_oriented_op  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBitOrientedOpBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_bit_oriented_op::enum_BCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 36864U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BSF:
    {
    var_cas_outBaseCode = GGS_uint (true, 32768U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSC:
    {
    var_cas_outBaseCode = GGS_uint (true, 45056U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSS:
    {
    var_cas_outBaseCode = GGS_uint (true, 40960U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTG:
    {
    var_cas_outBaseCode = GGS_uint (true, 28672U) ;
    }
    break ;
  case GGS_bit_oriented_op::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBitOrientedOpBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_FBA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_FBA::
cPtr_ipic_instruction_FBA (const GGS_location & argument_0,
                                const GGS_bit_oriented_op& argument_1,
                                const GGS_ipic_registerExpression& argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mBitOrientedOp (argument_1),
mRegisterDescription (argument_2),
mBitNumber (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_FBA * GGS_ipic_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_FBA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_FBA * _p = dynamic_cast <const cPtr_ipic_instruction_FBA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mBitOrientedOp._operator_isEqual (_p->mBitOrientedOp).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FBA::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getBitOrientedOpBaseCode (_inLexique,  mBitOrientedOp,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (235)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FBA::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents._dotAssign_operation (mBitOrientedOp.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (241))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (241))) ;
  var_cas_ioListFileContents.writeString (", ") ;
  var_cas_ioListFileContents._dotAssign_operation (mBitNumber.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (241))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FBA::
method_isSkippingInstruction (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsSkipping COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mBitOrientedOp.enumValue ()) {
  case GGS_bit_oriented_op::enum_BCF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BSF:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSC:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSS:
    {
    var_cas_outIsSkipping = GGS_bool (true, true) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTG:
    {
    var_cas_outIsSkipping = GGS_bool (true, false) ;
    }
    break ;
  case GGS_bit_oriented_op::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_FBA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_FBA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitOrientedOp.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_FBA (& typeid (cPtr_ipic_instruction_FBA), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_FBA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_FBA'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_FBA::
GGS_ipic_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FBA::
GGS_ipic_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_FBA GGS_ipic_instruction_FBA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FBA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_FBA GGS_ipic_instruction_FBA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bit_oriented_op& argument_1,
                 const GGS_ipic_registerExpression& argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_FBA result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_FBA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bit_oriented_op GGS_ipic_instruction_FBA::
reader_mBitOrientedOp (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bit_oriented_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FBA *) mPointer)->mBitOrientedOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_FBA::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FBA *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ipic_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_FBA::actualTypeName (void) const {
  return "ipic_instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_FBA ("ipic_instruction_FBA", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'condionalBranchMode' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_condionalBranchMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_isEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_isNotEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_infOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_supOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_strictInf (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_strictSup (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_condionalBranchMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @condionalBranchMode" ;
  switch (mValue) {
  case enum_native:
    s << " native>" ;
    break ;
  case enum_usesBRA:
    s << " usesBRA>" ;
    break ;
  case enum_usesGOTO:
    s << " usesGOTO>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_ipic_instruction_conditionalBranch'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_conditionalBranch::
cPtr_ipic_instruction_conditionalBranch (const GGS_location & argument_0,
                                const GGS_condionalBranchMode& argument_1,
                                const GGS_conditional_branch& argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mBranchMode (argument_1),
mConditionalBranch (argument_2),
mTargetLabel (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_conditionalBranch * GGS_ipic_instruction_conditionalBranch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_conditionalBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_conditionalBranch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_conditionalBranch * _p = dynamic_cast <const cPtr_ipic_instruction_conditionalBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mBranchMode._operator_isEqual (_p->mBranchMode).boolValue ()
         && mConditionalBranch._operator_isEqual (_p->mConditionalBranch).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_conditionalBranch::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mBranchMode.enumValue ()) {
  case GGS_condionalBranchMode::enum_native:
    {
    var_cas_outLength = GGS_uint (true, 2U) ;
    }
    break ;
  case GGS_condionalBranchMode::enum_usesBRA:
    {
    var_cas_outLength = GGS_uint (true, 4U) ;
    }
    break ;
  case GGS_condionalBranchMode::enum_usesGOTO:
    {
    var_cas_outLength = GGS_uint (true, 6U) ;
    }
    break ;
  case GGS_condionalBranchMode::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_conditionalBranch::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("JUMP ") ;
  var_cas_ioListFileContents._dotAssign_operation (mConditionalBranch.reader_condition (_inLexique COMMA_SOURCE_FILE_AT_LINE (283))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
  switch (mBranchMode.enumValue ()) {
  case GGS_condionalBranchMode::enum_native:
    {
    var_cas_ioListFileContents.writeString (" (native)") ;
    }
    break ;
  case GGS_condionalBranchMode::enum_usesBRA:
    {
    var_cas_ioListFileContents.writeString (" (uses BRA)") ;
    }
    break ;
  case GGS_condionalBranchMode::enum_usesGOTO:
    {
    var_cas_ioListFileContents.writeString (" (uses GOTO)") ;
    }
    break ;
  case GGS_condionalBranchMode::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_conditionalBranch::
method_enterReferencedLabel (C_Compiler & _inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (292))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_conditionalBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_conditionalBranch:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchMode.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConditionalBranch.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_conditionalBranch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_conditionalBranch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_conditionalBranch (& typeid (cPtr_ipic_instruction_conditionalBranch), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_conditionalBranch::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_conditionalBranch ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_ipic_instruction_conditionalBranch'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_conditionalBranch::
GGS_ipic_instruction_conditionalBranch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_conditionalBranch::
GGS_ipic_instruction_conditionalBranch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_conditionalBranch GGS_ipic_instruction_conditionalBranch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_conditionalBranch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_conditionalBranch *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_conditionalBranch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_conditionalBranch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_conditionalBranch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_conditionalBranch GGS_ipic_instruction_conditionalBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_condionalBranchMode& argument_1,
                 const GGS_conditional_branch& argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_conditionalBranch result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_conditionalBranch (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_condionalBranchMode GGS_ipic_instruction_conditionalBranch::
reader_mBranchMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_condionalBranchMode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_conditionalBranch *) mPointer)->mBranchMode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_ipic_instruction_conditionalBranch::
reader_mConditionalBranch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_conditionalBranch *) mPointer)->mConditionalBranch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_instruction_conditionalBranch::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_conditionalBranch *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_conditionalBranch::actualTypeName (void) const {
  return "ipic_instruction_conditionalBranch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_conditionalBranch ("ipic_instruction_conditionalBranch", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'jumpInstructionKind' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_jumpInstructionKind::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_isEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_isNotEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_infOrEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_supOrEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_strictInf (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
_operator_strictSup (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_jumpInstructionKind::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @jumpInstructionKind" ;
  switch (mValue) {
  case enum_absolute:
    s << " absolute>" ;
    break ;
  case enum_ipicAbsolute:
    s << " ipicAbsolute>" ;
    break ;
  case enum_ipicRelative:
    s << " ipicRelative>" ;
    break ;
  case enum_relative:
    s << " relative>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_JUMP'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_JUMP::
cPtr_ipic_JUMP (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_JUMP * GGS_ipic_JUMP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_JUMP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_JUMP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_JUMP * _p = dynamic_cast <const cPtr_ipic_JUMP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue ()
         && mKind._operator_isEqual (_p->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_outLength = GGS_uint (true, 2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_outLength = GGS_uint (true, 4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_outLength = GGS_uint (true, 2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_outLength = GGS_uint (true, 4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_ioListFileContents.writeString ("JUMP (uses BRA) ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_ioListFileContents.writeString ("JUMP (uses GOTO) ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_ioListFileContents.writeString ("BRA ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_ioListFileContents.writeString ("GOTO ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
method_enterReferencedLabel (C_Compiler & _inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (337))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JUMP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_JUMP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_JUMP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_JUMP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_JUMP (& typeid (cPtr_ipic_JUMP), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_JUMP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_JUMP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_JUMP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_JUMP::
GGS_ipic_JUMP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JUMP::
GGS_ipic_JUMP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_JUMP GGS_ipic_JUMP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_JUMP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_JUMP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_JUMP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_JUMP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_JUMP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JUMP GGS_ipic_JUMP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_JUMP result ;
  macroMyNew (result.mPointer, cPtr_ipic_JUMP (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_JUMP::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JUMP *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_ipic_JUMP::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JUMP *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_JUMP::actualTypeName (void) const {
  return "ipic_JUMP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_JUMP ("ipic_JUMP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ipic_JSR'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_JSR::
cPtr_ipic_JSR (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_JSR * GGS_ipic_JSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_JSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_JSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_JSR * _p = dynamic_cast <const cPtr_ipic_JSR *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue ()
         && mKind._operator_isEqual (_p->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_outLength = GGS_uint (true, 2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_outLength = GGS_uint (true, 4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_outLength = GGS_uint (true, 2U) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_outLength = GGS_uint (true, 4U) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mKind.enumValue ()) {
  case GGS_jumpInstructionKind::enum_ipicRelative:
    {
    var_cas_ioListFileContents.writeString ("JSR (uses RCALL) ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_ipicAbsolute:
    {
    var_cas_ioListFileContents.writeString ("JSR (uses CALL) ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_relative:
    {
    var_cas_ioListFileContents.writeString ("RCALL ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::enum_absolute:
    {
    var_cas_ioListFileContents.writeString ("CALL ") ;
    var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
    }
    break ;
  case GGS_jumpInstructionKind::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
method_enterReferencedLabel (C_Compiler & _inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (368))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_JSR::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_JSR:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_JSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_JSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_JSR (& typeid (cPtr_ipic_JSR), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_JSR::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_JSR ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ipic_JSR'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_JSR::
GGS_ipic_JSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JSR::
GGS_ipic_JSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_JSR GGS_ipic_JSR::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_JSR _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_JSR *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_JSR) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_JSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_JSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_JSR GGS_ipic_JSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_JSR result ;
  macroMyNew (result.mPointer, cPtr_ipic_JSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ipic_JSR::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JSR *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_ipic_JSR::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_JSR *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_JSR::actualTypeName (void) const {
  return "ipic_JSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_JSR ("ipic_JSR", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_CLRWDT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_CLRWDT::
cPtr_ipic_instruction_CLRWDT (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_CLRWDT * GGS_ipic_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_CLRWDT * _p = dynamic_cast <const cPtr_ipic_instruction_CLRWDT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_CLRWDT::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("CLRWDT") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_CLRWDT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_CLRWDT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_CLRWDT (& typeid (cPtr_ipic_instruction_CLRWDT), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_CLRWDT'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_CLRWDT::
GGS_ipic_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_CLRWDT::
GGS_ipic_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_CLRWDT GGS_ipic_instruction_CLRWDT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_CLRWDT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_CLRWDT GGS_ipic_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_CLRWDT result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_CLRWDT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_CLRWDT::actualTypeName (void) const {
  return "ipic_instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_CLRWDT ("ipic_instruction_CLRWDT", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_DAW'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_DAW::
cPtr_ipic_instruction_DAW (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_DAW * GGS_ipic_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_DAW * _p = dynamic_cast <const cPtr_ipic_instruction_DAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_DAW::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("DAW") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_DAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_DAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_DAW (& typeid (cPtr_ipic_instruction_DAW), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_DAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_DAW'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_DAW::
GGS_ipic_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_DAW::
GGS_ipic_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_DAW GGS_ipic_instruction_DAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_DAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_DAW GGS_ipic_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_DAW result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_DAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_DAW::actualTypeName (void) const {
  return "ipic_instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_DAW ("ipic_instruction_DAW", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_NOP'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_NOP::
cPtr_ipic_instruction_NOP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_NOP * GGS_ipic_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_NOP * _p = dynamic_cast <const cPtr_ipic_instruction_NOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_NOP::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("NOP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_NOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_NOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_NOP (& typeid (cPtr_ipic_instruction_NOP), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_NOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_NOP'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_NOP::
GGS_ipic_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_NOP::
GGS_ipic_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_NOP GGS_ipic_instruction_NOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_NOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_NOP GGS_ipic_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_NOP result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_NOP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_NOP::actualTypeName (void) const {
  return "ipic_instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_NOP ("ipic_instruction_NOP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_POP'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_POP::
cPtr_ipic_instruction_POP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_POP * GGS_ipic_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_POP * _p = dynamic_cast <const cPtr_ipic_instruction_POP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_POP::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("POP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_POP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_POP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_POP (& typeid (cPtr_ipic_instruction_POP), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_POP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_POP'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_POP::
GGS_ipic_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_POP::
GGS_ipic_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_POP GGS_ipic_instruction_POP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_POP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_POP GGS_ipic_instruction_POP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_POP result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_POP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_POP::actualTypeName (void) const {
  return "ipic_instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_POP ("ipic_instruction_POP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_PUSH'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_PUSH::
cPtr_ipic_instruction_PUSH (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_PUSH * GGS_ipic_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_PUSH * _p = dynamic_cast <const cPtr_ipic_instruction_PUSH *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_PUSH::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("PUSH") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_PUSH::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_PUSH:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_PUSH (& typeid (cPtr_ipic_instruction_PUSH), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_PUSH ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_PUSH'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_PUSH::
GGS_ipic_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_PUSH::
GGS_ipic_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_PUSH GGS_ipic_instruction_PUSH::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_PUSH _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_PUSH GGS_ipic_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_PUSH result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_PUSH (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_PUSH::actualTypeName (void) const {
  return "ipic_instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_PUSH ("ipic_instruction_PUSH", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_RESET'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_RESET::
cPtr_ipic_instruction_RESET (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_RESET * GGS_ipic_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_RESET * _p = dynamic_cast <const cPtr_ipic_instruction_RESET *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RESET::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("RESET") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RESET::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_RESET:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_RESET (& typeid (cPtr_ipic_instruction_RESET), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_RESET ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_RESET'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_RESET::
GGS_ipic_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RESET::
GGS_ipic_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_RESET GGS_ipic_instruction_RESET::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RESET _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RESET GGS_ipic_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RESET result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_RESET (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_RESET::actualTypeName (void) const {
  return "ipic_instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_RESET ("ipic_instruction_RESET", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_RETURN'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_RETURN::
cPtr_ipic_instruction_RETURN (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_RETURN * GGS_ipic_instruction_RETURN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_RETURN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_RETURN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_RETURN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_RETURN * _p = dynamic_cast <const cPtr_ipic_instruction_RETURN *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETURN::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("RETURN") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETURN::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETURN::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_RETURN:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RETURN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RETURN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_RETURN (& typeid (cPtr_ipic_instruction_RETURN), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_RETURN::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_RETURN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_RETURN'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETURN::
GGS_ipic_instruction_RETURN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETURN::
GGS_ipic_instruction_RETURN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_RETURN GGS_ipic_instruction_RETURN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RETURN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_RETURN *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_RETURN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_RETURN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_RETURN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETURN GGS_ipic_instruction_RETURN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RETURN result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_RETURN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_RETURN::actualTypeName (void) const {
  return "ipic_instruction_RETURN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_RETURN ("ipic_instruction_RETURN", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_RETFIE'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_RETFIE::
cPtr_ipic_instruction_RETFIE (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFastReturn (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_RETFIE * GGS_ipic_instruction_RETFIE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_RETFIE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_RETFIE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_RETFIE * _p = dynamic_cast <const cPtr_ipic_instruction_RETFIE *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFastReturn._operator_isEqual (_p->mFastReturn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETFIE::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("RETFIE") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETFIE::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_RETFIE::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_RETFIE:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFastReturn.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RETFIE::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_RETFIE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_RETFIE (& typeid (cPtr_ipic_instruction_RETFIE), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_RETFIE::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_RETFIE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_RETFIE'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETFIE::
GGS_ipic_instruction_RETFIE (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETFIE::
GGS_ipic_instruction_RETFIE (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_RETFIE GGS_ipic_instruction_RETFIE::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RETFIE _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_RETFIE *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_RETFIE) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_RETFIE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_RETFIE),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_RETFIE GGS_ipic_instruction_RETFIE::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_RETFIE result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_RETFIE (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_instruction_RETFIE::
reader_mFastReturn (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_RETFIE *) mPointer)->mFastReturn ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_RETFIE::actualTypeName (void) const {
  return "ipic_instruction_RETFIE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_RETFIE ("ipic_instruction_RETFIE", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_SLEEP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_SLEEP::
cPtr_ipic_instruction_SLEEP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_SLEEP * GGS_ipic_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_SLEEP * _p = dynamic_cast <const cPtr_ipic_instruction_SLEEP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_SLEEP::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("SLEEP") ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_SLEEP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_SLEEP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_SLEEP (& typeid (cPtr_ipic_instruction_SLEEP), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_SLEEP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_SLEEP'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_SLEEP::
GGS_ipic_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_SLEEP::
GGS_ipic_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_SLEEP GGS_ipic_instruction_SLEEP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_SLEEP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_SLEEP GGS_ipic_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_SLEEP result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_SLEEP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_SLEEP::actualTypeName (void) const {
  return "ipic_instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_SLEEP ("ipic_instruction_SLEEP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "getLiteralInstructionBaseCode"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getLiteralInstructionBaseCode (C_Compiler &,
                                const GGS_literal_instruction_opcode  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getLiteralInstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_literal_instruction_opcode::enum_ADDLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3840U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_ANDLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2816U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_IORLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2304U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MOVLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3584U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MULLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3328U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_RETLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3072U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_SUBLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2048U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_XORLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2560U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getLiteralInstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic_instruction_literalOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_literalOperation::
cPtr_ipic_instruction_literalOperation (const GGS_location & argument_0,
                                const GGS_literal_instruction_opcode& argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mLiteralInstruction (argument_1),
mLiteralValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_literalOperation * GGS_ipic_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_literalOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_literalOperation * _p = dynamic_cast <const cPtr_ipic_instruction_literalOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralInstruction._operator_isEqual (_p->mLiteralInstruction).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_literalOperation::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getLiteralInstructionBaseCode (_inLexique,  mLiteralInstruction,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (492)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_literalOperation::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents._dotAssign_operation (mLiteralInstruction.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (498))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mLiteralValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (498)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (498))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_literalOperation::
method_nextInstructionIsReachable (C_Compiler & _inLexique,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = (mLiteralInstruction)._operator_isNotEqual (GGS_literal_instruction_opcode::constructor_RETLW (_inLexique COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_literalOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_literalOperation:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_literalOperation (& typeid (cPtr_ipic_instruction_literalOperation), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_literalOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic_instruction_literalOperation'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_literalOperation::
GGS_ipic_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_literalOperation::
GGS_ipic_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_literalOperation GGS_ipic_instruction_literalOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_literalOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_literalOperation GGS_ipic_instruction_literalOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_literal_instruction_opcode& argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_literalOperation result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_literalOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literal_instruction_opcode GGS_ipic_instruction_literalOperation::
reader_mLiteralInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_literal_instruction_opcode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_literalOperation *) mPointer)->mLiteralInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic_instruction_literalOperation::
reader_mLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_literalOperation *) mPointer)->mLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_literalOperation::actualTypeName (void) const {
  return "ipic_instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_literalOperation ("ipic_instruction_literalOperation", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_LFSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_LFSR::
cPtr_ipic_instruction_LFSR (const GGS_location & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mFSRindex (argument_1),
mRegisterDescription (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_LFSR * GGS_ipic_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_LFSR * _p = dynamic_cast <const cPtr_ipic_instruction_LFSR *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFSRindex._operator_isEqual (_p->mFSRindex).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_LFSR::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_LFSR::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("LFSR ") ;
  var_cas_ioListFileContents._dotAssign_operation (mFSRindex.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (519)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (519))) ;
  var_cas_ioListFileContents.writeString (", ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (519))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_LFSR::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_LFSR:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFSRindex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_LFSR (& typeid (cPtr_ipic_instruction_LFSR), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_LFSR ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_LFSR'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_LFSR::
GGS_ipic_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_LFSR::
GGS_ipic_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_LFSR GGS_ipic_instruction_LFSR::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_LFSR _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_LFSR GGS_ipic_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_ipic_registerExpression& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_LFSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_LFSR::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_LFSR *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_LFSR::actualTypeName (void) const {
  return "ipic_instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_LFSR ("ipic_instruction_LFSR", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_MOVLB'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_MOVLB::
cPtr_ipic_instruction_MOVLB (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mPageIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_MOVLB * GGS_ipic_instruction_MOVLB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_MOVLB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_MOVLB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_MOVLB * _p = dynamic_cast <const cPtr_ipic_instruction_MOVLB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mPageIndex._operator_isEqual (_p->mPageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVLB::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("MOVLB ") ;
  var_cas_ioListFileContents._dotAssign_operation (mPageIndex.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (530)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (530))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVLB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_MOVLB:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVLB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVLB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_MOVLB (& typeid (cPtr_ipic_instruction_MOVLB), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_MOVLB::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_MOVLB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_MOVLB'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVLB::
GGS_ipic_instruction_MOVLB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVLB::
GGS_ipic_instruction_MOVLB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_MOVLB GGS_ipic_instruction_MOVLB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVLB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_MOVLB *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_MOVLB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_MOVLB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_MOVLB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVLB GGS_ipic_instruction_MOVLB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVLB result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_MOVLB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic_instruction_MOVLB::
reader_mPageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_MOVLB *) mPointer)->mPageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_MOVLB::actualTypeName (void) const {
  return "ipic_instruction_MOVLB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_MOVLB ("ipic_instruction_MOVLB", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_MOVAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_MOVAW::
cPtr_ipic_instruction_MOVAW (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_MOVAW * GGS_ipic_instruction_MOVAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_MOVAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_MOVAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_MOVAW * _p = dynamic_cast <const cPtr_ipic_instruction_MOVAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVAW::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("MOVAW ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (541))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MOVAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_MOVAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MOVAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_MOVAW (& typeid (cPtr_ipic_instruction_MOVAW), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_MOVAW::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_MOVAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_MOVAW'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVAW::
GGS_ipic_instruction_MOVAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVAW::
GGS_ipic_instruction_MOVAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_MOVAW GGS_ipic_instruction_MOVAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_MOVAW *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_MOVAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_MOVAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_MOVAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MOVAW GGS_ipic_instruction_MOVAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MOVAW result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_MOVAW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_instruction_MOVAW::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_MOVAW *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_MOVAW::actualTypeName (void) const {
  return "ipic_instruction_MOVAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_MOVAW ("ipic_instruction_MOVAW", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_TBLRD'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_TBLRD::
cPtr_ipic_instruction_TBLRD (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_TBLRD * GGS_ipic_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_TBLRD * _p = dynamic_cast <const cPtr_ipic_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_TBLRD::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("TBLRD ") ;
  var_cas_ioListFileContents._dotAssign_operation (mOption.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (552))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_TBLRD::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_TBLRD:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_TBLRD (& typeid (cPtr_ipic_instruction_TBLRD), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_TBLRD ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_TBLRD'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLRD::
GGS_ipic_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLRD::
GGS_ipic_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_TBLRD GGS_ipic_instruction_TBLRD::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_TBLRD _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLRD GGS_ipic_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_TBLRD (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_ipic_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_TBLRD::actualTypeName (void) const {
  return "ipic_instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_TBLRD ("ipic_instruction_TBLRD", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_instruction_TBLWT'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_TBLWT::
cPtr_ipic_instruction_TBLWT (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_TBLWT * GGS_ipic_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_TBLWT * _p = dynamic_cast <const cPtr_ipic_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_TBLWT::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("TBLWT ") ;
  var_cas_ioListFileContents._dotAssign_operation (mOption.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (563))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_TBLWT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_TBLWT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_TBLWT (& typeid (cPtr_ipic_instruction_TBLWT), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_TBLWT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_instruction_TBLWT'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLWT::
GGS_ipic_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLWT::
GGS_ipic_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_TBLWT GGS_ipic_instruction_TBLWT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_TBLWT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_TBLWT GGS_ipic_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_TBLWT (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_ipic_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_TBLWT::actualTypeName (void) const {
  return "ipic_instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_TBLWT ("ipic_instruction_TBLWT", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_ipic_instruction_MNOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_MNOP::
cPtr_ipic_instruction_MNOP (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mOccurrenceFactor (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_MNOP * GGS_ipic_instruction_MNOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_MNOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_MNOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_MNOP * _p = dynamic_cast <const cPtr_ipic_instruction_MNOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOccurrenceFactor._operator_isEqual (_p->mOccurrenceFactor).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MNOP::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mOccurrenceFactor.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (573))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (573)) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MNOP::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("MNOP ") ;
  var_cas_ioListFileContents._dotAssign_operation (mOccurrenceFactor.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (578)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (578))) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_MNOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_MNOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOccurrenceFactor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MNOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_MNOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_MNOP (& typeid (cPtr_ipic_instruction_MNOP), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_MNOP::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_MNOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_ipic_instruction_MNOP'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_MNOP::
GGS_ipic_instruction_MNOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MNOP::
GGS_ipic_instruction_MNOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_MNOP GGS_ipic_instruction_MNOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MNOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_MNOP *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_MNOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_MNOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_MNOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_MNOP GGS_ipic_instruction_MNOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_MNOP result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_MNOP (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ipic_instruction_MNOP::
reader_mOccurrenceFactor (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_MNOP *) mPointer)->mOccurrenceFactor ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_MNOP::actualTypeName (void) const {
  return "ipic_instruction_MNOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_MNOP ("ipic_instruction_MNOP", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic_instruction_computed_retlw'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_computed_retlw::
cPtr_ipic_instruction_computed_retlw (const GGS_location & argument_0,
                                const GGS_luintlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mLiteralValues (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_computed_retlw * GGS_ipic_instruction_computed_retlw::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_computed_retlw *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_computed_retlw::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_computed_retlw * _p = dynamic_cast <const cPtr_ipic_instruction_computed_retlw *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValues._operator_isEqual (_p->mLiteralValues).boolValue ()
         && mUsesRCALL._operator_isEqual (_p->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_retlw::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mLiteralValues.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (590))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (590))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (590)) ;
  if (((mUsesRCALL)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (592)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_retlw::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("COMPUTED RETLW ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses CALL)") ;
  }
  {
    GGS_luintlist::cEnumerator enumerator_17441 (mLiteralValues, true) ;
    const GGS_luintlist::cElement * operand_17441 = NULL ;
    while (((operand_17441 = enumerator_17441.nextObject ()))) {
      macroValidPointer (operand_17441) ;
      var_cas_ioListFileContents.writeString (", ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_17441->mValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (605)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (605))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_retlw::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_retlw::
method_enterReferencedLabel (C_Compiler & /* _inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string (true, "_computed_goto_2")) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_retlw::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_computed_retlw:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValues.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_retlw::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_retlw::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_computed_retlw (& typeid (cPtr_ipic_instruction_computed_retlw), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_computed_retlw::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_computed_retlw ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic_instruction_computed_retlw'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_retlw::
GGS_ipic_instruction_computed_retlw (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_retlw::
GGS_ipic_instruction_computed_retlw (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_computed_retlw GGS_ipic_instruction_computed_retlw::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_retlw _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_computed_retlw *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_computed_retlw) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_computed_retlw (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_computed_retlw),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_retlw GGS_ipic_instruction_computed_retlw::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luintlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_retlw result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_computed_retlw (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintlist  GGS_ipic_instruction_computed_retlw::
reader_mLiteralValues (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luintlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_retlw *) mPointer)->mLiteralValues ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_instruction_computed_retlw::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_retlw *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_computed_retlw::actualTypeName (void) const {
  return "ipic_instruction_computed_retlw" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_computed_retlw ("ipic_instruction_computed_retlw", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_ipic_instruction_computed_bra'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_computed_bra::
cPtr_ipic_instruction_computed_bra (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_computed_bra * GGS_ipic_instruction_computed_bra::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_computed_bra *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_computed_bra::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_computed_bra * _p = dynamic_cast <const cPtr_ipic_instruction_computed_bra *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRCALL._operator_isEqual (_p->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_bra::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (626))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (626))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (626)) ;
  if (((mUsesRCALL)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (628)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_bra::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("COMPUTED BRA ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses CALL)") ;
  }
  {
    GGS_lstringlist::cEnumerator enumerator_18458 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_18458 = NULL ;
    while (((operand_18458 = enumerator_18458.nextObject ()))) {
      macroValidPointer (operand_18458) ;
      var_cas_ioListFileContents.writeString (", ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_18458->mValue) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_bra::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_bra::
method_enterReferencedLabel (C_Compiler & _inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string (true, "_computed_goto_2")) ;
  {
    GGS_lstringlist::cEnumerator enumerator_18805 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_18805 = NULL ;
    while (((operand_18805 = enumerator_18805.nextObject ()))) {
      macroValidPointer (operand_18805) ;
      var_cas_ioReferencedLabelSet._addAssign_operation (operand_18805->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (652))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_bra::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_computed_bra:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_bra::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_bra::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_computed_bra (& typeid (cPtr_ipic_instruction_computed_bra), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_computed_bra::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_computed_bra ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_ipic_instruction_computed_bra'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_bra::
GGS_ipic_instruction_computed_bra (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_bra::
GGS_ipic_instruction_computed_bra (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_computed_bra GGS_ipic_instruction_computed_bra::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_bra _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_computed_bra *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_computed_bra) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_computed_bra (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_computed_bra),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_bra GGS_ipic_instruction_computed_bra::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_bra result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_computed_bra (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_ipic_instruction_computed_bra::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_bra *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_instruction_computed_bra::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_bra *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_computed_bra::actualTypeName (void) const {
  return "ipic_instruction_computed_bra" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_computed_bra ("ipic_instruction_computed_bra", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic_instruction_computed_goto'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_instruction_computed_goto::
cPtr_ipic_instruction_computed_goto (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRCALL (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_instruction_computed_goto * GGS_ipic_instruction_computed_goto::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_instruction_computed_goto *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_instruction_computed_goto::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_instruction_computed_goto * _p = dynamic_cast <const cPtr_ipic_instruction_computed_goto *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRCALL._operator_isEqual (_p->mUsesRCALL).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_goto::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (665))._multiply_operation (_inLexique, GGS_uint (true, 4U) COMMA_SOURCE_FILE_AT_LINE (665))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (665)) ;
  if (((mUsesRCALL)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (667)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_goto::
method_displayIPICinstruction (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("COMPUTED GOTO ") ;
  if ((mUsesRCALL).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses RCALL)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses CALL)") ;
  }
  {
    GGS_lstringlist::cEnumerator enumerator_19553 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_19553 = NULL ;
    while (((operand_19553 = enumerator_19553.nextObject ()))) {
      macroValidPointer (operand_19553) ;
      var_cas_ioListFileContents.writeString (", ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_19553->mValue) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_goto::
method_nextInstructionIsReachable (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outIsReachable COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outIsReachable = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_goto::
method_enterReferencedLabel (C_Compiler & _inLexique,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (GGS_string (true, "_computed_goto_4")) ;
  {
    GGS_lstringlist::cEnumerator enumerator_19901 (mTargetLabels, true) ;
    const GGS_lstringlist::cElement * operand_19901 = NULL ;
    while (((operand_19901 = enumerator_19901.nextObject ()))) {
      macroValidPointer (operand_19901) ;
      var_cas_ioReferencedLabelSet._addAssign_operation (operand_19901->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (692))) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_instruction_computed_goto::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_instruction_computed_goto:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRCALL.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_goto::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_instruction_computed_goto::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_instruction_computed_goto (& typeid (cPtr_ipic_instruction_computed_goto), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_instruction_computed_goto::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_instruction_computed_goto ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic_instruction_computed_goto'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_goto::
GGS_ipic_instruction_computed_goto (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_goto::
GGS_ipic_instruction_computed_goto (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_instruction_computed_goto GGS_ipic_instruction_computed_goto::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_goto _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_instruction_computed_goto *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_instruction_computed_goto) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_instruction_computed_goto (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_instruction_computed_goto),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_instruction_computed_goto GGS_ipic_instruction_computed_goto::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_instruction_computed_goto result ;
  macroMyNew (result.mPointer, cPtr_ipic_instruction_computed_goto (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_ipic_instruction_computed_goto::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_goto *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_instruction_computed_goto::
reader_mUsesRCALL (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_instruction_computed_goto *) mPointer)->mUsesRCALL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_instruction_computed_goto::actualTypeName (void) const {
  return "ipic_instruction_computed_goto" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_instruction_computed_goto ("ipic_instruction_computed_goto", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_ipic_jump_test_register'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_jump_test_register::
cPtr_ipic_jump_test_register (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mBranchIfZero (argument_3),
mUsesBra (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_jump_test_register * GGS_ipic_jump_test_register::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_jump_test_register *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_jump_test_register::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_jump_test_register * _p = dynamic_cast <const cPtr_ipic_jump_test_register *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue ()
         && mBranchIfZero._operator_isEqual (_p->mBranchIfZero).boolValue ()
         && mUsesBra._operator_isEqual (_p->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 2U) ;
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (709)) ;
  }
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (712)) ;
  }else{
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 4U) COMMA_SOURCE_FILE_AT_LINE (714)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("JUMP ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (720))) ;
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString ("Z") ;
  }else{
    var_cas_ioListFileContents.writeString ("NZ") ;
  }
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses BRA)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses GOTO)") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
method_enterReferencedLabel (C_Compiler & /* _inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_jump_test_register::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_jump_test_register:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_jump_test_register::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_jump_test_register::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_jump_test_register (& typeid (cPtr_ipic_jump_test_register), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_jump_test_register::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_jump_test_register ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_ipic_jump_test_register'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register::
GGS_ipic_jump_test_register (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register::
GGS_ipic_jump_test_register (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_jump_test_register GGS_ipic_jump_test_register::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_jump_test_register _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_jump_test_register *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_jump_test_register) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_jump_test_register (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_jump_test_register),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_jump_test_register GGS_ipic_jump_test_register::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_jump_test_register result ;
  macroMyNew (result.mPointer, cPtr_ipic_jump_test_register (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_jump_test_register::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_jump_test_register::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_jump_test_register::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_jump_test_register::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_jump_test_register *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_jump_test_register *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_jump_test_register::actualTypeName (void) const {
  return "ipic_jump_test_register" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_jump_test_register ("ipic_jump_test_register", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_ipic_incDecRegisterInCondition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_incDecRegisterInCondition::
cPtr_ipic_incDecRegisterInCondition (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_bool& argument_5,
                                const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mIncrement (argument_3),
m_W_isDestination (argument_4),
mBranchIfZero (argument_5),
mUsesBra (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_incDecRegisterInCondition * GGS_ipic_incDecRegisterInCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_incDecRegisterInCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_incDecRegisterInCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_incDecRegisterInCondition * _p = dynamic_cast <const cPtr_ipic_incDecRegisterInCondition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue ()
         && mIncrement._operator_isEqual (_p->mIncrement).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue ()
         && mBranchIfZero._operator_isEqual (_p->mBranchIfZero).boolValue ()
         && mUsesBra._operator_isEqual (_p->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = GGS_uint (true, 4U) ;
  }else{
    var_cas_outLength = GGS_uint (true, 6U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("JUMP ") ;
  if ((mIncrement).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString ("INCF ") ;
  }else{
    var_cas_ioListFileContents.writeString ("DECF ") ;
  }
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (766))) ;
  if ((m_W_isDestination).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (", W ") ;
  }
  if ((mBranchIfZero).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString ("Z") ;
  }else{
    var_cas_ioListFileContents.writeString ("NZ") ;
  }
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses BRA)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses GOTO)") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
method_enterReferencedLabel (C_Compiler & /* _inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_incDecRegisterInCondition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_incDecRegisterInCondition:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIncrement.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_incDecRegisterInCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_incDecRegisterInCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_incDecRegisterInCondition (& typeid (cPtr_ipic_incDecRegisterInCondition), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_incDecRegisterInCondition::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_incDecRegisterInCondition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_ipic_incDecRegisterInCondition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition::
GGS_ipic_incDecRegisterInCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition::
GGS_ipic_incDecRegisterInCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_incDecRegisterInCondition GGS_ipic_incDecRegisterInCondition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_incDecRegisterInCondition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_incDecRegisterInCondition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_incDecRegisterInCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_incDecRegisterInCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_incDecRegisterInCondition GGS_ipic_incDecRegisterInCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_bool& argument_4,
                 const GGS_bool& argument_5,
                 const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_incDecRegisterInCondition result ;
  macroMyNew (result.mPointer, cPtr_ipic_incDecRegisterInCondition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_incDecRegisterInCondition::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_incDecRegisterInCondition::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mIncrement (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mIncrement ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_incDecRegisterInCondition::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_incDecRegisterInCondition *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_incDecRegisterInCondition::actualTypeName (void) const {
  return "ipic_incDecRegisterInCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_incDecRegisterInCondition ("ipic_incDecRegisterInCondition", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_ipic_registerComparisonCondition'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ipic_registerComparisonCondition::
cPtr_ipic_registerComparisonCondition (const GGS_location & argument_0,
                                const GGS_ipic_registerExpression& argument_1,
                                const GGS_string& argument_2,
                                const GGS_registerComparison& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ipic_actualInstruction (argument_0 COMMA_THERE),
mRegisterDescription (argument_1),
mTargetLabel (argument_2),
mComparison (argument_3),
mUsesBra (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ipic_registerComparisonCondition * GGS_ipic_registerComparisonCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ipic_registerComparisonCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ipic_registerComparisonCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ipic_registerComparisonCondition * _p = dynamic_cast <const cPtr_ipic_registerComparisonCondition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterDescription._operator_isEqual (_p->mRegisterDescription).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue ()
         && mComparison._operator_isEqual (_p->mComparison).boolValue ()
         && mUsesBra._operator_isEqual (_p->mUsesBra).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_usesIntermediateBRA (C_Compiler & /* _inLexique */,
                                GGS_bool& var_cas_outUses COMMA_UNUSED_LOCATION_ARGS) const {
  switch (mComparison.enumValue ()) {
  case GGS_registerComparison::enum_notEqual:
    {
    var_cas_outUses = GGS_bool (true, false) ;
    }
    break ;
  case GGS_registerComparison::enum_equal:
    {
    var_cas_outUses = GGS_bool (true, true) ;
    }
    break ;
  case GGS_registerComparison::enum_greaterOrEqual:
    {
    var_cas_outUses = GGS_bool (true, false) ;
    }
    break ;
  case GGS_registerComparison::enum_greater:
    {
    var_cas_outUses = GGS_bool (true, true) ;
    }
    break ;
  case GGS_registerComparison::enum_lowerOrEqual:
    {
    var_cas_outUses = GGS_bool (true, false) ;
    }
    break ;
  case GGS_registerComparison::enum_lower:
    {
    var_cas_outUses = GGS_bool (true, true) ;
    }
    break ;
  case GGS_registerComparison::kNotBuilt:
    break ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool var_cas_usesIntermediateBRA ;
  method_usesIntermediateBRA (_inLexique, var_cas_usesIntermediateBRA COMMA_SOURCE_FILE_AT_LINE (809)) ;
  if ((var_cas_usesIntermediateBRA).isBuiltAndTrue ()) {
    var_cas_outLength = GGS_uint (true, 4U) ;
  }else{
    var_cas_outLength = GGS_uint (true, 2U) ;
  }
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (816)) ;
  }else{
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 4U) COMMA_SOURCE_FILE_AT_LINE (818)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_displayIPICinstruction (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioListFileContents COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioListFileContents.writeString ("JUMP ") ;
  var_cas_ioListFileContents._dotAssign_operation (mRegisterDescription.reader_mAssemblyString (_inLexique COMMA_SOURCE_FILE_AT_LINE (825))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mComparison.reader_mnemonic (_inLexique COMMA_SOURCE_FILE_AT_LINE (826))) ;
  var_cas_ioListFileContents.writeString (" ") ;
  var_cas_ioListFileContents._dotAssign_operation (mTargetLabel) ;
  if ((mUsesBra).isBuiltAndTrue ()) {
    var_cas_ioListFileContents.writeString (" (uses BRA)") ;
  }else{
    var_cas_ioListFileContents.writeString (" (uses GOTO)") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
method_enterReferencedLabel (C_Compiler & /* _inLexique */,
                                GGS_stringset & var_cas_ioReferencedLabelSet COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_ioReferencedLabelSet._addAssign_operation (mTargetLabel) ;
}

//---------------------------------------------------------------------------*

void cPtr_ipic_registerComparisonCondition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ipic_registerComparisonCondition:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesBra.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ipic_registerComparisonCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ipic_registerComparisonCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ipic_registerComparisonCondition (& typeid (cPtr_ipic_registerComparisonCondition), & typeid (cPtr_ipic_actualInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ipic_registerComparisonCondition::galgasRTTI (void) const {
  return & gClassInfoFor__ipic_registerComparisonCondition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_ipic_registerComparisonCondition'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition::
GGS_ipic_registerComparisonCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition::
GGS_ipic_registerComparisonCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ipic_registerComparisonCondition GGS_ipic_registerComparisonCondition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ipic_registerComparisonCondition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (inPointer) != NULL)
      : (typeid (cPtr_ipic_registerComparisonCondition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ipic_registerComparisonCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ipic_registerComparisonCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerComparisonCondition GGS_ipic_registerComparisonCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ipic_registerExpression& argument_1,
                 const GGS_string& argument_2,
                 const GGS_registerComparison& argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ipic_registerComparisonCondition result ;
  macroMyNew (result.mPointer, cPtr_ipic_registerComparisonCondition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ipic_registerExpression GGS_ipic_registerComparisonCondition::
reader_mRegisterDescription (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ipic_registerExpression  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mRegisterDescription ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ipic_registerComparisonCondition::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparison GGS_ipic_registerComparisonCondition::
reader_mComparison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerComparison  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mComparison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ipic_registerComparisonCondition::
reader_mUsesBra (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ipic_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ipic_registerComparisonCondition *) mPointer)->mUsesBra ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ipic_registerComparisonCondition::actualTypeName (void) const {
  return "ipic_registerComparisonCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ipic_registerComparisonCondition ("ipic_registerComparisonCondition", gClassInfoFor__ipic_actualInstruction) ;

//---------------------------------------------------------------------------*

