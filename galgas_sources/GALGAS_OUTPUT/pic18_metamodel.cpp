//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'pic18_metamodel.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 13th, 2009, at 19h19'56"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "pic18_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "pic18_metamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_bootloaderReservedRAMmap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_bootloaderReservedRAMmap::e_bootloaderReservedRAMmap (void) :
mReservedSize () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@bootloaderReservedRAMmap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_bootloaderReservedRAMmap::
elementOf_GGS_bootloaderReservedRAMmap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_bootloaderReservedRAMmap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_bootloaderReservedRAMmap::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReservedSize.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_bootloaderReservedRAMmap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_bootloaderReservedRAMmap * ptr = dynamic_cast <const elementOf_GGS_bootloaderReservedRAMmap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mReservedSize.operator_isEqual (ptr->mInfo.mReservedSize)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_bootloaderReservedRAMmap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_bootloaderReservedRAMmap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_bootloaderReservedRAMmap * info = (e_bootloaderReservedRAMmap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_bootloaderReservedRAMmap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_bootloaderReservedRAMmap * info = (e_bootloaderReservedRAMmap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_bootloaderReservedRAMmap GGS_bootloaderReservedRAMmap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bootloaderReservedRAMmap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_bootloaderReservedRAMmap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bootloaderReservedRAMmap::
operator_isEqual (const GGS_bootloaderReservedRAMmap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bootloaderReservedRAMmap::
operator_isNotEqual (const GGS_bootloaderReservedRAMmap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_luint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_bootloaderReservedRAMmap info  ;
    info.mReservedSize = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mReservedSize ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_bootloaderReservedRAMmap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('z'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_bootloaderReservedRAMmap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('z'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_bootloaderReservedRAMmap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bootloaderReservedRAMmap GGS_bootloaderReservedRAMmap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_bootloaderReservedRAMmap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bootloaderReservedRAMmap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bootloaderReservedRAMmap GGS_bootloaderReservedRAMmap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bootloaderReservedRAMmap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bootloaderReservedRAMmap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @bootloaderReservedRAMmap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_bootloaderReservedRAMmap::cEnumerator::_mReservedSize (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReservedSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_piccolo_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_piccolo_instruction::
cPtr_piccolo_instruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_piccolo_instruction * GGS_piccolo_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_piccolo_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_piccolo_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_piccolo_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@piccolo_instruction:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_piccolo_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_piccolo_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_piccolo_instruction (& typeid (cPtr_piccolo_instruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_piccolo_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__piccolo_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_piccolo_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccolo_instruction::
GGS_piccolo_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction::
GGS_piccolo_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_piccolo_instruction GGS_piccolo_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_piccolo_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_piccolo_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_piccolo_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_piccolo_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_piccolo_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_piccolo_instruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_piccolo_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_piccolo_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_piccolo_instruction::actualTypeName (void) const {
  return "piccolo_instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_piccolo_instruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__piccolo_instruction ("piccolo_instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@instructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_instructionList::
elementOf_GGS_instructionList (const GGS_piccolo_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_instructionList * ptr = dynamic_cast <const elementOf_GGS_instructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instructionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@instructionList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalAppendValues (const GGS_piccolo_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalPrependValues (const GGS_piccolo_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_addAssign_operation (const GGS_piccolo_instruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
operator_concat (const GGS_instructionList & inOperand) const {
  GGS_instructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
dotAssign_operation (const GGS_instructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_piccolo_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_piccolo_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_emptyList (void) {
  GGS_instructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_listWithValue (const GGS_piccolo_instruction & argument_0) {
  GGS_instructionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
internalSubListWithRange (GGS_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instructionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_first (C_Compiler & inLexique,
              GGS_piccolo_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_last (C_Compiler & inLexique,
             GGS_piccolo_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_piccolo_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_piccolo_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction  GGS_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_piccolo_instruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_piccolo_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_piccolo_instruction  & GGS_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_nobanksel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_nobanksel::
cPtr_instruction_nobanksel (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_nobanksel * GGS_instruction_nobanksel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_nobanksel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_nobanksel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_nobanksel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_nobanksel * ptr = dynamic_cast <const cPtr_instruction_nobanksel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_nobanksel::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_nobanksel:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_nobanksel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_nobanksel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_nobanksel (& typeid (cPtr_instruction_nobanksel), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_nobanksel::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_nobanksel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_nobanksel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_nobanksel (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_nobanksel'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_nobanksel::
GGS_instruction_nobanksel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_nobanksel::
GGS_instruction_nobanksel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_nobanksel GGS_instruction_nobanksel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_nobanksel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_nobanksel *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_nobanksel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_nobanksel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_nobanksel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_nobanksel GGS_instruction_nobanksel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_nobanksel result ;
  macroMyNew (result.mPointer, cPtr_instruction_nobanksel (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_nobanksel::actualTypeName (void) const {
  return "instruction_nobanksel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_nobanksel ("instruction_nobanksel", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_banksel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_banksel::
cPtr_instruction_banksel (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mBankIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_banksel * GGS_instruction_banksel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_banksel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_banksel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_banksel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_banksel * ptr = dynamic_cast <const cPtr_instruction_banksel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBankIndex.operator_isEqual (ptr->mBankIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_banksel::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_banksel:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBankIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_banksel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_banksel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_banksel (& typeid (cPtr_instruction_banksel), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_banksel::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_banksel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_banksel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_banksel (mInstructionLocation, mBankIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_banksel'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_banksel::
GGS_instruction_banksel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_banksel::
GGS_instruction_banksel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_banksel GGS_instruction_banksel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_banksel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_banksel *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_banksel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_banksel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_banksel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_banksel GGS_instruction_banksel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_banksel result ;
  macroMyNew (result.mPointer, cPtr_instruction_banksel (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_banksel::
reader_mBankIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_banksel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_banksel *) mPointer)->mBankIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_banksel::actualTypeName (void) const {
  return "instruction_banksel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_banksel ("instruction_banksel", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_savebank'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_savebank::
cPtr_instruction_savebank (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mRegister (argument_1),
mInstructionList (argument_2),
mEndOfSaveBankInstruction (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_savebank * GGS_instruction_savebank::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_savebank *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_savebank *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_savebank::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_savebank * ptr = dynamic_cast <const cPtr_instruction_savebank *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRegister.operator_isEqual (ptr->mRegister).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfSaveBankInstruction.operator_isEqual (ptr->mEndOfSaveBankInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_savebank::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_savebank:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegister.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfSaveBankInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_savebank::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_savebank::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_savebank (& typeid (cPtr_instruction_savebank), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_savebank::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_savebank ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_savebank::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_savebank (mInstructionLocation, mRegister, mInstructionList, mEndOfSaveBankInstruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_savebank'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_savebank::
GGS_instruction_savebank (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_savebank::
GGS_instruction_savebank (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_savebank GGS_instruction_savebank::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_savebank result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_savebank *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_savebank) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_savebank (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_savebank),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_savebank GGS_instruction_savebank::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instructionList & argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_savebank result ;
  macroMyNew (result.mPointer, cPtr_instruction_savebank (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_savebank::
reader_mRegister (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_savebank *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_savebank *) mPointer)->mRegister ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_savebank::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_savebank *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_savebank *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_instruction_savebank::
reader_mEndOfSaveBankInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_savebank *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_savebank *) mPointer)->mEndOfSaveBankInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_savebank::actualTypeName (void) const {
  return "instruction_savebank" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_savebank ("instruction_savebank", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'instruction_FDA_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_instruction_FDA_base_code::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_isEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_isNotEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_infOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_supOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_strictInf (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
operator_strictSup (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instruction_FDA_base_code::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [22] = {"",
    "ADDWF",
    "ADDWFC",
    "ANDWF",
    "COMF",
    "DCFSNZ",
    "DECF",
    "DECFSZ",
    "INCF",
    "INCFSZ",
    "INFSNZ",
    "IORWF",
    "MOVF",
    "RLCF",
    "RLNCF",
    "RRCF",
    "RRNCF",
    "SUBFWB",
    "SUBWF",
    "SUBWFB",
    "SWAPF",
    "XORWF"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instruction_FDA_base_code::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @instruction_FDA_base_code" ;
  switch (mValue) {
  case enum_ADDWF:
    s << " ADDWF>" ;
    break ;
  case enum_ADDWFC:
    s << " ADDWFC>" ;
    break ;
  case enum_ANDWF:
    s << " ANDWF>" ;
    break ;
  case enum_COMF:
    s << " COMF>" ;
    break ;
  case enum_DCFSNZ:
    s << " DCFSNZ>" ;
    break ;
  case enum_DECF:
    s << " DECF>" ;
    break ;
  case enum_DECFSZ:
    s << " DECFSZ>" ;
    break ;
  case enum_INCF:
    s << " INCF>" ;
    break ;
  case enum_INCFSZ:
    s << " INCFSZ>" ;
    break ;
  case enum_INFSNZ:
    s << " INFSNZ>" ;
    break ;
  case enum_IORWF:
    s << " IORWF>" ;
    break ;
  case enum_MOVF:
    s << " MOVF>" ;
    break ;
  case enum_RLCF:
    s << " RLCF>" ;
    break ;
  case enum_RLNCF:
    s << " RLNCF>" ;
    break ;
  case enum_RRCF:
    s << " RRCF>" ;
    break ;
  case enum_RRNCF:
    s << " RRNCF>" ;
    break ;
  case enum_SUBFWB:
    s << " SUBFWB>" ;
    break ;
  case enum_SUBWF:
    s << " SUBWF>" ;
    break ;
  case enum_SUBWFB:
    s << " SUBWFB>" ;
    break ;
  case enum_SWAPF:
    s << " SWAPF>" ;
    break ;
  case enum_XORWF:
    s << " XORWF>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "getFDAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFDAinstructionBaseCode (C_Compiler &,
                                const GGS_instruction_FDA_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFDAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_instruction_FDA_base_code::enum_ADDWF:
    {
    var_cas_outBaseCode = GGS_uint (9216U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ADDWFC:
    {
    var_cas_outBaseCode = GGS_uint (8192U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ANDWF:
    {
    var_cas_outBaseCode = GGS_uint (5120U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_COMF:
    {
    var_cas_outBaseCode = GGS_uint (7168U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECF:
    {
    var_cas_outBaseCode = GGS_uint (1024U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECFSZ:
    {
    var_cas_outBaseCode = GGS_uint (11264U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DCFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (19456U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCF:
    {
    var_cas_outBaseCode = GGS_uint (10240U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCFSZ:
    {
    var_cas_outBaseCode = GGS_uint (15360U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (18432U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_IORWF:
    {
    var_cas_outBaseCode = GGS_uint (4096U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_MOVF:
    {
    var_cas_outBaseCode = GGS_uint (20480U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLCF:
    {
    var_cas_outBaseCode = GGS_uint (13312U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLNCF:
    {
    var_cas_outBaseCode = GGS_uint (17408U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRCF:
    {
    var_cas_outBaseCode = GGS_uint (12288U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRNCF:
    {
    var_cas_outBaseCode = GGS_uint (16384U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBFWB:
    {
    var_cas_outBaseCode = GGS_uint (21504U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWF:
    {
    var_cas_outBaseCode = GGS_uint (23552U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWFB:
    {
    var_cas_outBaseCode = GGS_uint (22528U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SWAPF:
    {
    var_cas_outBaseCode = GGS_uint (14336U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_XORWF:
    {
    var_cas_outBaseCode = GGS_uint (6144U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFDAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FDA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FDA::
cPtr_instruction_FDA (const GGS_location & argument_0,
                                const GGS_instruction_FDA_base_code& argument_1,
                                const GGS_registerExpression & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstruction_FDA_base_code (argument_1),
mRegisterExpression (argument_2),
m_W_isDestination (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FDA * GGS_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FDA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FDA * ptr = dynamic_cast <const cPtr_instruction_FDA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstruction_FDA_base_code.operator_isEqual (ptr->mInstruction_FDA_base_code).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && m_W_isDestination.operator_isEqual (ptr->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FDA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FDA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction_FDA_base_code.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FDA (& typeid (cPtr_instruction_FDA), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FDA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_FDA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_FDA (mInstructionLocation, mInstruction_FDA_base_code, mRegisterExpression, m_W_isDestination COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FDA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_FDA GGS_instruction_FDA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA GGS_instruction_FDA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instruction_FDA_base_code& argument_1,
                 const GGS_registerExpression & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FDA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA_base_code GGS_instruction_FDA::
reader_mInstruction_FDA_base_code (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction_FDA_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mInstruction_FDA_base_code ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FDA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FDA::actualTypeName (void) const {
  return "instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FDA ("instruction_FDA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Class for 'FA_instruction_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_FA_instruction_base_code::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_isEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_isNotEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_infOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_supOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_strictInf (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
operator_strictSup (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [10] = {"",
    "CLRF",
    "CPFSEQ",
    "CPFSGT",
    "CPFSLT",
    "MOVWF",
    "MULWF",
    "NEGF",
    "SETF",
    "TSTFSZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @FA_instruction_base_code" ;
  switch (mValue) {
  case enum_CLRF:
    s << " CLRF>" ;
    break ;
  case enum_CPFSEQ:
    s << " CPFSEQ>" ;
    break ;
  case enum_CPFSGT:
    s << " CPFSGT>" ;
    break ;
  case enum_CPFSLT:
    s << " CPFSLT>" ;
    break ;
  case enum_MOVWF:
    s << " MOVWF>" ;
    break ;
  case enum_MULWF:
    s << " MULWF>" ;
    break ;
  case enum_NEGF:
    s << " NEGF>" ;
    break ;
  case enum_SETF:
    s << " SETF>" ;
    break ;
  case enum_TSTFSZ:
    s << " TSTFSZ>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FA'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FA::
cPtr_instruction_FA (const GGS_location & argument_0,
                                const GGS_FA_instruction_base_code& argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mFAinstruction (argument_1),
mRegisterExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FA * GGS_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FA * ptr = dynamic_cast <const cPtr_instruction_FA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mFAinstruction.operator_isEqual (ptr->mFAinstruction).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFAinstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FA (& typeid (cPtr_instruction_FA), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_FA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_FA (mInstructionLocation, mFAinstruction, mRegisterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_FA GGS_instruction_FA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA GGS_instruction_FA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_FA_instruction_base_code& argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FA (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_FA_instruction_base_code GGS_instruction_FA::
reader_mFAinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_FA_instruction_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mFAinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FA::actualTypeName (void) const {
  return "instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FA ("instruction_FA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVFF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVFF::
cPtr_instruction_MOVFF (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSourceRegisterName (argument_1),
mDestinationRegisterName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVFF * GGS_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVFF * ptr = dynamic_cast <const cPtr_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSourceRegisterName.operator_isEqual (ptr->mSourceRegisterName).boolValue ()
         && mDestinationRegisterName.operator_isEqual (ptr->mDestinationRegisterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVFF:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceRegisterName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVFF (& typeid (cPtr_instruction_MOVFF), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVFF ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_MOVFF::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_MOVFF (mInstructionLocation, mSourceRegisterName, mDestinationRegisterName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVFF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_MOVFF GGS_instruction_MOVFF::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF GGS_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVFF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mSourceRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mSourceRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mDestinationRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mDestinationRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVFF::actualTypeName (void) const {
  return "instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVFF ("instruction_MOVFF", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'bit_oriented_op' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_bit_oriented_op::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_isEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_isNotEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_infOrEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_supOrEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_strictInf (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
operator_strictSup (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bit_oriented_op::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "BCF",
    "BSF",
    "BTG"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bit_oriented_op::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @bit_oriented_op" ;
  switch (mValue) {
  case enum_BCF:
    s << " BCF>" ;
    break ;
  case enum_BSF:
    s << " BSF>" ;
    break ;
  case enum_BTG:
    s << " BTG>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FBA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FBA::
cPtr_instruction_FBA (const GGS_location & argument_0,
                                const GGS_bit_oriented_op& argument_1,
                                const GGS_registerExpression & argument_2,
                                const GGS_bitNumberExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mBitOrientedOp (argument_1),
mRegisterExpression (argument_2),
mBitNumber (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FBA * GGS_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FBA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FBA * ptr = dynamic_cast <const cPtr_instruction_FBA *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBitOrientedOp.operator_isEqual (ptr->mBitOrientedOp).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mBitNumber.operator_isEqual (ptr->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FBA::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FBA:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitOrientedOp.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FBA (& typeid (cPtr_instruction_FBA), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FBA ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_FBA::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_FBA (mInstructionLocation, mBitOrientedOp, mRegisterExpression, mBitNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FBA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_FBA GGS_instruction_FBA::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA GGS_instruction_FBA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bit_oriented_op& argument_1,
                 const GGS_registerExpression & argument_2,
                 const GGS_bitNumberExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FBA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bit_oriented_op GGS_instruction_FBA::
reader_mBitOrientedOp (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bit_oriented_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitOrientedOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FBA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FBA::actualTypeName (void) const {
  return "instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FBA ("instruction_FBA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'conditional_branch' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_conditional_branch::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_isEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_isNotEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_infOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_supOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_strictInf (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
operator_strictSup (const GGS_conditional_branch inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "BC",
    "BN",
    "BNC",
    "BNN",
    "BNOV",
    "BNZ",
    "BOV",
    "BZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_condition (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "C",
    "N",
    "NC",
    "NN",
    "NOV",
    "NZ",
    "OV",
    "Z"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @conditional_branch" ;
  switch (mValue) {
  case enum_bc:
    s << " bc>" ;
    break ;
  case enum_bn:
    s << " bn>" ;
    break ;
  case enum_bnc:
    s << " bnc>" ;
    break ;
  case enum_bnn:
    s << " bnn>" ;
    break ;
  case enum_bnov:
    s << " bnov>" ;
    break ;
  case enum_bnz:
    s << " bnz>" ;
    break ;
  case enum_bov:
    s << " bov>" ;
    break ;
  case enum_bz:
    s << " bz>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "getComplementaryBcc"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getComplementaryBcc (C_Compiler & inLexique,
                                const GGS_conditional_branch  var_cas_inConditionalBranch,
                                GGS_conditional_branch & var_cas_outComplementary COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getComplementaryBcc at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inConditionalBranch.enumValue ()) {
  case GGS_conditional_branch::enum_bz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnz (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bz (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnn (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bn (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnc (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bc (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnov (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bov (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getComplementaryBcc\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'jumpInstructionKind' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_jumpInstructionKind::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_isEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_isNotEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_infOrEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_supOrEqual (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_strictInf (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_jumpInstructionKind::
operator_strictSup (const GGS_jumpInstructionKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_jumpInstructionKind::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @jumpInstructionKind" ;
  switch (mValue) {
  case enum_absolute:
    s << " absolute>" ;
    break ;
  case enum_ipicAbsolute:
    s << " ipicAbsolute>" ;
    break ;
  case enum_ipicRelative:
    s << " ipicRelative>" ;
    break ;
  case enum_relative:
    s << " relative>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_JSR'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_JSR::
cPtr_instruction_JSR (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_JSR * GGS_instruction_JSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_JSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_JSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_JSR * ptr = dynamic_cast <const cPtr_instruction_JSR *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_JSR::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_JSR:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_JSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_JSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_JSR (& typeid (cPtr_instruction_JSR), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_JSR::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_JSR ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_JSR::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_JSR (mInstructionLocation, mTargetLabel, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_JSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_JSR::
GGS_instruction_JSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JSR::
GGS_instruction_JSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_JSR GGS_instruction_JSR::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_JSR result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_JSR *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_JSR) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_JSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_JSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JSR GGS_instruction_JSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_JSR result ;
  macroMyNew (result.mPointer, cPtr_instruction_JSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_JSR::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JSR *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_instruction_JSR::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JSR *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_JSR::actualTypeName (void) const {
  return "instruction_JSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_JSR ("instruction_JSR", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_JUMP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_JUMP::
cPtr_instruction_JUMP (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_JUMP * GGS_instruction_JUMP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_JUMP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_JUMP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_JUMP * ptr = dynamic_cast <const cPtr_instruction_JUMP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_JUMP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_JUMP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_JUMP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_JUMP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_JUMP (& typeid (cPtr_instruction_JUMP), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_JUMP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_JUMP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_JUMP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_JUMP (mInstructionLocation, mTargetLabel, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_JUMP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_JUMP::
GGS_instruction_JUMP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JUMP::
GGS_instruction_JUMP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_JUMP GGS_instruction_JUMP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_JUMP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_JUMP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_JUMP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_JUMP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_JUMP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JUMP GGS_instruction_JUMP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_jumpInstructionKind& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_JUMP result ;
  macroMyNew (result.mPointer, cPtr_instruction_JUMP (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_JUMP::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JUMP *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_jumpInstructionKind GGS_instruction_JUMP::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_jumpInstructionKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JUMP *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_JUMP::actualTypeName (void) const {
  return "instruction_JUMP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_JUMP ("instruction_JUMP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_JUMPCC'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_JUMPCC::
cPtr_instruction_JUMPCC (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_conditional_branch& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1),
mConditionalBranch (argument_2),
mIsBcc (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_JUMPCC * GGS_instruction_JUMPCC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMPCC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_JUMPCC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_JUMPCC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_JUMPCC * ptr = dynamic_cast <const cPtr_instruction_JUMPCC *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetLabel.operator_isEqual (ptr->mTargetLabel).boolValue ()
         && mConditionalBranch.operator_isEqual (ptr->mConditionalBranch).boolValue ()
         && mIsBcc.operator_isEqual (ptr->mIsBcc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_JUMPCC::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_JUMPCC:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConditionalBranch.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIsBcc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_JUMPCC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_JUMPCC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_JUMPCC (& typeid (cPtr_instruction_JUMPCC), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_JUMPCC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_JUMPCC ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_JUMPCC::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_JUMPCC (mInstructionLocation, mTargetLabel, mConditionalBranch, mIsBcc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_JUMPCC'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_JUMPCC::
GGS_instruction_JUMPCC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JUMPCC::
GGS_instruction_JUMPCC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_JUMPCC GGS_instruction_JUMPCC::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_JUMPCC result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_JUMPCC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_JUMPCC) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_JUMPCC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_JUMPCC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_JUMPCC GGS_instruction_JUMPCC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_conditional_branch& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_JUMPCC result ;
  macroMyNew (result.mPointer, cPtr_instruction_JUMPCC (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_JUMPCC::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMPCC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JUMPCC *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_instruction_JUMPCC::
reader_mConditionalBranch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMPCC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JUMPCC *) mPointer)->mConditionalBranch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_JUMPCC::
reader_mIsBcc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_JUMPCC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_JUMPCC *) mPointer)->mIsBcc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_JUMPCC::actualTypeName (void) const {
  return "instruction_JUMPCC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_JUMPCC ("instruction_JUMPCC", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CLRWDT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CLRWDT::
cPtr_instruction_CLRWDT (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CLRWDT * GGS_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CLRWDT * ptr = dynamic_cast <const cPtr_instruction_CLRWDT *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CLRWDT::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CLRWDT:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CLRWDT (& typeid (cPtr_instruction_CLRWDT), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_CLRWDT::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_CLRWDT (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CLRWDT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT result ;
  macroMyNew (result.mPointer, cPtr_instruction_CLRWDT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CLRWDT::actualTypeName (void) const {
  return "instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CLRWDT ("instruction_CLRWDT", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_DAW'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DAW::
cPtr_instruction_DAW (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DAW * GGS_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DAW * ptr = dynamic_cast <const cPtr_instruction_DAW *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DAW::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DAW:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DAW (& typeid (cPtr_instruction_DAW), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DAW ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_DAW::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_DAW (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_DAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_DAW GGS_instruction_DAW::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW GGS_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_DAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DAW::actualTypeName (void) const {
  return "instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DAW ("instruction_DAW", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_NOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_NOP::
cPtr_instruction_NOP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_NOP * GGS_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_NOP * ptr = dynamic_cast <const cPtr_instruction_NOP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_NOP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_NOP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_NOP (& typeid (cPtr_instruction_NOP), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_NOP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_NOP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_NOP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_NOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_NOP GGS_instruction_NOP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP GGS_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_NOP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_NOP::actualTypeName (void) const {
  return "instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_NOP ("instruction_NOP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_POP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_POP::
cPtr_instruction_POP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_POP * GGS_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_POP * ptr = dynamic_cast <const cPtr_instruction_POP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_POP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_POP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_POP (& typeid (cPtr_instruction_POP), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_POP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_POP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_POP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_POP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_POP GGS_instruction_POP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_POP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP GGS_instruction_POP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_POP result ;
  macroMyNew (result.mPointer, cPtr_instruction_POP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_POP::actualTypeName (void) const {
  return "instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_POP ("instruction_POP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_PUSH'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_PUSH::
cPtr_instruction_PUSH (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_PUSH * GGS_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_PUSH * ptr = dynamic_cast <const cPtr_instruction_PUSH *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_PUSH::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_PUSH:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_PUSH (& typeid (cPtr_instruction_PUSH), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_PUSH ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_PUSH::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_PUSH (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_PUSH'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_PUSH GGS_instruction_PUSH::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH GGS_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH result ;
  macroMyNew (result.mPointer, cPtr_instruction_PUSH (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_PUSH::actualTypeName (void) const {
  return "instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_PUSH ("instruction_PUSH", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RESET'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RESET::
cPtr_instruction_RESET (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RESET * GGS_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RESET * ptr = dynamic_cast <const cPtr_instruction_RESET *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RESET::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RESET:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RESET (& typeid (cPtr_instruction_RESET), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RESET ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_RESET::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_RESET (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RESET'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_RESET GGS_instruction_RESET::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET GGS_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET result ;
  macroMyNew (result.mPointer, cPtr_instruction_RESET (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RESET::actualTypeName (void) const {
  return "instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RESET ("instruction_RESET", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SLEEP'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SLEEP::
cPtr_instruction_SLEEP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SLEEP * GGS_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SLEEP * ptr = dynamic_cast <const cPtr_instruction_SLEEP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SLEEP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SLEEP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SLEEP (& typeid (cPtr_instruction_SLEEP), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SLEEP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_SLEEP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_SLEEP (mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SLEEP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_SLEEP GGS_instruction_SLEEP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP GGS_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP result ;
  macroMyNew (result.mPointer, cPtr_instruction_SLEEP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SLEEP::actualTypeName (void) const {
  return "instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SLEEP ("instruction_SLEEP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'literal_instruction_opcode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_literal_instruction_opcode::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_isEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_isNotEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_infOrEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_supOrEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_strictInf (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
operator_strictSup (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literal_instruction_opcode::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "ADDLW",
    "ANDLW",
    "IORLW",
    "MOVLW",
    "MULLW",
    "RETLW",
    "SUBLW",
    "XORLW"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literal_instruction_opcode::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @literal_instruction_opcode" ;
  switch (mValue) {
  case enum_ADDLW:
    s << " ADDLW>" ;
    break ;
  case enum_ANDLW:
    s << " ANDLW>" ;
    break ;
  case enum_IORLW:
    s << " IORLW>" ;
    break ;
  case enum_MOVLW:
    s << " MOVLW>" ;
    break ;
  case enum_MULLW:
    s << " MULLW>" ;
    break ;
  case enum_RETLW:
    s << " RETLW>" ;
    break ;
  case enum_SUBLW:
    s << " SUBLW>" ;
    break ;
  case enum_XORLW:
    s << " XORLW>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_literalOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_literalOperation::
cPtr_instruction_literalOperation (const GGS_location & argument_0,
                                const GGS_literal_instruction_opcode& argument_1,
                                const GGS_immediatExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mLiteralInstruction (argument_1),
mImmediatExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_literalOperation * GGS_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_literalOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_literalOperation * ptr = dynamic_cast <const cPtr_instruction_literalOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLiteralInstruction.operator_isEqual (ptr->mLiteralInstruction).boolValue ()
         && mImmediatExpression.operator_isEqual (ptr->mImmediatExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_literalOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_literalOperation:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mImmediatExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_literalOperation (& typeid (cPtr_instruction_literalOperation), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_literalOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_literalOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_literalOperation (mInstructionLocation, mLiteralInstruction, mImmediatExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_literalOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_literalOperation GGS_instruction_literalOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation GGS_instruction_literalOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_literal_instruction_opcode& argument_1,
                 const GGS_immediatExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation result ;
  macroMyNew (result.mPointer, cPtr_instruction_literalOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literal_instruction_opcode GGS_instruction_literalOperation::
reader_mLiteralInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_literal_instruction_opcode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mLiteralInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_literalOperation::
reader_mImmediatExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mImmediatExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_literalOperation::actualTypeName (void) const {
  return "instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_literalOperation ("instruction_literalOperation", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LFSR'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LFSR::
cPtr_instruction_LFSR (const GGS_location & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_immediatExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mFSRindex (argument_1),
mImmediatExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LFSR * GGS_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LFSR * ptr = dynamic_cast <const cPtr_instruction_LFSR *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mFSRindex.operator_isEqual (ptr->mFSRindex).boolValue ()
         && mImmediatExpression.operator_isEqual (ptr->mImmediatExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LFSR:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFSRindex.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mImmediatExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LFSR (& typeid (cPtr_instruction_LFSR), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LFSR ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_LFSR::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_LFSR (mInstructionLocation, mFSRindex, mImmediatExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LFSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_LFSR GGS_instruction_LFSR::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR GGS_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_immediatExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_instruction_LFSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_LFSR::
reader_mImmediatExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mImmediatExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LFSR::actualTypeName (void) const {
  return "instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LFSR ("instruction_LFSR", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'tableAccessOption' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_tableAccessOption::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_isEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_isNotEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_infOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_supOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_strictInf (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
operator_strictSup (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "*-",
    "*+",
    "+*",
    "*"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @tableAccessOption" ;
  switch (mValue) {
  case enum_postDecrement:
    s << " postDecrement>" ;
    break ;
  case enum_postIncrement:
    s << " postIncrement>" ;
    break ;
  case enum_preIncrement:
    s << " preIncrement>" ;
    break ;
  case enum_simpleAccess:
    s << " simpleAccess>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLRD'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLRD::
cPtr_instruction_TBLRD (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLRD * GGS_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLRD * ptr = dynamic_cast <const cPtr_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOption.operator_isEqual (ptr->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLRD::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLRD:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLRD (& typeid (cPtr_instruction_TBLRD), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLRD ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_TBLRD::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_TBLRD (mInstructionLocation, mOption COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLRD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_TBLRD GGS_instruction_TBLRD::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD GGS_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLRD (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLRD::actualTypeName (void) const {
  return "instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLRD ("instruction_TBLRD", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLWT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLWT::
cPtr_instruction_TBLWT (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLWT * GGS_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLWT * ptr = dynamic_cast <const cPtr_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOption.operator_isEqual (ptr->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLWT::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLWT:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLWT (& typeid (cPtr_instruction_TBLWT), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLWT ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_TBLWT::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_TBLWT (mInstructionLocation, mOption COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLWT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_TBLWT GGS_instruction_TBLWT::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT GGS_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLWT (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLWT::actualTypeName (void) const {
  return "instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLWT ("instruction_TBLWT", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MNOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MNOP::
cPtr_instruction_MNOP (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOccurrenceFactor (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MNOP * GGS_instruction_MNOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MNOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MNOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MNOP * ptr = dynamic_cast <const cPtr_instruction_MNOP *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mOccurrenceFactor.operator_isEqual (ptr->mOccurrenceFactor).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MNOP::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MNOP:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOccurrenceFactor.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MNOP (& typeid (cPtr_instruction_MNOP), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MNOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MNOP ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_MNOP::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_MNOP (mInstructionLocation, mOccurrenceFactor COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MNOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_MNOP GGS_instruction_MNOP::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MNOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MNOP) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_MNOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MNOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP GGS_instruction_MNOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_MNOP (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MNOP::
reader_mOccurrenceFactor (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MNOP *) mPointer)->mOccurrenceFactor ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MNOP::actualTypeName (void) const {
  return "instruction_MNOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MNOP ("instruction_MNOP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_FOREVER'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FOREVER::
cPtr_instruction_FOREVER (const GGS_location & argument_0,
                                const GGS_instructionList & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstructionList (argument_1),
mEndOfInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FOREVER * GGS_instruction_FOREVER::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FOREVER *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FOREVER::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FOREVER * ptr = dynamic_cast <const cPtr_instruction_FOREVER *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfInstructionList.operator_isEqual (ptr->mEndOfInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FOREVER::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FOREVER:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FOREVER (& typeid (cPtr_instruction_FOREVER), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FOREVER::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FOREVER ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_FOREVER::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_FOREVER (mInstructionLocation, mInstructionList, mEndOfInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_FOREVER'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_FOREVER GGS_instruction_FOREVER::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FOREVER *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FOREVER) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_FOREVER (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FOREVER),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER GGS_instruction_FOREVER::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instructionList & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER result ;
  macroMyNew (result.mPointer, cPtr_instruction_FOREVER (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_FOREVER::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FOREVER *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_instruction_FOREVER::
reader_mEndOfInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FOREVER *) mPointer)->mEndOfInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FOREVER::actualTypeName (void) const {
  return "instruction_FOREVER" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FOREVER ("instruction_FOREVER", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'if_semi_colon_op' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_if_semi_colon_op::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_isEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_isNotEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_infOrEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_supOrEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_strictInf (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
operator_strictSup (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_if_semi_colon_op::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "CPFSEQ",
    "CPFSGT",
    "CPFSLT",
    "TSTFSZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_if_semi_colon_op::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @if_semi_colon_op" ;
  switch (mValue) {
  case enum_CPFSEQ:
    s << " CPFSEQ>" ;
    break ;
  case enum_CPFSGT:
    s << " CPFSGT>" ;
    break ;
  case enum_CPFSLT:
    s << " CPFSLT>" ;
    break ;
  case enum_TSTFSZ:
    s << " TSTFSZ>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_IF_SEMI_COLON'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_SEMI_COLON::
cPtr_instruction_IF_SEMI_COLON (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstruction (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_SEMI_COLON * GGS_instruction_IF_SEMI_COLON::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_SEMI_COLON *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_SEMI_COLON::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_SEMI_COLON:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_SEMI_COLON (& typeid (cPtr_instruction_IF_SEMI_COLON), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_SEMI_COLON::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_SEMI_COLON ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_IF_SEMI_COLON'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_IF_SEMI_COLON GGS_instruction_IF_SEMI_COLON::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_SEMI_COLON result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_SEMI_COLON) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_IF_SEMI_COLON (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_SEMI_COLON),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction  GGS_instruction_IF_SEMI_COLON::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_piccolo_instruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_SEMI_COLON *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_SEMI_COLON::actualTypeName (void) const {
  return "instruction_IF_SEMI_COLON" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_SEMI_COLON ("instruction_IF_SEMI_COLON", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_IF_FA_SEMI_COLON'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_FA_SEMI_COLON::
cPtr_instruction_IF_FA_SEMI_COLON (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_if_semi_colon_op& argument_2,
                                const GGS_registerExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mOpCode (argument_2),
mRegisterExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_FA_SEMI_COLON * GGS_instruction_IF_FA_SEMI_COLON::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_FA_SEMI_COLON *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_FA_SEMI_COLON::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_FA_SEMI_COLON * ptr = dynamic_cast <const cPtr_instruction_IF_FA_SEMI_COLON *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstruction.operator_isEqual (ptr->mInstruction).boolValue ()
         && mOpCode.operator_isEqual (ptr->mOpCode).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_FA_SEMI_COLON::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_FA_SEMI_COLON:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOpCode.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_FA_SEMI_COLON::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_FA_SEMI_COLON::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_FA_SEMI_COLON (& typeid (cPtr_instruction_IF_FA_SEMI_COLON), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_FA_SEMI_COLON::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_FA_SEMI_COLON ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_IF_FA_SEMI_COLON::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_IF_FA_SEMI_COLON (mInstructionLocation, mInstruction, mOpCode, mRegisterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_IF_FA_SEMI_COLON'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON::
GGS_instruction_IF_FA_SEMI_COLON (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON::
GGS_instruction_IF_FA_SEMI_COLON (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_IF_FA_SEMI_COLON GGS_instruction_IF_FA_SEMI_COLON::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_FA_SEMI_COLON result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_FA_SEMI_COLON) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_IF_FA_SEMI_COLON (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_FA_SEMI_COLON),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON GGS_instruction_IF_FA_SEMI_COLON::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_if_semi_colon_op& argument_2,
                 const GGS_registerExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_FA_SEMI_COLON result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_FA_SEMI_COLON (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_if_semi_colon_op GGS_instruction_IF_FA_SEMI_COLON::
reader_mOpCode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_if_semi_colon_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_FA_SEMI_COLON *) mPointer)->mOpCode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_FA_SEMI_COLON::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_FA_SEMI_COLON *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_FA_SEMI_COLON::actualTypeName (void) const {
  return "instruction_IF_FA_SEMI_COLON" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_FA_SEMI_COLON ("instruction_IF_FA_SEMI_COLON", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_instruction_IF_BitTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_BitTest::
cPtr_instruction_IF_BitTest (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_registerExpression & argument_3,
                                const GGS_bitNumberExpression & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mSkipIfSet (argument_2),
mRegisterExpression (argument_3),
mBitNumber (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_BitTest * GGS_instruction_IF_BitTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_BitTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_BitTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_BitTest * ptr = dynamic_cast <const cPtr_instruction_IF_BitTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstruction.operator_isEqual (ptr->mInstruction).boolValue ()
         && mSkipIfSet.operator_isEqual (ptr->mSkipIfSet).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mBitNumber.operator_isEqual (ptr->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
method_getBaseCode (C_Compiler & /* inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outBaseCode = GGS_uint (40960U) ;
  }else{
    var_cas_outBaseCode = GGS_uint (45056U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
method_getMnemonic (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outMnemonic COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outMnemonic = GGS_string ("BTFSS") ;
  }else{
    var_cas_outMnemonic = GGS_string ("BTFSC") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_BitTest:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfSet.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_BitTest (& typeid (cPtr_instruction_IF_BitTest), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_BitTest::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_BitTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_IF_BitTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_IF_BitTest (mInstructionLocation, mInstruction, mSkipIfSet, mRegisterExpression, mBitNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_instruction_IF_BitTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_BitTest *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_BitTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_IF_BitTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_BitTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_registerExpression & argument_3,
                 const GGS_bitNumberExpression & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_BitTest (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_BitTest::
reader_mSkipIfSet (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mSkipIfSet ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_BitTest::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_IF_BitTest::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_BitTest::actualTypeName (void) const {
  return "instruction_IF_BitTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_BitTest ("instruction_IF_BitTest", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_IF_IncDec'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_IncDec::
cPtr_instruction_IF_IncDec (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_registerExpression & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mIncrement (argument_2),
mSkipIfZero (argument_3),
mRegisterExpression (argument_4),
m_W_isDestination (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_IncDec * GGS_instruction_IF_IncDec::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_IncDec *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_IncDec::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_IncDec * ptr = dynamic_cast <const cPtr_instruction_IF_IncDec *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mInstruction.operator_isEqual (ptr->mInstruction).boolValue ()
         && mIncrement.operator_isEqual (ptr->mIncrement).boolValue ()
         && mSkipIfZero.operator_isEqual (ptr->mSkipIfZero).boolValue ()
         && mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && m_W_isDestination.operator_isEqual (ptr->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_IncDec::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_IncDec:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIncrement.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfZero.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_IncDec::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_IncDec::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_IncDec (& typeid (cPtr_instruction_IF_IncDec), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_IncDec::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_IncDec ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_IF_IncDec::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_IF_IncDec (mInstructionLocation, mInstruction, mIncrement, mSkipIfZero, mRegisterExpression, m_W_isDestination COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_IF_IncDec'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec::
GGS_instruction_IF_IncDec (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec::
GGS_instruction_IF_IncDec (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_IF_IncDec GGS_instruction_IF_IncDec::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_IncDec result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_IncDec *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_IncDec) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_IF_IncDec (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_IncDec),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec GGS_instruction_IF_IncDec::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_registerExpression & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_IncDec result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_IncDec (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_mIncrement (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mIncrement ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_mSkipIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mSkipIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_IncDec::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_IncDec::actualTypeName (void) const {
  return "instruction_IF_IncDec" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_IncDec ("instruction_IF_IncDec", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_computed_retlw'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_retlw::
cPtr_instruction_computed_retlw (const GGS_location & argument_0,
                                const GGS_immediatExpression & argument_1,
                                const GGS_immediatExpressionList & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSizeExpression (argument_1),
mImmediateExpressionList (argument_2),
mUsesRelativeCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_retlw * GGS_instruction_computed_retlw::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_retlw *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_retlw::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_retlw * ptr = dynamic_cast <const cPtr_instruction_computed_retlw *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSizeExpression.operator_isEqual (ptr->mSizeExpression).boolValue ()
         && mImmediateExpressionList.operator_isEqual (ptr->mImmediateExpressionList).boolValue ()
         && mUsesRelativeCall.operator_isEqual (ptr->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_retlw::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_retlw:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSizeExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mImmediateExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_retlw (& typeid (cPtr_instruction_computed_retlw), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_retlw::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_retlw ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_computed_retlw::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_computed_retlw (mInstructionLocation, mSizeExpression, mImmediateExpressionList, mUsesRelativeCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_computed_retlw'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_retlw *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_retlw) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_computed_retlw (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_retlw),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_immediatExpression & argument_1,
                 const GGS_immediatExpressionList & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_retlw (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_computed_retlw::
reader_mSizeExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mSizeExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpressionList  GGS_instruction_computed_retlw::
reader_mImmediateExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mImmediateExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_retlw::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_retlw::actualTypeName (void) const {
  return "instruction_computed_retlw" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_retlw ("instruction_computed_retlw", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_bra'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_bra::
cPtr_instruction_computed_bra (const GGS_location & argument_0,
                                const GGS_immediatExpression & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSizeExpression (argument_1),
mTargetLabels (argument_2),
mUsesRelativeCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_bra * GGS_instruction_computed_bra::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_bra *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_bra::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_bra * ptr = dynamic_cast <const cPtr_instruction_computed_bra *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSizeExpression.operator_isEqual (ptr->mSizeExpression).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mUsesRelativeCall.operator_isEqual (ptr->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_bra::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_bra:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSizeExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_bra (& typeid (cPtr_instruction_computed_bra), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_bra::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_bra ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_computed_bra::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_computed_bra (mInstructionLocation, mSizeExpression, mTargetLabels, mUsesRelativeCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_bra'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_computed_bra GGS_instruction_computed_bra::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_bra *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_bra) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_computed_bra (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_bra),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra GGS_instruction_computed_bra::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_immediatExpression & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_bra (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_computed_bra::
reader_mSizeExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mSizeExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_bra::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_bra::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_bra::actualTypeName (void) const {
  return "instruction_computed_bra" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_bra ("instruction_computed_bra", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_goto'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_goto::
cPtr_instruction_computed_goto (const GGS_location & argument_0,
                                const GGS_immediatExpression & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSizeExpression (argument_1),
mTargetLabels (argument_2),
mUsesRelativeCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_goto * GGS_instruction_computed_goto::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_goto *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_goto::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_goto * ptr = dynamic_cast <const cPtr_instruction_computed_goto *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSizeExpression.operator_isEqual (ptr->mSizeExpression).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mUsesRelativeCall.operator_isEqual (ptr->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_goto::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_goto:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSizeExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_goto (& typeid (cPtr_instruction_computed_goto), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_goto::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_goto ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_computed_goto::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_computed_goto (mInstructionLocation, mSizeExpression, mTargetLabels, mUsesRelativeCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_goto'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_computed_goto GGS_instruction_computed_goto::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_goto *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_goto) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_computed_goto (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_goto),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto GGS_instruction_computed_goto::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_immediatExpression & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_goto (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_computed_goto::
reader_mSizeExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mSizeExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_goto::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_goto::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_goto::actualTypeName (void) const {
  return "instruction_computed_goto" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_goto ("instruction_computed_goto", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_computed_rcall'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_rcall::
cPtr_instruction_computed_rcall (const GGS_location & argument_0,
                                const GGS_immediatExpression & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSizeExpression (argument_1),
mTargetLabels (argument_2),
mUsesRelativeCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_rcall * GGS_instruction_computed_rcall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_rcall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_rcall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_rcall * ptr = dynamic_cast <const cPtr_instruction_computed_rcall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSizeExpression.operator_isEqual (ptr->mSizeExpression).boolValue ()
         && mTargetLabels.operator_isEqual (ptr->mTargetLabels).boolValue ()
         && mUsesRelativeCall.operator_isEqual (ptr->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_rcall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_rcall:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSizeExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_rcall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_rcall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_rcall (& typeid (cPtr_instruction_computed_rcall), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_rcall::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_rcall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_computed_rcall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_computed_rcall (mInstructionLocation, mSizeExpression, mTargetLabels, mUsesRelativeCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_computed_rcall'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_rcall::
GGS_instruction_computed_rcall (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_rcall::
GGS_instruction_computed_rcall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_computed_rcall GGS_instruction_computed_rcall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_rcall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_rcall *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_rcall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_computed_rcall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_rcall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_rcall GGS_instruction_computed_rcall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_immediatExpression & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_rcall result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_rcall (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_immediatExpression  GGS_instruction_computed_rcall::
reader_mSizeExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_immediatExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_rcall *) mPointer)->mSizeExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_rcall::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_rcall *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_rcall::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_rcall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_rcall *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_rcall::actualTypeName (void) const {
  return "instruction_computed_rcall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_rcall ("instruction_computed_rcall", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_conditionExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_conditionExpression::
cPtr_conditionExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_conditionExpression * GGS_conditionExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_conditionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_conditionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_conditionExpression::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@conditionExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_conditionExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_conditionExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_conditionExpression (& typeid (cPtr_conditionExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_conditionExpression::galgasRTTI (void) const {
  return & gClassInfoFor__conditionExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_conditionExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_conditionExpression::
GGS_conditionExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression::
GGS_conditionExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_conditionExpression GGS_conditionExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_conditionExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_conditionExpression *> (inPointer) != NULL)
      : (typeid (cPtr_conditionExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_conditionExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_conditionExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_conditionExpression::actualTypeName (void) const {
  return "conditionExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_conditionExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__conditionExpression ("conditionExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_registerTestCondition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerTestCondition::
cPtr_registerTestCondition (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mBranchIfZero (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerTestCondition * GGS_registerTestCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerTestCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerTestCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerTestCondition * ptr = dynamic_cast <const cPtr_registerTestCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mBranchIfZero.operator_isEqual (ptr->mBranchIfZero).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerTestCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerTestCondition:"
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerTestCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerTestCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerTestCondition (& typeid (cPtr_registerTestCondition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerTestCondition::galgasRTTI (void) const {
  return & gClassInfoFor__registerTestCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_registerTestCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_registerTestCondition (mRegisterExpression, mBranchIfZero COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_registerTestCondition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerTestCondition::
GGS_registerTestCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerTestCondition::
GGS_registerTestCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_registerTestCondition GGS_registerTestCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerTestCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerTestCondition *> (inPointer) != NULL)
      : (typeid (cPtr_registerTestCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_registerTestCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerTestCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerTestCondition GGS_registerTestCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerTestCondition result ;
  macroMyNew (result.mPointer, cPtr_registerTestCondition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_registerTestCondition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerTestCondition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerTestCondition::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerTestCondition *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerTestCondition::actualTypeName (void) const {
  return "registerTestCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__registerTestCondition ("registerTestCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'registerComparison' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_registerComparison::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_isEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_isNotEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_infOrEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_supOrEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_strictInf (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
operator_strictSup (const GGS_registerComparison inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_registerComparison::
reader_mnemonic (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [7] = {"",
    "==",
    ">",
    ">=",
    "<",
    "<=",
    "!="
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_registerComparison::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @registerComparison" ;
  switch (mValue) {
  case enum_equal:
    s << " equal>" ;
    break ;
  case enum_greater:
    s << " greater>" ;
    break ;
  case enum_greaterOrEqual:
    s << " greaterOrEqual>" ;
    break ;
  case enum_lower:
    s << " lower>" ;
    break ;
  case enum_lowerOrEqual:
    s << " lowerOrEqual>" ;
    break ;
  case enum_notEqual:
    s << " notEqual>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "getRegisterComparisonComplementary"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getRegisterComparisonComplementary (C_Compiler & inLexique,
                                const GGS_registerComparison  var_cas_inComparison,
                                GGS_registerComparison & var_cas_outComparison COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getRegisterComparisonComplementary at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inComparison.enumValue ()) {
  case GGS_registerComparison::enum_notEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_equal (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_equal:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_notEqual (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_greaterOrEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_lower (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_greater:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_lowerOrEqual (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_lowerOrEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_greater (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_lower:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_greaterOrEqual (inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getRegisterComparisonComplementary\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "getRegisterComparisonInstructionCount"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getRegisterComparisonInstructionCount (C_Compiler &,
                                const GGS_registerComparison  var_cas_inComparison,
                                GGS_uint  & var_cas_outInstructionCount COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getRegisterComparisonInstructionCount at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inComparison.enumValue ()) {
  case GGS_registerComparison::enum_notEqual:
    {
    var_cas_outInstructionCount = GGS_uint (2U) ;
    }
    break ;
  case GGS_registerComparison::enum_equal:
    {
    var_cas_outInstructionCount = GGS_uint (3U) ;
    }
    break ;
  case GGS_registerComparison::enum_greaterOrEqual:
    {
    var_cas_outInstructionCount = GGS_uint (2U) ;
    }
    break ;
  case GGS_registerComparison::enum_greater:
    {
    var_cas_outInstructionCount = GGS_uint (3U) ;
    }
    break ;
  case GGS_registerComparison::enum_lowerOrEqual:
    {
    var_cas_outInstructionCount = GGS_uint (2U) ;
    }
    break ;
  case GGS_registerComparison::enum_lower:
    {
    var_cas_outInstructionCount = GGS_uint (3U) ;
    }
    break ;
  case GGS_registerComparison::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getRegisterComparisonInstructionCount\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_registerComparisonCondition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerComparisonCondition::
cPtr_registerComparisonCondition (const GGS_registerExpression & argument_0,
                                const GGS_registerComparison& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mComparison (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerComparisonCondition * GGS_registerComparisonCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerComparisonCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerComparisonCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerComparisonCondition * ptr = dynamic_cast <const cPtr_registerComparisonCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mComparison.operator_isEqual (ptr->mComparison).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerComparisonCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerComparisonCondition:"
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mComparison.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerComparisonCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerComparisonCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerComparisonCondition (& typeid (cPtr_registerComparisonCondition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerComparisonCondition::galgasRTTI (void) const {
  return & gClassInfoFor__registerComparisonCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_registerComparisonCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_registerComparisonCondition (mRegisterExpression, mComparison COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_registerComparisonCondition'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerComparisonCondition::
GGS_registerComparisonCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerComparisonCondition::
GGS_registerComparisonCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_registerComparisonCondition GGS_registerComparisonCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerComparisonCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerComparisonCondition *> (inPointer) != NULL)
      : (typeid (cPtr_registerComparisonCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_registerComparisonCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerComparisonCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparisonCondition GGS_registerComparisonCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_registerComparison& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerComparisonCondition result ;
  macroMyNew (result.mPointer, cPtr_registerComparisonCondition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_registerComparisonCondition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerComparisonCondition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparison GGS_registerComparisonCondition::
reader_mComparison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerComparison  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerComparisonCondition *) mPointer)->mComparison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerComparisonCondition::actualTypeName (void) const {
  return "registerComparisonCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__registerComparisonCondition ("registerComparisonCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_incDecRegisterInCondition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incDecRegisterInCondition::
cPtr_incDecRegisterInCondition (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mIncrement (argument_1),
m_W_isDestination (argument_2),
mBranchIfZero (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incDecRegisterInCondition * GGS_incDecRegisterInCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_incDecRegisterInCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incDecRegisterInCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incDecRegisterInCondition * ptr = dynamic_cast <const cPtr_incDecRegisterInCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mIncrement.operator_isEqual (ptr->mIncrement).boolValue ()
         && m_W_isDestination.operator_isEqual (ptr->m_W_isDestination).boolValue ()
         && mBranchIfZero.operator_isEqual (ptr->mBranchIfZero).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incDecRegisterInCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@incDecRegisterInCondition:"
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIncrement.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incDecRegisterInCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incDecRegisterInCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incDecRegisterInCondition (& typeid (cPtr_incDecRegisterInCondition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_incDecRegisterInCondition::galgasRTTI (void) const {
  return & gClassInfoFor__incDecRegisterInCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incDecRegisterInCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incDecRegisterInCondition (mRegisterExpression, mIncrement, m_W_isDestination, mBranchIfZero COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_incDecRegisterInCondition'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_incDecRegisterInCondition::
GGS_incDecRegisterInCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incDecRegisterInCondition::
GGS_incDecRegisterInCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incDecRegisterInCondition GGS_incDecRegisterInCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incDecRegisterInCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incDecRegisterInCondition *> (inPointer) != NULL)
      : (typeid (cPtr_incDecRegisterInCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incDecRegisterInCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incDecRegisterInCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incDecRegisterInCondition GGS_incDecRegisterInCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_incDecRegisterInCondition result ;
  macroMyNew (result.mPointer, cPtr_incDecRegisterInCondition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_incDecRegisterInCondition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incDecRegisterInCondition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_incDecRegisterInCondition::
reader_mIncrement (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incDecRegisterInCondition *) mPointer)->mIncrement ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_incDecRegisterInCondition::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incDecRegisterInCondition *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_incDecRegisterInCondition::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incDecRegisterInCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incDecRegisterInCondition *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incDecRegisterInCondition::actualTypeName (void) const {
  return "incDecRegisterInCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__incDecRegisterInCondition ("incDecRegisterInCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_bcc_in_structured_if_condition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bcc_in_structured_if_condition::
cPtr_bcc_in_structured_if_condition (const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mCondition (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bcc_in_structured_if_condition * GGS_bcc_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bcc_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bcc_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bcc_in_structured_if_condition * ptr = dynamic_cast <const cPtr_bcc_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCondition.operator_isEqual (ptr->mCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bcc_in_structured_if_condition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bcc_in_structured_if_condition:"
           << mCondition.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bcc_in_structured_if_condition (& typeid (cPtr_bcc_in_structured_if_condition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bcc_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bcc_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bcc_in_structured_if_condition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bcc_in_structured_if_condition (mCondition COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_bcc_in_structured_if_condition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bcc_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bcc_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bcc_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bcc_in_structured_if_condition (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_bcc_in_structured_if_condition::
reader_mCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bcc_in_structured_if_condition *) mPointer)->mCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bcc_in_structured_if_condition::actualTypeName (void) const {
  return "bcc_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bcc_in_structured_if_condition ("bcc_in_structured_if_condition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_negateCondition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_negateCondition::
cPtr_negateCondition (const GGS_conditionExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mCondition (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_negateCondition * GGS_negateCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_negateCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_negateCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_negateCondition * ptr = dynamic_cast <const cPtr_negateCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCondition.operator_isEqual (ptr->mCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_negateCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@negateCondition:"
           << mCondition.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_negateCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_negateCondition (& typeid (cPtr_negateCondition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_negateCondition::galgasRTTI (void) const {
  return & gClassInfoFor__negateCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_negateCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_negateCondition (mCondition COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_negateCondition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_negateCondition::
GGS_negateCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_negateCondition::
GGS_negateCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_negateCondition GGS_negateCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_negateCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_negateCondition *> (inPointer) != NULL)
      : (typeid (cPtr_negateCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_negateCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_negateCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateCondition GGS_negateCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_conditionExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_negateCondition result ;
  macroMyNew (result.mPointer, cPtr_negateCondition (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_negateCondition::
reader_mCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateCondition *) mPointer)->mCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_negateCondition::actualTypeName (void) const {
  return "negateCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__negateCondition ("negateCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_andCondition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andCondition::
cPtr_andCondition (const GGS_conditionExpression & argument_0,
                                const GGS_conditionExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andCondition * GGS_andCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_andCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andCondition * ptr = dynamic_cast <const cPtr_andCondition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andCondition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@andCondition:"
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andCondition (& typeid (cPtr_andCondition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_andCondition::galgasRTTI (void) const {
  return & gClassInfoFor__andCondition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andCondition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andCondition (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_andCondition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_andCondition::
GGS_andCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andCondition::
GGS_andCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andCondition GGS_andCondition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andCondition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andCondition *> (inPointer) != NULL)
      : (typeid (cPtr_andCondition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andCondition GGS_andCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_conditionExpression & argument_0,
                 const GGS_conditionExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_andCondition result ;
  macroMyNew (result.mPointer, cPtr_andCondition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_andCondition::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andCondition *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_andCondition::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andCondition *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andCondition::actualTypeName (void) const {
  return "andCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__andCondition ("andCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_bitTest_in_structured_if_condition'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitTest_in_structured_if_condition::
cPtr_bitTest_in_structured_if_condition (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mBitNumber (argument_1),
mBTFSSinstruction (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitTest_in_structured_if_condition * GGS_bitTest_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitTest_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitTest_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitTest_in_structured_if_condition * ptr = dynamic_cast <const cPtr_bitTest_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegisterExpression.operator_isEqual (ptr->mRegisterExpression).boolValue ()
         && mBitNumber.operator_isEqual (ptr->mBitNumber).boolValue ()
         && mBTFSSinstruction.operator_isEqual (ptr->mBTFSSinstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitTest_in_structured_if_condition::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitTest_in_structured_if_condition:"
           << mRegisterExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBTFSSinstruction.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitTest_in_structured_if_condition (& typeid (cPtr_bitTest_in_structured_if_condition), & typeid (cPtr_conditionExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitTest_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bitTest_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bitTest_in_structured_if_condition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bitTest_in_structured_if_condition (mRegisterExpression, mBitNumber, mBTFSSinstruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_bitTest_in_structured_if_condition'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bitTest_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bitTest_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitTest_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bitTest_in_structured_if_condition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_bitTest_in_structured_if_condition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_bitTest_in_structured_if_condition::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bitTest_in_structured_if_condition::
reader_mBTFSSinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBTFSSinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitTest_in_structured_if_condition::actualTypeName (void) const {
  return "bitTest_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitTest_in_structured_if_condition ("bitTest_in_structured_if_condition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_structured_if'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_structured_if::
cPtr_instruction_structured_if (const GGS_location & argument_0,
                                const GGS_conditionExpression & argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_instructionList & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mIfCondition (argument_1),
mThenInstructionList (argument_2),
mElseInstructionList (argument_3),
mEndOfElsePartLocation (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_structured_if * GGS_instruction_structured_if::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_structured_if *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_structured_if::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_structured_if * ptr = dynamic_cast <const cPtr_instruction_structured_if *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mIfCondition.operator_isEqual (ptr->mIfCondition).boolValue ()
         && mThenInstructionList.operator_isEqual (ptr->mThenInstructionList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue ()
         && mEndOfElsePartLocation.operator_isEqual (ptr->mEndOfElsePartLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_structured_if::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_structured_if:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIfCondition.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mThenInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfElsePartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_structured_if (& typeid (cPtr_instruction_structured_if), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_structured_if::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_structured_if ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_structured_if::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_structured_if (mInstructionLocation, mIfCondition, mThenInstructionList, mElseInstructionList, mEndOfElsePartLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_structured_if'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_structured_if GGS_instruction_structured_if::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_structured_if *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_structured_if) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_structured_if (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_structured_if),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if GGS_instruction_structured_if::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_conditionExpression & argument_1,
                 const GGS_instructionList & argument_2,
                 const GGS_instructionList & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if result ;
  macroMyNew (result.mPointer, cPtr_instruction_structured_if (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_instruction_structured_if::
reader_mIfCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mIfCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mThenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mThenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_instruction_structured_if::
reader_mEndOfElsePartLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mEndOfElsePartLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_structured_if::actualTypeName (void) const {
  return "instruction_structured_if" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_structured_if ("instruction_structured_if", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@partList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_partList::
elementOf_GGS_partList (const GGS_conditionExpression & argument_0,
                                const GGS_instructionList & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCondition (argument_0),
mInstructionList (argument_1),
mEndOfPartLocation (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_partList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_partList * ptr = dynamic_cast <const elementOf_GGS_partList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCondition.operator_isEqual (ptr->mCondition).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfPartLocation.operator_isEqual (ptr->mEndOfPartLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_partList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCondition.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfPartLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             List '@partList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_partList::
_internalAppendValues (const GGS_conditionExpression & argument_0,
                    const GGS_instructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
_internalPrependValues (const GGS_conditionExpression & argument_0,
                    const GGS_instructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
_addAssign_operation (const GGS_conditionExpression & argument_0,
                                const GGS_instructionList & argument_1,
                                const GGS_location & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_partList GGS_partList::
operator_concat (const GGS_partList & inOperand) const {
  GGS_partList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
dotAssign_operation (const GGS_partList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_partList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_conditionExpression  p_0 = p->mCondition ;
          GGS_instructionList  p_1 = p->mInstructionList ;
          GGS_location  p_2 = p->mEndOfPartLocation ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_conditionExpression & argument_0,
                     const GGS_instructionList & argument_1,
                     const GGS_location & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCondition,
                                ptr->mInstructionList,
                                ptr->mEndOfPartLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partList  GGS_partList::
constructor_emptyList (void) {
  GGS_partList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partList  GGS_partList::
constructor_listWithValue (const GGS_conditionExpression & argument_0,
                                const GGS_instructionList & argument_1,
                                const GGS_location & argument_2) {
  GGS_partList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
internalSubListWithRange (GGS_partList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mCondition, ptr->mInstructionList, ptr->mEndOfPartLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partList GGS_partList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_partList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partList GGS_partList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_partList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_partList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@partList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
method_first (C_Compiler & inLexique,
              GGS_conditionExpression & _out_0,
              GGS_instructionList & _out_1,
              GGS_location & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCondition ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mEndOfPartLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
method_last (C_Compiler & inLexique,
             GGS_conditionExpression & _out_0,
             GGS_instructionList & _out_1,
             GGS_location & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCondition ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mEndOfPartLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_conditionExpression & _out_0,
                 GGS_instructionList & _out_1,
                 GGS_location & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCondition ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mEndOfPartLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_popLast (C_Compiler & inLexique,
                GGS_conditionExpression & _out_0,
                GGS_instructionList & _out_1,
                GGS_location & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCondition ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mEndOfPartLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_partList::
reader_mConditionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_conditionExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCondition ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_partList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_partList::
reader_mEndOfPartLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfPartLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_setMConditionAtIndex (C_Compiler & inLexique,
                              const GGS_conditionExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCondition = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partList::
modifier_setMEndOfPartLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfPartLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_conditionExpression  & GGS_partList::cEnumerator::_mCondition (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mCondition ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_partList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_partList::cEnumerator::_mEndOfPartLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndOfPartLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_do_while'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_do_while::
cPtr_instruction_do_while (const GGS_location & argument_0,
                                const GGS_instructionList & argument_1,
                                const GGS_location & argument_2,
                                const GGS_partList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mRepeatedInstructionList (argument_1),
mEndOfRepeatedInstructionList (argument_2),
mWhilePartList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_do_while * GGS_instruction_do_while::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_do_while *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_do_while::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_do_while * ptr = dynamic_cast <const cPtr_instruction_do_while *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRepeatedInstructionList.operator_isEqual (ptr->mRepeatedInstructionList).boolValue ()
         && mEndOfRepeatedInstructionList.operator_isEqual (ptr->mEndOfRepeatedInstructionList).boolValue ()
         && mWhilePartList.operator_isEqual (ptr->mWhilePartList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_do_while::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_do_while:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRepeatedInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfRepeatedInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWhilePartList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_do_while::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_do_while::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_do_while (& typeid (cPtr_instruction_do_while), & typeid (cPtr_piccolo_instruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_do_while::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_do_while ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_instruction_do_while::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_instruction_do_while (mInstructionLocation, mRepeatedInstructionList, mEndOfRepeatedInstructionList, mWhilePartList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_do_while'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_do_while::
GGS_instruction_do_while (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_do_while::
GGS_instruction_do_while (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_instruction_do_while GGS_instruction_do_while::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_do_while result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_do_while *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_do_while) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_instruction_do_while (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_do_while),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_do_while GGS_instruction_do_while::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instructionList & argument_1,
                 const GGS_location & argument_2,
                 const GGS_partList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_do_while result ;
  macroMyNew (result.mPointer, cPtr_instruction_do_while (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_do_while::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_do_while *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_instruction_do_while::
reader_mEndOfRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_do_while *) mPointer)->mEndOfRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partList  GGS_instruction_do_while::
reader_mWhilePartList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_partList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_do_while *) mPointer)->mWhilePartList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_do_while::actualTypeName (void) const {
  return "instruction_do_while" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_do_while ("instruction_do_while", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@interruptDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_interruptDefinitionList::
elementOf_GGS_interruptDefinitionList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInterruptName (argument_0),
mFastReturn (argument_1),
mInstructionList (argument_2),
mEndOfInterruptLocation (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_interruptDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_interruptDefinitionList * ptr = dynamic_cast <const elementOf_GGS_interruptDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInterruptName.operator_isEqual (ptr->mInterruptName).boolValue ()
         && mFastReturn.operator_isEqual (ptr->mFastReturn).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfInterruptLocation.operator_isEqual (ptr->mEndOfInterruptLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_interruptDefinitionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInterruptName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFastReturn.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfInterruptLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@interruptDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_instructionList & argument_2,
                    const GGS_location & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_instructionList & argument_2,
                    const GGS_location & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_location & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
operator_concat (const GGS_interruptDefinitionList & inOperand) const {
  GGS_interruptDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
dotAssign_operation (const GGS_interruptDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_interruptDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mInterruptName ;
          GGS_bool p_1 = p->mFastReturn ;
          GGS_instructionList  p_2 = p->mInstructionList ;
          GGS_location  p_3 = p->mEndOfInterruptLocation ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1,
                     const GGS_instructionList & argument_2,
                     const GGS_location & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mInterruptName,
                                ptr->mFastReturn,
                                ptr->mInstructionList,
                                ptr->mEndOfInterruptLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_emptyList (void) {
  GGS_interruptDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_location & argument_3) {
  GGS_interruptDefinitionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
internalSubListWithRange (GGS_interruptDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mInterruptName, ptr->mFastReturn, ptr->mInstructionList, ptr->mEndOfInterruptLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_interruptDefinitionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@interruptDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1,
              GGS_instructionList & _out_2,
              GGS_location & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInterruptName ;
    _out_1 = ptr->mFastReturn ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mEndOfInterruptLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1,
             GGS_instructionList & _out_2,
             GGS_location & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInterruptName ;
    _out_1 = ptr->mFastReturn ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mEndOfInterruptLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1,
                 GGS_instructionList & _out_2,
                 GGS_location & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInterruptName ;
    _out_1 = ptr->mFastReturn ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mEndOfInterruptLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1,
                GGS_instructionList & _out_2,
                GGS_location & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInterruptName ;
    _out_1 = ptr->mFastReturn ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mEndOfInterruptLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_interruptDefinitionList::
reader_mInterruptNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInterruptName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_interruptDefinitionList::
reader_mFastReturnAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFastReturn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_interruptDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_interruptDefinitionList::
reader_mEndOfInterruptLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfInterruptLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInterruptNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInterruptName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMFastReturnAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFastReturn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMEndOfInterruptLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfInterruptLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_interruptDefinitionList::cEnumerator::_mInterruptName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInterruptName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_interruptDefinitionList::cEnumerator::_mFastReturn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mFastReturn ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_interruptDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_interruptDefinitionList::cEnumerator::_mEndOfInterruptLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndOfInterruptLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@routineDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDefinitionList::
elementOf_GGS_routineDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_instructionList & argument_5,
                                const GGS_location & argument_6
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mRequiredBank (argument_1),
mReturnedBank (argument_2),
mPreservesBank (argument_3),
mIsNoReturn (argument_4),
mInstructionList (argument_5),
mEndOfRoutineLocation (argument_6) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_routineDefinitionList * ptr = dynamic_cast <const elementOf_GGS_routineDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mRequiredBank.operator_isEqual (ptr->mRequiredBank).boolValue ()
         && mReturnedBank.operator_isEqual (ptr->mReturnedBank).boolValue ()
         && mPreservesBank.operator_isEqual (ptr->mPreservesBank).boolValue ()
         && mIsNoReturn.operator_isEqual (ptr->mIsNoReturn).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfRoutineLocation.operator_isEqual (ptr->mEndOfRoutineLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDefinitionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRequiredBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPreservesBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsNoReturn.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfRoutineLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_bool& argument_4,
                    const GGS_instructionList & argument_5,
                    const GGS_location & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_bool& argument_4,
                    const GGS_instructionList & argument_5,
                    const GGS_location & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_instructionList & argument_5,
                                const GGS_location & argument_6) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()&& argument_5.isBuilt ()&& argument_6.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
operator_concat (const GGS_routineDefinitionList & inOperand) const {
  GGS_routineDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
dotAssign_operation (const GGS_routineDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_routineDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_luint  p_1 = p->mRequiredBank ;
          GGS_luint  p_2 = p->mReturnedBank ;
          GGS_bool p_3 = p->mPreservesBank ;
          GGS_bool p_4 = p->mIsNoReturn ;
          GGS_instructionList  p_5 = p->mInstructionList ;
          GGS_location  p_6 = p->mEndOfRoutineLocation ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_bool& argument_4,
                     const GGS_instructionList & argument_5,
                     const GGS_location & argument_6
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mRoutineName,
                                ptr->mRequiredBank,
                                ptr->mReturnedBank,
                                ptr->mPreservesBank,
                                ptr->mIsNoReturn,
                                ptr->mInstructionList,
                                ptr->mEndOfRoutineLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_emptyList (void) {
  GGS_routineDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_instructionList & argument_5,
                                const GGS_location & argument_6) {
  GGS_routineDefinitionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
internalSubListWithRange (GGS_routineDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mRoutineName, ptr->mRequiredBank, ptr->mReturnedBank, ptr->mPreservesBank, ptr->mIsNoReturn, ptr->mInstructionList, ptr->mEndOfRoutineLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDefinitionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@routineDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_bool& _out_3,
              GGS_bool& _out_4,
              GGS_instructionList & _out_5,
              GGS_location & _out_6
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _out_5 = ptr->mInstructionList ;
    _out_6 = ptr->mEndOfRoutineLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_bool& _out_3,
             GGS_bool& _out_4,
             GGS_instructionList & _out_5,
             GGS_location & _out_6
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _out_5 = ptr->mInstructionList ;
    _out_6 = ptr->mEndOfRoutineLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_bool& _out_3,
                 GGS_bool& _out_4,
                 GGS_instructionList & _out_5,
                 GGS_location & _out_6
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _out_5 = ptr->mInstructionList ;
    _out_6 = ptr->mEndOfRoutineLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_bool& _out_3,
                GGS_bool& _out_4,
                GGS_instructionList & _out_5,
                GGS_location & _out_6
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _out_5 = ptr->mInstructionList ;
    _out_6 = ptr->mEndOfRoutineLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDefinitionList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDefinitionList::
reader_mRequiredBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRequiredBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDefinitionList::
reader_mReturnedBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDefinitionList::
reader_mPreservesBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPreservesBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDefinitionList::
reader_mIsNoReturnAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsNoReturn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_routineDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_routineDefinitionList::
reader_mEndOfRoutineLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfRoutineLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMRequiredBankAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRequiredBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMReturnedBankAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMPreservesBankAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPreservesBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMIsNoReturnAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsNoReturn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMEndOfRoutineLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfRoutineLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_routineDefinitionList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDefinitionList::cEnumerator::_mRequiredBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRequiredBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDefinitionList::cEnumerator::_mReturnedBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mReturnedBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDefinitionList::cEnumerator::_mPreservesBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mPreservesBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDefinitionList::cEnumerator::_mIsNoReturn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mIsNoReturn ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_routineDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_routineDefinitionList::cEnumerator::_mEndOfRoutineLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndOfRoutineLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@routineDeclarationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDeclarationList::
elementOf_GGS_routineDeclarationList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mRequiredBank (argument_1),
mReturnedBank (argument_2),
mPreservesBank (argument_3),
mIsNoReturn (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_routineDeclarationList * ptr = dynamic_cast <const elementOf_GGS_routineDeclarationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mRequiredBank.operator_isEqual (ptr->mRequiredBank).boolValue ()
         && mReturnedBank.operator_isEqual (ptr->mReturnedBank).boolValue ()
         && mPreservesBank.operator_isEqual (ptr->mPreservesBank).boolValue ()
         && mIsNoReturn.operator_isEqual (ptr->mIsNoReturn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDeclarationList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRequiredBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPreservesBank.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsNoReturn.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList GGS_routineDeclarationList::
operator_concat (const GGS_routineDeclarationList & inOperand) const {
  GGS_routineDeclarationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
dotAssign_operation (const GGS_routineDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_routineDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_luint  p_1 = p->mRequiredBank ;
          GGS_luint  p_2 = p->mReturnedBank ;
          GGS_bool p_3 = p->mPreservesBank ;
          GGS_bool p_4 = p->mIsNoReturn ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_bool& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mRoutineName,
                                ptr->mRequiredBank,
                                ptr->mReturnedBank,
                                ptr->mPreservesBank,
                                ptr->mIsNoReturn
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList  GGS_routineDeclarationList::
constructor_emptyList (void) {
  GGS_routineDeclarationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList  GGS_routineDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_bool& argument_4) {
  GGS_routineDeclarationList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
internalSubListWithRange (GGS_routineDeclarationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mRoutineName, ptr->mRequiredBank, ptr->mReturnedBank, ptr->mPreservesBank, ptr->mIsNoReturn) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList GGS_routineDeclarationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList GGS_routineDeclarationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDeclarationList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@routineDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_bool& _out_3,
              GGS_bool& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_bool& _out_3,
             GGS_bool& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_bool& _out_3,
                 GGS_bool& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_bool& _out_3,
                GGS_bool& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mRequiredBank ;
    _out_2 = ptr->mReturnedBank ;
    _out_3 = ptr->mPreservesBank ;
    _out_4 = ptr->mIsNoReturn ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDeclarationList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDeclarationList::
reader_mRequiredBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRequiredBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDeclarationList::
reader_mReturnedBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDeclarationList::
reader_mPreservesBankAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPreservesBank ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDeclarationList::
reader_mIsNoReturnAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsNoReturn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_setMRequiredBankAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRequiredBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_setMReturnedBankAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_setMPreservesBankAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPreservesBank = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_setMIsNoReturnAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsNoReturn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_routineDeclarationList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDeclarationList::cEnumerator::_mRequiredBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRequiredBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDeclarationList::cEnumerator::_mReturnedBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mReturnedBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDeclarationList::cEnumerator::_mPreservesBank (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mPreservesBank ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDeclarationList::cEnumerator::_mIsNoReturn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mIsNoReturn ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class for 'programKind' Enumeration                     *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_programKind::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_isEqual (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_isNotEqual (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_infOrEqual (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_supOrEqual (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_strictInf (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_programKind::
operator_strictSup (const GGS_programKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_programKind::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @programKind" ;
  switch (mValue) {
  case enum_bootloaderProgram:
    s << " bootloaderProgram>" ;
    break ;
  case enum_regularProgram:
    s << " regularProgram>" ;
    break ;
  case enum_userProgram:
    s << " userProgram>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of 'piccoloModel' struct                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccoloModel::GGS_piccoloModel (void) :
mProgramName (),
mProgramKind (),
mDeviceNameOrBootLoaderReference (),
mConfigDefinitionList (),
mAcceptDefaultConfiguration (),
mRamDefinitionList (),
mInterruptDefinitionList (),
mConstantDefinitionList (),
mRoutineDefinitionList (),
mNeedsComputedGoto2 (),
mNeedsComputedGoto4 (),
mEndOfProgram () {
}

//---------------------------------------------------------------------------*

GGS_piccoloModel::~GGS_piccoloModel (void) {
}

//---------------------------------------------------------------------------*

void GGS_piccoloModel::drop (void) {
  mProgramName.drop () ;
  mProgramKind.drop () ;
  mDeviceNameOrBootLoaderReference.drop () ;
  mConfigDefinitionList.drop () ;
  mAcceptDefaultConfiguration.drop () ;
  mRamDefinitionList.drop () ;
  mInterruptDefinitionList.drop () ;
  mConstantDefinitionList.drop () ;
  mRoutineDefinitionList.drop () ;
  mNeedsComputedGoto2.drop () ;
  mNeedsComputedGoto4.drop () ;
  mEndOfProgram.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_piccoloModel::isBuilt (void) const {
  return mProgramName.isBuilt ()
    && mProgramKind.isBuilt ()
    && mDeviceNameOrBootLoaderReference.isBuilt ()
    && mConfigDefinitionList.isBuilt ()
    && mAcceptDefaultConfiguration.isBuilt ()
    && mRamDefinitionList.isBuilt ()
    && mInterruptDefinitionList.isBuilt ()
    && mConstantDefinitionList.isBuilt ()
    && mRoutineDefinitionList.isBuilt ()
    && mNeedsComputedGoto2.isBuilt ()
    && mNeedsComputedGoto4.isBuilt ()
    && mEndOfProgram.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
operator_isEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName.operator_isEqual (inOperand.mProgramName)
    .operator_and (mProgramKind.operator_isEqual (inOperand.mProgramKind))
    .operator_and (mDeviceNameOrBootLoaderReference.operator_isEqual (inOperand.mDeviceNameOrBootLoaderReference))
    .operator_and (mConfigDefinitionList.operator_isEqual (inOperand.mConfigDefinitionList))
    .operator_and (mAcceptDefaultConfiguration.operator_isEqual (inOperand.mAcceptDefaultConfiguration))
    .operator_and (mRamDefinitionList.operator_isEqual (inOperand.mRamDefinitionList))
    .operator_and (mInterruptDefinitionList.operator_isEqual (inOperand.mInterruptDefinitionList))
    .operator_and (mConstantDefinitionList.operator_isEqual (inOperand.mConstantDefinitionList))
    .operator_and (mRoutineDefinitionList.operator_isEqual (inOperand.mRoutineDefinitionList))
    .operator_and (mNeedsComputedGoto2.operator_isEqual (inOperand.mNeedsComputedGoto2))
    .operator_and (mNeedsComputedGoto4.operator_isEqual (inOperand.mNeedsComputedGoto4))
    .operator_and (mEndOfProgram.operator_isEqual (inOperand.mEndOfProgram)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
operator_isNotEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName.operator_isNotEqual (inOperand.mProgramName)
    .operator_or (mProgramKind.operator_isNotEqual (inOperand.mProgramKind))
    .operator_or (mDeviceNameOrBootLoaderReference.operator_isNotEqual (inOperand.mDeviceNameOrBootLoaderReference))
    .operator_or (mConfigDefinitionList.operator_isNotEqual (inOperand.mConfigDefinitionList))
    .operator_or (mAcceptDefaultConfiguration.operator_isNotEqual (inOperand.mAcceptDefaultConfiguration))
    .operator_or (mRamDefinitionList.operator_isNotEqual (inOperand.mRamDefinitionList))
    .operator_or (mInterruptDefinitionList.operator_isNotEqual (inOperand.mInterruptDefinitionList))
    .operator_or (mConstantDefinitionList.operator_isNotEqual (inOperand.mConstantDefinitionList))
    .operator_or (mRoutineDefinitionList.operator_isNotEqual (inOperand.mRoutineDefinitionList))
    .operator_or (mNeedsComputedGoto2.operator_isNotEqual (inOperand.mNeedsComputedGoto2))
    .operator_or (mNeedsComputedGoto4.operator_isNotEqual (inOperand.mNeedsComputedGoto4))
    .operator_or (mEndOfProgram.operator_isNotEqual (inOperand.mEndOfProgram)) ;
}

//---------------------------------------------------------------------------*

GGS_piccoloModel GGS_piccoloModel::
constructor_new (const GGS_lstring & argument_0,
                 const GGS_programKind& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_configDefinitionList & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_ramDefinitionList & argument_5,
                 const GGS_interruptDefinitionList & argument_6,
                 const GGS_constantDefinitionList & argument_7,
                 const GGS_routineDefinitionList & argument_8,
                 const GGS_bool& argument_9,
                 const GGS_bool& argument_10,
                 const GGS_location & argument_11) {
  GGS_piccoloModel result ;
  result.mProgramName = argument_0 ;
  result.mProgramKind = argument_1 ;
  result.mDeviceNameOrBootLoaderReference = argument_2 ;
  result.mConfigDefinitionList = argument_3 ;
  result.mAcceptDefaultConfiguration = argument_4 ;
  result.mRamDefinitionList = argument_5 ;
  result.mInterruptDefinitionList = argument_6 ;
  result.mConstantDefinitionList = argument_7 ;
  result.mRoutineDefinitionList = argument_8 ;
  result.mNeedsComputedGoto2 = argument_9 ;
  result.mNeedsComputedGoto4 = argument_10 ;
  result.mEndOfProgram = argument_11 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_piccoloModel::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @piccoloModel" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mProgramName " ;
    _s << mProgramName.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mProgramKind " ;
    _s << mProgramKind.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDeviceNameOrBootLoaderReference " ;
    _s << mDeviceNameOrBootLoaderReference.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mConfigDefinitionList " ;
    _s << mConfigDefinitionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAcceptDefaultConfiguration " ;
    _s << mAcceptDefaultConfiguration.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRamDefinitionList " ;
    _s << mRamDefinitionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mInterruptDefinitionList " ;
    _s << mInterruptDefinitionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mConstantDefinitionList " ;
    _s << mConstantDefinitionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineDefinitionList " ;
    _s << mRoutineDefinitionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto2 " ;
    _s << mNeedsComputedGoto2.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto4 " ;
    _s << mNeedsComputedGoto4.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mEndOfProgram " ;
    _s << mEndOfProgram.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

