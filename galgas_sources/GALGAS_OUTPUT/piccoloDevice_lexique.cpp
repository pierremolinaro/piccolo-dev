//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'piccoloDevice_lexique.cpp'                      *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 28th, 2009, at 22h1'15"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "piccoloDevice_lexique.h"

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_piccoloDevice_lexique::cTokenFor_piccoloDevice_lexique (void) :
identifierString (),
uint32value (),
charValue (),
tokenString () {
}

//---------------------------------------------------------------------------*

piccoloDevice_lexique::
piccoloDevice_lexique (C_Compiler * inCallerCompiler,
                const GGS_string & inDependancyFileExtension,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependancyFileExtension, inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*

piccoloDevice_lexique::
piccoloDevice_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const char * gErrorMessage_0 = "hex number too large" ;
//--- Message 1
static const char * gErrorMessage_1 = "decimal number too large" ;
//--- Message 2
static const char * gErrorMessage_2 = "internal error" ;
//--- Message 3
static const char * gErrorMessage_3 = "incorrect literal character" ;
//--- Message 4
static const char * gErrorMessage_4 = "ASCII code > 255" ;
//--- Message 5
static const char * gErrorMessage_5 = "string does not end with '\"'" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$identifier$' :
static const char * gSyntaxErrorMessage_identifier = "an identifier" ;

//--- Syntax error message for terminal '$controller$' :
static const char * gSyntaxErrorMessage_controller = "the 'controller' keyword" ;

//--- Syntax error message for terminal '$processor$' :
static const char * gSyntaxErrorMessage_processor = "the 'processor' keyword" ;

//--- Syntax error message for terminal '$romsize$' :
static const char * gSyntaxErrorMessage_romsize = "the 'romsize' keyword" ;

//--- Syntax error message for terminal '$eepromsize$' :
static const char * gSyntaxErrorMessage_eepromsize = "the 'eepromsize' keyword" ;

//--- Syntax error message for terminal '$bank$' :
static const char * gSyntaxErrorMessage_bank = "the 'bank' keyword" ;

//--- Syntax error message for terminal '$unusedregister$' :
static const char * gSyntaxErrorMessage_unusedregister = "the 'unusedregister' keyword" ;

//--- Syntax error message for terminal '$mirrorat$' :
static const char * gSyntaxErrorMessage_mirrorat = "the 'mirrorat' keyword" ;

//--- Syntax error message for terminal '$ram$' :
static const char * gSyntaxErrorMessage_ram = "the 'ram' keyword" ;

//--- Syntax error message for terminal '$register$' :
static const char * gSyntaxErrorMessage_register = "the 'register' keyword" ;

//--- Syntax error message for terminal '$at$' :
static const char * gSyntaxErrorMessage_at = "the 'at' keyword" ;

//--- Syntax error message for terminal '$to$' :
static const char * gSyntaxErrorMessage_to = "the 'to' keyword" ;

//--- Syntax error message for terminal '$configuration$' :
static const char * gSyntaxErrorMessage_configuration = "the 'configuration' keyword" ;

//--- Syntax error message for terminal '$width$' :
static const char * gSyntaxErrorMessage_width = "the 'width' keyword" ;

//--- Syntax error message for terminal '$description$' :
static const char * gSyntaxErrorMessage_description = "the 'description' keyword" ;

//--- Syntax error message for terminal '$mask$' :
static const char * gSyntaxErrorMessage_mask = "the 'mask' keyword" ;

//--- Syntax error message for terminal '$illegal$' :
static const char * gSyntaxErrorMessage_illegal = "the 'illegal' keyword" ;

//--- Syntax error message for terminal '$message$' :
static const char * gSyntaxErrorMessage_message = "the 'message' keyword" ;

//--- Syntax error message for terminal '$setting$' :
static const char * gSyntaxErrorMessage_setting = "the 'setting' keyword" ;

//--- Syntax error message for terminal '$integer$' :
static const char * gSyntaxErrorMessage_integer = "a 32-bit unsigned number" ;

//--- Syntax error message for terminal '$<$' :
static const char * gSyntaxErrorMessage__3C = "the '<' delimitor" ;

//--- Syntax error message for terminal '$>$' :
static const char * gSyntaxErrorMessage__3E = "the '>' delimitor" ;

//--- Syntax error message for terminal '$,$' :
static const char * gSyntaxErrorMessage__2C = "the ',' delimitor" ;

//--- Syntax error message for terminal '$-$' :
static const char * gSyntaxErrorMessage__2D = "the '-' delimitor" ;

//--- Syntax error message for terminal '$/$' :
static const char * gSyntaxErrorMessage__2F = "the '/' delimitor" ;

//--- Syntax error message for terminal '$;$' :
static const char * gSyntaxErrorMessage__3B = "the ';' delimitor" ;

//--- Syntax error message for terminal '$:$' :
static const char * gSyntaxErrorMessage__3A = "the ':' delimitor" ;

//--- Syntax error message for terminal '$[$' :
static const char * gSyntaxErrorMessage__5B = "the '[' delimitor" ;

//--- Syntax error message for terminal '$]$' :
static const char * gSyntaxErrorMessage__5D = "the ']' delimitor" ;

//--- Syntax error message for terminal '${$' :
static const char * gSyntaxErrorMessage__7B = "the '{' delimitor" ;

//--- Syntax error message for terminal '$}$' :
static const char * gSyntaxErrorMessage__7D = "the '}' delimitor" ;

//--- Syntax error message for terminal '$string$' :
static const char * gSyntaxErrorMessage_string = "a character string constant \"...\"" ;

//--- Syntax error message for terminal '$comment$' :
static const char * gSyntaxErrorMessage_comment = "a comment" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void piccoloDevice_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [34] = {"end of source",
       gSyntaxErrorMessage_identifier,
       gSyntaxErrorMessage_controller,
       gSyntaxErrorMessage_processor,
       gSyntaxErrorMessage_romsize,
       gSyntaxErrorMessage_eepromsize,
       gSyntaxErrorMessage_bank,
       gSyntaxErrorMessage_unusedregister,
       gSyntaxErrorMessage_mirrorat,
       gSyntaxErrorMessage_ram,
       gSyntaxErrorMessage_register,
       gSyntaxErrorMessage_at,
       gSyntaxErrorMessage_to,
       gSyntaxErrorMessage_configuration,
       gSyntaxErrorMessage_width,
       gSyntaxErrorMessage_description,
       gSyntaxErrorMessage_mask,
       gSyntaxErrorMessage_illegal,
       gSyntaxErrorMessage_message,
       gSyntaxErrorMessage_setting,
       gSyntaxErrorMessage_integer,
       gSyntaxErrorMessage__3C,
       gSyntaxErrorMessage__3E,
       gSyntaxErrorMessage__2C,
       gSyntaxErrorMessage__2D,
       gSyntaxErrorMessage__2F,
       gSyntaxErrorMessage__3B,
       gSyntaxErrorMessage__3A,
       gSyntaxErrorMessage__5B,
       gSyntaxErrorMessage__5D,
       gSyntaxErrorMessage__7B,
       gSyntaxErrorMessage__7D,
       gSyntaxErrorMessage_string,
       gSyntaxErrorMessage_comment} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'controlKeyWordList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 piccoloDevice_lexique::piccoloDevice_lexique_table_size_controlKeyWordList = 18 ;

const C_lexique_table_entry piccoloDevice_lexique::piccoloDevice_lexique_table_for_controlKeyWordList [18] = {
  C_lexique_table_entry ("at", 2, piccoloDevice_lexique_1_at),
  C_lexique_table_entry ("to", 2, piccoloDevice_lexique_1_to),
  C_lexique_table_entry ("ram", 3, piccoloDevice_lexique_1_ram),
  C_lexique_table_entry ("bank", 4, piccoloDevice_lexique_1_bank),
  C_lexique_table_entry ("mask", 4, piccoloDevice_lexique_1_mask),
  C_lexique_table_entry ("width", 5, piccoloDevice_lexique_1_width),
  C_lexique_table_entry ("illegal", 7, piccoloDevice_lexique_1_illegal),
  C_lexique_table_entry ("message", 7, piccoloDevice_lexique_1_message),
  C_lexique_table_entry ("romsize", 7, piccoloDevice_lexique_1_romsize),
  C_lexique_table_entry ("setting", 7, piccoloDevice_lexique_1_setting),
  C_lexique_table_entry ("mirrorat", 8, piccoloDevice_lexique_1_mirrorat),
  C_lexique_table_entry ("register", 8, piccoloDevice_lexique_1_register),
  C_lexique_table_entry ("processor", 9, piccoloDevice_lexique_1_processor),
  C_lexique_table_entry ("controller", 10, piccoloDevice_lexique_1_controller),
  C_lexique_table_entry ("eepromsize", 10, piccoloDevice_lexique_1_eepromsize),
  C_lexique_table_entry ("description", 11, piccoloDevice_lexique_1_description),
  C_lexique_table_entry ("configuration", 13, piccoloDevice_lexique_1_configuration),
  C_lexique_table_entry ("unusedregister", 14, piccoloDevice_lexique_1_unusedregister)
} ;

sint16 piccoloDevice_lexique::search_into_controlKeyWordList (const C_String & inSearchedString) {
  return searchInList (inSearchedString, piccoloDevice_lexique_table_for_controlKeyWordList, piccoloDevice_lexique_table_size_controlKeyWordList) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Key words table 'delimitorsList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 piccoloDevice_lexique::piccoloDevice_lexique_table_size_delimitorsList = 11 ;

const C_lexique_table_entry piccoloDevice_lexique::piccoloDevice_lexique_table_for_delimitorsList [11] = {
  C_lexique_table_entry (",", 1, piccoloDevice_lexique_1__2C),
  C_lexique_table_entry ("-", 1, piccoloDevice_lexique_1__2D),
  C_lexique_table_entry ("/", 1, piccoloDevice_lexique_1__2F),
  C_lexique_table_entry (":", 1, piccoloDevice_lexique_1__3A),
  C_lexique_table_entry (";", 1, piccoloDevice_lexique_1__3B),
  C_lexique_table_entry ("<", 1, piccoloDevice_lexique_1__3C),
  C_lexique_table_entry (">", 1, piccoloDevice_lexique_1__3E),
  C_lexique_table_entry ("[", 1, piccoloDevice_lexique_1__5B),
  C_lexique_table_entry ("]", 1, piccoloDevice_lexique_1__5D),
  C_lexique_table_entry ("{", 1, piccoloDevice_lexique_1__7B),
  C_lexique_table_entry ("}", 1, piccoloDevice_lexique_1__7D)
} ;

sint16 piccoloDevice_lexique::search_into_delimitorsList (const C_String & inSearchedString) {
  return searchInList (inSearchedString, piccoloDevice_lexique_table_for_delimitorsList, piccoloDevice_lexique_table_size_delimitorsList) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String piccoloDevice_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  piccoloDevice_lexique_1_:
      s << "$$" ;
      break ;
    case  piccoloDevice_lexique_1_identifier:
      s << '$'
        << "identifier"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  piccoloDevice_lexique_1_controller:
      s << '$'
        << "controller"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_processor:
      s << '$'
        << "processor"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_romsize:
      s << '$'
        << "romsize"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_eepromsize:
      s << '$'
        << "eepromsize"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_bank:
      s << '$'
        << "bank"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_unusedregister:
      s << '$'
        << "unusedregister"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_mirrorat:
      s << '$'
        << "mirrorat"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_ram:
      s << '$'
        << "ram"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_register:
      s << '$'
        << "register"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_at:
      s << '$'
        << "at"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_to:
      s << '$'
        << "to"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_configuration:
      s << '$'
        << "configuration"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_width:
      s << '$'
        << "width"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_description:
      s << '$'
        << "description"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_mask:
      s << '$'
        << "mask"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_illegal:
      s << '$'
        << "illegal"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_message:
      s << '$'
        << "message"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_setting:
      s << '$'
        << "setting"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_integer:
      s << '$'
        << "integer"
        << '$' ;
    s << ' ' << _p->uint32value ;
      break;
    case  piccoloDevice_lexique_1__3C:
      s << '$'
        << "<"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__3E:
      s << '$'
        << ">"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__2C:
      s << '$'
        << ","
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__2D:
      s << '$'
        << "-"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__2F:
      s << '$'
        << "/"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__3B:
      s << '$'
        << ";"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__3A:
      s << '$'
        << ":"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__5B:
      s << '$'
        << "["
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__5D:
      s << '$'
        << "]"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__7B:
      s << '$'
        << "{"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1__7D:
      s << '$'
        << "}"
        << '$' ;
      break;
    case  piccoloDevice_lexique_1_string:
      s << '$'
        << "string"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  piccoloDevice_lexique_1_comment:
      s << '$'
        << "comment"
        << '$' ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool piccoloDevice_lexique::
parseLexicalToken (void) {
  cTokenFor_piccoloDevice_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while ((_token._mTokenCode < 0) && (mCurrentChar != '\0')) {
    _token.identifierString.clear () ;
    _token.uint32value = 0 ;
    _token.charValue = '\0' ;
    _token.tokenString.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.identifierString, scanner_action_toLower (previousChar ())) ;
          scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_controlKeyWordList (_token.identifierString) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = piccoloDevice_lexique_1_identifier ;
        }
        _enterToken (_token) ;
      }else if (testForInputString ("0x", 2)) {
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('a', 'f')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('A', 'F')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = piccoloDevice_lexique_1_integer ;
        _enterToken (_token) ;
      }else if (testForInputChar ('0', '9')) {
        scanner_action_enterDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = piccoloDevice_lexique_1_integer ;
        _enterToken (_token) ;
      }else if (testForInputString ("<", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3C ;
        _enterToken (_token) ;
      }else if (testForInputString (">", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3E ;
        _enterToken (_token) ;
      }else if (testForInputString (",", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2C ;
        _enterToken (_token) ;
      }else if (testForInputString ("-", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2D ;
        _enterToken (_token) ;
      }else if (testForInputString ("/", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2F ;
        _enterToken (_token) ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3B ;
        _enterToken (_token) ;
      }else if (testForInputString (":", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3A ;
        _enterToken (_token) ;
      }else if (testForInputString ("[", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__5B ;
        _enterToken (_token) ;
      }else if (testForInputString ("]", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__5D ;
        _enterToken (_token) ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__7B ;
        _enterToken (_token) ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__7D ;
        _enterToken (_token) ;
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar ('\\')) {
            if (testForInputChar ('f')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\f') ;
            }else if (testForInputChar ('n')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\n') ;
            }else if (testForInputChar ('r')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\r') ;
            }else if (testForInputChar ('t')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\t') ;
            }else if (testForInputChar ('v')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\v') ;
            }else if (testForInputChar ('\\')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\\') ;
            }else if (testForInputChar ('0')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\0') ;
            }else if (testForInputChar ('\"')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
            }else if (testForInputChar ('\'')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
            }else if (testForInputChar ('0', '9')) {
              do {
                scanner_action_enterHexDigitIntoASCIIcharacter (_token.charValue, previousChar (), gErrorMessage_4, gErrorMessage_2) ;
                if (testForInputChar ('0', '9')) {
                }else{
                  loop_ = false ;
                }
              }while (loop_) ;
              loop_ = true ;
              scanner_action_enterCharacterIntoString (_token.tokenString, _token.charValue) ;
            }else{
              lexicalError (gErrorMessage_3 COMMA_LINE_AND_SOURCE_FILE) ;
            }
          }else if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = piccoloDevice_lexique_1_string ;
          _enterToken (_token) ;
        }else{
          lexicalError (gErrorMessage_5 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('#')) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = piccoloDevice_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  if ((mCurrentChar == '\0') && (_token._mTemplateStringBeforeToken.length () > 0)) {
    _token._mTokenCode = 0 ;
    _enterToken (_token) ;
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 piccoloDevice_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_piccoloDevice_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.identifierString.clear () ;
    _token.uint32value = 0 ;
    _token.charValue = '\0' ;
    _token.tokenString.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.identifierString, scanner_action_toLower (previousChar ())) ;
          scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_controlKeyWordList (_token.identifierString) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = piccoloDevice_lexique_1_identifier ;
        }
      }else if (testForInputString ("0x", 2)) {
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('a', 'f')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('A', 'F')) {
            scanner_action_enterHexDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_0, gErrorMessage_2) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = piccoloDevice_lexique_1_integer ;
      }else if (testForInputChar ('0', '9')) {
        scanner_action_enterDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterDigitIntoUlong (_token.uint32value, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = piccoloDevice_lexique_1_integer ;
      }else if (testForInputString ("<", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3C ;
      }else if (testForInputString (">", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3E ;
      }else if (testForInputString (",", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2C ;
      }else if (testForInputString ("-", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2D ;
      }else if (testForInputString ("/", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__2F ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3B ;
      }else if (testForInputString (":", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__3A ;
      }else if (testForInputString ("[", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__5B ;
      }else if (testForInputString ("]", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__5D ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__7B ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = piccoloDevice_lexique_1__7D ;
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar ('\\')) {
            if (testForInputChar ('f')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\f') ;
            }else if (testForInputChar ('n')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\n') ;
            }else if (testForInputChar ('r')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\r') ;
            }else if (testForInputChar ('t')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\t') ;
            }else if (testForInputChar ('v')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\v') ;
            }else if (testForInputChar ('\\')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\\') ;
            }else if (testForInputChar ('0')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\0') ;
            }else if (testForInputChar ('\"')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
            }else if (testForInputChar ('\'')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
            }else if (testForInputChar ('0', '9')) {
              do {
                scanner_action_enterHexDigitIntoASCIIcharacter (_token.charValue, previousChar (), gErrorMessage_4, gErrorMessage_2) ;
                if (testForInputChar ('0', '9')) {
                }else{
                  loop_ = false ;
                }
              }while (loop_) ;
              loop_ = true ;
              scanner_action_enterCharacterIntoString (_token.tokenString, _token.charValue) ;
            }else{
              lexicalError (gErrorMessage_3 COMMA_LINE_AND_SOURCE_FILE) ;
            }
          }else if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = piccoloDevice_lexique_1_string ;
        }else{
          lexicalError (gErrorMessage_5 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('#')) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = piccoloDevice_lexique_1_comment ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = piccoloDevice_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 piccoloDevice_lexique::getStylesCount (void) {
  return 7 ;
}

//---------------------------------------------------------------------------*

const char * piccoloDevice_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [8] = {"Default style", "Keywords:", "Instructions:", "Delimiters:", "Integer Constants:", "String Constants:", "Comments:", NULL} ;
  return (inIndex < 7) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * piccoloDevice_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [8] = {"", "keywordStyle", "instructionStyle", "delimitersStyle", "integerStyle", "stringStyle", "commentStyle", NULL} ;
  return (inIndex < 7) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 piccoloDevice_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [34] = {0,
    0 /* piccoloDevice_lexique_1_identifier */,
    1 /* piccoloDevice_lexique_1_controller */,
    1 /* piccoloDevice_lexique_1_processor */,
    1 /* piccoloDevice_lexique_1_romsize */,
    1 /* piccoloDevice_lexique_1_eepromsize */,
    1 /* piccoloDevice_lexique_1_bank */,
    1 /* piccoloDevice_lexique_1_unusedregister */,
    1 /* piccoloDevice_lexique_1_mirrorat */,
    1 /* piccoloDevice_lexique_1_ram */,
    1 /* piccoloDevice_lexique_1_register */,
    1 /* piccoloDevice_lexique_1_at */,
    1 /* piccoloDevice_lexique_1_to */,
    1 /* piccoloDevice_lexique_1_configuration */,
    1 /* piccoloDevice_lexique_1_width */,
    1 /* piccoloDevice_lexique_1_description */,
    1 /* piccoloDevice_lexique_1_mask */,
    1 /* piccoloDevice_lexique_1_illegal */,
    1 /* piccoloDevice_lexique_1_message */,
    1 /* piccoloDevice_lexique_1_setting */,
    4 /* piccoloDevice_lexique_1_integer */,
    3 /* piccoloDevice_lexique_1__3C */,
    3 /* piccoloDevice_lexique_1__3E */,
    3 /* piccoloDevice_lexique_1__2C */,
    3 /* piccoloDevice_lexique_1__2D */,
    3 /* piccoloDevice_lexique_1__2F */,
    3 /* piccoloDevice_lexique_1__3B */,
    3 /* piccoloDevice_lexique_1__3A */,
    3 /* piccoloDevice_lexique_1__5B */,
    3 /* piccoloDevice_lexique_1__5D */,
    3 /* piccoloDevice_lexique_1__7B */,
    3 /* piccoloDevice_lexique_1__7D */,
    5 /* piccoloDevice_lexique_1_string */,
    6 /* piccoloDevice_lexique_1_comment */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void piccoloDevice_lexique::_enterToken (const cTokenFor_piccoloDevice_lexique & inToken) {
  cTokenFor_piccoloDevice_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_piccoloDevice_lexique ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mFirstLocation = _mTokenFirstLocation ;
  _p->_mLastLocation  = _mTokenLastLocation ;
  _p->_mTemplateStringBeforeToken  = inToken._mTemplateStringBeforeToken ;
  _p->identifierString = inToken.identifierString ;
  _p->uint32value = inToken.uint32value ;
  _p->charValue = inToken.charValue ;
  _p->tokenString = inToken.tokenString ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void piccoloDevice_lexique::
_assignFromAttribute_identifierString (GGS_lstring & outValue) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->identifierString) ;
}

//---------------------------------------------------------------------------*

C_String piccoloDevice_lexique::
_attributeValue_identifierString (void) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  return _p->identifierString ;
}

//---------------------------------------------------------------------------*

void piccoloDevice_lexique::
_assignFromAttribute_uint32value (GGS_luint & outValue) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  outValue = GGS_luint (* this, _p->uint32value) ;
}

//---------------------------------------------------------------------------*

uint32 piccoloDevice_lexique::
_attributeValue_uint32value (void) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  return _p->uint32value ;
}

//---------------------------------------------------------------------------*

void piccoloDevice_lexique::
_assignFromAttribute_charValue (GGS_lchar & outValue) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lchar (* this, _p->charValue) ;
}

//---------------------------------------------------------------------------*

char piccoloDevice_lexique::
_attributeValue_charValue (void) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  return _p->charValue ;
}

//---------------------------------------------------------------------------*

void piccoloDevice_lexique::
_assignFromAttribute_tokenString (GGS_lstring & outValue) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->tokenString) ;
}

//---------------------------------------------------------------------------*

C_String piccoloDevice_lexique::
_attributeValue_tokenString (void) const {
  cTokenFor_piccoloDevice_lexique * _p = (cTokenFor_piccoloDevice_lexique *) mCurrentTokenPtr ;
  return _p->tokenString ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

