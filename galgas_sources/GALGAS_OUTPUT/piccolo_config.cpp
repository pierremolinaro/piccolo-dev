//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'piccolo_config.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      august 7th, 2008, at 22h13'15"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_config.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_config.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_configFieldMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_configFieldMap::e_configFieldMap (void) :
mRegisterName (),
mMaskValue (),
mDescription (),
mFieldSettingMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@configFieldMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_configFieldMap::
elementOf_GGS_configFieldMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_configFieldMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_configFieldMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMaskValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFieldSettingMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_configFieldMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_configFieldMap * _p = dynamic_cast <const elementOf_GGS_configFieldMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRegisterName._operator_isEqual (_p->mInfo.mRegisterName)).boolValue ()
           && (mInfo.mMaskValue._operator_isEqual (_p->mInfo.mMaskValue)).boolValue ()
           && (mInfo.mDescription._operator_isEqual (_p->mInfo.mDescription)).boolValue ()
           && (mInfo.mFieldSettingMap._operator_isEqual (_p->mInfo.mFieldSettingMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_configFieldMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_configFieldMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
_operator_isEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
_operator_isNotEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_lstring & inParameter2,
                const GGS_fieldSettingMap & inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_configFieldMap info  ;
    info.mRegisterName = inParameter0 ;
    info.mMaskValue = inParameter1 ;
    info.mDescription = inParameter2 ;
    info.mFieldSettingMap = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_fieldSettingMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    outParameter3._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegisterName ;
    outParameter1 = node->mInfo.mMaskValue ;
    outParameter2 = node->mInfo.mDescription ;
    outParameter3 = node->mInfo.mFieldSettingMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMRegisterNameForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRegisterNameForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRegisterName = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMMaskValueForKey (C_Compiler & inLexique,
                        const GGS_luint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMMaskValueForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mMaskValue = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMDescriptionForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMDescriptionForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mDescription = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMFieldSettingMapForKey (C_Compiler & inLexique,
                        const GGS_fieldSettingMap & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFieldSettingMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFieldSettingMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_fieldSettingMap   & outParameter3 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' configuration field is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_fieldSettingMap & inParameter3 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' configuration field is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_configFieldMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_configFieldMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_configFieldMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @configFieldMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mRegisterName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_configFieldMap::cEnumerator::_mMaskValue (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMaskValue ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mDescription (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDescription ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_fieldSettingMap  & GGS_configFieldMap::cEnumerator::_mFieldSettingMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFieldSettingMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "actualBuildConfig"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_actualBuildConfig (C_Compiler & _inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_actualBuildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_actualConfigurationMap  var_cas_temporaryActualConfigurationMap ;
  var_cas_temporaryActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_configFieldMap  var_cas_configFieldMap ;
  var_cas_configFieldMap = GGS_configFieldMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_configRegisterMap::cEnumerator enumerator_1216 (var_cas_inConfigRegisterMap, true) ;
    const GGS_configRegisterMap::cElement * operand_1216 = NULL ;
    while (((operand_1216 = enumerator_1216.nextObject ()))) {
      macroValidPointer (operand_1216) ;
      GGS_uint  var_cas_defaultValue ;
      var_cas_defaultValue = GGS_uint (true, 1U)._left_shift_operation (_inLexique, operand_1216->mInfo.mRegisterWidth.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (31)) COMMA_SOURCE_FILE_AT_LINE (31))._substract_operation (_inLexique, GGS_uint (true, 1U) COMMA_SOURCE_FILE_AT_LINE (31)) ;
      var_cas_temporaryActualConfigurationMap.modifier_insertKey (_inLexique, operand_1216->mKey, operand_1216->mInfo.mRegisterAddress.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (32)), var_cas_defaultValue COMMA_SOURCE_FILE_AT_LINE (32)) ;
      GGS_lstring  var_cas_registerName ;
      var_cas_registerName = operand_1216->mKey ;
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_1446 (operand_1216->mInfo.mConfigRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_1446 = NULL ;
        while (((operand_1446 = enumerator_1446.nextObject ()))) {
          macroValidPointer (operand_1446) ;
          var_cas_configFieldMap.modifier_insertKey (_inLexique, operand_1446->mKey, var_cas_registerName, operand_1446->mInfo.mMaskValue, operand_1446->mInfo.mDescription, operand_1446->mInfo.mFieldSettingMap COMMA_SOURCE_FILE_AT_LINE (35)) ;
        }
      }
    }
  }
  GGS_stringset  var_cas_actualSettingNameSet ;
  var_cas_actualSettingNameSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_configDefinitionList::cEnumerator enumerator_1689 (var_cas_inConfigDefinitionList, true) ;
    const GGS_configDefinitionList::cElement * operand_1689 = NULL ;
    while (((operand_1689 = enumerator_1689.nextObject ()))) {
      macroValidPointer (operand_1689) ;
      {
        GGS_configSettingList::cEnumerator enumerator_1717 (operand_1689->mSettingList, true) ;
        const GGS_configSettingList::cElement * operand_1717 = NULL ;
        while (((operand_1717 = enumerator_1717.nextObject ()))) {
          macroValidPointer (operand_1717) ;
          if ((var_cas_actualSettingNameSet.reader_hasKey (_inLexique, operand_1717->mSettingName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (42)) COMMA_SOURCE_FILE_AT_LINE (42))).isBuiltAndTrue ()) {
            operand_1717->mSettingName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (operand_1717->mSettingName))._operator_concat (GGS_string (true, "' setting is already defined")) COMMA_SOURCE_FILE_AT_LINE (44)) ;
          }
          var_cas_actualSettingNameSet._addAssign_operation (operand_1717->mSettingName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (45))) ;
          GGS_lstring  var_cas_registerName ;
          GGS_luint  var_cas_maskValue ;
          GGS_lstring  var_cas_settingDescription ;
          GGS_fieldSettingMap  var_cas_fieldSettingMap ;
          const GGS_configFieldMap  _temp_2107 = var_cas_configFieldMap ;
          if (_temp_2107._isBuilt ()) {
            _temp_2107 (HERE)->method_searchKey (_inLexique, operand_1717->mSettingName, var_cas_registerName, var_cas_maskValue, var_cas_settingDescription, var_cas_fieldSettingMap COMMA_SOURCE_FILE_AT_LINE (50)) ;
          }
          if ((var_cas_fieldSettingMap.reader_hasKey (_inLexique, operand_1717->mSettingValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (51)) COMMA_SOURCE_FILE_AT_LINE (51))).isBuiltAndTrue ()) {
            GGS_uint  var_cas_settingValue ;
            GGS_uint  var_cas_settingMask ;
            const GGS_fieldSettingMap  _temp_2341 = var_cas_fieldSettingMap ;
            if (_temp_2341._isBuilt ()) {
              _temp_2341 (HERE)->method_searchKey (_inLexique, operand_1717->mSettingValue, var_cas_settingValue, var_cas_settingMask COMMA_SOURCE_FILE_AT_LINE (54)) ;
            }
            GGS_uint  var_cas_registerValue ;
            GGS_uint  automatic_var_0 ;
            const GGS_actualConfigurationMap  _temp_2467 = var_cas_temporaryActualConfigurationMap ;
            if (_temp_2467._isBuilt ()) {
              _temp_2467 (HERE)->method_searchKey (_inLexique, var_cas_registerName, automatic_var_0, var_cas_registerValue COMMA_SOURCE_FILE_AT_LINE (56)) ;
            }
            var_cas_registerValue = ((var_cas_registerValue)._operator_and ((var_cas_settingMask)._operator_tilde ()))._operator_or (var_cas_settingValue) ;
            var_cas_temporaryActualConfigurationMap.modifier_setMRegisterValueForKey (_inLexique, var_cas_registerValue, var_cas_registerName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (58)) COMMA_SOURCE_FILE_AT_LINE (58)) ;
          }else if (((var_cas_fieldSettingMap.reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
            GGS_string var_cas_errorMessage ;
            var_cas_errorMessage = ((((GGS_string (true, "the '"))._operator_concat (operand_1717->mSettingValue))._operator_concat (GGS_string (true, "' value is not defined for configuration setting '")))._operator_concat (operand_1717->mSettingName))._operator_concat (GGS_string (true, "'; possible values are:")) ;
            {
              GGS_fieldSettingMap::cEnumerator enumerator_2926 (var_cas_fieldSettingMap, true) ;
              const GGS_fieldSettingMap::cElement * operand_2926 = NULL ;
              while (((operand_2926 = enumerator_2926.nextObject ()))) {
                macroValidPointer (operand_2926) ;
                var_cas_errorMessage.writeString ("\n"
                  "-  \"") ;
                var_cas_errorMessage._dotAssign_operation (operand_2926->mKey) ;
                var_cas_errorMessage.writeString ("\"") ;
              }
            }
            operand_1717->mSettingValue.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (66)) ;
          }
        }
      }
    }
  }
  if (((var_cas_inAcceptDefaultConfiguration)._operator_not ()).isBuiltAndTrue ()) {
    GGS_stringset  var_cas_notDefinedSetting ;
    var_cas_notDefinedSetting = var_cas_configFieldMap.reader_allKeys (_inLexique COMMA_SOURCE_FILE_AT_LINE (71))._substract_operation (_inLexique, var_cas_actualSettingNameSet COMMA_SOURCE_FILE_AT_LINE (71)) ;
    if (((var_cas_notDefinedSetting.reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (72)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage ;
      var_cas_errorMessage = GGS_string (true, "the following configuration settings are not defined:") ;
      {
        GGS_stringset::cEnumerator enumerator_3434 (var_cas_notDefinedSetting, true) ;
        while (enumerator_3434.hc ()) {
          var_cas_errorMessage.writeString ("\n"
            "-  ") ;
          var_cas_errorMessage._dotAssign_operation (enumerator_3434._key (HERE)) ;
          enumerator_3434.next () ;
        }
      }
      GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (78)) ;
    }
  }
  var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_3777 (var_cas_temporaryActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_3777 = NULL ;
    while (((operand_3777 = enumerator_3777.nextObject ()))) {
      macroValidPointer (operand_3777) ;
      GGS_uint  var_cas_registerAddress ;
      var_cas_registerAddress = (operand_3777->mInfo.mRegisterAddress)._operator_and (GGS_uint ::constructor_max (_inLexique COMMA_HERE)._substract_operation (_inLexique, GGS_uint (true, 1U) COMMA_SOURCE_FILE_AT_LINE (84))) ;
      GGS_lstring  var_cas_newKey ;
      var_cas_newKey = GGS_lstring ::constructor_new (_inLexique, var_cas_registerAddress.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (85)), GGS_location (_inLexique) COMMA_HERE) ;
      if ((var_cas_outActualConfigurationMap.reader_hasKey (_inLexique, var_cas_newKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)) COMMA_SOURCE_FILE_AT_LINE (86))).isBuiltAndTrue ()) {
        GGS_uint  var_cas_value ;
        GGS_uint  automatic_var_1 ;
        const GGS_actualConfigurationMap  _temp_4035 = var_cas_outActualConfigurationMap ;
        if (_temp_4035._isBuilt ()) {
          _temp_4035 (HERE)->method_searchKey (_inLexique, var_cas_newKey, automatic_var_1, var_cas_value COMMA_SOURCE_FILE_AT_LINE (88)) ;
        }
        if ((((operand_3777->mInfo.mRegisterAddress)._operator_and (GGS_uint (true, 1U)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
          var_cas_value = ((var_cas_value)._operator_and (GGS_uint (true, 65280U)))._operator_or (operand_3777->mInfo.mRegisterValue) ;
        }else{
          var_cas_value = ((var_cas_value)._operator_and (GGS_uint (true, 255U)))._operator_or (operand_3777->mInfo.mRegisterValue._left_shift_operation (_inLexique, GGS_uint (true, 8U) COMMA_SOURCE_FILE_AT_LINE (92))) ;
        }
        var_cas_outActualConfigurationMap.modifier_setMRegisterValueForKey (_inLexique, var_cas_value, var_cas_newKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (94)) COMMA_SOURCE_FILE_AT_LINE (94)) ;
      }else{
        GGS_uint  var_cas_value ;
        var_cas_value = GGS_uint (true, 65535U) ;
        if ((((operand_3777->mInfo.mRegisterAddress)._operator_and (GGS_uint (true, 1U)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
          var_cas_value = (GGS_uint (true, 65280U))._operator_or (operand_3777->mInfo.mRegisterValue) ;
        }else{
          var_cas_value = (GGS_uint (true, 255U))._operator_or (operand_3777->mInfo.mRegisterValue._left_shift_operation (_inLexique, GGS_uint (true, 8U) COMMA_SOURCE_FILE_AT_LINE (100))) ;
        }
        var_cas_outActualConfigurationMap.modifier_insertKey (_inLexique, var_cas_newKey, var_cas_registerAddress, var_cas_value COMMA_SOURCE_FILE_AT_LINE (102)) ;
      }
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_4727 (var_cas_temporaryActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_4727 = NULL ;
    while (((operand_4727 = enumerator_4727.nextObject ()))) {
      macroValidPointer (operand_4727) ;
      var_cas_ioListFileContents.writeString ("Register '") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_4727->mKey) ;
      var_cas_ioListFileContents.writeString ("' at ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_4727->mInfo.mRegisterAddress.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (107))) ;
      var_cas_ioListFileContents.writeString (" set to ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_4727->mInfo.mRegisterValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (107))) ;
      var_cas_ioListFileContents.writeString ("\n") ;
      GGS_configRegisterMaskMap  var_cas_configRegisterMaskMap ;
      GGS_luint  automatic_var_2 ;
      GGS_luint  automatic_var_3 ;
      GGS_illegalMaskList  automatic_var_4 ;
      const GGS_configRegisterMap  _temp_4953 = var_cas_inConfigRegisterMap ;
      if (_temp_4953._isBuilt ()) {
        _temp_4953 (HERE)->method_searchKey (_inLexique, operand_4727->mKey, automatic_var_2, automatic_var_3, var_cas_configRegisterMaskMap, automatic_var_4 COMMA_SOURCE_FILE_AT_LINE (109)) ;
      }
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_5027 (var_cas_configRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_5027 = NULL ;
        while (((operand_5027 = enumerator_5027.nextObject ()))) {
          macroValidPointer (operand_5027) ;
          GGS_lstring  var_cas_settingName ;
          var_cas_settingName = operand_5027->mKey ;
          {
            GGS_fieldSettingMap::cEnumerator enumerator_5097 (operand_5027->mInfo.mFieldSettingMap, true) ;
            const GGS_fieldSettingMap::cElement * operand_5097 = NULL ;
            while (((operand_5097 = enumerator_5097.nextObject ()))) {
              macroValidPointer (operand_5097) ;
              if ((((operand_4727->mInfo.mRegisterValue)._operator_and (operand_5027->mInfo.mMaskValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (113))))._operator_isEqual (operand_5097->mInfo.mValue)).isBuiltAndTrue ()) {
                var_cas_ioListFileContents.writeString ("  setting '") ;
                var_cas_ioListFileContents._dotAssign_operation (var_cas_settingName) ;
                var_cas_ioListFileContents.writeString ("' set to ") ;
                var_cas_ioListFileContents._dotAssign_operation (operand_5097->mInfo.mValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (114))) ;
                var_cas_ioListFileContents.writeString (" (\"") ;
                var_cas_ioListFileContents._dotAssign_operation (operand_5097->mKey) ;
                var_cas_ioListFileContents.writeString ("\")\n") ;
              }
            }
          }
        }
      }
      var_cas_ioListFileContents.writeString ("\n") ;
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_5466 (var_cas_temporaryActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_5466 = NULL ;
    while (((operand_5466 = enumerator_5466.nextObject ()))) {
      macroValidPointer (operand_5466) ;
      GGS_illegalMaskList  var_cas_illegalMaskList ;
      GGS_luint  automatic_var_5 ;
      GGS_luint  automatic_var_6 ;
      GGS_configRegisterMaskMap  automatic_var_7 ;
      const GGS_configRegisterMap  _temp_5543 = var_cas_inConfigRegisterMap ;
      if (_temp_5543._isBuilt ()) {
        _temp_5543 (HERE)->method_searchKey (_inLexique, operand_5466->mKey, automatic_var_5, automatic_var_6, automatic_var_7, var_cas_illegalMaskList COMMA_SOURCE_FILE_AT_LINE (123)) ;
      }
      {
        GGS_illegalMaskList::cEnumerator enumerator_5606 (var_cas_illegalMaskList, true) ;
        const GGS_illegalMaskList::cElement * operand_5606 = NULL ;
        while (((operand_5606 = enumerator_5606.nextObject ()))) {
          macroValidPointer (operand_5606) ;
          if ((((operand_5466->mInfo.mRegisterValue)._operator_and (operand_5606->mIllegalMask.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (125))))._operator_isEqual (operand_5606->mIllegalValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (125)))).isBuiltAndTrue ()) {
            GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "illegal setting for '"))._operator_concat (operand_5466->mKey))._operator_concat (GGS_string (true, "' register: ")))._operator_concat (operand_5606->mDescription) COMMA_SOURCE_FILE_AT_LINE (127)) ;
            var_cas_ioListFileContents.writeString ("*** ILLEGAL SETTING for register '") ;
            var_cas_ioListFileContents._dotAssign_operation (operand_5466->mKey) ;
            var_cas_ioListFileContents.writeString ("' ***\n") ;
            var_cas_ioListFileContents.writeString ("  message: ") ;
            var_cas_ioListFileContents._dotAssign_operation (operand_5606->mDescription) ;
            var_cas_ioListFileContents.writeString ("\n"
              "\n") ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_actualBuildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "buildConfig"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildConfig (C_Compiler & _inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 79U), GGS_char (true, '*') COMMA_SOURCE_FILE_AT_LINE (144))) ;
  var_cas_ioListFileContents.writeString ("\n") ;
  var_cas_ioListFileContents.writeString ("*") ;
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "MICROCONTROLLER CONFIGURATION").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 77U), GGS_char (true, ' ') COMMA_SOURCE_FILE_AT_LINE (145))) ;
  var_cas_ioListFileContents.writeString ("*\n") ;
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 79U), GGS_char (true, '*') COMMA_SOURCE_FILE_AT_LINE (146))) ;
  var_cas_ioListFileContents.writeString ("\n"
    "\n") ;
  if (((var_cas_inConfigDefinitionList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (148)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    ::routine_actualBuildConfig (_inLexique,  var_cas_inConfigRegisterMap,  var_cas_inConfigDefinitionList,  var_cas_inAcceptDefaultConfiguration,  var_cas_ioListFileContents,  var_cas_outActualConfigurationMap COMMA_SOURCE_FILE_AT_LINE (149)) ;
  }else{
    var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
    var_cas_ioListFileContents.writeString ("No configuration.\n"
      "\n") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*

