//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'piccolo_config.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 23th, 2010, at 16h3'23"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "piccolo_config.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_config.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_configFieldMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_configFieldMap::e_configFieldMap (void) :
mRegisterName (),
mMaskValue (),
mDescription (),
mFieldSettingMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@configFieldMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_configFieldMap ("configFieldMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_configFieldMap::
elementOf_GGS_configFieldMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_configFieldMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_configFieldMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRegisterName.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMaskValue.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDescription.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFieldSettingMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_configFieldMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_configFieldMap * ptr = dynamic_cast <const elementOf_GGS_configFieldMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRegisterName.operator_isEqual (ptr->mInfo.mRegisterName)).boolValue ()
           && (mInfo.mMaskValue.operator_isEqual (ptr->mInfo.mMaskValue)).boolValue ()
           && (mInfo.mDescription.operator_isEqual (ptr->mInfo.mDescription)).boolValue ()
           && (mInfo.mFieldSettingMap.operator_isEqual (ptr->mInfo.mFieldSettingMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_configFieldMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_configFieldMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
operator_isEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
operator_isNotEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               const GGS_luint & inParameter1,
               const GGS_lstring & inParameter2,
               const GGS_fieldSettingMap & inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_configFieldMap info  ;
    info.mRegisterName = inParameter0 ;
    info.mMaskValue = inParameter1 ;
    info.mDescription = inParameter2 ;
    info.mFieldSettingMap = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_fieldSettingMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mRegisterName ;
    outParameter1 = node->mInfo.mMaskValue ;
    outParameter2 = node->mInfo.mDescription ;
    outParameter3 = node->mInfo.mFieldSettingMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_configFieldMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_fieldSettingMap   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_configFieldMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_fieldSettingMap & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_configFieldMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_configFieldMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_configFieldMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @configFieldMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mRegisterName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_configFieldMap::cEnumerator::_mMaskValue (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMaskValue ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mDescription (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDescription ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_fieldSettingMap  & GGS_configFieldMap::cEnumerator::_mFieldSettingMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFieldSettingMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_configFieldMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_configFieldMap * p = NULL ;
    macroMyNew (p, GGS_configFieldMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_configFieldMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_configFieldMap * p = dynamic_cast <const GGS_configFieldMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_configFieldMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_configFieldMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_configFieldMap ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0,
                                             const GGS_luint & inValue1,
                                             const GGS_lstring & inValue2,
                                             const GGS_fieldSettingMap & inValue3
                                             COMMA_LOCATION_ARGS) {
  GGS_configFieldMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "actualBuildConfig"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_actualBuildConfig (C_Compiler & inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_actualBuildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (29)) ;
  GGS_configFieldMap  var_cas_configFieldMap = GGS_configFieldMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (30)) ;
  {
    GGS_configRegisterMap::cEnumerator enumerator_1259 (var_cas_inConfigRegisterMap, true) ;
    const GGS_configRegisterMap::cElement * operand_1259 = NULL ;
    while (((operand_1259 = enumerator_1259.nextObject ()))) {
      macroValidPointer (operand_1259) ;
      GGS_uint  var_cas_defaultValue = GGS_uint (1U).left_shift_operation (inLexique, operand_1259->mInfo.mRegisterWidth.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (32)) COMMA_SOURCE_FILE_AT_LINE (32)).substract_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (32)) ;
      var_cas_outActualConfigurationMap.modifier_insertKey (inLexique, operand_1259->mKey, operand_1259->mInfo.mRegisterAddress.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (33)), var_cas_defaultValue COMMA_SOURCE_FILE_AT_LINE (33)) ;
      GGS_lstring  var_cas_registerName = operand_1259->mKey ;
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_1486 (operand_1259->mInfo.mConfigRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_1486 = NULL ;
        while (((operand_1486 = enumerator_1486.nextObject ()))) {
          macroValidPointer (operand_1486) ;
          var_cas_configFieldMap.modifier_insertKey (inLexique, operand_1486->mKey, var_cas_registerName, operand_1486->mInfo.mMaskValue, operand_1486->mInfo.mDescription, operand_1486->mInfo.mFieldSettingMap COMMA_SOURCE_FILE_AT_LINE (36)) ;
        }
      }
    }
  }
  GGS_stringset  var_cas_actualSettingNameSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_configDefinitionList::cEnumerator enumerator_1772 (var_cas_inConfigDefinitionList, true) ;
    const GGS_configDefinitionList::cElement * operand_1772 = NULL ;
    while (((operand_1772 = enumerator_1772.nextObject ()))) {
      macroValidPointer (operand_1772) ;
      {
        GGS_configSettingList::cEnumerator enumerator_1800 (operand_1772->mSettingList, true) ;
        const GGS_configSettingList::cElement * operand_1800 = NULL ;
        while (((operand_1800 = enumerator_1800.nextObject ()))) {
          macroValidPointer (operand_1800) ;
          const GGS_bool cond_1966 = var_cas_actualSettingNameSet.reader_hasKey (operand_1800->mSettingName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (43))) ;
          if (cond_1966.isBuiltAndTrue ()) {
            operand_1800->mSettingName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_1800->mSettingName)).operator_concat (GGS_string ("' setting is already defined")) COMMA_SOURCE_FILE_AT_LINE (45)) ;
          }
          var_cas_actualSettingNameSet.addAssign_operation (operand_1800->mSettingName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (46))) ;
          GGS_lstring  var_cas_registerName ;
          GGS_luint  var_cas_maskValue ;
          GGS_lstring  var_cas_settingDescription ;
          GGS_fieldSettingMap  var_cas_fieldSettingMap ;
          if (var_cas_configFieldMap.isBuilt ()) {
            var_cas_configFieldMap (HERE)->method_searchKey (inLexique, operand_1800->mSettingName, var_cas_registerName, var_cas_maskValue, var_cas_settingDescription, var_cas_fieldSettingMap COMMA_SOURCE_FILE_AT_LINE (51)) ;
          }
          const GGS_bool cond_2767 = var_cas_fieldSettingMap.reader_hasKey (operand_1800->mSettingValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (52))) ;
          if (cond_2767.isBuiltAndTrue ()) {
            GGS_uint  var_cas_settingValue ;
            GGS_uint  var_cas_settingMask ;
            if (var_cas_fieldSettingMap.isBuilt ()) {
              var_cas_fieldSettingMap (HERE)->method_searchKey (inLexique, operand_1800->mSettingValue, var_cas_settingValue, var_cas_settingMask COMMA_SOURCE_FILE_AT_LINE (55)) ;
            }
            GGS_uint  var_cas_registerValue ;
            GGS_uint  automatic_var_2577_0 ;
            if (var_cas_outActualConfigurationMap.isBuilt ()) {
              var_cas_outActualConfigurationMap (HERE)->method_searchKey (inLexique, var_cas_registerName, automatic_var_2577_0, var_cas_registerValue COMMA_SOURCE_FILE_AT_LINE (57)) ;
            }
            var_cas_registerValue = ((var_cas_registerValue).operator_and ((var_cas_settingMask).operator_tilde ())).operator_or (var_cas_settingValue) ;
            var_cas_outActualConfigurationMap.modifier_setMRegisterValueForKey (inLexique, var_cas_registerValue, var_cas_registerName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (59)) COMMA_SOURCE_FILE_AT_LINE (59)) ;
          }else if (cond_2767.isBuiltAndFalse ()) {
            const GGS_bool cond_3127 = (var_cas_fieldSettingMap.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
            if (cond_3127.isBuiltAndTrue ()) {
              GGS_string var_cas_errorMessage = ((((GGS_string ("the '")).operator_concat (operand_1800->mSettingValue)).operator_concat (GGS_string ("' value is not defined for configuration setting '"))).operator_concat (operand_1800->mSettingName)).operator_concat (GGS_string ("'; possible values are:")) ;
              {
                GGS_fieldSettingMap::cEnumerator enumerator_2996 (var_cas_fieldSettingMap, true) ;
                const GGS_fieldSettingMap::cElement * operand_2996 = NULL ;
                while (((operand_2996 = enumerator_2996.nextObject ()))) {
                  macroValidPointer (operand_2996) ;
                  var_cas_errorMessage.appendCString ("\n"
                    "-  \"") ;
                  var_cas_errorMessage.dotAssign_operation (operand_2996->mKey) ;
                  var_cas_errorMessage.appendCString ("\"") ;
                }
              }
              operand_1800->mSettingValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (67)) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_3621 = (var_cas_inAcceptDefaultConfiguration).operator_not () ;
  if (cond_3621.isBuiltAndTrue ()) {
    GGS_stringset  var_cas_notDefinedSetting = var_cas_configFieldMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (72)).substract_operation (inLexique, var_cas_actualSettingNameSet COMMA_SOURCE_FILE_AT_LINE (72)) ;
    const GGS_bool cond_3610 = (var_cas_notDefinedSetting.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
    if (cond_3610.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = GGS_string ("the following configuration settings are not defined:") ;
      {
        GGS_stringset::cEnumerator enumerator_3505 (var_cas_notDefinedSetting, true) ;
        while (enumerator_3505.hasCurrentObject ()) {
          var_cas_errorMessage.appendCString ("\n"
            "-  ") ;
          var_cas_errorMessage.dotAssign_operation (enumerator_3505._key (HERE)) ;
          enumerator_3505.next () ;
        }
      }
      GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (79)) ;
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_3711 (var_cas_outActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_3711 = NULL ;
    while (((operand_3711 = enumerator_3711.nextObject ()))) {
      macroValidPointer (operand_3711) ;
      var_cas_ioListFileContents.appendCString ("Register '") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_3711->mKey) ;
      var_cas_ioListFileContents.appendCString ("' at ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_3711->mInfo.mRegisterAddress.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (83))) ;
      var_cas_ioListFileContents.appendCString (" set to ") ;
      var_cas_ioListFileContents.dotAssign_operation (operand_3711->mInfo.mRegisterValue.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (83))) ;
      var_cas_ioListFileContents.appendCString ("\n") ;
      GGS_configRegisterMaskMap  var_cas_configRegisterMaskMap ;
      GGS_luint  automatic_var_3977_0 ;
      GGS_luint  automatic_var_3977_1 ;
      GGS_illegalMaskList  automatic_var_3977_2 ;
      if (var_cas_inConfigRegisterMap.isBuilt ()) {
        var_cas_inConfigRegisterMap (HERE)->method_searchKey (inLexique, operand_3711->mKey, automatic_var_3977_0, automatic_var_3977_1, var_cas_configRegisterMaskMap, automatic_var_3977_2 COMMA_SOURCE_FILE_AT_LINE (85)) ;
      }
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_4013 (var_cas_configRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_4013 = NULL ;
        while (((operand_4013 = enumerator_4013.nextObject ()))) {
          macroValidPointer (operand_4013) ;
          GGS_lstring  var_cas_settingName = operand_4013->mKey ;
          {
            GGS_fieldSettingMap::cEnumerator enumerator_4117 (operand_4013->mInfo.mFieldSettingMap, true) ;
            const GGS_fieldSettingMap::cElement * operand_4117 = NULL ;
            while (((operand_4117 = enumerator_4117.nextObject ()))) {
              macroValidPointer (operand_4117) ;
              const GGS_bool cond_4365 = ((operand_3711->mInfo.mRegisterValue).operator_and (operand_4013->mInfo.mMaskValue.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (89)))).operator_isEqual (operand_4117->mInfo.mValue) ;
              if (cond_4365.isBuiltAndTrue ()) {
                var_cas_ioListFileContents.appendCString ("  setting '") ;
                var_cas_ioListFileContents.dotAssign_operation (var_cas_settingName) ;
                var_cas_ioListFileContents.appendCString ("' set to ") ;
                var_cas_ioListFileContents.dotAssign_operation (operand_4117->mInfo.mValue.reader_hexString (inLexique COMMA_SOURCE_FILE_AT_LINE (90))) ;
                var_cas_ioListFileContents.appendCString (" (\"") ;
                var_cas_ioListFileContents.dotAssign_operation (operand_4117->mKey) ;
                var_cas_ioListFileContents.appendCString ("\")\n") ;
              }
            }
          }
        }
      }
      var_cas_ioListFileContents.appendCString ("\n") ;
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_4528 (var_cas_outActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_4528 = NULL ;
    while (((operand_4528 = enumerator_4528.nextObject ()))) {
      macroValidPointer (operand_4528) ;
      GGS_illegalMaskList  var_cas_illegalMaskList ;
      GGS_luint  automatic_var_4638_0 ;
      GGS_luint  automatic_var_4638_1 ;
      GGS_configRegisterMaskMap  automatic_var_4638_2 ;
      if (var_cas_inConfigRegisterMap.isBuilt ()) {
        var_cas_inConfigRegisterMap (HERE)->method_searchKey (inLexique, operand_4528->mKey, automatic_var_4638_0, automatic_var_4638_1, automatic_var_4638_2, var_cas_illegalMaskList COMMA_SOURCE_FILE_AT_LINE (99)) ;
      }
      {
        GGS_illegalMaskList::cEnumerator enumerator_4669 (var_cas_illegalMaskList, true) ;
        const GGS_illegalMaskList::cElement * operand_4669 = NULL ;
        while (((operand_4669 = enumerator_4669.nextObject ()))) {
          macroValidPointer (operand_4669) ;
          const GGS_bool cond_5001 = ((operand_4528->mInfo.mRegisterValue).operator_and (operand_4669->mIllegalMask.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (101)))).operator_isEqual (operand_4669->mIllegalValue.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (101))) ;
          if (cond_5001.isBuiltAndTrue ()) {
            GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("illegal setting for '")).operator_concat (operand_4528->mKey)).operator_concat (GGS_string ("' register: "))).operator_concat (operand_4669->mDescription) COMMA_SOURCE_FILE_AT_LINE (103)) ;
            var_cas_ioListFileContents.appendCString ("*** ILLEGAL SETTING for register '") ;
            var_cas_ioListFileContents.dotAssign_operation (operand_4528->mKey) ;
            var_cas_ioListFileContents.appendCString ("' ***\n") ;
            var_cas_ioListFileContents.appendCString ("  message: ") ;
            var_cas_ioListFileContents.dotAssign_operation (operand_4669->mDescription) ;
            var_cas_ioListFileContents.appendCString ("\n"
              "\n") ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_actualBuildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "buildConfig"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildConfig (C_Compiler & inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioListFileContents.dotAssign_operation (GGS_string ("").reader_stringByLeftAndRightPadding (GGS_uint (79U), GGS_char (TO_UNICODE ('*')))) ;
  var_cas_ioListFileContents.appendCString ("\n") ;
  var_cas_ioListFileContents.appendCString ("*") ;
  var_cas_ioListFileContents.dotAssign_operation (GGS_string ("MICROCONTROLLER CONFIGURATION").reader_stringByLeftAndRightPadding (GGS_uint (77U), GGS_char (TO_UNICODE (' ')))) ;
  var_cas_ioListFileContents.appendCString ("*\n") ;
  var_cas_ioListFileContents.dotAssign_operation (GGS_string ("").reader_stringByLeftAndRightPadding (GGS_uint (79U), GGS_char (TO_UNICODE ('*')))) ;
  var_cas_ioListFileContents.appendCString ("\n"
    "\n") ;
  const GGS_bool cond_5855 = (var_cas_inConfigDefinitionList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
  if (cond_5855.isBuiltAndTrue ()) {
    ::routine_actualBuildConfig (inLexique,  var_cas_inConfigRegisterMap,  var_cas_inConfigDefinitionList,  var_cas_inAcceptDefaultConfiguration,  var_cas_ioListFileContents,  var_cas_outActualConfigurationMap COMMA_SOURCE_FILE_AT_LINE (125)) ;
  }else if (cond_5855.isBuiltAndFalse ()) {
    var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (133)) ;
    var_cas_ioListFileContents.appendCString ("No configuration.\n"
      "\n") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*

