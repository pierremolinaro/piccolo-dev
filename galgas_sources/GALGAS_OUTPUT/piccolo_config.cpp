//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'piccolo_config.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 28th, 2009, at 22h3'31"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_config.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_config.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_configFieldMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_configFieldMap::e_configFieldMap (void) :
mRegisterName (),
mMaskValue (),
mDescription (),
mFieldSettingMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@configFieldMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_configFieldMap::
elementOf_GGS_configFieldMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_configFieldMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_configFieldMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMaskValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDescription.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFieldSettingMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_configFieldMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_configFieldMap * _p = dynamic_cast <const elementOf_GGS_configFieldMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRegisterName._operator_isEqual (_p->mInfo.mRegisterName)).boolValue ()
           && (mInfo.mMaskValue._operator_isEqual (_p->mInfo.mMaskValue)).boolValue ()
           && (mInfo.mDescription._operator_isEqual (_p->mInfo.mDescription)).boolValue ()
           && (mInfo.mFieldSettingMap._operator_isEqual (_p->mInfo.mFieldSettingMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_configFieldMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_configFieldMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_configFieldMap * info = (e_configFieldMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_configFieldMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
_operator_isEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_configFieldMap::
_operator_isNotEqual (const GGS_configFieldMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_lstring & inParameter2,
                const GGS_fieldSettingMap & inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_configFieldMap info  ;
    info.mRegisterName = inParameter0 ;
    info.mMaskValue = inParameter1 ;
    info.mDescription = inParameter2 ;
    info.mFieldSettingMap = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_fieldSettingMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    outParameter3._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegisterName ;
    outParameter1 = node->mInfo.mMaskValue ;
    outParameter2 = node->mInfo.mDescription ;
    outParameter3 = node->mInfo.mFieldSettingMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMRegisterNameForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRegisterNameForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRegisterName = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMMaskValueForKey (C_Compiler & inLexique,
                        const GGS_luint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMMaskValueForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mMaskValue = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMDescriptionForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMDescriptionForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mDescription = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_setMFieldSettingMapForKey (C_Compiler & inLexique,
                        const GGS_fieldSettingMap & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFieldSettingMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFieldSettingMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_fieldSettingMap   & outParameter3 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' configuration field is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_configFieldMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_fieldSettingMap & inParameter3 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' configuration field is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_configFieldMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_configFieldMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_configFieldMap GGS_configFieldMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_configFieldMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_configFieldMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @configFieldMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mRegisterName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_configFieldMap::cEnumerator::_mMaskValue (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMaskValue ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_configFieldMap::cEnumerator::_mDescription (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDescription ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_fieldSettingMap  & GGS_configFieldMap::cEnumerator::_mFieldSettingMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFieldSettingMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "actualBuildConfig"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_actualBuildConfig (C_Compiler & _inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_actualBuildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_configFieldMap  var_cas_configFieldMap ;
  var_cas_configFieldMap = GGS_configFieldMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_configRegisterMap::cEnumerator enumerator_1259 (var_cas_inConfigRegisterMap, true) ;
    const GGS_configRegisterMap::cElement * operand_1259 = NULL ;
    while (((operand_1259 = enumerator_1259.nextObject ()))) {
      macroValidPointer (operand_1259) ;
      GGS_uint  var_cas_defaultValue ;
      var_cas_defaultValue = GGS_uint (true, 1U)._left_shift_operation (_inLexique, operand_1259->mInfo.mRegisterWidth.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (32)) COMMA_SOURCE_FILE_AT_LINE (32))._substract_operation (_inLexique, GGS_uint (true, 1U) COMMA_SOURCE_FILE_AT_LINE (32)) ;
      var_cas_outActualConfigurationMap.modifier_insertKey (_inLexique, operand_1259->mKey, operand_1259->mInfo.mRegisterAddress.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (33)), var_cas_defaultValue COMMA_SOURCE_FILE_AT_LINE (33)) ;
      GGS_lstring  var_cas_registerName ;
      var_cas_registerName = operand_1259->mKey ;
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_1484 (operand_1259->mInfo.mConfigRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_1484 = NULL ;
        while (((operand_1484 = enumerator_1484.nextObject ()))) {
          macroValidPointer (operand_1484) ;
          var_cas_configFieldMap.modifier_insertKey (_inLexique, operand_1484->mKey, var_cas_registerName, operand_1484->mInfo.mMaskValue, operand_1484->mInfo.mDescription, operand_1484->mInfo.mFieldSettingMap COMMA_SOURCE_FILE_AT_LINE (36)) ;
        }
      }
    }
  }
  GGS_stringset  var_cas_actualSettingNameSet ;
  var_cas_actualSettingNameSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_configDefinitionList::cEnumerator enumerator_1727 (var_cas_inConfigDefinitionList, true) ;
    const GGS_configDefinitionList::cElement * operand_1727 = NULL ;
    while (((operand_1727 = enumerator_1727.nextObject ()))) {
      macroValidPointer (operand_1727) ;
      {
        GGS_configSettingList::cEnumerator enumerator_1755 (operand_1727->mSettingList, true) ;
        const GGS_configSettingList::cElement * operand_1755 = NULL ;
        while (((operand_1755 = enumerator_1755.nextObject ()))) {
          macroValidPointer (operand_1755) ;
          if ((var_cas_actualSettingNameSet.reader_hasKey (_inLexique, operand_1755->mSettingName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (43)) COMMA_SOURCE_FILE_AT_LINE (43))).isBuiltAndTrue ()) {
            operand_1755->mSettingName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (operand_1755->mSettingName))._operator_concat (GGS_string (true, "' setting is already defined")) COMMA_SOURCE_FILE_AT_LINE (45)) ;
          }
          var_cas_actualSettingNameSet._addAssign_operation (operand_1755->mSettingName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (46))) ;
          GGS_lstring  var_cas_registerName ;
          GGS_luint  var_cas_maskValue ;
          GGS_lstring  var_cas_settingDescription ;
          GGS_fieldSettingMap  var_cas_fieldSettingMap ;
          const GGS_configFieldMap  _temp_2145 = var_cas_configFieldMap ;
          if (_temp_2145._isBuilt ()) {
            _temp_2145 (HERE)->method_searchKey (_inLexique, operand_1755->mSettingName, var_cas_registerName, var_cas_maskValue, var_cas_settingDescription, var_cas_fieldSettingMap COMMA_SOURCE_FILE_AT_LINE (51)) ;
          }
          if ((var_cas_fieldSettingMap.reader_hasKey (_inLexique, operand_1755->mSettingValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (52)) COMMA_SOURCE_FILE_AT_LINE (52))).isBuiltAndTrue ()) {
            GGS_uint  var_cas_settingValue ;
            GGS_uint  var_cas_settingMask ;
            const GGS_fieldSettingMap  _temp_2379 = var_cas_fieldSettingMap ;
            if (_temp_2379._isBuilt ()) {
              _temp_2379 (HERE)->method_searchKey (_inLexique, operand_1755->mSettingValue, var_cas_settingValue, var_cas_settingMask COMMA_SOURCE_FILE_AT_LINE (55)) ;
            }
            GGS_uint  var_cas_registerValue ;
            GGS_uint  automatic_var_0 ;
            const GGS_actualConfigurationMap  _temp_2499 = var_cas_outActualConfigurationMap ;
            if (_temp_2499._isBuilt ()) {
              _temp_2499 (HERE)->method_searchKey (_inLexique, var_cas_registerName, automatic_var_0, var_cas_registerValue COMMA_SOURCE_FILE_AT_LINE (57)) ;
            }
            var_cas_registerValue = ((var_cas_registerValue)._operator_and ((var_cas_settingMask)._operator_tilde ()))._operator_or (var_cas_settingValue) ;
            var_cas_outActualConfigurationMap.modifier_setMRegisterValueForKey (_inLexique, var_cas_registerValue, var_cas_registerName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)) COMMA_SOURCE_FILE_AT_LINE (59)) ;
          }else if (((var_cas_fieldSettingMap.reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (60)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
            GGS_string var_cas_errorMessage ;
            var_cas_errorMessage = ((((GGS_string (true, "the '"))._operator_concat (operand_1755->mSettingValue))._operator_concat (GGS_string (true, "' value is not defined for configuration setting '")))._operator_concat (operand_1755->mSettingName))._operator_concat (GGS_string (true, "'; possible values are:")) ;
            {
              GGS_fieldSettingMap::cEnumerator enumerator_2952 (var_cas_fieldSettingMap, true) ;
              const GGS_fieldSettingMap::cElement * operand_2952 = NULL ;
              while (((operand_2952 = enumerator_2952.nextObject ()))) {
                macroValidPointer (operand_2952) ;
                var_cas_errorMessage.appendCstring ("\n"
                  "-  \"") ;
                var_cas_errorMessage._dotAssign_operation (operand_2952->mKey) ;
                var_cas_errorMessage.appendCstring ("\"") ;
              }
            }
            operand_1755->mSettingValue.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (67)) ;
          }
        }
      }
    }
  }
  if (((var_cas_inAcceptDefaultConfiguration)._operator_not ()).isBuiltAndTrue ()) {
    GGS_stringset  var_cas_notDefinedSetting ;
    var_cas_notDefinedSetting = var_cas_configFieldMap.reader_allKeys (_inLexique COMMA_SOURCE_FILE_AT_LINE (72))._substract_operation (_inLexique, var_cas_actualSettingNameSet COMMA_SOURCE_FILE_AT_LINE (72)) ;
    if (((var_cas_notDefinedSetting.reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage ;
      var_cas_errorMessage = GGS_string (true, "the following configuration settings are not defined:") ;
      {
        GGS_stringset::cEnumerator enumerator_3460 (var_cas_notDefinedSetting, true) ;
        while (enumerator_3460.hc ()) {
          var_cas_errorMessage.appendCstring ("\n"
            "-  ") ;
          var_cas_errorMessage._dotAssign_operation (enumerator_3460._key (HERE)) ;
          enumerator_3460.next () ;
        }
      }
      GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (79)) ;
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_3666 (var_cas_outActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_3666 = NULL ;
    while (((operand_3666 = enumerator_3666.nextObject ()))) {
      macroValidPointer (operand_3666) ;
      var_cas_ioListFileContents.appendCstring ("Register '") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_3666->mKey) ;
      var_cas_ioListFileContents.appendCstring ("' at ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_3666->mInfo.mRegisterAddress.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))) ;
      var_cas_ioListFileContents.appendCstring (" set to ") ;
      var_cas_ioListFileContents._dotAssign_operation (operand_3666->mInfo.mRegisterValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))) ;
      var_cas_ioListFileContents.appendCstring ("\n") ;
      GGS_configRegisterMaskMap  var_cas_configRegisterMaskMap ;
      GGS_luint  automatic_var_1 ;
      GGS_luint  automatic_var_2 ;
      GGS_illegalMaskList  automatic_var_3 ;
      const GGS_configRegisterMap  _temp_3892 = var_cas_inConfigRegisterMap ;
      if (_temp_3892._isBuilt ()) {
        _temp_3892 (HERE)->method_searchKey (_inLexique, operand_3666->mKey, automatic_var_1, automatic_var_2, var_cas_configRegisterMaskMap, automatic_var_3 COMMA_SOURCE_FILE_AT_LINE (85)) ;
      }
      {
        GGS_configRegisterMaskMap::cEnumerator enumerator_3966 (var_cas_configRegisterMaskMap, true) ;
        const GGS_configRegisterMaskMap::cElement * operand_3966 = NULL ;
        while (((operand_3966 = enumerator_3966.nextObject ()))) {
          macroValidPointer (operand_3966) ;
          GGS_lstring  var_cas_settingName ;
          var_cas_settingName = operand_3966->mKey ;
          {
            GGS_fieldSettingMap::cEnumerator enumerator_4036 (operand_3966->mInfo.mFieldSettingMap, true) ;
            const GGS_fieldSettingMap::cElement * operand_4036 = NULL ;
            while (((operand_4036 = enumerator_4036.nextObject ()))) {
              macroValidPointer (operand_4036) ;
              if ((((operand_3666->mInfo.mRegisterValue)._operator_and (operand_3966->mInfo.mMaskValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (89))))._operator_isEqual (operand_4036->mInfo.mValue)).isBuiltAndTrue ()) {
                var_cas_ioListFileContents.appendCstring ("  setting '") ;
                var_cas_ioListFileContents._dotAssign_operation (var_cas_settingName) ;
                var_cas_ioListFileContents.appendCstring ("' set to ") ;
                var_cas_ioListFileContents._dotAssign_operation (operand_4036->mInfo.mValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (90))) ;
                var_cas_ioListFileContents.appendCstring (" (\"") ;
                var_cas_ioListFileContents._dotAssign_operation (operand_4036->mKey) ;
                var_cas_ioListFileContents.appendCstring ("\")\n") ;
              }
            }
          }
        }
      }
      var_cas_ioListFileContents.appendCstring ("\n") ;
    }
  }
  {
    GGS_actualConfigurationMap::cEnumerator enumerator_4399 (var_cas_outActualConfigurationMap, true) ;
    const GGS_actualConfigurationMap::cElement * operand_4399 = NULL ;
    while (((operand_4399 = enumerator_4399.nextObject ()))) {
      macroValidPointer (operand_4399) ;
      GGS_illegalMaskList  var_cas_illegalMaskList ;
      GGS_luint  automatic_var_4 ;
      GGS_luint  automatic_var_5 ;
      GGS_configRegisterMaskMap  automatic_var_6 ;
      const GGS_configRegisterMap  _temp_4476 = var_cas_inConfigRegisterMap ;
      if (_temp_4476._isBuilt ()) {
        _temp_4476 (HERE)->method_searchKey (_inLexique, operand_4399->mKey, automatic_var_4, automatic_var_5, automatic_var_6, var_cas_illegalMaskList COMMA_SOURCE_FILE_AT_LINE (99)) ;
      }
      {
        GGS_illegalMaskList::cEnumerator enumerator_4539 (var_cas_illegalMaskList, true) ;
        const GGS_illegalMaskList::cElement * operand_4539 = NULL ;
        while (((operand_4539 = enumerator_4539.nextObject ()))) {
          macroValidPointer (operand_4539) ;
          if ((((operand_4399->mInfo.mRegisterValue)._operator_and (operand_4539->mIllegalMask.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (101))))._operator_isEqual (operand_4539->mIllegalValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (101)))).isBuiltAndTrue ()) {
            GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "illegal setting for '"))._operator_concat (operand_4399->mKey))._operator_concat (GGS_string (true, "' register: ")))._operator_concat (operand_4539->mDescription) COMMA_SOURCE_FILE_AT_LINE (103)) ;
            var_cas_ioListFileContents.appendCstring ("*** ILLEGAL SETTING for register '") ;
            var_cas_ioListFileContents._dotAssign_operation (operand_4399->mKey) ;
            var_cas_ioListFileContents.appendCstring ("' ***\n") ;
            var_cas_ioListFileContents.appendCstring ("  message: ") ;
            var_cas_ioListFileContents._dotAssign_operation (operand_4539->mDescription) ;
            var_cas_ioListFileContents.appendCstring ("\n"
              "\n") ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_actualBuildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "buildConfig"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildConfig (C_Compiler & _inLexique,
                                const GGS_configRegisterMap   var_cas_inConfigRegisterMap,
                                const GGS_configDefinitionList   var_cas_inConfigDefinitionList,
                                const GGS_bool  var_cas_inAcceptDefaultConfiguration,
                                GGS_string & var_cas_ioListFileContents,
                                GGS_actualConfigurationMap  & var_cas_outActualConfigurationMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildConfig at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 79U), GGS_char (true, '*') COMMA_SOURCE_FILE_AT_LINE (120))) ;
  var_cas_ioListFileContents.appendCstring ("\n") ;
  var_cas_ioListFileContents.appendCstring ("*") ;
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "MICROCONTROLLER CONFIGURATION").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 77U), GGS_char (true, ' ') COMMA_SOURCE_FILE_AT_LINE (121))) ;
  var_cas_ioListFileContents.appendCstring ("*\n") ;
  var_cas_ioListFileContents._dotAssign_operation (GGS_string (true, "").reader_stringByLeftAndRightPadding (_inLexique, GGS_uint (true, 79U), GGS_char (true, '*') COMMA_SOURCE_FILE_AT_LINE (122))) ;
  var_cas_ioListFileContents.appendCstring ("\n"
    "\n") ;
  if (((var_cas_inConfigDefinitionList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (124)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    ::routine_actualBuildConfig (_inLexique,  var_cas_inConfigRegisterMap,  var_cas_inConfigDefinitionList,  var_cas_inAcceptDefaultConfiguration,  var_cas_ioListFileContents,  var_cas_outActualConfigurationMap COMMA_SOURCE_FILE_AT_LINE (125)) ;
  }else{
    var_cas_outActualConfigurationMap = GGS_actualConfigurationMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
    var_cas_ioListFileContents.appendCstring ("No configuration.\n"
      "\n") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildConfig\n") ;
  #endif
}

//---------------------------------------------------------------------------*

