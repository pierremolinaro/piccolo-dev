//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'piccolo_metamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      july 25th, 2008, at 14h44'14"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_metamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_piccolo_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_piccolo_instruction::
cPtr_piccolo_instruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_piccolo_instruction * GGS_piccolo_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_piccolo_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_piccolo_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_piccolo_instruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@piccolo_instruction:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_piccolo_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_piccolo_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_piccolo_instruction (& typeid (cPtr_piccolo_instruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_piccolo_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__piccolo_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_piccolo_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccolo_instruction::
GGS_piccolo_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction::
GGS_piccolo_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_piccolo_instruction GGS_piccolo_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_piccolo_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_piccolo_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_piccolo_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_piccolo_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_piccolo_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_piccolo_instruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_piccolo_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_piccolo_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_piccolo_instruction::actualTypeName (void) const {
  return "piccolo_instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_piccolo_instruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__piccolo_instruction ("piccolo_instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@instructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_instructionList::
elementOf_GGS_instructionList (const GGS_piccolo_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_instructionList * _p = dynamic_cast <const elementOf_GGS_instructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@instructionList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalAppendValues (const GGS_piccolo_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalPrependValues (const GGS_piccolo_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_addAssign_operation (const GGS_piccolo_instruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
_operator_concat (const GGS_instructionList & inOperand) const {
  GGS_instructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_dotAssign_operation (const GGS_instructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_piccolo_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_piccolo_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_emptyList (void) {
  GGS_instructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_listWithValue (const GGS_piccolo_instruction & argument_0) {
  GGS_instructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
internalSubListWithRange (GGS_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_first (C_Compiler & _inLexique,
              GGS_piccolo_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_last (C_Compiler & _inLexique,
             GGS_piccolo_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_piccolo_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_piccolo_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction  GGS_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_piccolo_instruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_piccolo_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_piccolo_instruction  & GGS_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_pseudo_LABEL'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_pseudo_LABEL::
cPtr_pseudo_LABEL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_pseudo_LABEL * GGS_pseudo_LABEL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_pseudo_LABEL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_pseudo_LABEL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_pseudo_LABEL * _p = dynamic_cast <const cPtr_pseudo_LABEL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_pseudo_LABEL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@pseudo_LABEL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_pseudo_LABEL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_pseudo_LABEL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_pseudo_LABEL (& typeid (cPtr_pseudo_LABEL), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_pseudo_LABEL::galgasRTTI (void) const {
  return & gClassInfoFor__pseudo_LABEL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_pseudo_LABEL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_pseudo_LABEL::
GGS_pseudo_LABEL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_pseudo_LABEL::
GGS_pseudo_LABEL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_pseudo_LABEL GGS_pseudo_LABEL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_pseudo_LABEL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_pseudo_LABEL *> (inPointer) != NULL)
      : (typeid (cPtr_pseudo_LABEL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_pseudo_LABEL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_pseudo_LABEL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_pseudo_LABEL GGS_pseudo_LABEL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_pseudo_LABEL result ;
  macroMyNew (result.mPointer, cPtr_pseudo_LABEL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_pseudo_LABEL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_pseudo_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_pseudo_LABEL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_pseudo_LABEL::actualTypeName (void) const {
  return "pseudo_LABEL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__pseudo_LABEL ("pseudo_LABEL", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_registerExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerExpression::
cPtr_registerExpression (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mRegisterName (argument_0),
mOffset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerExpression * GGS_registerExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerExpression * _p = dynamic_cast <const cPtr_registerExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterName._operator_isEqual (_p->mRegisterName).boolValue ()
         && mOffset._operator_isEqual (_p->mOffset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerExpression:"
           << mRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerExpression (& typeid (cPtr_registerExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerExpression::galgasRTTI (void) const {
  return & gClassInfoFor__registerExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_registerExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_registerExpression GGS_registerExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerExpression *> (inPointer) != NULL)
      : (typeid (cPtr_registerExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_registerExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression GGS_registerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerExpression result ;
  macroMyNew (result.mPointer, cPtr_registerExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_registerExpression::
reader_mRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_registerExpression::
reader_mOffset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerExpression::actualTypeName (void) const {
  return "registerExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_registerExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__registerExpression ("registerExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'instruction_FDA_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_instruction_FDA_base_code::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_isEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_isNotEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_infOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_supOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_strictInf (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_strictSup (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instruction_FDA_base_code::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [22] = {"",
    "ADDWF",
    "ADDWFC",
    "ANDWF",
    "COMF",
    "DCFSNZ",
    "DECF",
    "DECFSZ",
    "INCF",
    "INCFSZ",
    "INFSNZ",
    "IORWF",
    "MOVF",
    "RLCF",
    "RLNCF",
    "RRCF",
    "RRNCF",
    "SUBFWB",
    "SUBWF",
    "SUBWFB",
    "SWAPF",
    "XORWF"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instruction_FDA_base_code::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @instruction_FDA_base_code" ;
  switch (mValue) {
  case enum_ADDWF:
    s << " ADDWF>" ;
    break ;
  case enum_ADDWFC:
    s << " ADDWFC>" ;
    break ;
  case enum_ANDWF:
    s << " ANDWF>" ;
    break ;
  case enum_COMF:
    s << " COMF>" ;
    break ;
  case enum_DCFSNZ:
    s << " DCFSNZ>" ;
    break ;
  case enum_DECF:
    s << " DECF>" ;
    break ;
  case enum_DECFSZ:
    s << " DECFSZ>" ;
    break ;
  case enum_INCF:
    s << " INCF>" ;
    break ;
  case enum_INCFSZ:
    s << " INCFSZ>" ;
    break ;
  case enum_INFSNZ:
    s << " INFSNZ>" ;
    break ;
  case enum_IORWF:
    s << " IORWF>" ;
    break ;
  case enum_MOVF:
    s << " MOVF>" ;
    break ;
  case enum_RLCF:
    s << " RLCF>" ;
    break ;
  case enum_RLNCF:
    s << " RLNCF>" ;
    break ;
  case enum_RRCF:
    s << " RRCF>" ;
    break ;
  case enum_RRNCF:
    s << " RRNCF>" ;
    break ;
  case enum_SUBFWB:
    s << " SUBFWB>" ;
    break ;
  case enum_SUBWF:
    s << " SUBWF>" ;
    break ;
  case enum_SUBWFB:
    s << " SUBWFB>" ;
    break ;
  case enum_SWAPF:
    s << " SWAPF>" ;
    break ;
  case enum_XORWF:
    s << " XORWF>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "getFDAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFDAinstructionBaseCode (C_Compiler &,
                                const GGS_instruction_FDA_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFDAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_instruction_FDA_base_code::enum_ADDWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 9216U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ADDWFC:
    {
    var_cas_outBaseCode = GGS_uint (true, 8192U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ANDWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 5120U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_COMF:
    {
    var_cas_outBaseCode = GGS_uint (true, 7168U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECF:
    {
    var_cas_outBaseCode = GGS_uint (true, 1024U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 11264U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DCFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 19456U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 10240U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 15360U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 18432U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_IORWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 4096U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_MOVF:
    {
    var_cas_outBaseCode = GGS_uint (true, 20480U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 13312U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLNCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 17408U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 12288U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRNCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 16384U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBFWB:
    {
    var_cas_outBaseCode = GGS_uint (true, 21504U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 23552U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWFB:
    {
    var_cas_outBaseCode = GGS_uint (true, 22528U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SWAPF:
    {
    var_cas_outBaseCode = GGS_uint (true, 14336U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_XORWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 6144U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFDAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FDA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FDA::
cPtr_instruction_FDA (const GGS_location & argument_0,
                                const GGS_instruction_FDA_base_code& argument_1,
                                const GGS_registerExpression & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstruction_FDA_base_code (argument_1),
mRegisterExpression (argument_2),
m_W_isDestination (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FDA * GGS_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FDA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FDA * _p = dynamic_cast <const cPtr_instruction_FDA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction_FDA_base_code._operator_isEqual (_p->mInstruction_FDA_base_code).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FDA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FDA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction_FDA_base_code.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FDA (& typeid (cPtr_instruction_FDA), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FDA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FDA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FDA GGS_instruction_FDA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA GGS_instruction_FDA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instruction_FDA_base_code& argument_1,
                 const GGS_registerExpression & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FDA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA_base_code GGS_instruction_FDA::
reader_mInstruction_FDA_base_code (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction_FDA_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mInstruction_FDA_base_code ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FDA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FDA::actualTypeName (void) const {
  return "instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FDA ("instruction_FDA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Class for 'FA_instruction_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_FA_instruction_base_code::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_isEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_isNotEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_infOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_supOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_strictInf (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_strictSup (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [10] = {"",
    "CLRF",
    "CPFSEQ",
    "CPFSGT",
    "CPFSLT",
    "MOVWF",
    "MULWF",
    "NEGF",
    "SETF",
    "TSTFSZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @FA_instruction_base_code" ;
  switch (mValue) {
  case enum_CLRF:
    s << " CLRF>" ;
    break ;
  case enum_CPFSEQ:
    s << " CPFSEQ>" ;
    break ;
  case enum_CPFSGT:
    s << " CPFSGT>" ;
    break ;
  case enum_CPFSLT:
    s << " CPFSLT>" ;
    break ;
  case enum_MOVWF:
    s << " MOVWF>" ;
    break ;
  case enum_MULWF:
    s << " MULWF>" ;
    break ;
  case enum_NEGF:
    s << " NEGF>" ;
    break ;
  case enum_SETF:
    s << " SETF>" ;
    break ;
  case enum_TSTFSZ:
    s << " TSTFSZ>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getFAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFAinstructionBaseCode (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27136U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSEQ:
    {
    var_cas_outBaseCode = GGS_uint (true, 25088U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outBaseCode = GGS_uint (true, 25600U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outBaseCode = GGS_uint (true, 24576U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 28160U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 512U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27648U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outBaseCode = GGS_uint (true, 26624U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 26112U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FA'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FA::
cPtr_instruction_FA (const GGS_location & argument_0,
                                const GGS_FA_instruction_base_code& argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mFAinstruction (argument_1),
mRegisterExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FA * GGS_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FA * _p = dynamic_cast <const cPtr_instruction_FA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFAinstruction._operator_isEqual (_p->mFAinstruction).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFAinstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FA (& typeid (cPtr_instruction_FA), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FA GGS_instruction_FA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA GGS_instruction_FA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_FA_instruction_base_code& argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FA (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_FA_instruction_base_code GGS_instruction_FA::
reader_mFAinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_FA_instruction_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mFAinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FA::actualTypeName (void) const {
  return "instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FA ("instruction_FA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVFF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVFF::
cPtr_instruction_MOVFF (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mSourceRegisterName (argument_1),
mDestinationRegisterName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVFF * GGS_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVFF * _p = dynamic_cast <const cPtr_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mSourceRegisterName._operator_isEqual (_p->mSourceRegisterName).boolValue ()
         && mDestinationRegisterName._operator_isEqual (_p->mDestinationRegisterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVFF:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVFF (& typeid (cPtr_instruction_MOVFF), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVFF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVFF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVFF GGS_instruction_MOVFF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF GGS_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVFF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mSourceRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mSourceRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mDestinationRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mDestinationRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVFF::actualTypeName (void) const {
  return "instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVFF ("instruction_MOVFF", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberExpression::
cPtr_bitNumberExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberExpression * GGS_bitNumberExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_bitNumberExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@bitNumberExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberExpression (& typeid (cPtr_bitNumberExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberExpression::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberExpression GGS_bitNumberExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberExpression *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberExpression::actualTypeName (void) const {
  return "bitNumberExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_bitNumberExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__bitNumberExpression ("bitNumberExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_bitNumberLiteralValue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLiteralValue::
cPtr_bitNumberLiteralValue (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLiteralValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLiteralValue * GGS_bitNumberLiteralValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLiteralValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLiteralValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLiteralValue * _p = dynamic_cast <const cPtr_bitNumberLiteralValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLiteralValue._operator_isEqual (_p->mBitNumberLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLiteralValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLiteralValue:"
           << mBitNumberLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLiteralValue (& typeid (cPtr_bitNumberLiteralValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLiteralValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLiteralValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_bitNumberLiteralValue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLiteralValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLiteralValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLiteralValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLiteralValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLiteralValue (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLiteralValue::
reader_mBitNumberLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLiteralValue *) mPointer)->mBitNumberLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLiteralValue::actualTypeName (void) const {
  return "bitNumberLiteralValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLiteralValue ("bitNumberLiteralValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberLabelValue'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLabelValue::
cPtr_bitNumberLabelValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLabelValue (argument_0),
mBitNumberIndexValue (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLabelValue * GGS_bitNumberLabelValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLabelValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLabelValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLabelValue * _p = dynamic_cast <const cPtr_bitNumberLabelValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLabelValue._operator_isEqual (_p->mBitNumberLabelValue).boolValue ()
         && mBitNumberIndexValue._operator_isEqual (_p->mBitNumberIndexValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLabelValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLabelValue:"
           << mBitNumberLabelValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumberIndexValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLabelValue (& typeid (cPtr_bitNumberLabelValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLabelValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLabelValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberLabelValue'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLabelValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLabelValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLabelValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLabelValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLabelValue (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_bitNumberLabelValue::
reader_mBitNumberLabelValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberLabelValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLabelValue::
reader_mBitNumberIndexValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberIndexValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLabelValue::actualTypeName (void) const {
  return "bitNumberLabelValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLabelValue ("bitNumberLabelValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'bit_oriented_op' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_bit_oriented_op::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_isEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_isNotEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_infOrEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_supOrEqual (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_strictInf (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bit_oriented_op::
_operator_strictSup (const GGS_bit_oriented_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bit_oriented_op::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [6] = {"",
    "BCF",
    "BSF",
    "BTFSC",
    "BTFSS",
    "BTG"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_bit_oriented_op::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @bit_oriented_op" ;
  switch (mValue) {
  case enum_BCF:
    s << " BCF>" ;
    break ;
  case enum_BSF:
    s << " BSF>" ;
    break ;
  case enum_BTFSC:
    s << " BTFSC>" ;
    break ;
  case enum_BTFSS:
    s << " BTFSS>" ;
    break ;
  case enum_BTG:
    s << " BTG>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getBitOrientedOpBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBitOrientedOpBaseCode (C_Compiler &,
                                const GGS_bit_oriented_op  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBitOrientedOpBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_bit_oriented_op::enum_BCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 36864U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BSF:
    {
    var_cas_outBaseCode = GGS_uint (true, 32768U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSC:
    {
    var_cas_outBaseCode = GGS_uint (true, 45056U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTFSS:
    {
    var_cas_outBaseCode = GGS_uint (true, 40960U) ;
    }
    break ;
  case GGS_bit_oriented_op::enum_BTG:
    {
    var_cas_outBaseCode = GGS_uint (true, 28672U) ;
    }
    break ;
  case GGS_bit_oriented_op::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBitOrientedOpBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FBA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FBA::
cPtr_instruction_FBA (const GGS_location & argument_0,
                                const GGS_bit_oriented_op& argument_1,
                                const GGS_registerExpression & argument_2,
                                const GGS_bitNumberExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mBitOrientedOp (argument_1),
mRegisterExpression (argument_2),
mBitNumber (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FBA * GGS_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FBA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FBA * _p = dynamic_cast <const cPtr_instruction_FBA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mBitOrientedOp._operator_isEqual (_p->mBitOrientedOp).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FBA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FBA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitOrientedOp.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FBA (& typeid (cPtr_instruction_FBA), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FBA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FBA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FBA GGS_instruction_FBA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA GGS_instruction_FBA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bit_oriented_op& argument_1,
                 const GGS_registerExpression & argument_2,
                 const GGS_bitNumberExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FBA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bit_oriented_op GGS_instruction_FBA::
reader_mBitOrientedOp (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bit_oriented_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitOrientedOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FBA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FBA::actualTypeName (void) const {
  return "instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FBA ("instruction_FBA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'conditional_branch' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_conditional_branch::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_isEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_isNotEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_infOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_supOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_strictInf (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_strictSup (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "BC",
    "BN",
    "BNC",
    "BNN",
    "BNOV",
    "BNZ",
    "BOV",
    "BZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @conditional_branch" ;
  switch (mValue) {
  case enum_bc:
    s << " bc>" ;
    break ;
  case enum_bn:
    s << " bn>" ;
    break ;
  case enum_bnc:
    s << " bnc>" ;
    break ;
  case enum_bnn:
    s << " bnn>" ;
    break ;
  case enum_bnov:
    s << " bnov>" ;
    break ;
  case enum_bnz:
    s << " bnz>" ;
    break ;
  case enum_bov:
    s << " bov>" ;
    break ;
  case enum_bz:
    s << " bz>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "getBccBaseCode"                 *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBccBaseCode (C_Compiler &,
                                const GGS_conditional_branch  var_cas_inConditionalBranch,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBccBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inConditionalBranch.enumValue ()) {
  case GGS_conditional_branch::enum_bz:
    {
    var_cas_outBaseCode = GGS_uint (true, 57344U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnz:
    {
    var_cas_outBaseCode = GGS_uint (true, 57600U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bn:
    {
    var_cas_outBaseCode = GGS_uint (true, 58880U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnn:
    {
    var_cas_outBaseCode = GGS_uint (true, 59136U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bc:
    {
    var_cas_outBaseCode = GGS_uint (true, 57856U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnc:
    {
    var_cas_outBaseCode = GGS_uint (true, 58112U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bov:
    {
    var_cas_outBaseCode = GGS_uint (true, 58368U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnov:
    {
    var_cas_outBaseCode = GGS_uint (true, 58624U) ;
    }
    break ;
  case GGS_conditional_branch::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBccBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "getComplementaryBcc"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getComplementaryBcc (C_Compiler & _inLexique,
                                const GGS_conditional_branch  var_cas_inConditionalBranch,
                                GGS_conditional_branch & var_cas_outComplementary COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getComplementaryBcc at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inConditionalBranch.enumValue ()) {
  case GGS_conditional_branch::enum_bz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnz (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bz (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnn (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bn (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnc (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bc (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnov (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bov (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getComplementaryBcc\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'condionalBranchMode' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_condionalBranchMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_isEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_isNotEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_infOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_supOrEqual (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_strictInf (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_condionalBranchMode::
_operator_strictSup (const GGS_condionalBranchMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_condionalBranchMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @condionalBranchMode" ;
  switch (mValue) {
  case enum_native:
    s << " native>" ;
    break ;
  case enum_usesBRA:
    s << " usesBRA>" ;
    break ;
  case enum_usesGOTO:
    s << " usesGOTO>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_conditionalBranch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_conditionalBranch::
cPtr_instruction_conditionalBranch (const GGS_location & argument_0,
                                const GGS_condionalBranchMode& argument_1,
                                const GGS_conditional_branch& argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mBranchMode (argument_1),
mConditionalBranch (argument_2),
mTargetLabel (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_conditionalBranch * GGS_instruction_conditionalBranch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_conditionalBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_conditionalBranch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_conditionalBranch * _p = dynamic_cast <const cPtr_instruction_conditionalBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mBranchMode._operator_isEqual (_p->mBranchMode).boolValue ()
         && mConditionalBranch._operator_isEqual (_p->mConditionalBranch).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_conditionalBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_conditionalBranch:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchMode.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConditionalBranch.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_conditionalBranch (& typeid (cPtr_instruction_conditionalBranch), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_conditionalBranch::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_conditionalBranch ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_conditionalBranch'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_conditionalBranch GGS_instruction_conditionalBranch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_conditionalBranch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_conditionalBranch *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_conditionalBranch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_conditionalBranch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_conditionalBranch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch GGS_instruction_conditionalBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_condionalBranchMode& argument_1,
                 const GGS_conditional_branch& argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_conditionalBranch result ;
  macroMyNew (result.mPointer, cPtr_instruction_conditionalBranch (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_condionalBranchMode GGS_instruction_conditionalBranch::
reader_mBranchMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_condionalBranchMode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mBranchMode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_instruction_conditionalBranch::
reader_mConditionalBranch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mConditionalBranch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_conditionalBranch::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_conditionalBranch::actualTypeName (void) const {
  return "instruction_conditionalBranch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_conditionalBranch ("instruction_conditionalBranch", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BRA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BRA::
cPtr_instruction_BRA (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BRA * GGS_instruction_BRA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BRA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BRA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BRA * _p = dynamic_cast <const cPtr_instruction_BRA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BRA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BRA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BRA (& typeid (cPtr_instruction_BRA), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BRA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BRA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BRA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BRA GGS_instruction_BRA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BRA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BRA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BRA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BRA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA GGS_instruction_BRA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA result ;
  macroMyNew (result.mPointer, cPtr_instruction_BRA (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_BRA::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_BRA *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BRA::actualTypeName (void) const {
  return "instruction_BRA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BRA ("instruction_BRA", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_CALL'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CALL::
cPtr_instruction_CALL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CALL * GGS_instruction_CALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CALL * _p = dynamic_cast <const cPtr_instruction_CALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CALL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CALL (& typeid (cPtr_instruction_CALL), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_CALL'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CALL GGS_instruction_CALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL GGS_instruction_CALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_CALL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_CALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_CALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CALL::actualTypeName (void) const {
  return "instruction_CALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CALL ("instruction_CALL", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_GOTO'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_GOTO::
cPtr_instruction_GOTO (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_GOTO * GGS_instruction_GOTO::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_GOTO *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_GOTO::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_GOTO * _p = dynamic_cast <const cPtr_instruction_GOTO *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_GOTO::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_GOTO:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_GOTO (& typeid (cPtr_instruction_GOTO), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_GOTO::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_GOTO ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_GOTO'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_GOTO GGS_instruction_GOTO::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_GOTO *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_GOTO) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_GOTO (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_GOTO),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO GGS_instruction_GOTO::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO result ;
  macroMyNew (result.mPointer, cPtr_instruction_GOTO (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_GOTO::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_GOTO *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_GOTO::actualTypeName (void) const {
  return "instruction_GOTO" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_GOTO ("instruction_GOTO", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RCALL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RCALL::
cPtr_instruction_RCALL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RCALL * GGS_instruction_RCALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RCALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RCALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RCALL * _p = dynamic_cast <const cPtr_instruction_RCALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RCALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RCALL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RCALL (& typeid (cPtr_instruction_RCALL), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RCALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RCALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RCALL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RCALL GGS_instruction_RCALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RCALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RCALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RCALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RCALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL GGS_instruction_RCALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_RCALL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_RCALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_RCALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RCALL::actualTypeName (void) const {
  return "instruction_RCALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RCALL ("instruction_RCALL", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CLRWDT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CLRWDT::
cPtr_instruction_CLRWDT (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CLRWDT * GGS_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CLRWDT * _p = dynamic_cast <const cPtr_instruction_CLRWDT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CLRWDT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CLRWDT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CLRWDT (& typeid (cPtr_instruction_CLRWDT), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CLRWDT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT result ;
  macroMyNew (result.mPointer, cPtr_instruction_CLRWDT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CLRWDT::actualTypeName (void) const {
  return "instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CLRWDT ("instruction_CLRWDT", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_DAW'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DAW::
cPtr_instruction_DAW (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DAW * GGS_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DAW * _p = dynamic_cast <const cPtr_instruction_DAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DAW (& typeid (cPtr_instruction_DAW), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_DAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DAW GGS_instruction_DAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW GGS_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_DAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DAW::actualTypeName (void) const {
  return "instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DAW ("instruction_DAW", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_NOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_NOP::
cPtr_instruction_NOP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_NOP * GGS_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_NOP * _p = dynamic_cast <const cPtr_instruction_NOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_NOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_NOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_NOP (& typeid (cPtr_instruction_NOP), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_NOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_NOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_NOP GGS_instruction_NOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP GGS_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_NOP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_NOP::actualTypeName (void) const {
  return "instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_NOP ("instruction_NOP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_POP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_POP::
cPtr_instruction_POP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_POP * GGS_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_POP * _p = dynamic_cast <const cPtr_instruction_POP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_POP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_POP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_POP (& typeid (cPtr_instruction_POP), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_POP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_POP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_POP GGS_instruction_POP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_POP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP GGS_instruction_POP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_POP result ;
  macroMyNew (result.mPointer, cPtr_instruction_POP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_POP::actualTypeName (void) const {
  return "instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_POP ("instruction_POP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_PUSH'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_PUSH::
cPtr_instruction_PUSH (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_PUSH * GGS_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_PUSH * _p = dynamic_cast <const cPtr_instruction_PUSH *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_PUSH::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_PUSH:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_PUSH (& typeid (cPtr_instruction_PUSH), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_PUSH ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_PUSH'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_PUSH GGS_instruction_PUSH::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH GGS_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH result ;
  macroMyNew (result.mPointer, cPtr_instruction_PUSH (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_PUSH::actualTypeName (void) const {
  return "instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_PUSH ("instruction_PUSH", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RESET'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RESET::
cPtr_instruction_RESET (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RESET * GGS_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RESET * _p = dynamic_cast <const cPtr_instruction_RESET *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RESET::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RESET:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RESET (& typeid (cPtr_instruction_RESET), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RESET ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RESET'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RESET GGS_instruction_RESET::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET GGS_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET result ;
  macroMyNew (result.mPointer, cPtr_instruction_RESET (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RESET::actualTypeName (void) const {
  return "instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RESET ("instruction_RESET", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_RETURN'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETURN::
cPtr_instruction_RETURN (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETURN * GGS_instruction_RETURN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETURN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETURN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETURN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RETURN * _p = dynamic_cast <const cPtr_instruction_RETURN *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETURN::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RETURN:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETURN (& typeid (cPtr_instruction_RETURN), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETURN::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETURN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_RETURN'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETURN GGS_instruction_RETURN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETURN *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETURN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETURN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETURN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN GGS_instruction_RETURN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN result ;
  macroMyNew (result.mPointer, cPtr_instruction_RETURN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETURN::actualTypeName (void) const {
  return "instruction_RETURN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETURN ("instruction_RETURN", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_RETFIE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETFIE::
cPtr_instruction_RETFIE (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mFastReturn (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETFIE * GGS_instruction_RETFIE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETFIE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETFIE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RETFIE * _p = dynamic_cast <const cPtr_instruction_RETFIE *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFastReturn._operator_isEqual (_p->mFastReturn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETFIE::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RETFIE:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFastReturn.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETFIE::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETFIE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETFIE (& typeid (cPtr_instruction_RETFIE), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETFIE::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETFIE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_RETFIE'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETFIE::
GGS_instruction_RETFIE (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETFIE::
GGS_instruction_RETFIE (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETFIE GGS_instruction_RETFIE::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETFIE _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETFIE *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETFIE) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETFIE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETFIE),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETFIE GGS_instruction_RETFIE::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETFIE result ;
  macroMyNew (result.mPointer, cPtr_instruction_RETFIE (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_RETFIE::
reader_mFastReturn (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETFIE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_RETFIE *) mPointer)->mFastReturn ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETFIE::actualTypeName (void) const {
  return "instruction_RETFIE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETFIE ("instruction_RETFIE", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SLEEP'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SLEEP::
cPtr_instruction_SLEEP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SLEEP * GGS_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SLEEP * _p = dynamic_cast <const cPtr_instruction_SLEEP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SLEEP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SLEEP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SLEEP (& typeid (cPtr_instruction_SLEEP), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SLEEP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SLEEP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SLEEP GGS_instruction_SLEEP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP GGS_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP result ;
  macroMyNew (result.mPointer, cPtr_instruction_SLEEP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SLEEP::actualTypeName (void) const {
  return "instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SLEEP ("instruction_SLEEP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'literal_instruction_opcode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_literal_instruction_opcode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_isEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_isNotEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_infOrEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_supOrEqual (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_strictInf (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_literal_instruction_opcode::
_operator_strictSup (const GGS_literal_instruction_opcode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literal_instruction_opcode::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "ADDLW",
    "ANDLW",
    "IORLW",
    "MOVLW",
    "MULLW",
    "RETLW",
    "SUBLW",
    "XORLW"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literal_instruction_opcode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @literal_instruction_opcode" ;
  switch (mValue) {
  case enum_ADDLW:
    s << " ADDLW>" ;
    break ;
  case enum_ANDLW:
    s << " ANDLW>" ;
    break ;
  case enum_IORLW:
    s << " IORLW>" ;
    break ;
  case enum_MOVLW:
    s << " MOVLW>" ;
    break ;
  case enum_MULLW:
    s << " MULLW>" ;
    break ;
  case enum_RETLW:
    s << " RETLW>" ;
    break ;
  case enum_SUBLW:
    s << " SUBLW>" ;
    break ;
  case enum_XORLW:
    s << " XORLW>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "getLiteralInstructionBaseCode"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getLiteralInstructionBaseCode (C_Compiler &,
                                const GGS_literal_instruction_opcode  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getLiteralInstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_literal_instruction_opcode::enum_ADDLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3840U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_ANDLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2816U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_IORLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2304U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MOVLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3584U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_MULLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3328U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_RETLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 3072U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_SUBLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2048U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::enum_XORLW:
    {
    var_cas_outBaseCode = GGS_uint (true, 2560U) ;
    }
    break ;
  case GGS_literal_instruction_opcode::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getLiteralInstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_literalOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_literalOperation::
cPtr_instruction_literalOperation (const GGS_location & argument_0,
                                const GGS_literal_instruction_opcode& argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mLiteralInstruction (argument_1),
mLiteralValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_literalOperation * GGS_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_literalOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_literalOperation * _p = dynamic_cast <const cPtr_instruction_literalOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralInstruction._operator_isEqual (_p->mLiteralInstruction).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_literalOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_literalOperation:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_literalOperation (& typeid (cPtr_instruction_literalOperation), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_literalOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_literalOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_literalOperation GGS_instruction_literalOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation GGS_instruction_literalOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_literal_instruction_opcode& argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation result ;
  macroMyNew (result.mPointer, cPtr_instruction_literalOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literal_instruction_opcode GGS_instruction_literalOperation::
reader_mLiteralInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_literal_instruction_opcode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mLiteralInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_literalOperation::
reader_mLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_literalOperation::actualTypeName (void) const {
  return "instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_literalOperation ("instruction_literalOperation", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LFSR'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LFSR::
cPtr_instruction_LFSR (const GGS_location & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mFSRindex (argument_1),
mRegisterExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LFSR * GGS_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LFSR * _p = dynamic_cast <const cPtr_instruction_LFSR *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFSRindex._operator_isEqual (_p->mFSRindex).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LFSR:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFSRindex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LFSR (& typeid (cPtr_instruction_LFSR), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LFSR ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LFSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_LFSR GGS_instruction_LFSR::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR GGS_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_instruction_LFSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_LFSR::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LFSR::actualTypeName (void) const {
  return "instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LFSR ("instruction_LFSR", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVLB'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVLB::
cPtr_instruction_MOVLB (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mPageIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVLB * GGS_instruction_MOVLB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVLB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVLB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVLB * _p = dynamic_cast <const cPtr_instruction_MOVLB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mPageIndex._operator_isEqual (_p->mPageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVLB:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVLB (& typeid (cPtr_instruction_MOVLB), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVLB::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVLB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVLB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVLB GGS_instruction_MOVLB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVLB *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVLB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVLB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVLB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB GGS_instruction_MOVLB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVLB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MOVLB::
reader_mPageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVLB *) mPointer)->mPageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVLB::actualTypeName (void) const {
  return "instruction_MOVLB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVLB ("instruction_MOVLB", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVAW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVAW::
cPtr_instruction_MOVAW (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mRegisterExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVAW * GGS_instruction_MOVAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVAW * _p = dynamic_cast <const cPtr_instruction_MOVAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVAW (& typeid (cPtr_instruction_MOVAW), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVAW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVAW GGS_instruction_MOVAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW GGS_instruction_MOVAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVAW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVAW::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVAW *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVAW::actualTypeName (void) const {
  return "instruction_MOVAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVAW ("instruction_MOVAW", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'tableAccessOption' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_tableAccessOption::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isNotEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_infOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_supOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictInf (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictSup (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "*-",
    "*+",
    "+*",
    "*"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @tableAccessOption" ;
  switch (mValue) {
  case enum_postDecrement:
    s << " postDecrement>" ;
    break ;
  case enum_postIncrement:
    s << " postIncrement>" ;
    break ;
  case enum_preIncrement:
    s << " preIncrement>" ;
    break ;
  case enum_simpleAccess:
    s << " simpleAccess>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLRD'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLRD::
cPtr_instruction_TBLRD (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLRD * GGS_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLRD * _p = dynamic_cast <const cPtr_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLRD::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLRD:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLRD (& typeid (cPtr_instruction_TBLRD), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLRD ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLRD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLRD GGS_instruction_TBLRD::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD GGS_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLRD (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLRD::actualTypeName (void) const {
  return "instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLRD ("instruction_TBLRD", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLWT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLWT::
cPtr_instruction_TBLWT (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLWT * GGS_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLWT * _p = dynamic_cast <const cPtr_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLWT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLWT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLWT (& typeid (cPtr_instruction_TBLWT), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLWT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLWT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLWT GGS_instruction_TBLWT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT GGS_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLWT (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLWT::actualTypeName (void) const {
  return "instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLWT ("instruction_TBLWT", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MNOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MNOP::
cPtr_instruction_MNOP (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mOccurrenceFactor (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MNOP * GGS_instruction_MNOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MNOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MNOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MNOP * _p = dynamic_cast <const cPtr_instruction_MNOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOccurrenceFactor._operator_isEqual (_p->mOccurrenceFactor).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MNOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MNOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOccurrenceFactor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MNOP (& typeid (cPtr_instruction_MNOP), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MNOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MNOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MNOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MNOP GGS_instruction_MNOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MNOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MNOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MNOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MNOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP GGS_instruction_MNOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_MNOP (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MNOP::
reader_mOccurrenceFactor (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MNOP *) mPointer)->mOccurrenceFactor ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MNOP::actualTypeName (void) const {
  return "instruction_MNOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MNOP ("instruction_MNOP", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_FOREVER'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FOREVER::
cPtr_instruction_FOREVER (const GGS_location & argument_0,
                                const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FOREVER * GGS_instruction_FOREVER::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FOREVER *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FOREVER::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FOREVER * _p = dynamic_cast <const cPtr_instruction_FOREVER *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FOREVER::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FOREVER:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FOREVER (& typeid (cPtr_instruction_FOREVER), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FOREVER::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FOREVER ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_FOREVER'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FOREVER GGS_instruction_FOREVER::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FOREVER *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FOREVER) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FOREVER (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FOREVER),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER GGS_instruction_FOREVER::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER result ;
  macroMyNew (result.mPointer, cPtr_instruction_FOREVER (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_FOREVER::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FOREVER *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FOREVER::actualTypeName (void) const {
  return "instruction_FOREVER" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FOREVER ("instruction_FOREVER", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'if_semi_colon_op' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_if_semi_colon_op::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_isEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_isNotEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_infOrEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_supOrEqual (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_strictInf (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_if_semi_colon_op::
_operator_strictSup (const GGS_if_semi_colon_op inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_if_semi_colon_op::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "CPFSEQ",
    "CPFSGT",
    "CPFSLT",
    "TSTFSZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_if_semi_colon_op::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @if_semi_colon_op" ;
  switch (mValue) {
  case enum_CPFSEQ:
    s << " CPFSEQ>" ;
    break ;
  case enum_CPFSGT:
    s << " CPFSGT>" ;
    break ;
  case enum_CPFSLT:
    s << " CPFSLT>" ;
    break ;
  case enum_TSTFSZ:
    s << " TSTFSZ>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "getBaseCodeForIfSemiColonOp"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBaseCodeForIfSemiColonOp (C_Compiler &,
                                const GGS_if_semi_colon_op  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBaseCodeForIfSemiColonOp at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_if_semi_colon_op::enum_CPFSEQ:
    {
    var_cas_outBaseCode = GGS_uint (true, 25088U) ;
    }
    break ;
  case GGS_if_semi_colon_op::enum_CPFSGT:
    {
    var_cas_outBaseCode = GGS_uint (true, 25600U) ;
    }
    break ;
  case GGS_if_semi_colon_op::enum_CPFSLT:
    {
    var_cas_outBaseCode = GGS_uint (true, 24576U) ;
    }
    break ;
  case GGS_if_semi_colon_op::enum_TSTFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 26112U) ;
    }
    break ;
  case GGS_if_semi_colon_op::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBaseCodeForIfSemiColonOp\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_IF_SEMI_COLON'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_SEMI_COLON::
cPtr_instruction_IF_SEMI_COLON (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mInstruction (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_SEMI_COLON * GGS_instruction_IF_SEMI_COLON::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_SEMI_COLON *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_SEMI_COLON::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_SEMI_COLON:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_SEMI_COLON (& typeid (cPtr_instruction_IF_SEMI_COLON), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_SEMI_COLON::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_SEMI_COLON ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_IF_SEMI_COLON'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_SEMI_COLON GGS_instruction_IF_SEMI_COLON::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_SEMI_COLON _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_SEMI_COLON) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_SEMI_COLON (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_SEMI_COLON),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_piccolo_instruction  GGS_instruction_IF_SEMI_COLON::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_piccolo_instruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_SEMI_COLON *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_SEMI_COLON::actualTypeName (void) const {
  return "instruction_IF_SEMI_COLON" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_SEMI_COLON ("instruction_IF_SEMI_COLON", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_IF_FA_SEMI_COLON'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_FA_SEMI_COLON::
cPtr_instruction_IF_FA_SEMI_COLON (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_if_semi_colon_op& argument_2,
                                const GGS_registerExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mOpCode (argument_2),
mRegisterExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_FA_SEMI_COLON * GGS_instruction_IF_FA_SEMI_COLON::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_FA_SEMI_COLON *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_FA_SEMI_COLON::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_FA_SEMI_COLON * _p = dynamic_cast <const cPtr_instruction_IF_FA_SEMI_COLON *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue ()
         && mOpCode._operator_isEqual (_p->mOpCode).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_FA_SEMI_COLON::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_FA_SEMI_COLON:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOpCode.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_FA_SEMI_COLON::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_FA_SEMI_COLON::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_FA_SEMI_COLON (& typeid (cPtr_instruction_IF_FA_SEMI_COLON), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_FA_SEMI_COLON::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_FA_SEMI_COLON ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_IF_FA_SEMI_COLON'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON::
GGS_instruction_IF_FA_SEMI_COLON (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON::
GGS_instruction_IF_FA_SEMI_COLON (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_FA_SEMI_COLON GGS_instruction_IF_FA_SEMI_COLON::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_FA_SEMI_COLON _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_FA_SEMI_COLON) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_FA_SEMI_COLON (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_FA_SEMI_COLON),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_FA_SEMI_COLON GGS_instruction_IF_FA_SEMI_COLON::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_if_semi_colon_op& argument_2,
                 const GGS_registerExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_FA_SEMI_COLON result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_FA_SEMI_COLON (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_if_semi_colon_op GGS_instruction_IF_FA_SEMI_COLON::
reader_mOpCode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_if_semi_colon_op  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_FA_SEMI_COLON *) mPointer)->mOpCode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_FA_SEMI_COLON::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_FA_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_FA_SEMI_COLON *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_FA_SEMI_COLON::actualTypeName (void) const {
  return "instruction_IF_FA_SEMI_COLON" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_FA_SEMI_COLON ("instruction_IF_FA_SEMI_COLON", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_instruction_IF_BitTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_BitTest::
cPtr_instruction_IF_BitTest (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_registerExpression & argument_3,
                                const GGS_bitNumberExpression & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mSkipIfSet (argument_2),
mRegisterExpression (argument_3),
mBitNumber (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_BitTest * GGS_instruction_IF_BitTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_BitTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_BitTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_BitTest * _p = dynamic_cast <const cPtr_instruction_IF_BitTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue ()
         && mSkipIfSet._operator_isEqual (_p->mSkipIfSet).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outBaseCode = GGS_uint (true, 40960U) ;
  }else{
    var_cas_outBaseCode = GGS_uint (true, 45056U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
method_getMnemonic (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outMnemonic COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outMnemonic = GGS_string (true, "BTFSS") ;
  }else{
    var_cas_outMnemonic = GGS_string (true, "BTFSC") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_BitTest:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfSet.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_BitTest (& typeid (cPtr_instruction_IF_BitTest), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_BitTest::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_BitTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_instruction_IF_BitTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_BitTest *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_BitTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_BitTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_BitTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_registerExpression & argument_3,
                 const GGS_bitNumberExpression & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_BitTest (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_BitTest::
reader_mSkipIfSet (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mSkipIfSet ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_BitTest::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_IF_BitTest::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_BitTest::actualTypeName (void) const {
  return "instruction_IF_BitTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_BitTest ("instruction_IF_BitTest", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_IF_IncDec'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_IncDec::
cPtr_instruction_IF_IncDec (const GGS_location & argument_0,
                                const GGS_piccolo_instruction & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_registerExpression & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1 COMMA_THERE),
mIncrement (argument_2),
mSkipIfZero (argument_3),
mRegisterExpression (argument_4),
m_W_isDestination (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_IncDec * GGS_instruction_IF_IncDec::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_IncDec *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_IncDec::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_IncDec * _p = dynamic_cast <const cPtr_instruction_IF_IncDec *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue ()
         && mIncrement._operator_isEqual (_p->mIncrement).boolValue ()
         && mSkipIfZero._operator_isEqual (_p->mSkipIfZero).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_IncDec::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_IncDec:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIncrement.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfZero.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_IncDec::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_IncDec::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_IncDec (& typeid (cPtr_instruction_IF_IncDec), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_IncDec::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_IncDec ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_IF_IncDec'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec::
GGS_instruction_IF_IncDec (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec::
GGS_instruction_IF_IncDec (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_IncDec GGS_instruction_IF_IncDec::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_IncDec _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_IncDec *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_IncDec) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_IncDec (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_IncDec),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_IncDec GGS_instruction_IF_IncDec::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_piccolo_instruction & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_registerExpression & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_IncDec result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_IncDec (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_mIncrement (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mIncrement ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_mSkipIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mSkipIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_IncDec::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_IncDec::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_IncDec *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_IncDec *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_IncDec::actualTypeName (void) const {
  return "instruction_IF_IncDec" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_IncDec ("instruction_IF_IncDec", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_computed_retlw'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_retlw::
cPtr_instruction_computed_retlw (const GGS_location & argument_0,
                                const GGS_luintlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mLiteralValues (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_retlw * GGS_instruction_computed_retlw::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_retlw *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_retlw::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_retlw * _p = dynamic_cast <const cPtr_instruction_computed_retlw *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValues._operator_isEqual (_p->mLiteralValues).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_retlw::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_retlw:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValues.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_retlw (& typeid (cPtr_instruction_computed_retlw), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_retlw::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_retlw ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_computed_retlw'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_retlw *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_retlw) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_retlw (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_retlw),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luintlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_retlw (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintlist  GGS_instruction_computed_retlw::
reader_mLiteralValues (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luintlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mLiteralValues ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_retlw::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_retlw::actualTypeName (void) const {
  return "instruction_computed_retlw" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_retlw ("instruction_computed_retlw", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_bra'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_bra::
cPtr_instruction_computed_bra (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_bra * GGS_instruction_computed_bra::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_bra *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_bra::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_bra * _p = dynamic_cast <const cPtr_instruction_computed_bra *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_bra::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_bra:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_bra (& typeid (cPtr_instruction_computed_bra), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_bra::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_bra ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_bra'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_bra GGS_instruction_computed_bra::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_bra *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_bra) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_bra (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_bra),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra GGS_instruction_computed_bra::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_bra (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_bra::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_bra::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_bra::actualTypeName (void) const {
  return "instruction_computed_bra" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_bra ("instruction_computed_bra", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_goto'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_goto::
cPtr_instruction_computed_goto (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_goto * GGS_instruction_computed_goto::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_goto *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_goto::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_goto * _p = dynamic_cast <const cPtr_instruction_computed_goto *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_goto::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_goto:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_goto (& typeid (cPtr_instruction_computed_goto), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_goto::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_goto ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_goto'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_goto GGS_instruction_computed_goto::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_goto *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_goto) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_goto (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_goto),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto GGS_instruction_computed_goto::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_goto (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_goto::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_goto::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_goto::actualTypeName (void) const {
  return "instruction_computed_goto" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_goto ("instruction_computed_goto", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_conditionExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_conditionExpression::
cPtr_conditionExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_conditionExpression * GGS_conditionExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_conditionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_conditionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_conditionExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@conditionExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_conditionExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_conditionExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_conditionExpression (& typeid (cPtr_conditionExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_conditionExpression::galgasRTTI (void) const {
  return & gClassInfoFor__conditionExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_conditionExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_conditionExpression::
GGS_conditionExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression::
GGS_conditionExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_conditionExpression GGS_conditionExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_conditionExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_conditionExpression *> (inPointer) != NULL)
      : (typeid (cPtr_conditionExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_conditionExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_conditionExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_conditionExpression::actualTypeName (void) const {
  return "conditionExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_conditionExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__conditionExpression ("conditionExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_registerTestCondition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerTestCondition::
cPtr_registerTestCondition (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mBranchIfZero (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerTestCondition * GGS_registerTestCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerTestCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerTestCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerTestCondition * _p = dynamic_cast <const cPtr_registerTestCondition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBranchIfZero._operator_isEqual (_p->mBranchIfZero).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerTestCondition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerTestCondition:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchIfZero.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerTestCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerTestCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerTestCondition (& typeid (cPtr_registerTestCondition), & typeid (cPtr_conditionExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerTestCondition::galgasRTTI (void) const {
  return & gClassInfoFor__registerTestCondition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_registerTestCondition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerTestCondition::
GGS_registerTestCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerTestCondition::
GGS_registerTestCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_registerTestCondition GGS_registerTestCondition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerTestCondition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerTestCondition *> (inPointer) != NULL)
      : (typeid (cPtr_registerTestCondition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_registerTestCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerTestCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerTestCondition GGS_registerTestCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerTestCondition result ;
  macroMyNew (result.mPointer, cPtr_registerTestCondition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_registerTestCondition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerTestCondition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerTestCondition::
reader_mBranchIfZero (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerTestCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerTestCondition *) mPointer)->mBranchIfZero ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerTestCondition::actualTypeName (void) const {
  return "registerTestCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__registerTestCondition ("registerTestCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'registerComparison' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_registerComparison::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_isEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_isNotEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_infOrEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_supOrEqual (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_strictInf (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerComparison::
_operator_strictSup (const GGS_registerComparison inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_registerComparison::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @registerComparison" ;
  switch (mValue) {
  case enum_equal:
    s << " equal>" ;
    break ;
  case enum_greater:
    s << " greater>" ;
    break ;
  case enum_greaterOrEqual:
    s << " greaterOrEqual>" ;
    break ;
  case enum_lower:
    s << " lower>" ;
    break ;
  case enum_lowerOrEqual:
    s << " lowerOrEqual>" ;
    break ;
  case enum_notEqual:
    s << " notEqual>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "getRegisterComparisonComplementary"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getRegisterComparisonComplementary (C_Compiler & _inLexique,
                                const GGS_registerComparison  var_cas_inComparison,
                                GGS_registerComparison & var_cas_outComparison COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getRegisterComparisonComplementary at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inComparison.enumValue ()) {
  case GGS_registerComparison::enum_notEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_equal (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_equal:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_notEqual (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_greaterOrEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_lower (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_greater:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_lowerOrEqual (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_lowerOrEqual:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_greater (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::enum_lower:
    {
    var_cas_outComparison = GGS_registerComparison::constructor_greaterOrEqual (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_registerComparison::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getRegisterComparisonComplementary\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_registerComparisonCondition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerComparisonCondition::
cPtr_registerComparisonCondition (const GGS_registerExpression & argument_0,
                                const GGS_registerComparison& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mComparison (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerComparisonCondition * GGS_registerComparisonCondition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerComparisonCondition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerComparisonCondition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerComparisonCondition * _p = dynamic_cast <const cPtr_registerComparisonCondition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mComparison._operator_isEqual (_p->mComparison).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerComparisonCondition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerComparisonCondition:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerComparisonCondition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerComparisonCondition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerComparisonCondition (& typeid (cPtr_registerComparisonCondition), & typeid (cPtr_conditionExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerComparisonCondition::galgasRTTI (void) const {
  return & gClassInfoFor__registerComparisonCondition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_registerComparisonCondition'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerComparisonCondition::
GGS_registerComparisonCondition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerComparisonCondition::
GGS_registerComparisonCondition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_registerComparisonCondition GGS_registerComparisonCondition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerComparisonCondition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerComparisonCondition *> (inPointer) != NULL)
      : (typeid (cPtr_registerComparisonCondition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_registerComparisonCondition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerComparisonCondition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparisonCondition GGS_registerComparisonCondition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_registerComparison& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerComparisonCondition result ;
  macroMyNew (result.mPointer, cPtr_registerComparisonCondition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_registerComparisonCondition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerComparisonCondition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerComparison GGS_registerComparisonCondition::
reader_mComparison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerComparison  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerComparisonCondition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerComparisonCondition *) mPointer)->mComparison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerComparisonCondition::actualTypeName (void) const {
  return "registerComparisonCondition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__registerComparisonCondition ("registerComparisonCondition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_bcc_in_structured_if_condition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bcc_in_structured_if_condition::
cPtr_bcc_in_structured_if_condition (const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mCondition (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bcc_in_structured_if_condition * GGS_bcc_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bcc_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bcc_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bcc_in_structured_if_condition * _p = dynamic_cast <const cPtr_bcc_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCondition._operator_isEqual (_p->mCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bcc_in_structured_if_condition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bcc_in_structured_if_condition:"
           << mCondition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bcc_in_structured_if_condition (& typeid (cPtr_bcc_in_structured_if_condition), & typeid (cPtr_conditionExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bcc_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bcc_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_bcc_in_structured_if_condition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bcc_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bcc_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bcc_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bcc_in_structured_if_condition (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_bcc_in_structured_if_condition::
reader_mCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bcc_in_structured_if_condition *) mPointer)->mCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bcc_in_structured_if_condition::actualTypeName (void) const {
  return "bcc_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bcc_in_structured_if_condition ("bcc_in_structured_if_condition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_bitTest_in_structured_if_condition'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitTest_in_structured_if_condition::
cPtr_bitTest_in_structured_if_condition (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_conditionExpression (THERE),
mRegisterExpression (argument_0),
mBitNumber (argument_1),
mBTFSSinstruction (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitTest_in_structured_if_condition * GGS_bitTest_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitTest_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitTest_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitTest_in_structured_if_condition * _p = dynamic_cast <const cPtr_bitTest_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue ()
         && mBTFSSinstruction._operator_isEqual (_p->mBTFSSinstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitTest_in_structured_if_condition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitTest_in_structured_if_condition:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBTFSSinstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitTest_in_structured_if_condition (& typeid (cPtr_bitTest_in_structured_if_condition), & typeid (cPtr_conditionExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitTest_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bitTest_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_bitTest_in_structured_if_condition'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bitTest_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitTest_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitTest_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bitTest_in_structured_if_condition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_bitTest_in_structured_if_condition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_bitTest_in_structured_if_condition::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bitTest_in_structured_if_condition::
reader_mBTFSSinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBTFSSinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitTest_in_structured_if_condition::actualTypeName (void) const {
  return "bitTest_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitTest_in_structured_if_condition ("bitTest_in_structured_if_condition", gClassInfoFor__conditionExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_structured_if'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_structured_if::
cPtr_instruction_structured_if (const GGS_location & argument_0,
                                const GGS_conditionExpression & argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mIfCondition (argument_1),
mThenInstructionList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_structured_if * GGS_instruction_structured_if::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_structured_if *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_structured_if::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_structured_if * _p = dynamic_cast <const cPtr_instruction_structured_if *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mIfCondition._operator_isEqual (_p->mIfCondition).boolValue ()
         && mThenInstructionList._operator_isEqual (_p->mThenInstructionList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_structured_if::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_structured_if:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIfCondition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mThenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_structured_if (& typeid (cPtr_instruction_structured_if), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_structured_if::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_structured_if ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_structured_if'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_structured_if GGS_instruction_structured_if::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_structured_if *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_structured_if) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_structured_if (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_structured_if),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if GGS_instruction_structured_if::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_conditionExpression & argument_1,
                 const GGS_instructionList & argument_2,
                 const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if result ;
  macroMyNew (result.mPointer, cPtr_instruction_structured_if (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_instruction_structured_if::
reader_mIfCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mIfCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mThenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mThenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_structured_if::actualTypeName (void) const {
  return "instruction_structured_if" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_structured_if ("instruction_structured_if", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_instruction_do_while'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_do_while::
cPtr_instruction_do_while (const GGS_location & argument_0,
                                const GGS_conditionExpression & argument_1,
                                const GGS_instructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_piccolo_instruction (argument_0 COMMA_THERE),
mWhileCondition (argument_1),
mRepeatedInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_do_while * GGS_instruction_do_while::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_do_while *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_do_while::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_do_while * _p = dynamic_cast <const cPtr_instruction_do_while *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mWhileCondition._operator_isEqual (_p->mWhileCondition).boolValue ()
         && mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_do_while::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_do_while:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileCondition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_do_while::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_do_while::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_do_while (& typeid (cPtr_instruction_do_while), & typeid (cPtr_piccolo_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_do_while::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_do_while ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_instruction_do_while'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_do_while::
GGS_instruction_do_while (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_do_while::
GGS_instruction_do_while (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_do_while GGS_instruction_do_while::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_do_while _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_do_while *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_do_while) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_do_while (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_do_while),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_do_while GGS_instruction_do_while::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_conditionExpression & argument_1,
                 const GGS_instructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_do_while result ;
  macroMyNew (result.mPointer, cPtr_instruction_do_while (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditionExpression  GGS_instruction_do_while::
reader_mWhileCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditionExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_do_while *) mPointer)->mWhileCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_do_while::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_do_while *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_do_while *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_do_while::actualTypeName (void) const {
  return "instruction_do_while" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_do_while ("instruction_do_while", gClassInfoFor__piccolo_instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@interruptDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_interruptDefinitionList::
elementOf_GGS_interruptDefinitionList (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInterruptName (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_interruptDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_interruptDefinitionList * _p = dynamic_cast <const elementOf_GGS_interruptDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInterruptName._operator_isEqual (_p->mInterruptName).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_interruptDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInterruptName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@interruptDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_instructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_instructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
_operator_concat (const GGS_interruptDefinitionList & inOperand) const {
  GGS_interruptDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_dotAssign_operation (const GGS_interruptDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_interruptDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mInterruptName ;
          GGS_instructionList  p_1 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_instructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInterruptName,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_emptyList (void) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
internalSubListWithRange (GGS_interruptDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInterruptName, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_interruptDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@interruptDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_instructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_instructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_instructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_instructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_interruptDefinitionList::
reader_mInterruptNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInterruptName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_interruptDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInterruptNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInterruptName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_interruptDefinitionList::cEnumerator::_mInterruptName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInterruptName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_interruptDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@routineDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDefinitionList::
elementOf_GGS_routineDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mBanksel (argument_1),
mHasNoReturn (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_routineDefinitionList * _p = dynamic_cast <const elementOf_GGS_routineDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mBanksel._operator_isEqual (_p->mBanksel).boolValue ()
         && mHasNoReturn._operator_isEqual (_p->mHasNoReturn).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBanksel.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHasNoReturn.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_instructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_instructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
_operator_concat (const GGS_routineDefinitionList & inOperand) const {
  GGS_routineDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_dotAssign_operation (const GGS_routineDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_routineDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_luint  p_1 = p->mBanksel ;
          GGS_bool p_2 = p->mHasNoReturn ;
          GGS_instructionList  p_3 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_bool& argument_2,
                     const GGS_instructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mBanksel,
                                _p->mHasNoReturn,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_emptyList (void) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
internalSubListWithRange (GGS_routineDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mRoutineName, _p->mBanksel, _p->mHasNoReturn, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_bool& _out_2,
              GGS_instructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_bool& _out_2,
             GGS_instructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_bool& _out_2,
                 GGS_instructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_bool& _out_2,
                GGS_instructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDefinitionList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDefinitionList::
reader_mBankselAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBanksel ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDefinitionList::
reader_mHasNoReturnAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHasNoReturn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_routineDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMBankselAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBanksel = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMHasNoReturnAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHasNoReturn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_routineDefinitionList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDefinitionList::cEnumerator::_mBanksel (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mBanksel ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDefinitionList::cEnumerator::_mHasNoReturn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mHasNoReturn ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_routineDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@declarationInRamList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_declarationInRamList::
elementOf_GGS_declarationInRamList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mSize (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_declarationInRamList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_declarationInRamList * _p = dynamic_cast <const elementOf_GGS_declarationInRamList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mSize._operator_isEqual (_p->mSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_declarationInRamList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSize.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@declarationInRamList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
_operator_concat (const GGS_declarationInRamList & inOperand) const {
  GGS_declarationInRamList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_dotAssign_operation (const GGS_declarationInRamList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_declarationInRamList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_luint  p_1 = p->mSize ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSize
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_emptyList (void) {
  GGS_declarationInRamList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  GGS_declarationInRamList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
internalSubListWithRange (GGS_declarationInRamList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mSize) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_declarationInRamList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@declarationInRamList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_declarationInRamList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_declarationInRamList::
reader_mSizeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSize ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_setMSizeAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSize = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_declarationInRamList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_declarationInRamList::cEnumerator::_mSize (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@ramDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ramDefinitionList::
elementOf_GGS_ramDefinitionList (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mBankName (argument_0),
mDeclaration (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ramDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ramDefinitionList * _p = dynamic_cast <const elementOf_GGS_ramDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBankName._operator_isEqual (_p->mBankName).boolValue ()
         && mDeclaration._operator_isEqual (_p->mDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ramDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBankName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclaration.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@ramDefinitionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
_operator_concat (const GGS_ramDefinitionList & inOperand) const {
  GGS_ramDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_dotAssign_operation (const GGS_ramDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ramDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mBankName ;
          GGS_declarationInRamList  p_1 = p->mDeclaration ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_declarationInRamList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mBankName,
                                _p->mDeclaration
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_emptyList (void) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
internalSubListWithRange (GGS_ramDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mBankName, _p->mDeclaration) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ramDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ramDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_declarationInRamList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_declarationInRamList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_declarationInRamList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_declarationInRamList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ramDefinitionList::
reader_mBankNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBankName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_ramDefinitionList::
reader_mDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMBankNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBankName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_declarationInRamList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ramDefinitionList::cEnumerator::_mBankName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mBankName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_declarationInRamList  & GGS_ramDefinitionList::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of 'piccoloModel' struct                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccoloModel::GGS_piccoloModel (void) :
mProgramName (),
mDeviceName (),
mRamDefinitionList (),
mInterruptDefinitionList (),
mRoutineDefinitionList (),
mNeedsComputedGoto2 (),
mNeedsComputedGoto4 () {
}

//---------------------------------------------------------------------------*

GGS_piccoloModel::~GGS_piccoloModel (void) {
}

//---------------------------------------------------------------------------*

void GGS_piccoloModel::_drop (void) {
  mProgramName._drop () ;
  mDeviceName._drop () ;
  mRamDefinitionList._drop () ;
  mInterruptDefinitionList._drop () ;
  mRoutineDefinitionList._drop () ;
  mNeedsComputedGoto2._drop () ;
  mNeedsComputedGoto4._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_piccoloModel::_isBuilt (void) const {
  return mProgramName._isBuilt ()
    && mDeviceName._isBuilt ()
    && mRamDefinitionList._isBuilt ()
    && mInterruptDefinitionList._isBuilt ()
    && mRoutineDefinitionList._isBuilt ()
    && mNeedsComputedGoto2._isBuilt ()
    && mNeedsComputedGoto4._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isEqual (inOperand.mProgramName)
    ._operator_and (mDeviceName._operator_isEqual (inOperand.mDeviceName))
    ._operator_and (mRamDefinitionList._operator_isEqual (inOperand.mRamDefinitionList))
    ._operator_and (mInterruptDefinitionList._operator_isEqual (inOperand.mInterruptDefinitionList))
    ._operator_and (mRoutineDefinitionList._operator_isEqual (inOperand.mRoutineDefinitionList))
    ._operator_and (mNeedsComputedGoto2._operator_isEqual (inOperand.mNeedsComputedGoto2))
    ._operator_and (mNeedsComputedGoto4._operator_isEqual (inOperand.mNeedsComputedGoto4)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isNotEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isNotEqual (inOperand.mProgramName)
    ._operator_or (mDeviceName._operator_isNotEqual (inOperand.mDeviceName))
    ._operator_or (mRamDefinitionList._operator_isNotEqual (inOperand.mRamDefinitionList))
    ._operator_or (mInterruptDefinitionList._operator_isNotEqual (inOperand.mInterruptDefinitionList))
    ._operator_or (mRoutineDefinitionList._operator_isNotEqual (inOperand.mRoutineDefinitionList))
    ._operator_or (mNeedsComputedGoto2._operator_isNotEqual (inOperand.mNeedsComputedGoto2))
    ._operator_or (mNeedsComputedGoto4._operator_isNotEqual (inOperand.mNeedsComputedGoto4)) ;
}

//---------------------------------------------------------------------------*

GGS_piccoloModel GGS_piccoloModel::
constructor_new (const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_ramDefinitionList & argument_2,
                 const GGS_interruptDefinitionList & argument_3,
                 const GGS_routineDefinitionList & argument_4,
                 const GGS_bool& argument_5,
                 const GGS_bool& argument_6) {
  GGS_piccoloModel result ;
  result.mProgramName = argument_0 ;
  result.mDeviceName = argument_1 ;
  result.mRamDefinitionList = argument_2 ;
  result.mInterruptDefinitionList = argument_3 ;
  result.mRoutineDefinitionList = argument_4 ;
  result.mNeedsComputedGoto2 = argument_5 ;
  result.mNeedsComputedGoto4 = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_piccoloModel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @piccoloModel" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mProgramName " ;
    _s << mProgramName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDeviceName " ;
    _s << mDeviceName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRamDefinitionList " ;
    _s << mRamDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mInterruptDefinitionList " ;
    _s << mInterruptDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineDefinitionList " ;
    _s << mRoutineDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto2 " ;
    _s << mNeedsComputedGoto2.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto4 " ;
    _s << mNeedsComputedGoto4.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

