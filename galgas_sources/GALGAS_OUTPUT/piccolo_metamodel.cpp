//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'piccolo_metamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      july 21th, 2008, at 19h30'55"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_metamodel.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction::
cPtr_instruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction * GGS_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 2U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction (& typeid (cPtr_instruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_instruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction::
GGS_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction::
GGS_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction GGS_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_instruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction::actualTypeName (void) const {
  return "instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_instruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__instruction ("instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_pseudo_ORG'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_pseudo_ORG::
cPtr_pseudo_ORG (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mOrigin (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_pseudo_ORG * GGS_pseudo_ORG::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_pseudo_ORG *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_pseudo_ORG::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_pseudo_ORG * _p = dynamic_cast <const cPtr_pseudo_ORG *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOrigin._operator_isEqual (_p->mOrigin).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_pseudo_ORG::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_pseudo_ORG::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@pseudo_ORG:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOrigin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_pseudo_ORG::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_pseudo_ORG::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_pseudo_ORG (& typeid (cPtr_pseudo_ORG), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_pseudo_ORG::galgasRTTI (void) const {
  return & gClassInfoFor__pseudo_ORG ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_pseudo_ORG'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_pseudo_ORG::
GGS_pseudo_ORG (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_pseudo_ORG::
GGS_pseudo_ORG (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_pseudo_ORG GGS_pseudo_ORG::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_pseudo_ORG _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_pseudo_ORG *> (inPointer) != NULL)
      : (typeid (cPtr_pseudo_ORG) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_pseudo_ORG (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_pseudo_ORG),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_pseudo_ORG GGS_pseudo_ORG::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_pseudo_ORG result ;
  macroMyNew (result.mPointer, cPtr_pseudo_ORG (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_pseudo_ORG::
reader_mOrigin (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_pseudo_ORG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_pseudo_ORG *) mPointer)->mOrigin ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_pseudo_ORG::actualTypeName (void) const {
  return "pseudo_ORG" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__pseudo_ORG ("pseudo_ORG", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@instructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_instructionList::
elementOf_GGS_instructionList (const GGS_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instructionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instructionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@instructionList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalAppendValues (const GGS_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalPrependValues (const GGS_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_addAssign_operation (const GGS_instruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
_operator_concat (const GGS_instructionList & inOperand) const {
  GGS_instructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_dotAssign_operation (const GGS_instructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_emptyList (void) {
  GGS_instructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_listWithValue (const GGS_instruction & argument_0) {
  GGS_instructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
internalSubListWithRange (GGS_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_first (C_Compiler & _inLexique,
              GGS_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_last (C_Compiler & _inLexique,
             GGS_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_instruction  GGS_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_instruction  & GGS_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_registerExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerExpression::
cPtr_registerExpression (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mRegisterName (argument_0),
mOffset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerExpression * GGS_registerExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerExpression * _p = dynamic_cast <const cPtr_registerExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterName._operator_isEqual (_p->mRegisterName).boolValue ()
         && mOffset._operator_isEqual (_p->mOffset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerExpression:"
           << mRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerExpression (& typeid (cPtr_registerExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerExpression::galgasRTTI (void) const {
  return & gClassInfoFor__registerExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_registerExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_registerExpression GGS_registerExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerExpression *> (inPointer) != NULL)
      : (typeid (cPtr_registerExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_registerExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression GGS_registerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerExpression result ;
  macroMyNew (result.mPointer, cPtr_registerExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_registerExpression::
reader_mRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_registerExpression::
reader_mOffset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerExpression::actualTypeName (void) const {
  return "registerExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_registerExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__registerExpression ("registerExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'instruction_FDA_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_instruction_FDA_base_code::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_isEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_isNotEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_infOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_supOrEqual (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_strictInf (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA_base_code::
_operator_strictSup (const GGS_instruction_FDA_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instruction_FDA_base_code::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @instruction_FDA_base_code" ;
  switch (mValue) {
  case enum_ADDWF:
    s << " ADDWF>" ;
    break ;
  case enum_ADDWFC:
    s << " ADDWFC>" ;
    break ;
  case enum_ANDWF:
    s << " ANDWF>" ;
    break ;
  case enum_COMF:
    s << " COMF>" ;
    break ;
  case enum_DECF:
    s << " DECF>" ;
    break ;
  case enum_DECFSZ:
    s << " DECFSZ>" ;
    break ;
  case enum_DCFSNZ:
    s << " DCFSNZ>" ;
    break ;
  case enum_INCF:
    s << " INCF>" ;
    break ;
  case enum_INCFSZ:
    s << " INCFSZ>" ;
    break ;
  case enum_INFSNZ:
    s << " INFSNZ>" ;
    break ;
  case enum_IORWF:
    s << " IORWF>" ;
    break ;
  case enum_MOVF:
    s << " MOVF>" ;
    break ;
  case enum_RLCF:
    s << " RLCF>" ;
    break ;
  case enum_RLNCF:
    s << " RLNCF>" ;
    break ;
  case enum_RRCF:
    s << " RRCF>" ;
    break ;
  case enum_RRNCF:
    s << " RRNCF>" ;
    break ;
  case enum_SUBFWB:
    s << " SUBFWB>" ;
    break ;
  case enum_SUBWF:
    s << " SUBWF>" ;
    break ;
  case enum_SUBWFB:
    s << " SUBWFB>" ;
    break ;
  case enum_SWAPF:
    s << " SWAPF>" ;
    break ;
  case enum_XORWF:
    s << " XORWF>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "getFDAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFDAinstructionBaseCode (C_Compiler &,
                                const GGS_instruction_FDA_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFDAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_instruction_FDA_base_code::enum_ADDWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 9216U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ADDWFC:
    {
    var_cas_outBaseCode = GGS_uint (true, 8192U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_ANDWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 5120U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_COMF:
    {
    var_cas_outBaseCode = GGS_uint (true, 7168U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECF:
    {
    var_cas_outBaseCode = GGS_uint (true, 1024U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DECFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 11264U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_DCFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 19456U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 10240U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INCFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 15360U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_INFSNZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 18432U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_IORWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 4096U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_MOVF:
    {
    var_cas_outBaseCode = GGS_uint (true, 20480U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 13312U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RLNCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 17408U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 12288U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_RRNCF:
    {
    var_cas_outBaseCode = GGS_uint (true, 16384U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBFWB:
    {
    var_cas_outBaseCode = GGS_uint (true, 21504U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 23552U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SUBWFB:
    {
    var_cas_outBaseCode = GGS_uint (true, 22528U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_SWAPF:
    {
    var_cas_outBaseCode = GGS_uint (true, 14336U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::enum_XORWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 6144U) ;
    }
    break ;
  case GGS_instruction_FDA_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFDAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FDA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FDA::
cPtr_instruction_FDA (const GGS_location & argument_0,
                                const GGS_instruction_FDA_base_code& argument_1,
                                const GGS_registerExpression & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mInstruction_FDA_base_code (argument_1),
mRegisterExpression (argument_2),
m_W_isDestination (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FDA * GGS_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FDA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FDA * _p = dynamic_cast <const cPtr_instruction_FDA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstruction_FDA_base_code._operator_isEqual (_p->mInstruction_FDA_base_code).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FDA::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFDAinstructionBaseCode (_inLexique,  mInstruction_FDA_base_code,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (101)) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FDA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FDA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction_FDA_base_code.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FDA (& typeid (cPtr_instruction_FDA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FDA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FDA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FDA GGS_instruction_FDA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA GGS_instruction_FDA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instruction_FDA_base_code& argument_1,
                 const GGS_registerExpression & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FDA (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA_base_code GGS_instruction_FDA::
reader_mInstruction_FDA_base_code (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction_FDA_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mInstruction_FDA_base_code ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FDA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FDA::actualTypeName (void) const {
  return "instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FDA ("instruction_FDA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Class for 'FA_instruction_base_code' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_FA_instruction_base_code::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_isEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_isNotEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_infOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_supOrEqual (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_strictInf (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_FA_instruction_base_code::
_operator_strictSup (const GGS_FA_instruction_base_code inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_mnemonic (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [9] = {"",
    "CLRF",
    "CPFSGT",
    "CPFSLT",
    "MOVWF",
    "MULWF",
    "NEGF",
    "SETF",
    "TSTFSZ"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_FA_instruction_base_code::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @FA_instruction_base_code" ;
  switch (mValue) {
  case enum_CLRF:
    s << " CLRF>" ;
    break ;
  case enum_CPFSGT:
    s << " CPFSGT>" ;
    break ;
  case enum_CPFSLT:
    s << " CPFSLT>" ;
    break ;
  case enum_MOVWF:
    s << " MOVWF>" ;
    break ;
  case enum_MULWF:
    s << " MULWF>" ;
    break ;
  case enum_NEGF:
    s << " NEGF>" ;
    break ;
  case enum_SETF:
    s << " SETF>" ;
    break ;
  case enum_TSTFSZ:
    s << " TSTFSZ>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "getFAinstructionBaseCode"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getFAinstructionBaseCode (C_Compiler &,
                                const GGS_FA_instruction_base_code  var_cas_inInstruction,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getFAinstructionBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inInstruction.enumValue ()) {
  case GGS_FA_instruction_base_code::enum_CLRF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27136U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSGT:
    {
    var_cas_outBaseCode = GGS_uint (true, 25600U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_CPFSLT:
    {
    var_cas_outBaseCode = GGS_uint (true, 24576U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MOVWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 28160U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_MULWF:
    {
    var_cas_outBaseCode = GGS_uint (true, 512U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_NEGF:
    {
    var_cas_outBaseCode = GGS_uint (true, 27648U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_SETF:
    {
    var_cas_outBaseCode = GGS_uint (true, 26624U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::enum_TSTFSZ:
    {
    var_cas_outBaseCode = GGS_uint (true, 26112U) ;
    }
    break ;
  case GGS_FA_instruction_base_code::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getFAinstructionBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FA'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FA::
cPtr_instruction_FA (const GGS_location & argument_0,
                                const GGS_FA_instruction_base_code& argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mFAinstruction (argument_1),
mRegisterExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FA * GGS_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FA * _p = dynamic_cast <const cPtr_instruction_FA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFAinstruction._operator_isEqual (_p->mFAinstruction).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FA::
method_getBaseCode (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_getFAinstructionBaseCode (_inLexique,  mFAinstruction,  var_cas_outBaseCode COMMA_SOURCE_FILE_AT_LINE (155)) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFAinstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FA (& typeid (cPtr_instruction_FA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FA GGS_instruction_FA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA GGS_instruction_FA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_FA_instruction_base_code& argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FA result ;
  macroMyNew (result.mPointer, cPtr_instruction_FA (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_FA_instruction_base_code GGS_instruction_FA::
reader_mFAinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_FA_instruction_base_code  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mFAinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FA::actualTypeName (void) const {
  return "instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FA ("instruction_FA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVFF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVFF::
cPtr_instruction_MOVFF (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mSourceRegisterName (argument_1),
mDestinationRegisterName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVFF * GGS_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVFF * _p = dynamic_cast <const cPtr_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mSourceRegisterName._operator_isEqual (_p->mSourceRegisterName).boolValue ()
         && mDestinationRegisterName._operator_isEqual (_p->mDestinationRegisterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVFF:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVFF (& typeid (cPtr_instruction_MOVFF), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVFF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVFF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVFF GGS_instruction_MOVFF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF GGS_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVFF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mSourceRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mSourceRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mDestinationRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mDestinationRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVFF::actualTypeName (void) const {
  return "instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVFF ("instruction_MOVFF", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberExpression::
cPtr_bitNumberExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberExpression * GGS_bitNumberExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_bitNumberExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@bitNumberExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberExpression (& typeid (cPtr_bitNumberExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberExpression::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberExpression GGS_bitNumberExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberExpression *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberExpression::actualTypeName (void) const {
  return "bitNumberExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_bitNumberExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__bitNumberExpression ("bitNumberExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_bitNumberLiteralValue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLiteralValue::
cPtr_bitNumberLiteralValue (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLiteralValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLiteralValue * GGS_bitNumberLiteralValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLiteralValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLiteralValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLiteralValue * _p = dynamic_cast <const cPtr_bitNumberLiteralValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLiteralValue._operator_isEqual (_p->mBitNumberLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLiteralValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLiteralValue:"
           << mBitNumberLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLiteralValue (& typeid (cPtr_bitNumberLiteralValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLiteralValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLiteralValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_bitNumberLiteralValue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLiteralValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLiteralValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLiteralValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLiteralValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLiteralValue (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLiteralValue::
reader_mBitNumberLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLiteralValue *) mPointer)->mBitNumberLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLiteralValue::actualTypeName (void) const {
  return "bitNumberLiteralValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLiteralValue ("bitNumberLiteralValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberLabelValue'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLabelValue::
cPtr_bitNumberLabelValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLabelValue (argument_0),
mBitNumberIndexValue (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLabelValue * GGS_bitNumberLabelValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLabelValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLabelValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLabelValue * _p = dynamic_cast <const cPtr_bitNumberLabelValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLabelValue._operator_isEqual (_p->mBitNumberLabelValue).boolValue ()
         && mBitNumberIndexValue._operator_isEqual (_p->mBitNumberIndexValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLabelValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLabelValue:"
           << mBitNumberLabelValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumberIndexValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLabelValue (& typeid (cPtr_bitNumberLabelValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLabelValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLabelValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberLabelValue'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLabelValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLabelValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLabelValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLabelValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLabelValue (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_bitNumberLabelValue::
reader_mBitNumberLabelValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberLabelValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLabelValue::
reader_mBitNumberIndexValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberIndexValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLabelValue::actualTypeName (void) const {
  return "bitNumberLabelValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLabelValue ("bitNumberLabelValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FBA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FBA::
cPtr_instruction_FBA (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mRegisterExpression (argument_1),
mBitNumber (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FBA * GGS_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_FBA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FBA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FBA (& typeid (cPtr_instruction_FBA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FBA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FBA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FBA GGS_instruction_FBA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FBA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FBA::actualTypeName (void) const {
  return "instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FBA ("instruction_FBA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BCF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BCF::
cPtr_instruction_BCF (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BCF * GGS_instruction_BCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BCF * _p = dynamic_cast <const cPtr_instruction_BCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 36864U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BCF:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BCF (& typeid (cPtr_instruction_BCF), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BCF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BCF::
GGS_instruction_BCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BCF::
GGS_instruction_BCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BCF GGS_instruction_BCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BCF GGS_instruction_BCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_BCF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BCF::actualTypeName (void) const {
  return "instruction_BCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BCF ("instruction_BCF", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BSF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BSF::
cPtr_instruction_BSF (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BSF * GGS_instruction_BSF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BSF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BSF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BSF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BSF * _p = dynamic_cast <const cPtr_instruction_BSF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BSF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 32768U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BSF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BSF:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BSF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BSF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BSF (& typeid (cPtr_instruction_BSF), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BSF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BSF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BSF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BSF::
GGS_instruction_BSF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BSF::
GGS_instruction_BSF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BSF GGS_instruction_BSF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BSF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BSF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BSF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BSF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BSF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BSF GGS_instruction_BSF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BSF result ;
  macroMyNew (result.mPointer, cPtr_instruction_BSF (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BSF::actualTypeName (void) const {
  return "instruction_BSF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BSF ("instruction_BSF", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_BTFSC'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTFSC::
cPtr_instruction_BTFSC (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTFSC * GGS_instruction_BTFSC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTFSC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTFSC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTFSC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTFSC * _p = dynamic_cast <const cPtr_instruction_BTFSC *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSC::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 45056U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSC::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTFSC:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTFSC (& typeid (cPtr_instruction_BTFSC), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTFSC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTFSC ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_BTFSC'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTFSC::
GGS_instruction_BTFSC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSC::
GGS_instruction_BTFSC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTFSC GGS_instruction_BTFSC::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSC _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTFSC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTFSC) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTFSC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTFSC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSC GGS_instruction_BTFSC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSC result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTFSC (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTFSC::actualTypeName (void) const {
  return "instruction_BTFSC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTFSC ("instruction_BTFSC", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_BTFSS'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTFSS::
cPtr_instruction_BTFSS (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTFSS * GGS_instruction_BTFSS::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTFSS *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTFSS *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTFSS::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTFSS * _p = dynamic_cast <const cPtr_instruction_BTFSS *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSS::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 40960U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSS::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTFSS:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSS::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSS::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTFSS (& typeid (cPtr_instruction_BTFSS), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTFSS::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTFSS ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_BTFSS'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTFSS::
GGS_instruction_BTFSS (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSS::
GGS_instruction_BTFSS (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTFSS GGS_instruction_BTFSS::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSS _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTFSS *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTFSS) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTFSS (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTFSS),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSS GGS_instruction_BTFSS::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSS result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTFSS (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTFSS::actualTypeName (void) const {
  return "instruction_BTFSS" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTFSS ("instruction_BTFSS", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BTG'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTG::
cPtr_instruction_BTG (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTG * GGS_instruction_BTG::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTG *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTG::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTG * _p = dynamic_cast <const cPtr_instruction_BTG *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTG::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 28672U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTG::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTG:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTG::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTG::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTG (& typeid (cPtr_instruction_BTG), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTG::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTG ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BTG'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTG::
GGS_instruction_BTG (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTG::
GGS_instruction_BTG (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTG GGS_instruction_BTG::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTG _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTG *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTG) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTG (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTG),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTG GGS_instruction_BTG::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_bitNumberExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTG result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTG (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTG::actualTypeName (void) const {
  return "instruction_BTG" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTG ("instruction_BTG", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'conditional_branch' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_conditional_branch::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_isEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_isNotEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_infOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_supOrEqual (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_strictInf (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_conditional_branch::
_operator_strictSup (const GGS_conditional_branch inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_conditional_branch::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @conditional_branch" ;
  switch (mValue) {
  case enum_bz:
    s << " bz>" ;
    break ;
  case enum_bnz:
    s << " bnz>" ;
    break ;
  case enum_bn:
    s << " bn>" ;
    break ;
  case enum_bnn:
    s << " bnn>" ;
    break ;
  case enum_bc:
    s << " bc>" ;
    break ;
  case enum_bnc:
    s << " bnc>" ;
    break ;
  case enum_bov:
    s << " bov>" ;
    break ;
  case enum_bnov:
    s << " bnov>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "getBccBaseCode"                 *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getBccBaseCode (C_Compiler &,
                                const GGS_conditional_branch  var_cas_inConditionalBranch,
                                GGS_uint  & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getBccBaseCode at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inConditionalBranch.enumValue ()) {
  case GGS_conditional_branch::enum_bz:
    {
    var_cas_outBaseCode = GGS_uint (true, 57344U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnz:
    {
    var_cas_outBaseCode = GGS_uint (true, 57600U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bn:
    {
    var_cas_outBaseCode = GGS_uint (true, 58880U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnn:
    {
    var_cas_outBaseCode = GGS_uint (true, 59136U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bc:
    {
    var_cas_outBaseCode = GGS_uint (true, 57856U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnc:
    {
    var_cas_outBaseCode = GGS_uint (true, 58112U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bov:
    {
    var_cas_outBaseCode = GGS_uint (true, 58368U) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnov:
    {
    var_cas_outBaseCode = GGS_uint (true, 58624U) ;
    }
    break ;
  case GGS_conditional_branch::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getBccBaseCode\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "getComplementaryBcc"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getComplementaryBcc (C_Compiler & _inLexique,
                                const GGS_conditional_branch  var_cas_inConditionalBranch,
                                GGS_conditional_branch & var_cas_outComplementary COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getComplementaryBcc at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (var_cas_inConditionalBranch.enumValue ()) {
  case GGS_conditional_branch::enum_bz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnz (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnz:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bz (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnn (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnn:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bn (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnc (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnc:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bc (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bnov (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::enum_bnov:
    {
    var_cas_outComplementary = GGS_conditional_branch::constructor_bov (_inLexique COMMA_HERE) ;
    }
    break ;
  case GGS_conditional_branch::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getComplementaryBcc\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_conditionalBranch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_conditionalBranch::
cPtr_instruction_conditionalBranch (const GGS_location & argument_0,
                                const GGS_conditional_branch& argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mConditionalBranch (argument_1),
mTargetLabel (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_conditionalBranch * GGS_instruction_conditionalBranch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_conditionalBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_conditionalBranch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_conditionalBranch * _p = dynamic_cast <const cPtr_instruction_conditionalBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mConditionalBranch._operator_isEqual (_p->mConditionalBranch).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_conditionalBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_conditionalBranch:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConditionalBranch.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_conditionalBranch (& typeid (cPtr_instruction_conditionalBranch), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_conditionalBranch::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_conditionalBranch ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_conditionalBranch'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_conditionalBranch GGS_instruction_conditionalBranch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_conditionalBranch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_conditionalBranch *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_conditionalBranch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_conditionalBranch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_conditionalBranch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch GGS_instruction_conditionalBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_conditional_branch& argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_conditionalBranch result ;
  macroMyNew (result.mPointer, cPtr_instruction_conditionalBranch (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_instruction_conditionalBranch::
reader_mConditionalBranch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mConditionalBranch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_conditionalBranch::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_conditionalBranch::actualTypeName (void) const {
  return "instruction_conditionalBranch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_conditionalBranch ("instruction_conditionalBranch", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BRA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BRA::
cPtr_instruction_BRA (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BRA * GGS_instruction_BRA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BRA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BRA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BRA * _p = dynamic_cast <const cPtr_instruction_BRA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BRA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BRA:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BRA (& typeid (cPtr_instruction_BRA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BRA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BRA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BRA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BRA GGS_instruction_BRA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BRA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BRA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BRA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BRA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA GGS_instruction_BRA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA result ;
  macroMyNew (result.mPointer, cPtr_instruction_BRA (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_BRA::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_BRA *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BRA::actualTypeName (void) const {
  return "instruction_BRA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BRA ("instruction_BRA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_CALL'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CALL::
cPtr_instruction_CALL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CALL * GGS_instruction_CALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CALL * _p = dynamic_cast <const cPtr_instruction_CALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CALL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CALL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CALL (& typeid (cPtr_instruction_CALL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_CALL'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CALL GGS_instruction_CALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL GGS_instruction_CALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_CALL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_CALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_CALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CALL::actualTypeName (void) const {
  return "instruction_CALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CALL ("instruction_CALL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_GOTO'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_GOTO::
cPtr_instruction_GOTO (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_GOTO * GGS_instruction_GOTO::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_GOTO *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_GOTO::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_GOTO * _p = dynamic_cast <const cPtr_instruction_GOTO *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_GOTO::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_GOTO::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_GOTO:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_GOTO (& typeid (cPtr_instruction_GOTO), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_GOTO::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_GOTO ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_GOTO'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_GOTO GGS_instruction_GOTO::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_GOTO *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_GOTO) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_GOTO (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_GOTO),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO GGS_instruction_GOTO::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO result ;
  macroMyNew (result.mPointer, cPtr_instruction_GOTO (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_GOTO::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_GOTO *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_GOTO::actualTypeName (void) const {
  return "instruction_GOTO" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_GOTO ("instruction_GOTO", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RCALL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RCALL::
cPtr_instruction_RCALL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RCALL * GGS_instruction_RCALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RCALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RCALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RCALL * _p = dynamic_cast <const cPtr_instruction_RCALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RCALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RCALL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RCALL (& typeid (cPtr_instruction_RCALL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RCALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RCALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RCALL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RCALL GGS_instruction_RCALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RCALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RCALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RCALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RCALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL GGS_instruction_RCALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_RCALL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_RCALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_RCALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RCALL::actualTypeName (void) const {
  return "instruction_RCALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RCALL ("instruction_RCALL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CLRWDT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CLRWDT::
cPtr_instruction_CLRWDT (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CLRWDT * GGS_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CLRWDT * _p = dynamic_cast <const cPtr_instruction_CLRWDT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CLRWDT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CLRWDT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CLRWDT (& typeid (cPtr_instruction_CLRWDT), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CLRWDT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT result ;
  macroMyNew (result.mPointer, cPtr_instruction_CLRWDT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CLRWDT::actualTypeName (void) const {
  return "instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CLRWDT ("instruction_CLRWDT", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_DAW'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DAW::
cPtr_instruction_DAW (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DAW * GGS_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DAW * _p = dynamic_cast <const cPtr_instruction_DAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DAW (& typeid (cPtr_instruction_DAW), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_DAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DAW GGS_instruction_DAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW GGS_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_DAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DAW::actualTypeName (void) const {
  return "instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DAW ("instruction_DAW", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_NOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_NOP::
cPtr_instruction_NOP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_NOP * GGS_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_NOP * _p = dynamic_cast <const cPtr_instruction_NOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_NOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_NOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_NOP (& typeid (cPtr_instruction_NOP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_NOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_NOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_NOP GGS_instruction_NOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP GGS_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_NOP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_NOP::actualTypeName (void) const {
  return "instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_NOP ("instruction_NOP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_POP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_POP::
cPtr_instruction_POP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_POP * GGS_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_POP * _p = dynamic_cast <const cPtr_instruction_POP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_POP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_POP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_POP (& typeid (cPtr_instruction_POP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_POP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_POP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_POP GGS_instruction_POP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_POP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP GGS_instruction_POP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_POP result ;
  macroMyNew (result.mPointer, cPtr_instruction_POP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_POP::actualTypeName (void) const {
  return "instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_POP ("instruction_POP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_PUSH'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_PUSH::
cPtr_instruction_PUSH (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_PUSH * GGS_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_PUSH * _p = dynamic_cast <const cPtr_instruction_PUSH *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_PUSH::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_PUSH:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_PUSH (& typeid (cPtr_instruction_PUSH), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_PUSH ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_PUSH'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_PUSH GGS_instruction_PUSH::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH GGS_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH result ;
  macroMyNew (result.mPointer, cPtr_instruction_PUSH (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_PUSH::actualTypeName (void) const {
  return "instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_PUSH ("instruction_PUSH", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RESET'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RESET::
cPtr_instruction_RESET (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RESET * GGS_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RESET * _p = dynamic_cast <const cPtr_instruction_RESET *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RESET::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RESET:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RESET (& typeid (cPtr_instruction_RESET), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RESET ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RESET'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RESET GGS_instruction_RESET::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET GGS_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET result ;
  macroMyNew (result.mPointer, cPtr_instruction_RESET (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RESET::actualTypeName (void) const {
  return "instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RESET ("instruction_RESET", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_RETURN'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETURN::
cPtr_instruction_RETURN (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETURN * GGS_instruction_RETURN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETURN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETURN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETURN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RETURN * _p = dynamic_cast <const cPtr_instruction_RETURN *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETURN::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RETURN:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETURN (& typeid (cPtr_instruction_RETURN), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETURN::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETURN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_RETURN'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETURN GGS_instruction_RETURN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETURN *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETURN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETURN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETURN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN GGS_instruction_RETURN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN result ;
  macroMyNew (result.mPointer, cPtr_instruction_RETURN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETURN::actualTypeName (void) const {
  return "instruction_RETURN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETURN ("instruction_RETURN", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SLEEP'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SLEEP::
cPtr_instruction_SLEEP (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SLEEP * GGS_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SLEEP * _p = dynamic_cast <const cPtr_instruction_SLEEP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SLEEP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SLEEP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SLEEP (& typeid (cPtr_instruction_SLEEP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SLEEP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SLEEP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SLEEP GGS_instruction_SLEEP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP GGS_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP result ;
  macroMyNew (result.mPointer, cPtr_instruction_SLEEP (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SLEEP::actualTypeName (void) const {
  return "instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SLEEP ("instruction_SLEEP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_literalOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_literalOperation::
cPtr_instruction_literalOperation (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mLiteralValue (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_literalOperation * GGS_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_literalOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_literalOperation:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_literalOperation (& typeid (cPtr_instruction_literalOperation), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_literalOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_literalOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_literalOperation GGS_instruction_literalOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_literalOperation::
reader_mLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_literalOperation::actualTypeName (void) const {
  return "instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_literalOperation ("instruction_literalOperation", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ADDLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ADDLW::
cPtr_instruction_ADDLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ADDLW * GGS_instruction_ADDLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ADDLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ADDLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ADDLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ADDLW * _p = dynamic_cast <const cPtr_instruction_ADDLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 3840U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ADDLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ADDLW (& typeid (cPtr_instruction_ADDLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ADDLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ADDLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ADDLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ADDLW::
GGS_instruction_ADDLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDLW::
GGS_instruction_ADDLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ADDLW GGS_instruction_ADDLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ADDLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ADDLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ADDLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ADDLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDLW GGS_instruction_ADDLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_ADDLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ADDLW::actualTypeName (void) const {
  return "instruction_ADDLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ADDLW ("instruction_ADDLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ANDLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ANDLW::
cPtr_instruction_ANDLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ANDLW * GGS_instruction_ANDLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ANDLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ANDLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ANDLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ANDLW * _p = dynamic_cast <const cPtr_instruction_ANDLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ANDLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 2816U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ANDLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ANDLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ANDLW (& typeid (cPtr_instruction_ANDLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ANDLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ANDLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ANDLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ANDLW::
GGS_instruction_ANDLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDLW::
GGS_instruction_ANDLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ANDLW GGS_instruction_ANDLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ANDLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ANDLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ANDLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ANDLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDLW GGS_instruction_ANDLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_ANDLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ANDLW::actualTypeName (void) const {
  return "instruction_ANDLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ANDLW ("instruction_ANDLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_IORLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IORLW::
cPtr_instruction_IORLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IORLW * GGS_instruction_IORLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IORLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IORLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IORLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IORLW * _p = dynamic_cast <const cPtr_instruction_IORLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IORLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 2304U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IORLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IORLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IORLW (& typeid (cPtr_instruction_IORLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IORLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IORLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_IORLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IORLW::
GGS_instruction_IORLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORLW::
GGS_instruction_IORLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IORLW GGS_instruction_IORLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IORLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IORLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IORLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IORLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IORLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORLW GGS_instruction_IORLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IORLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_IORLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IORLW::actualTypeName (void) const {
  return "instruction_IORLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IORLW ("instruction_IORLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVLW::
cPtr_instruction_MOVLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVLW * GGS_instruction_MOVLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVLW * _p = dynamic_cast <const cPtr_instruction_MOVLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 3584U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVLW (& typeid (cPtr_instruction_MOVLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVLW::
GGS_instruction_MOVLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLW::
GGS_instruction_MOVLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVLW GGS_instruction_MOVLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLW GGS_instruction_MOVLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVLW::actualTypeName (void) const {
  return "instruction_MOVLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVLW ("instruction_MOVLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MULLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MULLW::
cPtr_instruction_MULLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MULLW * GGS_instruction_MULLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MULLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MULLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MULLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MULLW * _p = dynamic_cast <const cPtr_instruction_MULLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MULLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 3328U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MULLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MULLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MULLW (& typeid (cPtr_instruction_MULLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MULLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MULLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MULLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MULLW::
GGS_instruction_MULLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULLW::
GGS_instruction_MULLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MULLW GGS_instruction_MULLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MULLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MULLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MULLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MULLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MULLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULLW GGS_instruction_MULLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MULLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MULLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MULLW::actualTypeName (void) const {
  return "instruction_MULLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MULLW ("instruction_MULLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RETLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETLW::
cPtr_instruction_RETLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETLW * GGS_instruction_RETLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RETLW * _p = dynamic_cast <const cPtr_instruction_RETLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 3072U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RETLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETLW (& typeid (cPtr_instruction_RETLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RETLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETLW::
GGS_instruction_RETLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETLW::
GGS_instruction_RETLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETLW GGS_instruction_RETLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETLW GGS_instruction_RETLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_RETLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETLW::actualTypeName (void) const {
  return "instruction_RETLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETLW ("instruction_RETLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SUBLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SUBLW::
cPtr_instruction_SUBLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SUBLW * GGS_instruction_SUBLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SUBLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SUBLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SUBLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SUBLW * _p = dynamic_cast <const cPtr_instruction_SUBLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 2048U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SUBLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SUBLW (& typeid (cPtr_instruction_SUBLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SUBLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SUBLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SUBLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SUBLW::
GGS_instruction_SUBLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBLW::
GGS_instruction_SUBLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SUBLW GGS_instruction_SUBLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SUBLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SUBLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SUBLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SUBLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBLW GGS_instruction_SUBLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_SUBLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SUBLW::actualTypeName (void) const {
  return "instruction_SUBLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SUBLW ("instruction_SUBLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_XORLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_XORLW::
cPtr_instruction_XORLW (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_XORLW * GGS_instruction_XORLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_XORLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_XORLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_XORLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_XORLW * _p = dynamic_cast <const cPtr_instruction_XORLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_XORLW::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 2560U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_XORLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_XORLW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_XORLW (& typeid (cPtr_instruction_XORLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_XORLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_XORLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_XORLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_XORLW::
GGS_instruction_XORLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORLW::
GGS_instruction_XORLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_XORLW GGS_instruction_XORLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_XORLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_XORLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_XORLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_XORLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_XORLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORLW GGS_instruction_XORLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_XORLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_XORLW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_XORLW::actualTypeName (void) const {
  return "instruction_XORLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_XORLW ("instruction_XORLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LFSR'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LFSR::
cPtr_instruction_LFSR (const GGS_location & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mFSRindex (argument_1),
mRegisterExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LFSR * GGS_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LFSR * _p = dynamic_cast <const cPtr_instruction_LFSR *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mFSRindex._operator_isEqual (_p->mFSRindex).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LFSR:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFSRindex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LFSR (& typeid (cPtr_instruction_LFSR), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LFSR ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LFSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_LFSR GGS_instruction_LFSR::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR GGS_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_registerExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_instruction_LFSR (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_LFSR::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LFSR::actualTypeName (void) const {
  return "instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LFSR ("instruction_LFSR", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVLB'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVLB::
cPtr_instruction_MOVLB (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mPageIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVLB * GGS_instruction_MOVLB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVLB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVLB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVLB * _p = dynamic_cast <const cPtr_instruction_MOVLB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mPageIndex._operator_isEqual (_p->mPageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVLB:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVLB (& typeid (cPtr_instruction_MOVLB), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVLB::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVLB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVLB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVLB GGS_instruction_MOVLB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVLB *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVLB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVLB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVLB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB GGS_instruction_MOVLB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVLB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MOVLB::
reader_mPageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVLB *) mPointer)->mPageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVLB::actualTypeName (void) const {
  return "instruction_MOVLB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVLB ("instruction_MOVLB", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LABEL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LABEL::
cPtr_instruction_LABEL (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabel (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LABEL * GGS_instruction_LABEL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LABEL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LABEL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LABEL * _p = dynamic_cast <const cPtr_instruction_LABEL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LABEL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LABEL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LABEL:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LABEL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LABEL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LABEL (& typeid (cPtr_instruction_LABEL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LABEL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LABEL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LABEL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LABEL::
GGS_instruction_LABEL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LABEL::
GGS_instruction_LABEL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_LABEL GGS_instruction_LABEL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LABEL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LABEL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LABEL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_LABEL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LABEL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LABEL GGS_instruction_LABEL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LABEL result ;
  macroMyNew (result.mPointer, cPtr_instruction_LABEL (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_LABEL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LABEL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LABEL::actualTypeName (void) const {
  return "instruction_LABEL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LABEL ("instruction_LABEL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVAW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVAW::
cPtr_instruction_MOVAW (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mRegisterExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVAW * GGS_instruction_MOVAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVAW * _p = dynamic_cast <const cPtr_instruction_MOVAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVAW:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVAW (& typeid (cPtr_instruction_MOVAW), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVAW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVAW GGS_instruction_MOVAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW GGS_instruction_MOVAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVAW (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVAW::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVAW *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVAW::actualTypeName (void) const {
  return "instruction_MOVAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVAW ("instruction_MOVAW", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'tableAccessOption' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_tableAccessOption::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isNotEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_infOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_supOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictInf (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictSup (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @tableAccessOption" ;
  switch (mValue) {
  case enum_simpleAccess:
    s << " simpleAccess>" ;
    break ;
  case enum_postIncrement:
    s << " postIncrement>" ;
    break ;
  case enum_postDecrement:
    s << " postDecrement>" ;
    break ;
  case enum_preIncrement:
    s << " preIncrement>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLRD'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLRD::
cPtr_instruction_TBLRD (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLRD * GGS_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLRD * _p = dynamic_cast <const cPtr_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLRD::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLRD:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLRD (& typeid (cPtr_instruction_TBLRD), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLRD ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLRD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLRD GGS_instruction_TBLRD::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD GGS_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLRD (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLRD::actualTypeName (void) const {
  return "instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLRD ("instruction_TBLRD", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLWT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLWT::
cPtr_instruction_TBLWT (const GGS_location & argument_0,
                                const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mOption (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLWT * GGS_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLWT * _p = dynamic_cast <const cPtr_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLWT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLWT:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLWT (& typeid (cPtr_instruction_TBLWT), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLWT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLWT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLWT GGS_instruction_TBLWT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT GGS_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_tableAccessOption& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLWT (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLWT::actualTypeName (void) const {
  return "instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLWT ("instruction_TBLWT", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MNOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MNOP::
cPtr_instruction_MNOP (const GGS_location & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mOccurrenceFactor (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MNOP * GGS_instruction_MNOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MNOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MNOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MNOP * _p = dynamic_cast <const cPtr_instruction_MNOP *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mOccurrenceFactor._operator_isEqual (_p->mOccurrenceFactor).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MNOP::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mOccurrenceFactor.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (495))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (495)) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MNOP::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MNOP:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOccurrenceFactor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MNOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MNOP (& typeid (cPtr_instruction_MNOP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MNOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MNOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MNOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP::
GGS_instruction_MNOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MNOP GGS_instruction_MNOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MNOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MNOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MNOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MNOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MNOP GGS_instruction_MNOP::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MNOP result ;
  macroMyNew (result.mPointer, cPtr_instruction_MNOP (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MNOP::
reader_mOccurrenceFactor (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MNOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MNOP *) mPointer)->mOccurrenceFactor ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MNOP::actualTypeName (void) const {
  return "instruction_MNOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MNOP ("instruction_MNOP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_FOREVER'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FOREVER::
cPtr_instruction_FOREVER (const GGS_location & argument_0,
                                const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FOREVER * GGS_instruction_FOREVER::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FOREVER *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_FOREVER::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_FOREVER * _p = dynamic_cast <const cPtr_instruction_FOREVER *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FOREVER::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 2U) ;
  {
    GGS_instructionList::cEnumerator enumerator_12987 (mInstructionList, true) ;
    const GGS_instructionList::cElement * operand_12987 = NULL ;
    while (((operand_12987 = enumerator_12987.nextObject ()))) {
      macroValidPointer (operand_12987) ;
      GGS_uint  var_cas_lg ;
      const GGS_instruction  _temp_13038 = operand_12987->mInstruction ;
      if (_temp_13038._isBuilt ()) {
        _temp_13038 (HERE)->method_instructionLength (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (507)) ;
      }
      var_cas_outLength = var_cas_outLength._add_operation (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (508)) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_FOREVER::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FOREVER:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FOREVER::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FOREVER (& typeid (cPtr_instruction_FOREVER), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FOREVER::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FOREVER ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_FOREVER'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER::
GGS_instruction_FOREVER (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FOREVER GGS_instruction_FOREVER::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FOREVER *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FOREVER) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FOREVER (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FOREVER),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FOREVER GGS_instruction_FOREVER::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_FOREVER result ;
  macroMyNew (result.mPointer, cPtr_instruction_FOREVER (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_FOREVER::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FOREVER *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FOREVER *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FOREVER::actualTypeName (void) const {
  return "instruction_FOREVER" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FOREVER ("instruction_FOREVER", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_IF_SEMI_COLON'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_SEMI_COLON::
cPtr_instruction_IF_SEMI_COLON (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mRegisterExpression (argument_1),
mInstruction (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_SEMI_COLON * GGS_instruction_IF_SEMI_COLON::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_SEMI_COLON *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_SEMI_COLON::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_instruction  _temp_13458 = mInstruction ;
  if (_temp_13458._isBuilt ()) {
    _temp_13458 (HERE)->method_instructionLength (_inLexique, var_cas_outLength COMMA_SOURCE_FILE_AT_LINE (523)) ;
  }
  var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (524)) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_SEMI_COLON::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_SEMI_COLON:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_SEMI_COLON::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_SEMI_COLON (& typeid (cPtr_instruction_IF_SEMI_COLON), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_SEMI_COLON::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_SEMI_COLON ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_IF_SEMI_COLON'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_SEMI_COLON::
GGS_instruction_IF_SEMI_COLON (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_SEMI_COLON GGS_instruction_IF_SEMI_COLON::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_SEMI_COLON _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_SEMI_COLON) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_SEMI_COLON (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_SEMI_COLON),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_IF_SEMI_COLON::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_SEMI_COLON *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instruction  GGS_instruction_IF_SEMI_COLON::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_SEMI_COLON *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_SEMI_COLON *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_SEMI_COLON::actualTypeName (void) const {
  return "instruction_IF_SEMI_COLON" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_SEMI_COLON ("instruction_IF_SEMI_COLON", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_IF_CPF_NotEqual'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_CPF_NotEqual::
cPtr_instruction_IF_CPF_NotEqual (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_CPF_NotEqual * GGS_instruction_IF_CPF_NotEqual::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_CPF_NotEqual *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_CPF_NotEqual *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_CPF_NotEqual::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_CPF_NotEqual * _p = dynamic_cast <const cPtr_instruction_IF_CPF_NotEqual *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_NotEqual::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 25088U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_NotEqual::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_CPF_NotEqual:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_NotEqual::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_NotEqual::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_CPF_NotEqual (& typeid (cPtr_instruction_IF_CPF_NotEqual), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_CPF_NotEqual::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_CPF_NotEqual ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_IF_CPF_NotEqual'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_NotEqual::
GGS_instruction_IF_CPF_NotEqual (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_NotEqual::
GGS_instruction_IF_CPF_NotEqual (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_CPF_NotEqual GGS_instruction_IF_CPF_NotEqual::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_NotEqual _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_CPF_NotEqual *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_CPF_NotEqual) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_CPF_NotEqual (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_CPF_NotEqual),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_NotEqual GGS_instruction_IF_CPF_NotEqual::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_NotEqual result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_CPF_NotEqual (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_CPF_NotEqual::actualTypeName (void) const {
  return "instruction_IF_CPF_NotEqual" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_CPF_NotEqual ("instruction_IF_CPF_NotEqual", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_instruction_IF_CPF_LowerOrEqual'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_CPF_LowerOrEqual::
cPtr_instruction_IF_CPF_LowerOrEqual (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_CPF_LowerOrEqual * GGS_instruction_IF_CPF_LowerOrEqual::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_CPF_LowerOrEqual *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_CPF_LowerOrEqual *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_CPF_LowerOrEqual::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_CPF_LowerOrEqual * _p = dynamic_cast <const cPtr_instruction_IF_CPF_LowerOrEqual *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_LowerOrEqual::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 25600U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_LowerOrEqual::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_CPF_LowerOrEqual:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_LowerOrEqual::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_LowerOrEqual::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_CPF_LowerOrEqual (& typeid (cPtr_instruction_IF_CPF_LowerOrEqual), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_CPF_LowerOrEqual::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_CPF_LowerOrEqual ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_instruction_IF_CPF_LowerOrEqual'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_LowerOrEqual::
GGS_instruction_IF_CPF_LowerOrEqual (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_LowerOrEqual::
GGS_instruction_IF_CPF_LowerOrEqual (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_CPF_LowerOrEqual GGS_instruction_IF_CPF_LowerOrEqual::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_LowerOrEqual _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_CPF_LowerOrEqual *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_CPF_LowerOrEqual) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_CPF_LowerOrEqual (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_CPF_LowerOrEqual),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_LowerOrEqual GGS_instruction_IF_CPF_LowerOrEqual::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_LowerOrEqual result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_CPF_LowerOrEqual (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_CPF_LowerOrEqual::actualTypeName (void) const {
  return "instruction_IF_CPF_LowerOrEqual" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_CPF_LowerOrEqual ("instruction_IF_CPF_LowerOrEqual", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_instruction_IF_CPF_GreaterOrEqual'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_CPF_GreaterOrEqual::
cPtr_instruction_IF_CPF_GreaterOrEqual (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_CPF_GreaterOrEqual * GGS_instruction_IF_CPF_GreaterOrEqual::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_CPF_GreaterOrEqual *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_CPF_GreaterOrEqual *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_CPF_GreaterOrEqual::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_CPF_GreaterOrEqual * _p = dynamic_cast <const cPtr_instruction_IF_CPF_GreaterOrEqual *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_GreaterOrEqual::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 24576U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_CPF_GreaterOrEqual::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_CPF_GreaterOrEqual:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_GreaterOrEqual::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_CPF_GreaterOrEqual::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_CPF_GreaterOrEqual (& typeid (cPtr_instruction_IF_CPF_GreaterOrEqual), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_CPF_GreaterOrEqual::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_CPF_GreaterOrEqual ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_instruction_IF_CPF_GreaterOrEqual'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_GreaterOrEqual::
GGS_instruction_IF_CPF_GreaterOrEqual (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_GreaterOrEqual::
GGS_instruction_IF_CPF_GreaterOrEqual (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_CPF_GreaterOrEqual GGS_instruction_IF_CPF_GreaterOrEqual::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_GreaterOrEqual _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_CPF_GreaterOrEqual *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_CPF_GreaterOrEqual) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_CPF_GreaterOrEqual (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_CPF_GreaterOrEqual),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_CPF_GreaterOrEqual GGS_instruction_IF_CPF_GreaterOrEqual::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_CPF_GreaterOrEqual result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_CPF_GreaterOrEqual (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_CPF_GreaterOrEqual::actualTypeName (void) const {
  return "instruction_IF_CPF_GreaterOrEqual" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_CPF_GreaterOrEqual ("instruction_IF_CPF_GreaterOrEqual", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_IF_TST_NotZero'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_TST_NotZero::
cPtr_instruction_IF_TST_NotZero (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_TST_NotZero * GGS_instruction_IF_TST_NotZero::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_TST_NotZero *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_TST_NotZero *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_TST_NotZero::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_TST_NotZero * _p = dynamic_cast <const cPtr_instruction_IF_TST_NotZero *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_TST_NotZero::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outBaseCode = GGS_uint (true, 26112U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_TST_NotZero::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_TST_NotZero:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_TST_NotZero::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_TST_NotZero::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_TST_NotZero (& typeid (cPtr_instruction_IF_TST_NotZero), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_TST_NotZero::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_TST_NotZero ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_IF_TST_NotZero'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_TST_NotZero::
GGS_instruction_IF_TST_NotZero (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_TST_NotZero::
GGS_instruction_IF_TST_NotZero (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_TST_NotZero GGS_instruction_IF_TST_NotZero::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_TST_NotZero _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_TST_NotZero *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_TST_NotZero) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_TST_NotZero (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_TST_NotZero),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_TST_NotZero GGS_instruction_IF_TST_NotZero::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_TST_NotZero result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_TST_NotZero (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_TST_NotZero::actualTypeName (void) const {
  return "instruction_IF_TST_NotZero" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_TST_NotZero ("instruction_IF_TST_NotZero", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_instruction_IF_BitTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IF_BitTest::
cPtr_instruction_IF_BitTest (const GGS_location & argument_0,
                                const GGS_registerExpression & argument_1,
                                const GGS_instruction & argument_2,
                                const GGS_bitNumberExpression & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_IF_SEMI_COLON (argument_0, argument_1, argument_2 COMMA_THERE),
mBitNumber (argument_3),
mSkipIfSet (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IF_BitTest * GGS_instruction_IF_BitTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IF_BitTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IF_BitTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IF_BitTest * _p = dynamic_cast <const cPtr_instruction_IF_BitTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mInstruction._operator_isEqual (_p->mInstruction).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue ()
         && mSkipIfSet._operator_isEqual (_p->mSkipIfSet).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mSkipIfSet).isBuiltAndTrue ()) {
    var_cas_outBaseCode = GGS_uint (true, 40960U) ;
  }else{
    var_cas_outBaseCode = GGS_uint (true, 45056U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IF_BitTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IF_BitTest:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSkipIfSet.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IF_BitTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IF_BitTest (& typeid (cPtr_instruction_IF_BitTest), & typeid (cPtr_instruction_IF_SEMI_COLON), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IF_BitTest::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IF_BitTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_instruction_IF_BitTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest::
GGS_instruction_IF_BitTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IF_BitTest *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IF_BitTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IF_BitTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IF_BitTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IF_BitTest GGS_instruction_IF_BitTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_registerExpression & argument_1,
                 const GGS_instruction & argument_2,
                 const GGS_bitNumberExpression & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IF_BitTest result ;
  macroMyNew (result.mPointer, cPtr_instruction_IF_BitTest (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_IF_BitTest::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_IF_BitTest::
reader_mSkipIfSet (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IF_BitTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_IF_BitTest *) mPointer)->mSkipIfSet ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IF_BitTest::actualTypeName (void) const {
  return "instruction_IF_BitTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IF_BitTest ("instruction_IF_BitTest", gClassInfoFor__instruction_IF_SEMI_COLON) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_instruction_computed_retlw'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_retlw::
cPtr_instruction_computed_retlw (const GGS_location & argument_0,
                                const GGS_luintlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mLiteralValues (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_retlw * GGS_instruction_computed_retlw::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_retlw *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_retlw::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_retlw * _p = dynamic_cast <const cPtr_instruction_computed_retlw *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mLiteralValues._operator_isEqual (_p->mLiteralValues).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_retlw::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mLiteralValues.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (588))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (588))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (588)) ;
  if (((mUsesRelativeCall)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (590)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_retlw::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_retlw:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLiteralValues.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_retlw::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_retlw (& typeid (cPtr_instruction_computed_retlw), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_retlw::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_retlw ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_instruction_computed_retlw'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw::
GGS_instruction_computed_retlw (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_retlw *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_retlw) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_retlw (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_retlw),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_retlw GGS_instruction_computed_retlw::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luintlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_retlw result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_retlw (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintlist  GGS_instruction_computed_retlw::
reader_mLiteralValues (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luintlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mLiteralValues ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_retlw::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_retlw *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_retlw *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_retlw::actualTypeName (void) const {
  return "instruction_computed_retlw" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_retlw ("instruction_computed_retlw", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_bra'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_bra::
cPtr_instruction_computed_bra (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_bra * GGS_instruction_computed_bra::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_bra *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_bra::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_bra * _p = dynamic_cast <const cPtr_instruction_computed_bra *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_bra::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (603))._multiply_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (603))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (603)) ;
  if (((mUsesRelativeCall)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (605)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_bra::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_bra:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_bra::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_bra (& typeid (cPtr_instruction_computed_bra), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_bra::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_bra ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_bra'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra::
GGS_instruction_computed_bra (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_bra GGS_instruction_computed_bra::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_bra *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_bra) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_bra (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_bra),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_bra GGS_instruction_computed_bra::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_bra result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_bra (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_bra::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_bra::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_bra *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_bra *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_bra::actualTypeName (void) const {
  return "instruction_computed_bra" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_bra ("instruction_computed_bra", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_computed_goto'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_computed_goto::
cPtr_instruction_computed_goto (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mTargetLabels (argument_1),
mUsesRelativeCall (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_computed_goto * GGS_instruction_computed_goto::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_computed_goto *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_computed_goto::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_computed_goto * _p = dynamic_cast <const cPtr_instruction_computed_goto *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mTargetLabels._operator_isEqual (_p->mTargetLabels).boolValue ()
         && mUsesRelativeCall._operator_isEqual (_p->mUsesRelativeCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_goto::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = mTargetLabels.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (618))._multiply_operation (_inLexique, GGS_uint (true, 4U) COMMA_SOURCE_FILE_AT_LINE (618))._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (618)) ;
  if (((mUsesRelativeCall)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (620)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_computed_goto::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_computed_goto:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetLabels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUsesRelativeCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_computed_goto::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_computed_goto (& typeid (cPtr_instruction_computed_goto), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_computed_goto::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_computed_goto ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_computed_goto'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto::
GGS_instruction_computed_goto (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_computed_goto GGS_instruction_computed_goto::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_computed_goto *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_computed_goto) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_computed_goto (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_computed_goto),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_computed_goto GGS_instruction_computed_goto::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_computed_goto result ;
  macroMyNew (result.mPointer, cPtr_instruction_computed_goto (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_instruction_computed_goto::
reader_mTargetLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mTargetLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_computed_goto::
reader_mUsesRelativeCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_computed_goto *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_computed_goto *) mPointer)->mUsesRelativeCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_computed_goto::actualTypeName (void) const {
  return "instruction_computed_goto" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_computed_goto ("instruction_computed_goto", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_structured_if_condition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structured_if_condition::
cPtr_structured_if_condition (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structured_if_condition * GGS_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_structured_if_condition::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@structured_if_condition:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structured_if_condition (& typeid (cPtr_structured_if_condition), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__structured_if_condition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_structured_if_condition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_structured_if_condition::
GGS_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structured_if_condition::
GGS_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_structured_if_condition GGS_structured_if_condition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structured_if_condition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structured_if_condition::actualTypeName (void) const {
  return "structured_if_condition" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_structured_if_condition::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__structured_if_condition ("structured_if_condition") ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_bcc_in_structured_if_condition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bcc_in_structured_if_condition::
cPtr_bcc_in_structured_if_condition (const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_structured_if_condition (THERE),
mCondition (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bcc_in_structured_if_condition * GGS_bcc_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bcc_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bcc_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bcc_in_structured_if_condition * _p = dynamic_cast <const cPtr_bcc_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCondition._operator_isEqual (_p->mCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bcc_in_structured_if_condition::
method_conditionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 2U) ;
}

//---------------------------------------------------------------------------*

void cPtr_bcc_in_structured_if_condition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bcc_in_structured_if_condition:"
           << mCondition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bcc_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bcc_in_structured_if_condition (& typeid (cPtr_bcc_in_structured_if_condition), & typeid (cPtr_structured_if_condition), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bcc_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bcc_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_bcc_in_structured_if_condition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition::
GGS_bcc_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bcc_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bcc_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bcc_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bcc_in_structured_if_condition GGS_bcc_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_conditional_branch& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bcc_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bcc_in_structured_if_condition (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_conditional_branch GGS_bcc_in_structured_if_condition::
reader_mCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_conditional_branch  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bcc_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bcc_in_structured_if_condition *) mPointer)->mCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bcc_in_structured_if_condition::actualTypeName (void) const {
  return "bcc_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bcc_in_structured_if_condition ("bcc_in_structured_if_condition", gClassInfoFor__structured_if_condition) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_bitTest_in_structured_if_condition'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitTest_in_structured_if_condition::
cPtr_bitTest_in_structured_if_condition (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_structured_if_condition (THERE),
mRegisterExpression (argument_0),
mBitNumber (argument_1),
mBTFSSinstruction (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitTest_in_structured_if_condition * GGS_bitTest_in_structured_if_condition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitTest_in_structured_if_condition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitTest_in_structured_if_condition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitTest_in_structured_if_condition * _p = dynamic_cast <const cPtr_bitTest_in_structured_if_condition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue ()
         && mBTFSSinstruction._operator_isEqual (_p->mBTFSSinstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitTest_in_structured_if_condition::
method_conditionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_bitTest_in_structured_if_condition::
method_baseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mBTFSSinstruction).isBuiltAndTrue ()) {
    var_cas_outBaseCode = GGS_uint (true, 40960U) ;
  }else{
    var_cas_outBaseCode = GGS_uint (true, 45056U) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_bitTest_in_structured_if_condition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitTest_in_structured_if_condition:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBTFSSinstruction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitTest_in_structured_if_condition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitTest_in_structured_if_condition (& typeid (cPtr_bitTest_in_structured_if_condition), & typeid (cPtr_structured_if_condition), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitTest_in_structured_if_condition::galgasRTTI (void) const {
  return & gClassInfoFor__bitTest_in_structured_if_condition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_bitTest_in_structured_if_condition'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition::
GGS_bitTest_in_structured_if_condition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (inPointer) != NULL)
      : (typeid (cPtr_bitTest_in_structured_if_condition) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitTest_in_structured_if_condition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitTest_in_structured_if_condition),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitTest_in_structured_if_condition GGS_bitTest_in_structured_if_condition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_bitTest_in_structured_if_condition result ;
  macroMyNew (result.mPointer, cPtr_bitTest_in_structured_if_condition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_bitTest_in_structured_if_condition::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_bitTest_in_structured_if_condition::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bitTest_in_structured_if_condition::
reader_mBTFSSinstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitTest_in_structured_if_condition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitTest_in_structured_if_condition *) mPointer)->mBTFSSinstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitTest_in_structured_if_condition::actualTypeName (void) const {
  return "bitTest_in_structured_if_condition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitTest_in_structured_if_condition ("bitTest_in_structured_if_condition", gClassInfoFor__structured_if_condition) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_instruction_structured_if'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_structured_if::
cPtr_instruction_structured_if (const GGS_location & argument_0,
                                const GGS_structured_if_condition & argument_1,
                                const GGS_instructionList & argument_2,
                                const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (argument_0 COMMA_THERE),
mIfCondition (argument_1),
mThenInstructionList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_structured_if * GGS_instruction_structured_if::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_structured_if *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_structured_if::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_structured_if * _p = dynamic_cast <const cPtr_instruction_structured_if *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue ()
         && mIfCondition._operator_isEqual (_p->mIfCondition).boolValue ()
         && mThenInstructionList._operator_isEqual (_p->mThenInstructionList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_structured_if::
method_instructionLength (C_Compiler & _inLexique,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_structured_if_condition  _temp_17277 = mIfCondition ;
  if (_temp_17277._isBuilt ()) {
    _temp_17277 (HERE)->method_conditionLength (_inLexique, var_cas_outLength COMMA_SOURCE_FILE_AT_LINE (668)) ;
  }
  {
    GGS_instructionList::cEnumerator enumerator_17319 (mThenInstructionList, true) ;
    const GGS_instructionList::cElement * operand_17319 = NULL ;
    while (((operand_17319 = enumerator_17319.nextObject ()))) {
      macroValidPointer (operand_17319) ;
      GGS_uint  var_cas_lg ;
      const GGS_instruction  _temp_17374 = operand_17319->mInstruction ;
      if (_temp_17374._isBuilt ()) {
        _temp_17374 (HERE)->method_instructionLength (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (670)) ;
      }
      var_cas_outLength = var_cas_outLength._add_operation (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (671)) ;
    }
  }
  if (((mElseInstructionList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (673)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_outLength = var_cas_outLength._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (674)) ;
  }
  {
    GGS_instructionList::cEnumerator enumerator_17586 (mElseInstructionList, true) ;
    const GGS_instructionList::cElement * operand_17586 = NULL ;
    while (((operand_17586 = enumerator_17586.nextObject ()))) {
      macroValidPointer (operand_17586) ;
      GGS_uint  var_cas_lg ;
      const GGS_instruction  _temp_17641 = operand_17586->mInstruction ;
      if (_temp_17641._isBuilt ()) {
        _temp_17641 (HERE)->method_instructionLength (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (677)) ;
      }
      var_cas_outLength = var_cas_outLength._add_operation (_inLexique, var_cas_lg COMMA_SOURCE_FILE_AT_LINE (678)) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_instruction_structured_if::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_structured_if:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIfCondition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mThenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_structured_if::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_structured_if (& typeid (cPtr_instruction_structured_if), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_structured_if::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_structured_if ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_instruction_structured_if'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if::
GGS_instruction_structured_if (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_structured_if GGS_instruction_structured_if::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_structured_if *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_structured_if) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_structured_if (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_structured_if),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_structured_if GGS_instruction_structured_if::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_structured_if_condition & argument_1,
                 const GGS_instructionList & argument_2,
                 const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_structured_if result ;
  macroMyNew (result.mPointer, cPtr_instruction_structured_if (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structured_if_condition  GGS_instruction_structured_if::
reader_mIfCondition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_structured_if_condition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mIfCondition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mThenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mThenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instruction_structured_if::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_structured_if *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_structured_if *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_structured_if::actualTypeName (void) const {
  return "instruction_structured_if" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_structured_if ("instruction_structured_if", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@interruptDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_interruptDefinitionList::
elementOf_GGS_interruptDefinitionList (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInterruptName (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_interruptDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_interruptDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@interruptDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_instructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_instructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
_operator_concat (const GGS_interruptDefinitionList & inOperand) const {
  GGS_interruptDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_dotAssign_operation (const GGS_interruptDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_interruptDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mInterruptName ;
          GGS_instructionList  p_1 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_instructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInterruptName,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_emptyList (void) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_instructionList & argument_1) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
internalSubListWithRange (GGS_interruptDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInterruptName, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_interruptDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@interruptDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_instructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_instructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_instructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_instructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInterruptName ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_interruptDefinitionList::
reader_mInterruptNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInterruptName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_interruptDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInterruptNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInterruptName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_interruptDefinitionList::cEnumerator::_mInterruptName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInterruptName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_interruptDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@routineDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDefinitionList::
elementOf_GGS_routineDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mBanksel (argument_1),
mHasNoReturn (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_instructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_instructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
_operator_concat (const GGS_routineDefinitionList & inOperand) const {
  GGS_routineDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_dotAssign_operation (const GGS_routineDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_routineDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_luint  p_1 = p->mBanksel ;
          GGS_bool p_2 = p->mHasNoReturn ;
          GGS_instructionList  p_3 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_bool& argument_2,
                     const GGS_instructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mBanksel,
                                _p->mHasNoReturn,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_emptyList (void) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_instructionList & argument_3) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
internalSubListWithRange (GGS_routineDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mRoutineName, _p->mBanksel, _p->mHasNoReturn, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_bool& _out_2,
              GGS_instructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_bool& _out_2,
             GGS_instructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_bool& _out_2,
                 GGS_instructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_bool& _out_2,
                GGS_instructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mHasNoReturn ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDefinitionList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDefinitionList::
reader_mBankselAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBanksel ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDefinitionList::
reader_mHasNoReturnAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHasNoReturn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_routineDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMBankselAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBanksel = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMHasNoReturnAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHasNoReturn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_routineDefinitionList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDefinitionList::cEnumerator::_mBanksel (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mBanksel ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_routineDefinitionList::cEnumerator::_mHasNoReturn (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mHasNoReturn ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_routineDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@declarationInRamList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_declarationInRamList::
elementOf_GGS_declarationInRamList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mSize (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_declarationInRamList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_declarationInRamList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@declarationInRamList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
_operator_concat (const GGS_declarationInRamList & inOperand) const {
  GGS_declarationInRamList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_dotAssign_operation (const GGS_declarationInRamList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_declarationInRamList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_luint  p_1 = p->mSize ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSize
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_emptyList (void) {
  GGS_declarationInRamList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_declarationInRamList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  GGS_declarationInRamList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
internalSubListWithRange (GGS_declarationInRamList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mSize) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList GGS_declarationInRamList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_declarationInRamList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@declarationInRamList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_declarationInRamList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_declarationInRamList::
reader_mSizeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSize ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_declarationInRamList::
modifier_setMSizeAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSize = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_declarationInRamList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_declarationInRamList::cEnumerator::_mSize (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@ramDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ramDefinitionList::
elementOf_GGS_ramDefinitionList (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mBankName (argument_0),
mDeclaration (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ramDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ramDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@ramDefinitionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_declarationInRamList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
_operator_concat (const GGS_ramDefinitionList & inOperand) const {
  GGS_ramDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_dotAssign_operation (const GGS_ramDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ramDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mBankName ;
          GGS_declarationInRamList  p_1 = p->mDeclaration ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_declarationInRamList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mBankName,
                                _p->mDeclaration
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_emptyList (void) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_declarationInRamList & argument_1) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
internalSubListWithRange (GGS_ramDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mBankName, _p->mDeclaration) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ramDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ramDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_declarationInRamList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_declarationInRamList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_declarationInRamList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_declarationInRamList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mBankName ;
    _out_1 = _p->mDeclaration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ramDefinitionList::
reader_mBankNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBankName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declarationInRamList  GGS_ramDefinitionList::
reader_mDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_declarationInRamList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMBankNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBankName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_declarationInRamList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ramDefinitionList::cEnumerator::_mBankName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mBankName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_declarationInRamList  & GGS_ramDefinitionList::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of 'piccoloModel' struct                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccoloModel::GGS_piccoloModel (void) :
mProgramName (),
mDeviceName (),
mRamDefinitionList (),
mInterruptDefinitionList (),
mRoutineDefinitionList (),
mNeedsComputedGoto2 (),
mNeedsComputedGoto4 () {
}

//---------------------------------------------------------------------------*

GGS_piccoloModel::~GGS_piccoloModel (void) {
}

//---------------------------------------------------------------------------*

void GGS_piccoloModel::_drop (void) {
  mProgramName._drop () ;
  mDeviceName._drop () ;
  mRamDefinitionList._drop () ;
  mInterruptDefinitionList._drop () ;
  mRoutineDefinitionList._drop () ;
  mNeedsComputedGoto2._drop () ;
  mNeedsComputedGoto4._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_piccoloModel::_isBuilt (void) const {
  return mProgramName._isBuilt ()
    && mDeviceName._isBuilt ()
    && mRamDefinitionList._isBuilt ()
    && mInterruptDefinitionList._isBuilt ()
    && mRoutineDefinitionList._isBuilt ()
    && mNeedsComputedGoto2._isBuilt ()
    && mNeedsComputedGoto4._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isEqual (inOperand.mProgramName)
    ._operator_and (mDeviceName._operator_isEqual (inOperand.mDeviceName))
    ._operator_and (mRamDefinitionList._operator_isEqual (inOperand.mRamDefinitionList))
    ._operator_and (mInterruptDefinitionList._operator_isEqual (inOperand.mInterruptDefinitionList))
    ._operator_and (mRoutineDefinitionList._operator_isEqual (inOperand.mRoutineDefinitionList))
    ._operator_and (mNeedsComputedGoto2._operator_isEqual (inOperand.mNeedsComputedGoto2))
    ._operator_and (mNeedsComputedGoto4._operator_isEqual (inOperand.mNeedsComputedGoto4)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isNotEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isNotEqual (inOperand.mProgramName)
    ._operator_or (mDeviceName._operator_isNotEqual (inOperand.mDeviceName))
    ._operator_or (mRamDefinitionList._operator_isNotEqual (inOperand.mRamDefinitionList))
    ._operator_or (mInterruptDefinitionList._operator_isNotEqual (inOperand.mInterruptDefinitionList))
    ._operator_or (mRoutineDefinitionList._operator_isNotEqual (inOperand.mRoutineDefinitionList))
    ._operator_or (mNeedsComputedGoto2._operator_isNotEqual (inOperand.mNeedsComputedGoto2))
    ._operator_or (mNeedsComputedGoto4._operator_isNotEqual (inOperand.mNeedsComputedGoto4)) ;
}

//---------------------------------------------------------------------------*

GGS_piccoloModel GGS_piccoloModel::
constructor_new (const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_ramDefinitionList & argument_2,
                 const GGS_interruptDefinitionList & argument_3,
                 const GGS_routineDefinitionList & argument_4,
                 const GGS_bool& argument_5,
                 const GGS_bool& argument_6) {
  GGS_piccoloModel result ;
  result.mProgramName = argument_0 ;
  result.mDeviceName = argument_1 ;
  result.mRamDefinitionList = argument_2 ;
  result.mInterruptDefinitionList = argument_3 ;
  result.mRoutineDefinitionList = argument_4 ;
  result.mNeedsComputedGoto2 = argument_5 ;
  result.mNeedsComputedGoto4 = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_piccoloModel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @piccoloModel" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mProgramName " ;
    _s << mProgramName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDeviceName " ;
    _s << mDeviceName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRamDefinitionList " ;
    _s << mRamDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mInterruptDefinitionList " ;
    _s << mInterruptDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineDefinitionList " ;
    _s << mRoutineDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto2 " ;
    _s << mNeedsComputedGoto2.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNeedsComputedGoto4 " ;
    _s << mNeedsComputedGoto4.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

