//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'piccolo_metamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      july 17th, 2008, at 20h20'51"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_metamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_metamodel.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction::
cPtr_instruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction * GGS_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 2U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction (& typeid (cPtr_instruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_instruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction::
GGS_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction::
GGS_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction GGS_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction::actualTypeName (void) const {
  return "instruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_instruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__instruction ("instruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@instructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_instructionList::
elementOf_GGS_instructionList (const GGS_instruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instructionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instructionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@instructionList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalAppendValues (const GGS_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_internalPrependValues (const GGS_instruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_addAssign_operation (const GGS_instruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
_operator_concat (const GGS_instructionList & inOperand) const {
  GGS_instructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_dotAssign_operation (const GGS_instructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_instructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_instruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_instruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_emptyList (void) {
  GGS_instructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_instructionList::
constructor_listWithValue (const GGS_instruction & argument_0) {
  GGS_instructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
internalSubListWithRange (GGS_instructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList GGS_instructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_instructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@instructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_first (C_Compiler & _inLexique,
              GGS_instruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
method_last (C_Compiler & _inLexique,
             GGS_instruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_instruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_instruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_instruction  GGS_instructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_instruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_instruction  & GGS_instructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_registerExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_registerExpression::
cPtr_registerExpression (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mRegisterName (argument_0),
mOffset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_registerExpression * GGS_registerExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_registerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_registerExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_registerExpression * _p = dynamic_cast <const cPtr_registerExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterName._operator_isEqual (_p->mRegisterName).boolValue ()
         && mOffset._operator_isEqual (_p->mOffset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_registerExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@registerExpression:"
           << mRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_registerExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_registerExpression (& typeid (cPtr_registerExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_registerExpression::galgasRTTI (void) const {
  return & gClassInfoFor__registerExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_registerExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression::
GGS_registerExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_registerExpression GGS_registerExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_registerExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_registerExpression *> (inPointer) != NULL)
      : (typeid (cPtr_registerExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_registerExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_registerExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression GGS_registerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_registerExpression result ;
  macroMyNew (result.mPointer, cPtr_registerExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_registerExpression::
reader_mRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_registerExpression::
reader_mOffset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_registerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_registerExpression *) mPointer)->mOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_registerExpression::actualTypeName (void) const {
  return "registerExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_registerExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__registerExpression ("registerExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FDA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FDA::
cPtr_instruction_FDA (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mRegisterExpression (argument_0),
m_W_isDestination (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FDA * GGS_instruction_FDA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FDA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_FDA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FDA:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FDA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FDA (& typeid (cPtr_instruction_FDA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FDA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FDA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FDA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FDA::
GGS_instruction_FDA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FDA GGS_instruction_FDA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FDA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FDA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FDA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FDA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FDA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FDA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instruction_FDA::
reader_m_W_isDestination (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FDA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FDA *) mPointer)->m_W_isDestination ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FDA::actualTypeName (void) const {
  return "instruction_FDA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FDA ("instruction_FDA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ADDWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ADDWF::
cPtr_instruction_ADDWF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ADDWF * GGS_instruction_ADDWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ADDWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ADDWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ADDWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ADDWF * _p = dynamic_cast <const cPtr_instruction_ADDWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDWF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 9216U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ADDWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ADDWF (& typeid (cPtr_instruction_ADDWF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ADDWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ADDWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ADDWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ADDWF::
GGS_instruction_ADDWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDWF::
GGS_instruction_ADDWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ADDWF GGS_instruction_ADDWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ADDWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ADDWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ADDWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ADDWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDWF GGS_instruction_ADDWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_ADDWF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ADDWF::actualTypeName (void) const {
  return "instruction_ADDWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ADDWF ("instruction_ADDWF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_ADDWFC'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ADDWFC::
cPtr_instruction_ADDWFC (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ADDWFC * GGS_instruction_ADDWFC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ADDWFC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ADDWFC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ADDWFC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ADDWFC * _p = dynamic_cast <const cPtr_instruction_ADDWFC *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDWFC::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 8192U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDWFC::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ADDWFC:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDWFC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDWFC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ADDWFC (& typeid (cPtr_instruction_ADDWFC), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ADDWFC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ADDWFC ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_ADDWFC'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ADDWFC::
GGS_instruction_ADDWFC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDWFC::
GGS_instruction_ADDWFC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ADDWFC GGS_instruction_ADDWFC::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDWFC _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ADDWFC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ADDWFC) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ADDWFC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ADDWFC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDWFC GGS_instruction_ADDWFC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDWFC result ;
  macroMyNew (result.mPointer, cPtr_instruction_ADDWFC (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ADDWFC::actualTypeName (void) const {
  return "instruction_ADDWFC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ADDWFC ("instruction_ADDWFC", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ANDWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ANDWF::
cPtr_instruction_ANDWF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ANDWF * GGS_instruction_ANDWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ANDWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ANDWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ANDWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ANDWF * _p = dynamic_cast <const cPtr_instruction_ANDWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ANDWF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 4608U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ANDWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ANDWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ANDWF (& typeid (cPtr_instruction_ANDWF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ANDWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ANDWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ANDWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ANDWF::
GGS_instruction_ANDWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDWF::
GGS_instruction_ANDWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ANDWF GGS_instruction_ANDWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ANDWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ANDWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ANDWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ANDWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDWF GGS_instruction_ANDWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_ANDWF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ANDWF::actualTypeName (void) const {
  return "instruction_ANDWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ANDWF ("instruction_ANDWF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_COMF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_COMF::
cPtr_instruction_COMF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_COMF * GGS_instruction_COMF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_COMF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_COMF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_COMF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_COMF * _p = dynamic_cast <const cPtr_instruction_COMF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_COMF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 7168U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_COMF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_COMF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_COMF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_COMF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_COMF (& typeid (cPtr_instruction_COMF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_COMF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_COMF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_COMF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_COMF::
GGS_instruction_COMF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_COMF::
GGS_instruction_COMF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_COMF GGS_instruction_COMF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_COMF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_COMF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_COMF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_COMF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_COMF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_COMF GGS_instruction_COMF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_COMF result ;
  macroMyNew (result.mPointer, cPtr_instruction_COMF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_COMF::actualTypeName (void) const {
  return "instruction_COMF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_COMF ("instruction_COMF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_DECF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DECF::
cPtr_instruction_DECF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DECF * GGS_instruction_DECF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DECF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DECF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DECF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DECF * _p = dynamic_cast <const cPtr_instruction_DECF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DECF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 1024U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DECF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DECF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DECF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DECF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DECF (& typeid (cPtr_instruction_DECF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DECF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DECF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_DECF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DECF::
GGS_instruction_DECF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DECF::
GGS_instruction_DECF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DECF GGS_instruction_DECF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DECF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DECF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DECF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DECF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DECF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DECF GGS_instruction_DECF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DECF result ;
  macroMyNew (result.mPointer, cPtr_instruction_DECF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DECF::actualTypeName (void) const {
  return "instruction_DECF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DECF ("instruction_DECF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_DECFSZ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DECFSZ::
cPtr_instruction_DECFSZ (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DECFSZ * GGS_instruction_DECFSZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DECFSZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DECFSZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DECFSZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DECFSZ * _p = dynamic_cast <const cPtr_instruction_DECFSZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DECFSZ::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 11264U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DECFSZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DECFSZ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DECFSZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DECFSZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DECFSZ (& typeid (cPtr_instruction_DECFSZ), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DECFSZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DECFSZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_DECFSZ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DECFSZ::
GGS_instruction_DECFSZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DECFSZ::
GGS_instruction_DECFSZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DECFSZ GGS_instruction_DECFSZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DECFSZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DECFSZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DECFSZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DECFSZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DECFSZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DECFSZ GGS_instruction_DECFSZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DECFSZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_DECFSZ (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DECFSZ::actualTypeName (void) const {
  return "instruction_DECFSZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DECFSZ ("instruction_DECFSZ", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_DCFSNZ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DCFSNZ::
cPtr_instruction_DCFSNZ (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DCFSNZ * GGS_instruction_DCFSNZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DCFSNZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DCFSNZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DCFSNZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_DCFSNZ * _p = dynamic_cast <const cPtr_instruction_DCFSNZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DCFSNZ::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 19456U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DCFSNZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_DCFSNZ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DCFSNZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DCFSNZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DCFSNZ (& typeid (cPtr_instruction_DCFSNZ), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DCFSNZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DCFSNZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_DCFSNZ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DCFSNZ::
GGS_instruction_DCFSNZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DCFSNZ::
GGS_instruction_DCFSNZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DCFSNZ GGS_instruction_DCFSNZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DCFSNZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DCFSNZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DCFSNZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DCFSNZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DCFSNZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DCFSNZ GGS_instruction_DCFSNZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DCFSNZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_DCFSNZ (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DCFSNZ::actualTypeName (void) const {
  return "instruction_DCFSNZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DCFSNZ ("instruction_DCFSNZ", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_INCF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_INCF::
cPtr_instruction_INCF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_INCF * GGS_instruction_INCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_INCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_INCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_INCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_INCF * _p = dynamic_cast <const cPtr_instruction_INCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 10240U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_INCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_INCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_INCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_INCF (& typeid (cPtr_instruction_INCF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_INCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_INCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_INCF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_INCF::
GGS_instruction_INCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INCF::
GGS_instruction_INCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_INCF GGS_instruction_INCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_INCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_INCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_INCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_INCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_INCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INCF GGS_instruction_INCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_INCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_INCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_INCF::actualTypeName (void) const {
  return "instruction_INCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_INCF ("instruction_INCF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_INCFSZ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_INCFSZ::
cPtr_instruction_INCFSZ (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_INCFSZ * GGS_instruction_INCFSZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_INCFSZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_INCFSZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_INCFSZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_INCFSZ * _p = dynamic_cast <const cPtr_instruction_INCFSZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INCFSZ::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 15360U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INCFSZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_INCFSZ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_INCFSZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_INCFSZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_INCFSZ (& typeid (cPtr_instruction_INCFSZ), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_INCFSZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_INCFSZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_INCFSZ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_INCFSZ::
GGS_instruction_INCFSZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INCFSZ::
GGS_instruction_INCFSZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_INCFSZ GGS_instruction_INCFSZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_INCFSZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_INCFSZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_INCFSZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_INCFSZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_INCFSZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INCFSZ GGS_instruction_INCFSZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_INCFSZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_INCFSZ (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_INCFSZ::actualTypeName (void) const {
  return "instruction_INCFSZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_INCFSZ ("instruction_INCFSZ", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_INFSNZ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_INFSNZ::
cPtr_instruction_INFSNZ (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_INFSNZ * GGS_instruction_INFSNZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_INFSNZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_INFSNZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_INFSNZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_INFSNZ * _p = dynamic_cast <const cPtr_instruction_INFSNZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INFSNZ::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 18432U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_INFSNZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_INFSNZ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_INFSNZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_INFSNZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_INFSNZ (& typeid (cPtr_instruction_INFSNZ), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_INFSNZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_INFSNZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_INFSNZ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_INFSNZ::
GGS_instruction_INFSNZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INFSNZ::
GGS_instruction_INFSNZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_INFSNZ GGS_instruction_INFSNZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_INFSNZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_INFSNZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_INFSNZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_INFSNZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_INFSNZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_INFSNZ GGS_instruction_INFSNZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_INFSNZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_INFSNZ (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_INFSNZ::actualTypeName (void) const {
  return "instruction_INFSNZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_INFSNZ ("instruction_INFSNZ", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_IORWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IORWF::
cPtr_instruction_IORWF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IORWF * GGS_instruction_IORWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IORWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IORWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IORWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IORWF * _p = dynamic_cast <const cPtr_instruction_IORWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IORWF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 4096U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IORWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IORWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IORWF (& typeid (cPtr_instruction_IORWF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IORWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IORWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_IORWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IORWF::
GGS_instruction_IORWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORWF::
GGS_instruction_IORWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IORWF GGS_instruction_IORWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IORWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IORWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IORWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IORWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IORWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORWF GGS_instruction_IORWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IORWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_IORWF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IORWF::actualTypeName (void) const {
  return "instruction_IORWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IORWF ("instruction_IORWF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVF::
cPtr_instruction_MOVF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVF * GGS_instruction_MOVF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVF * _p = dynamic_cast <const cPtr_instruction_MOVF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 20480U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVF (& typeid (cPtr_instruction_MOVF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVF::
GGS_instruction_MOVF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVF::
GGS_instruction_MOVF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVF GGS_instruction_MOVF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVF GGS_instruction_MOVF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVF::actualTypeName (void) const {
  return "instruction_MOVF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVF ("instruction_MOVF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RLCF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RLCF::
cPtr_instruction_RLCF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RLCF * GGS_instruction_RLCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RLCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RLCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RLCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RLCF * _p = dynamic_cast <const cPtr_instruction_RLCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RLCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 13312U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RLCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RLCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RLCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RLCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RLCF (& typeid (cPtr_instruction_RLCF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RLCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RLCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RLCF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RLCF::
GGS_instruction_RLCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RLCF::
GGS_instruction_RLCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RLCF GGS_instruction_RLCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RLCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RLCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RLCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RLCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RLCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RLCF GGS_instruction_RLCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RLCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_RLCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RLCF::actualTypeName (void) const {
  return "instruction_RLCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RLCF ("instruction_RLCF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RLNCF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RLNCF::
cPtr_instruction_RLNCF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RLNCF * GGS_instruction_RLNCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RLNCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RLNCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RLNCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RLNCF * _p = dynamic_cast <const cPtr_instruction_RLNCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RLNCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 17408U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RLNCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RLNCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RLNCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RLNCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RLNCF (& typeid (cPtr_instruction_RLNCF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RLNCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RLNCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RLNCF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RLNCF::
GGS_instruction_RLNCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RLNCF::
GGS_instruction_RLNCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RLNCF GGS_instruction_RLNCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RLNCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RLNCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RLNCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RLNCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RLNCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RLNCF GGS_instruction_RLNCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RLNCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_RLNCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RLNCF::actualTypeName (void) const {
  return "instruction_RLNCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RLNCF ("instruction_RLNCF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RRCF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RRCF::
cPtr_instruction_RRCF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RRCF * GGS_instruction_RRCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RRCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RRCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RRCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RRCF * _p = dynamic_cast <const cPtr_instruction_RRCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RRCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 12288U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RRCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RRCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RRCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RRCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RRCF (& typeid (cPtr_instruction_RRCF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RRCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RRCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RRCF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RRCF::
GGS_instruction_RRCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RRCF::
GGS_instruction_RRCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RRCF GGS_instruction_RRCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RRCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RRCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RRCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RRCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RRCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RRCF GGS_instruction_RRCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RRCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_RRCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RRCF::actualTypeName (void) const {
  return "instruction_RRCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RRCF ("instruction_RRCF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RRNCF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RRNCF::
cPtr_instruction_RRNCF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RRNCF * GGS_instruction_RRNCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RRNCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RRNCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RRNCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RRNCF * _p = dynamic_cast <const cPtr_instruction_RRNCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RRNCF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 16384U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RRNCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RRNCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RRNCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RRNCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RRNCF (& typeid (cPtr_instruction_RRNCF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RRNCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RRNCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RRNCF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RRNCF::
GGS_instruction_RRNCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RRNCF::
GGS_instruction_RRNCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RRNCF GGS_instruction_RRNCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RRNCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RRNCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RRNCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RRNCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RRNCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RRNCF GGS_instruction_RRNCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RRNCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_RRNCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RRNCF::actualTypeName (void) const {
  return "instruction_RRNCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RRNCF ("instruction_RRNCF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_SUBFWB'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SUBFWB::
cPtr_instruction_SUBFWB (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SUBFWB * GGS_instruction_SUBFWB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SUBFWB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SUBFWB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SUBFWB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SUBFWB * _p = dynamic_cast <const cPtr_instruction_SUBFWB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBFWB::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 21504U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBFWB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SUBFWB:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBFWB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBFWB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SUBFWB (& typeid (cPtr_instruction_SUBFWB), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SUBFWB::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SUBFWB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_SUBFWB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SUBFWB::
GGS_instruction_SUBFWB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBFWB::
GGS_instruction_SUBFWB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SUBFWB GGS_instruction_SUBFWB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBFWB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SUBFWB *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SUBFWB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SUBFWB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SUBFWB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBFWB GGS_instruction_SUBFWB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBFWB result ;
  macroMyNew (result.mPointer, cPtr_instruction_SUBFWB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SUBFWB::actualTypeName (void) const {
  return "instruction_SUBFWB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SUBFWB ("instruction_SUBFWB", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SUBWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SUBWF::
cPtr_instruction_SUBWF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SUBWF * GGS_instruction_SUBWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SUBWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SUBWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SUBWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SUBWF * _p = dynamic_cast <const cPtr_instruction_SUBWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBWF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 23552U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SUBWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SUBWF (& typeid (cPtr_instruction_SUBWF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SUBWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SUBWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SUBWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SUBWF::
GGS_instruction_SUBWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBWF::
GGS_instruction_SUBWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SUBWF GGS_instruction_SUBWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SUBWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SUBWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SUBWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SUBWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBWF GGS_instruction_SUBWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_SUBWF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SUBWF::actualTypeName (void) const {
  return "instruction_SUBWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SUBWF ("instruction_SUBWF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_SUBWFB'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SUBWFB::
cPtr_instruction_SUBWFB (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SUBWFB * GGS_instruction_SUBWFB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SUBWFB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SUBWFB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SUBWFB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SUBWFB * _p = dynamic_cast <const cPtr_instruction_SUBWFB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBWFB::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 22528U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBWFB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SUBWFB:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBWFB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBWFB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SUBWFB (& typeid (cPtr_instruction_SUBWFB), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SUBWFB::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SUBWFB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_SUBWFB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SUBWFB::
GGS_instruction_SUBWFB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBWFB::
GGS_instruction_SUBWFB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SUBWFB GGS_instruction_SUBWFB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBWFB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SUBWFB *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SUBWFB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SUBWFB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SUBWFB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBWFB GGS_instruction_SUBWFB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBWFB result ;
  macroMyNew (result.mPointer, cPtr_instruction_SUBWFB (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SUBWFB::actualTypeName (void) const {
  return "instruction_SUBWFB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SUBWFB ("instruction_SUBWFB", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SWAPF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SWAPF::
cPtr_instruction_SWAPF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SWAPF * GGS_instruction_SWAPF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SWAPF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SWAPF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SWAPF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SWAPF * _p = dynamic_cast <const cPtr_instruction_SWAPF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SWAPF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 14336U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SWAPF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SWAPF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SWAPF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SWAPF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SWAPF (& typeid (cPtr_instruction_SWAPF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SWAPF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SWAPF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SWAPF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SWAPF::
GGS_instruction_SWAPF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SWAPF::
GGS_instruction_SWAPF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SWAPF GGS_instruction_SWAPF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SWAPF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SWAPF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SWAPF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SWAPF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SWAPF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SWAPF GGS_instruction_SWAPF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SWAPF result ;
  macroMyNew (result.mPointer, cPtr_instruction_SWAPF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SWAPF::actualTypeName (void) const {
  return "instruction_SWAPF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SWAPF ("instruction_SWAPF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_XORWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_XORWF::
cPtr_instruction_XORWF (const GGS_registerExpression & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FDA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_XORWF * GGS_instruction_XORWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_XORWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_XORWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_XORWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_XORWF * _p = dynamic_cast <const cPtr_instruction_XORWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && m_W_isDestination._operator_isEqual (_p->m_W_isDestination).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_XORWF::
method_getBaseCode (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outBaseCode COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outBaseCode = GGS_uint (true, 6144U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_XORWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_XORWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << m_W_isDestination.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_XORWF (& typeid (cPtr_instruction_XORWF), & typeid (cPtr_instruction_FDA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_XORWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_XORWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_XORWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_XORWF::
GGS_instruction_XORWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORWF::
GGS_instruction_XORWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_XORWF GGS_instruction_XORWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_XORWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_XORWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_XORWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_XORWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_XORWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORWF GGS_instruction_XORWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_XORWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_XORWF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_XORWF::actualTypeName (void) const {
  return "instruction_XORWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_XORWF ("instruction_XORWF", gClassInfoFor__instruction_FDA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FA'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FA::
cPtr_instruction_FA (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mRegisterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FA * GGS_instruction_FA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_FA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FA:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FA (& typeid (cPtr_instruction_FA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FA'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FA::
GGS_instruction_FA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FA GGS_instruction_FA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FA::actualTypeName (void) const {
  return "instruction_FA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FA ("instruction_FA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_CLRF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CLRF::
cPtr_instruction_CLRF (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CLRF * GGS_instruction_CLRF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CLRF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CLRF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CLRF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CLRF * _p = dynamic_cast <const cPtr_instruction_CLRF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CLRF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CLRF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CLRF (& typeid (cPtr_instruction_CLRF), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CLRF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CLRF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_CLRF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CLRF::
GGS_instruction_CLRF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRF::
GGS_instruction_CLRF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CLRF GGS_instruction_CLRF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CLRF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CLRF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CLRF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CLRF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRF GGS_instruction_CLRF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRF result ;
  macroMyNew (result.mPointer, cPtr_instruction_CLRF (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CLRF::actualTypeName (void) const {
  return "instruction_CLRF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CLRF ("instruction_CLRF", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CPFSEQ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CPFSEQ::
cPtr_instruction_CPFSEQ (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CPFSEQ * GGS_instruction_CPFSEQ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CPFSEQ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CPFSEQ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CPFSEQ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CPFSEQ * _p = dynamic_cast <const cPtr_instruction_CPFSEQ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CPFSEQ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CPFSEQ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSEQ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSEQ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CPFSEQ (& typeid (cPtr_instruction_CPFSEQ), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CPFSEQ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CPFSEQ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CPFSEQ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CPFSEQ::
GGS_instruction_CPFSEQ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSEQ::
GGS_instruction_CPFSEQ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CPFSEQ GGS_instruction_CPFSEQ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSEQ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CPFSEQ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CPFSEQ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CPFSEQ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CPFSEQ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSEQ GGS_instruction_CPFSEQ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSEQ result ;
  macroMyNew (result.mPointer, cPtr_instruction_CPFSEQ (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CPFSEQ::actualTypeName (void) const {
  return "instruction_CPFSEQ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CPFSEQ ("instruction_CPFSEQ", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CPFSGT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CPFSGT::
cPtr_instruction_CPFSGT (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CPFSGT * GGS_instruction_CPFSGT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CPFSGT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CPFSGT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CPFSGT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CPFSGT * _p = dynamic_cast <const cPtr_instruction_CPFSGT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CPFSGT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CPFSGT:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSGT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSGT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CPFSGT (& typeid (cPtr_instruction_CPFSGT), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CPFSGT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CPFSGT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CPFSGT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CPFSGT::
GGS_instruction_CPFSGT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSGT::
GGS_instruction_CPFSGT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CPFSGT GGS_instruction_CPFSGT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSGT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CPFSGT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CPFSGT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CPFSGT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CPFSGT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSGT GGS_instruction_CPFSGT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSGT result ;
  macroMyNew (result.mPointer, cPtr_instruction_CPFSGT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CPFSGT::actualTypeName (void) const {
  return "instruction_CPFSGT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CPFSGT ("instruction_CPFSGT", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CPFSLT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CPFSLT::
cPtr_instruction_CPFSLT (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CPFSLT * GGS_instruction_CPFSLT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CPFSLT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CPFSLT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CPFSLT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CPFSLT * _p = dynamic_cast <const cPtr_instruction_CPFSLT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CPFSLT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CPFSLT:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSLT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CPFSLT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CPFSLT (& typeid (cPtr_instruction_CPFSLT), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CPFSLT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CPFSLT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CPFSLT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CPFSLT::
GGS_instruction_CPFSLT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSLT::
GGS_instruction_CPFSLT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CPFSLT GGS_instruction_CPFSLT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSLT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CPFSLT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CPFSLT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CPFSLT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CPFSLT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CPFSLT GGS_instruction_CPFSLT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CPFSLT result ;
  macroMyNew (result.mPointer, cPtr_instruction_CPFSLT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CPFSLT::actualTypeName (void) const {
  return "instruction_CPFSLT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CPFSLT ("instruction_CPFSLT", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVWF::
cPtr_instruction_MOVWF (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVWF * GGS_instruction_MOVWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVWF * _p = dynamic_cast <const cPtr_instruction_MOVWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVWF (& typeid (cPtr_instruction_MOVWF), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVWF::
GGS_instruction_MOVWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVWF::
GGS_instruction_MOVWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVWF GGS_instruction_MOVWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVWF GGS_instruction_MOVWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVWF (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVWF::actualTypeName (void) const {
  return "instruction_MOVWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVWF ("instruction_MOVWF", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MULWF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MULWF::
cPtr_instruction_MULWF (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MULWF * GGS_instruction_MULWF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MULWF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MULWF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MULWF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MULWF * _p = dynamic_cast <const cPtr_instruction_MULWF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MULWF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MULWF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULWF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULWF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MULWF (& typeid (cPtr_instruction_MULWF), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MULWF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MULWF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MULWF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MULWF::
GGS_instruction_MULWF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULWF::
GGS_instruction_MULWF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MULWF GGS_instruction_MULWF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MULWF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MULWF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MULWF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MULWF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MULWF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULWF GGS_instruction_MULWF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MULWF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MULWF (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MULWF::actualTypeName (void) const {
  return "instruction_MULWF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MULWF ("instruction_MULWF", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_NEGF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_NEGF::
cPtr_instruction_NEGF (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_NEGF * GGS_instruction_NEGF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_NEGF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_NEGF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_NEGF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_NEGF * _p = dynamic_cast <const cPtr_instruction_NEGF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_NEGF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_NEGF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_NEGF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_NEGF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_NEGF (& typeid (cPtr_instruction_NEGF), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_NEGF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_NEGF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_NEGF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_NEGF::
GGS_instruction_NEGF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NEGF::
GGS_instruction_NEGF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_NEGF GGS_instruction_NEGF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_NEGF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_NEGF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_NEGF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_NEGF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_NEGF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NEGF GGS_instruction_NEGF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_NEGF result ;
  macroMyNew (result.mPointer, cPtr_instruction_NEGF (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_NEGF::actualTypeName (void) const {
  return "instruction_NEGF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_NEGF ("instruction_NEGF", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SETF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SETF::
cPtr_instruction_SETF (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SETF * GGS_instruction_SETF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SETF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SETF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SETF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SETF * _p = dynamic_cast <const cPtr_instruction_SETF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SETF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SETF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SETF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SETF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SETF (& typeid (cPtr_instruction_SETF), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SETF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SETF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SETF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SETF::
GGS_instruction_SETF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SETF::
GGS_instruction_SETF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SETF GGS_instruction_SETF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SETF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SETF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SETF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SETF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SETF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SETF GGS_instruction_SETF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SETF result ;
  macroMyNew (result.mPointer, cPtr_instruction_SETF (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SETF::actualTypeName (void) const {
  return "instruction_SETF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SETF ("instruction_SETF", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_TSTFSZ'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TSTFSZ::
cPtr_instruction_TSTFSZ (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FA (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TSTFSZ * GGS_instruction_TSTFSZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TSTFSZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TSTFSZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TSTFSZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TSTFSZ * _p = dynamic_cast <const cPtr_instruction_TSTFSZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TSTFSZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TSTFSZ:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TSTFSZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TSTFSZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TSTFSZ (& typeid (cPtr_instruction_TSTFSZ), & typeid (cPtr_instruction_FA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TSTFSZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TSTFSZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_TSTFSZ'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TSTFSZ::
GGS_instruction_TSTFSZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TSTFSZ::
GGS_instruction_TSTFSZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TSTFSZ GGS_instruction_TSTFSZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TSTFSZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TSTFSZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TSTFSZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TSTFSZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TSTFSZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TSTFSZ GGS_instruction_TSTFSZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TSTFSZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_TSTFSZ (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TSTFSZ::actualTypeName (void) const {
  return "instruction_TSTFSZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TSTFSZ ("instruction_TSTFSZ", gClassInfoFor__instruction_FA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVFF'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVFF::
cPtr_instruction_MOVFF (const GGS_registerExpression & argument_0,
                                const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mSourceRegisterName (argument_0),
mDestinationRegisterName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVFF * GGS_instruction_MOVFF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVFF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVFF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVFF * _p = dynamic_cast <const cPtr_instruction_MOVFF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceRegisterName._operator_isEqual (_p->mSourceRegisterName).boolValue ()
         && mDestinationRegisterName._operator_isEqual (_p->mDestinationRegisterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVFF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVFF:"
           << mSourceRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDestinationRegisterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVFF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVFF (& typeid (cPtr_instruction_MOVFF), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVFF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVFF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVFF'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF::
GGS_instruction_MOVFF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVFF GGS_instruction_MOVFF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVFF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVFF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVFF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVFF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVFF GGS_instruction_MOVFF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVFF result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVFF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mSourceRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mSourceRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVFF::
reader_mDestinationRegisterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVFF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVFF *) mPointer)->mDestinationRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVFF::actualTypeName (void) const {
  return "instruction_MOVFF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVFF ("instruction_MOVFF", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberExpression::
cPtr_bitNumberExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberExpression * GGS_bitNumberExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_bitNumberExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@bitNumberExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberExpression (& typeid (cPtr_bitNumberExpression), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberExpression::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression::
GGS_bitNumberExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberExpression GGS_bitNumberExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberExpression *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberExpression::actualTypeName (void) const {
  return "bitNumberExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_bitNumberExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__bitNumberExpression ("bitNumberExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_bitNumberLiteralValue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLiteralValue::
cPtr_bitNumberLiteralValue (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLiteralValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLiteralValue * GGS_bitNumberLiteralValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLiteralValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLiteralValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLiteralValue * _p = dynamic_cast <const cPtr_bitNumberLiteralValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLiteralValue._operator_isEqual (_p->mBitNumberLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLiteralValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLiteralValue:"
           << mBitNumberLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLiteralValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLiteralValue (& typeid (cPtr_bitNumberLiteralValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLiteralValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLiteralValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_bitNumberLiteralValue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue::
GGS_bitNumberLiteralValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLiteralValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLiteralValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLiteralValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLiteralValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLiteralValue GGS_bitNumberLiteralValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLiteralValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLiteralValue (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLiteralValue::
reader_mBitNumberLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLiteralValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLiteralValue *) mPointer)->mBitNumberLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLiteralValue::actualTypeName (void) const {
  return "bitNumberLiteralValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLiteralValue ("bitNumberLiteralValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_bitNumberLabelValue'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bitNumberLabelValue::
cPtr_bitNumberLabelValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bitNumberExpression (THERE),
mBitNumberLabelValue (argument_0),
mBitNumberIndexValue (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bitNumberLabelValue * GGS_bitNumberLabelValue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bitNumberLabelValue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bitNumberLabelValue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bitNumberLabelValue * _p = dynamic_cast <const cPtr_bitNumberLabelValue *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBitNumberLabelValue._operator_isEqual (_p->mBitNumberLabelValue).boolValue ()
         && mBitNumberIndexValue._operator_isEqual (_p->mBitNumberIndexValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bitNumberLabelValue::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bitNumberLabelValue:"
           << mBitNumberLabelValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumberIndexValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bitNumberLabelValue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bitNumberLabelValue (& typeid (cPtr_bitNumberLabelValue), & typeid (cPtr_bitNumberExpression), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bitNumberLabelValue::galgasRTTI (void) const {
  return & gClassInfoFor__bitNumberLabelValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_bitNumberLabelValue'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue::
GGS_bitNumberLabelValue (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bitNumberLabelValue *> (inPointer) != NULL)
      : (typeid (cPtr_bitNumberLabelValue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_bitNumberLabelValue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bitNumberLabelValue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberLabelValue GGS_bitNumberLabelValue::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bitNumberLabelValue result ;
  macroMyNew (result.mPointer, cPtr_bitNumberLabelValue (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_bitNumberLabelValue::
reader_mBitNumberLabelValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberLabelValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_bitNumberLabelValue::
reader_mBitNumberIndexValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bitNumberLabelValue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bitNumberLabelValue *) mPointer)->mBitNumberIndexValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bitNumberLabelValue::actualTypeName (void) const {
  return "bitNumberLabelValue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bitNumberLabelValue ("bitNumberLabelValue", gClassInfoFor__bitNumberExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_FBA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_FBA::
cPtr_instruction_FBA (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mRegisterExpression (argument_0),
mBitNumber (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_FBA * GGS_instruction_FBA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_FBA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_FBA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_FBA:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_FBA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_FBA (& typeid (cPtr_instruction_FBA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_FBA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_FBA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_FBA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_FBA::
GGS_instruction_FBA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_FBA GGS_instruction_FBA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_FBA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_FBA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_FBA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_FBA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_FBA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_FBA::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bitNumberExpression  GGS_instruction_FBA::
reader_mBitNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bitNumberExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_FBA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_FBA *) mPointer)->mBitNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_FBA::actualTypeName (void) const {
  return "instruction_FBA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_FBA ("instruction_FBA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BCF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BCF::
cPtr_instruction_BCF (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BCF * GGS_instruction_BCF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BCF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BCF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BCF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BCF * _p = dynamic_cast <const cPtr_instruction_BCF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BCF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BCF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BCF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BCF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BCF (& typeid (cPtr_instruction_BCF), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BCF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BCF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BCF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BCF::
GGS_instruction_BCF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BCF::
GGS_instruction_BCF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BCF GGS_instruction_BCF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BCF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BCF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BCF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BCF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BCF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BCF GGS_instruction_BCF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BCF result ;
  macroMyNew (result.mPointer, cPtr_instruction_BCF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BCF::actualTypeName (void) const {
  return "instruction_BCF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BCF ("instruction_BCF", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BSF'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BSF::
cPtr_instruction_BSF (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BSF * GGS_instruction_BSF::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BSF *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BSF *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BSF::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BSF * _p = dynamic_cast <const cPtr_instruction_BSF *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BSF::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BSF:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BSF::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BSF::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BSF (& typeid (cPtr_instruction_BSF), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BSF::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BSF ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BSF'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BSF::
GGS_instruction_BSF (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BSF::
GGS_instruction_BSF (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BSF GGS_instruction_BSF::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BSF _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BSF *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BSF) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BSF (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BSF),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BSF GGS_instruction_BSF::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BSF result ;
  macroMyNew (result.mPointer, cPtr_instruction_BSF (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BSF::actualTypeName (void) const {
  return "instruction_BSF" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BSF ("instruction_BSF", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_BTFSC'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTFSC::
cPtr_instruction_BTFSC (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTFSC * GGS_instruction_BTFSC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTFSC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTFSC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTFSC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTFSC * _p = dynamic_cast <const cPtr_instruction_BTFSC *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSC::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTFSC:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTFSC (& typeid (cPtr_instruction_BTFSC), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTFSC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTFSC ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_BTFSC'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTFSC::
GGS_instruction_BTFSC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSC::
GGS_instruction_BTFSC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTFSC GGS_instruction_BTFSC::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSC _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTFSC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTFSC) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTFSC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTFSC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSC GGS_instruction_BTFSC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSC result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTFSC (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTFSC::actualTypeName (void) const {
  return "instruction_BTFSC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTFSC ("instruction_BTFSC", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_BTFSS'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTFSS::
cPtr_instruction_BTFSS (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTFSS * GGS_instruction_BTFSS::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTFSS *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTFSS *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTFSS::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTFSS * _p = dynamic_cast <const cPtr_instruction_BTFSS *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTFSS::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTFSS:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSS::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTFSS::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTFSS (& typeid (cPtr_instruction_BTFSS), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTFSS::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTFSS ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_BTFSS'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTFSS::
GGS_instruction_BTFSS (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSS::
GGS_instruction_BTFSS (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTFSS GGS_instruction_BTFSS::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSS _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTFSS *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTFSS) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTFSS (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTFSS),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTFSS GGS_instruction_BTFSS::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTFSS result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTFSS (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTFSS::actualTypeName (void) const {
  return "instruction_BTFSS" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTFSS ("instruction_BTFSS", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BTG'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BTG::
cPtr_instruction_BTG (const GGS_registerExpression & argument_0,
                                const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_FBA (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BTG * GGS_instruction_BTG::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BTG *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BTG *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BTG::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BTG * _p = dynamic_cast <const cPtr_instruction_BTG *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue ()
         && mBitNumber._operator_isEqual (_p->mBitNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BTG::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BTG:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTG::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BTG::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BTG (& typeid (cPtr_instruction_BTG), & typeid (cPtr_instruction_FBA), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BTG::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BTG ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BTG'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BTG::
GGS_instruction_BTG (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTG::
GGS_instruction_BTG (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BTG GGS_instruction_BTG::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BTG _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BTG *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BTG) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BTG (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BTG),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BTG GGS_instruction_BTG::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0,
                 const GGS_bitNumberExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BTG result ;
  macroMyNew (result.mPointer, cPtr_instruction_BTG (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BTG::actualTypeName (void) const {
  return "instruction_BTG" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BTG ("instruction_BTG", gClassInfoFor__instruction_FBA) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_conditionalBranch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_conditionalBranch::
cPtr_instruction_conditionalBranch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_conditionalBranch * GGS_instruction_conditionalBranch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_conditionalBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_conditionalBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_conditionalBranch:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_conditionalBranch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_conditionalBranch (& typeid (cPtr_instruction_conditionalBranch), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_conditionalBranch::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_conditionalBranch ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_conditionalBranch'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_conditionalBranch::
GGS_instruction_conditionalBranch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_conditionalBranch GGS_instruction_conditionalBranch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_conditionalBranch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_conditionalBranch *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_conditionalBranch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_conditionalBranch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_conditionalBranch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_conditionalBranch::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_conditionalBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_conditionalBranch *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_conditionalBranch::actualTypeName (void) const {
  return "instruction_conditionalBranch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_conditionalBranch ("instruction_conditionalBranch", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BC'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BC::
cPtr_instruction_BC (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BC * GGS_instruction_BC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BC * _p = dynamic_cast <const cPtr_instruction_BC *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BC::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BC:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BC (& typeid (cPtr_instruction_BC), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BC ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BC'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BC::
GGS_instruction_BC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BC::
GGS_instruction_BC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BC GGS_instruction_BC::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BC _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BC) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BC GGS_instruction_BC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BC result ;
  macroMyNew (result.mPointer, cPtr_instruction_BC (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BC::actualTypeName (void) const {
  return "instruction_BC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BC ("instruction_BC", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BN'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BN::
cPtr_instruction_BN (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BN * GGS_instruction_BN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BN * _p = dynamic_cast <const cPtr_instruction_BN *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BN::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BN:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BN (& typeid (cPtr_instruction_BN), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BN::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BN'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BN::
GGS_instruction_BN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BN::
GGS_instruction_BN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BN GGS_instruction_BN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BN *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BN GGS_instruction_BN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BN result ;
  macroMyNew (result.mPointer, cPtr_instruction_BN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BN::actualTypeName (void) const {
  return "instruction_BN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BN ("instruction_BN", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BNC'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BNC::
cPtr_instruction_BNC (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BNC * GGS_instruction_BNC::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BNC *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BNC *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BNC::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BNC * _p = dynamic_cast <const cPtr_instruction_BNC *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BNC::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BNC:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNC::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNC::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BNC (& typeid (cPtr_instruction_BNC), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BNC::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BNC ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BNC'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BNC::
GGS_instruction_BNC (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNC::
GGS_instruction_BNC (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BNC GGS_instruction_BNC::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BNC _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BNC *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BNC) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BNC (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BNC),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNC GGS_instruction_BNC::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BNC result ;
  macroMyNew (result.mPointer, cPtr_instruction_BNC (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BNC::actualTypeName (void) const {
  return "instruction_BNC" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BNC ("instruction_BNC", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BNN'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BNN::
cPtr_instruction_BNN (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BNN * GGS_instruction_BNN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BNN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BNN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BNN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BNN * _p = dynamic_cast <const cPtr_instruction_BNN *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BNN::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BNN:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BNN (& typeid (cPtr_instruction_BNN), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BNN::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BNN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BNN'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BNN::
GGS_instruction_BNN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNN::
GGS_instruction_BNN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BNN GGS_instruction_BNN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BNN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BNN *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BNN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BNN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BNN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNN GGS_instruction_BNN::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BNN result ;
  macroMyNew (result.mPointer, cPtr_instruction_BNN (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BNN::actualTypeName (void) const {
  return "instruction_BNN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BNN ("instruction_BNN", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_BNOV'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BNOV::
cPtr_instruction_BNOV (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BNOV * GGS_instruction_BNOV::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BNOV *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BNOV *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BNOV::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BNOV * _p = dynamic_cast <const cPtr_instruction_BNOV *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BNOV::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BNOV:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNOV::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNOV::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BNOV (& typeid (cPtr_instruction_BNOV), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BNOV::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BNOV ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_BNOV'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BNOV::
GGS_instruction_BNOV (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNOV::
GGS_instruction_BNOV (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BNOV GGS_instruction_BNOV::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BNOV _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BNOV *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BNOV) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BNOV (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BNOV),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNOV GGS_instruction_BNOV::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BNOV result ;
  macroMyNew (result.mPointer, cPtr_instruction_BNOV (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BNOV::actualTypeName (void) const {
  return "instruction_BNOV" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BNOV ("instruction_BNOV", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BNZ'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BNZ::
cPtr_instruction_BNZ (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BNZ * GGS_instruction_BNZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BNZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BNZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BNZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BNZ * _p = dynamic_cast <const cPtr_instruction_BNZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BNZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BNZ:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BNZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BNZ (& typeid (cPtr_instruction_BNZ), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BNZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BNZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BNZ'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BNZ::
GGS_instruction_BNZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNZ::
GGS_instruction_BNZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BNZ GGS_instruction_BNZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BNZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BNZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BNZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BNZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BNZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BNZ GGS_instruction_BNZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BNZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_BNZ (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BNZ::actualTypeName (void) const {
  return "instruction_BNZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BNZ ("instruction_BNZ", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BOV'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BOV::
cPtr_instruction_BOV (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BOV * GGS_instruction_BOV::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BOV *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BOV *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BOV::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BOV * _p = dynamic_cast <const cPtr_instruction_BOV *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BOV::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BOV:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BOV::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BOV::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BOV (& typeid (cPtr_instruction_BOV), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BOV::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BOV ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BOV'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BOV::
GGS_instruction_BOV (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BOV::
GGS_instruction_BOV (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BOV GGS_instruction_BOV::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BOV _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BOV *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BOV) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BOV (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BOV),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BOV GGS_instruction_BOV::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BOV result ;
  macroMyNew (result.mPointer, cPtr_instruction_BOV (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BOV::actualTypeName (void) const {
  return "instruction_BOV" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BOV ("instruction_BOV", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BZ'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BZ::
cPtr_instruction_BZ (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_conditionalBranch (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BZ * GGS_instruction_BZ::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BZ *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BZ *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BZ::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BZ * _p = dynamic_cast <const cPtr_instruction_BZ *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BZ::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BZ:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BZ::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BZ::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BZ (& typeid (cPtr_instruction_BZ), & typeid (cPtr_instruction_conditionalBranch), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BZ::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BZ ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BZ'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BZ::
GGS_instruction_BZ (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BZ::
GGS_instruction_BZ (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BZ GGS_instruction_BZ::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BZ _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BZ *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BZ) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BZ (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BZ),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BZ GGS_instruction_BZ::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BZ result ;
  macroMyNew (result.mPointer, cPtr_instruction_BZ (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BZ::actualTypeName (void) const {
  return "instruction_BZ" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BZ ("instruction_BZ", gClassInfoFor__instruction_conditionalBranch) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_BRA'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_BRA::
cPtr_instruction_BRA (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_BRA * GGS_instruction_BRA::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_BRA *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_BRA::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_BRA * _p = dynamic_cast <const cPtr_instruction_BRA *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_BRA::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_BRA:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_BRA::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_BRA (& typeid (cPtr_instruction_BRA), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_BRA::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_BRA ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_BRA'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA::
GGS_instruction_BRA (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_BRA GGS_instruction_BRA::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_BRA *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_BRA) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_BRA (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_BRA),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_BRA GGS_instruction_BRA::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_BRA result ;
  macroMyNew (result.mPointer, cPtr_instruction_BRA (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_BRA::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_BRA *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_BRA *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_BRA::actualTypeName (void) const {
  return "instruction_BRA" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_BRA ("instruction_BRA", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_CALL'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CALL::
cPtr_instruction_CALL (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CALL * GGS_instruction_CALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_CALL * _p = dynamic_cast <const cPtr_instruction_CALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CALL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_CALL:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CALL (& typeid (cPtr_instruction_CALL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_CALL'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL::
GGS_instruction_CALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CALL GGS_instruction_CALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CALL GGS_instruction_CALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_CALL (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_CALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_CALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CALL::actualTypeName (void) const {
  return "instruction_CALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CALL ("instruction_CALL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_GOTO'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_GOTO::
cPtr_instruction_GOTO (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_GOTO * GGS_instruction_GOTO::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_GOTO *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_GOTO::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_GOTO * _p = dynamic_cast <const cPtr_instruction_GOTO *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_GOTO::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_GOTO::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_GOTO:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_GOTO::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_GOTO (& typeid (cPtr_instruction_GOTO), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_GOTO::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_GOTO ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_GOTO'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO::
GGS_instruction_GOTO (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_GOTO GGS_instruction_GOTO::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_GOTO *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_GOTO) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_GOTO (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_GOTO),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_GOTO GGS_instruction_GOTO::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_GOTO result ;
  macroMyNew (result.mPointer, cPtr_instruction_GOTO (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_GOTO::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_GOTO *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_GOTO *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_GOTO::actualTypeName (void) const {
  return "instruction_GOTO" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_GOTO ("instruction_GOTO", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RCALL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RCALL::
cPtr_instruction_RCALL (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RCALL * GGS_instruction_RCALL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RCALL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RCALL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RCALL * _p = dynamic_cast <const cPtr_instruction_RCALL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RCALL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RCALL:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RCALL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RCALL (& typeid (cPtr_instruction_RCALL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RCALL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RCALL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RCALL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL::
GGS_instruction_RCALL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RCALL GGS_instruction_RCALL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RCALL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RCALL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RCALL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RCALL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RCALL GGS_instruction_RCALL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RCALL result ;
  macroMyNew (result.mPointer, cPtr_instruction_RCALL (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_RCALL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RCALL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_RCALL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RCALL::actualTypeName (void) const {
  return "instruction_RCALL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RCALL ("instruction_RCALL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_CLRWDT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_CLRWDT::
cPtr_instruction_CLRWDT (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_CLRWDT * GGS_instruction_CLRWDT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_CLRWDT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_CLRWDT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_CLRWDT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_CLRWDT::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_CLRWDT:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_CLRWDT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_CLRWDT (& typeid (cPtr_instruction_CLRWDT), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_CLRWDT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_CLRWDT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_CLRWDT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT::
GGS_instruction_CLRWDT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_CLRWDT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_CLRWDT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_CLRWDT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_CLRWDT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_CLRWDT * gSingleton_instruction_CLRWDT = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_CLRWDT (void) {
  macroDetachPointer (gSingleton_instruction_CLRWDT, cPtr_instruction_CLRWDT) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_CLRWDT GGS_instruction_CLRWDT::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_CLRWDT result ;
  if (NULL == gSingleton_instruction_CLRWDT) {
    macroMyNew (gSingleton_instruction_CLRWDT, cPtr_instruction_CLRWDT (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_CLRWDT) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_CLRWDT) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_CLRWDT::actualTypeName (void) const {
  return "instruction_CLRWDT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_CLRWDT ("instruction_CLRWDT", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_DAW'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_DAW::
cPtr_instruction_DAW (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_DAW * GGS_instruction_DAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_DAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_DAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_DAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_DAW::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_DAW:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_DAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_DAW (& typeid (cPtr_instruction_DAW), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_DAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_DAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_DAW'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW::
GGS_instruction_DAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_DAW GGS_instruction_DAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_DAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_DAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_DAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_DAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_DAW * gSingleton_instruction_DAW = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_DAW (void) {
  macroDetachPointer (gSingleton_instruction_DAW, cPtr_instruction_DAW) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_DAW GGS_instruction_DAW::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_DAW result ;
  if (NULL == gSingleton_instruction_DAW) {
    macroMyNew (gSingleton_instruction_DAW, cPtr_instruction_DAW (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_DAW) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_DAW) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_DAW::actualTypeName (void) const {
  return "instruction_DAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_DAW ("instruction_DAW", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_NOP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_NOP::
cPtr_instruction_NOP (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_NOP * GGS_instruction_NOP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_NOP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_NOP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_NOP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_NOP::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_NOP:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_NOP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_NOP (& typeid (cPtr_instruction_NOP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_NOP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_NOP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_NOP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP::
GGS_instruction_NOP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_NOP GGS_instruction_NOP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_NOP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_NOP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_NOP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_NOP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_NOP * gSingleton_instruction_NOP = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_NOP (void) {
  macroDetachPointer (gSingleton_instruction_NOP, cPtr_instruction_NOP) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_NOP GGS_instruction_NOP::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_NOP result ;
  if (NULL == gSingleton_instruction_NOP) {
    macroMyNew (gSingleton_instruction_NOP, cPtr_instruction_NOP (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_NOP) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_NOP) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_NOP::actualTypeName (void) const {
  return "instruction_NOP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_NOP ("instruction_NOP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_instruction_POP'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_POP::
cPtr_instruction_POP (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_POP * GGS_instruction_POP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_POP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_POP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_POP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_POP::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_POP:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_POP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_POP (& typeid (cPtr_instruction_POP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_POP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_POP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_instruction_POP'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP::
GGS_instruction_POP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_POP GGS_instruction_POP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_POP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_POP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_POP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_POP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_POP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_POP * gSingleton_instruction_POP = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_POP (void) {
  macroDetachPointer (gSingleton_instruction_POP, cPtr_instruction_POP) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_POP GGS_instruction_POP::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_POP result ;
  if (NULL == gSingleton_instruction_POP) {
    macroMyNew (gSingleton_instruction_POP, cPtr_instruction_POP (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_POP) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_POP) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_POP::actualTypeName (void) const {
  return "instruction_POP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_POP ("instruction_POP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_PUSH'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_PUSH::
cPtr_instruction_PUSH (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_PUSH * GGS_instruction_PUSH::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_PUSH *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_PUSH *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_PUSH::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_PUSH::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_PUSH:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_PUSH::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_PUSH (& typeid (cPtr_instruction_PUSH), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_PUSH::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_PUSH ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_PUSH'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH::
GGS_instruction_PUSH (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_PUSH GGS_instruction_PUSH::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_PUSH *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_PUSH) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_PUSH (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_PUSH),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_PUSH * gSingleton_instruction_PUSH = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_PUSH (void) {
  macroDetachPointer (gSingleton_instruction_PUSH, cPtr_instruction_PUSH) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_PUSH GGS_instruction_PUSH::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_PUSH result ;
  if (NULL == gSingleton_instruction_PUSH) {
    macroMyNew (gSingleton_instruction_PUSH, cPtr_instruction_PUSH (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_PUSH) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_PUSH) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_PUSH::actualTypeName (void) const {
  return "instruction_PUSH" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_PUSH ("instruction_PUSH", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RESET'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RESET::
cPtr_instruction_RESET (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RESET * GGS_instruction_RESET::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RESET *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RESET *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RESET::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RESET::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_RESET:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RESET::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RESET (& typeid (cPtr_instruction_RESET), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RESET::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RESET ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RESET'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET::
GGS_instruction_RESET (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RESET GGS_instruction_RESET::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RESET *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RESET) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RESET (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RESET),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_RESET * gSingleton_instruction_RESET = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_RESET (void) {
  macroDetachPointer (gSingleton_instruction_RESET, cPtr_instruction_RESET) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RESET GGS_instruction_RESET::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RESET result ;
  if (NULL == gSingleton_instruction_RESET) {
    macroMyNew (gSingleton_instruction_RESET, cPtr_instruction_RESET (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_RESET) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_RESET) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RESET::actualTypeName (void) const {
  return "instruction_RESET" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RESET ("instruction_RESET", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_instruction_RETURN'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETURN::
cPtr_instruction_RETURN (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETURN * GGS_instruction_RETURN::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETURN *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETURN *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETURN::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETURN::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_RETURN:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETURN::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETURN (& typeid (cPtr_instruction_RETURN), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETURN::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETURN ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_instruction_RETURN'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN::
GGS_instruction_RETURN (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETURN GGS_instruction_RETURN::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETURN *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETURN) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETURN (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETURN),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_RETURN * gSingleton_instruction_RETURN = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_RETURN (void) {
  macroDetachPointer (gSingleton_instruction_RETURN, cPtr_instruction_RETURN) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETURN GGS_instruction_RETURN::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETURN result ;
  if (NULL == gSingleton_instruction_RETURN) {
    macroMyNew (gSingleton_instruction_RETURN, cPtr_instruction_RETURN (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_RETURN) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_RETURN) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETURN::actualTypeName (void) const {
  return "instruction_RETURN" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETURN ("instruction_RETURN", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SLEEP'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SLEEP::
cPtr_instruction_SLEEP (LOCATION_ARGS)
:cPtr_instruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SLEEP * GGS_instruction_SLEEP::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SLEEP *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SLEEP *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SLEEP::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SLEEP::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@instruction_SLEEP:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SLEEP::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SLEEP (& typeid (cPtr_instruction_SLEEP), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SLEEP::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SLEEP ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SLEEP'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP::
GGS_instruction_SLEEP (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SLEEP GGS_instruction_SLEEP::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SLEEP *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SLEEP) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SLEEP (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SLEEP),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_instruction_SLEEP * gSingleton_instruction_SLEEP = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_instruction_SLEEP (void) {
  macroDetachPointer (gSingleton_instruction_SLEEP, cPtr_instruction_SLEEP) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SLEEP GGS_instruction_SLEEP::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SLEEP result ;
  if (NULL == gSingleton_instruction_SLEEP) {
    macroMyNew (gSingleton_instruction_SLEEP, cPtr_instruction_SLEEP (THERE)) ;
    registerReleaseRoutine (cleanUp_instruction_SLEEP) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_instruction_SLEEP) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SLEEP::actualTypeName (void) const {
  return "instruction_SLEEP" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SLEEP ("instruction_SLEEP", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_instruction_literalOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_literalOperation::
cPtr_instruction_literalOperation (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mLiteralValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_literalOperation * GGS_instruction_literalOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_literalOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_instruction_literalOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_literalOperation:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_literalOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_literalOperation (& typeid (cPtr_instruction_literalOperation), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_literalOperation::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_literalOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_instruction_literalOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_literalOperation::
GGS_instruction_literalOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_literalOperation GGS_instruction_literalOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_literalOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_literalOperation *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_literalOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_literalOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_literalOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_literalOperation::
reader_mLiteralValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_literalOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_literalOperation *) mPointer)->mLiteralValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_literalOperation::actualTypeName (void) const {
  return "instruction_literalOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_literalOperation ("instruction_literalOperation", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ADDLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ADDLW::
cPtr_instruction_ADDLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ADDLW * GGS_instruction_ADDLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ADDLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ADDLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ADDLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ADDLW * _p = dynamic_cast <const cPtr_instruction_ADDLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ADDLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ADDLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ADDLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ADDLW (& typeid (cPtr_instruction_ADDLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ADDLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ADDLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ADDLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ADDLW::
GGS_instruction_ADDLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDLW::
GGS_instruction_ADDLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ADDLW GGS_instruction_ADDLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ADDLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ADDLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ADDLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ADDLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ADDLW GGS_instruction_ADDLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ADDLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_ADDLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ADDLW::actualTypeName (void) const {
  return "instruction_ADDLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ADDLW ("instruction_ADDLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_ANDLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_ANDLW::
cPtr_instruction_ANDLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_ANDLW * GGS_instruction_ANDLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_ANDLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_ANDLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_ANDLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_ANDLW * _p = dynamic_cast <const cPtr_instruction_ANDLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_ANDLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_ANDLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_ANDLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_ANDLW (& typeid (cPtr_instruction_ANDLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_ANDLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_ANDLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_ANDLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_ANDLW::
GGS_instruction_ANDLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDLW::
GGS_instruction_ANDLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_ANDLW GGS_instruction_ANDLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_ANDLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_ANDLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_ANDLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_ANDLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_ANDLW GGS_instruction_ANDLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_ANDLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_ANDLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_ANDLW::actualTypeName (void) const {
  return "instruction_ANDLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_ANDLW ("instruction_ANDLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_IORLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_IORLW::
cPtr_instruction_IORLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_IORLW * GGS_instruction_IORLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_IORLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_IORLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_IORLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_IORLW * _p = dynamic_cast <const cPtr_instruction_IORLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_IORLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_IORLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_IORLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_IORLW (& typeid (cPtr_instruction_IORLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_IORLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_IORLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_IORLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_IORLW::
GGS_instruction_IORLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORLW::
GGS_instruction_IORLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_IORLW GGS_instruction_IORLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_IORLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_IORLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_IORLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_IORLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_IORLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_IORLW GGS_instruction_IORLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_IORLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_IORLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_IORLW::actualTypeName (void) const {
  return "instruction_IORLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_IORLW ("instruction_IORLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVLW::
cPtr_instruction_MOVLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVLW * GGS_instruction_MOVLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVLW * _p = dynamic_cast <const cPtr_instruction_MOVLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVLW (& typeid (cPtr_instruction_MOVLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVLW::
GGS_instruction_MOVLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLW::
GGS_instruction_MOVLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVLW GGS_instruction_MOVLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLW GGS_instruction_MOVLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVLW::actualTypeName (void) const {
  return "instruction_MOVLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVLW ("instruction_MOVLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MULLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MULLW::
cPtr_instruction_MULLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MULLW * GGS_instruction_MULLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MULLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MULLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MULLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MULLW * _p = dynamic_cast <const cPtr_instruction_MULLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MULLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MULLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MULLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MULLW (& typeid (cPtr_instruction_MULLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MULLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MULLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MULLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MULLW::
GGS_instruction_MULLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULLW::
GGS_instruction_MULLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MULLW GGS_instruction_MULLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MULLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MULLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MULLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MULLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MULLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MULLW GGS_instruction_MULLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MULLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MULLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MULLW::actualTypeName (void) const {
  return "instruction_MULLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MULLW ("instruction_MULLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_RETLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_RETLW::
cPtr_instruction_RETLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_RETLW * GGS_instruction_RETLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_RETLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_RETLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_RETLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_RETLW * _p = dynamic_cast <const cPtr_instruction_RETLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_RETLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_RETLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_RETLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_RETLW (& typeid (cPtr_instruction_RETLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_RETLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_RETLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_RETLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_RETLW::
GGS_instruction_RETLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETLW::
GGS_instruction_RETLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_RETLW GGS_instruction_RETLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_RETLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_RETLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_RETLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_RETLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_RETLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_RETLW GGS_instruction_RETLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_RETLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_RETLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_RETLW::actualTypeName (void) const {
  return "instruction_RETLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_RETLW ("instruction_RETLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_SUBLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_SUBLW::
cPtr_instruction_SUBLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_SUBLW * GGS_instruction_SUBLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_SUBLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_SUBLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_SUBLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_SUBLW * _p = dynamic_cast <const cPtr_instruction_SUBLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_SUBLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_SUBLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_SUBLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_SUBLW (& typeid (cPtr_instruction_SUBLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_SUBLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_SUBLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_SUBLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_SUBLW::
GGS_instruction_SUBLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBLW::
GGS_instruction_SUBLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_SUBLW GGS_instruction_SUBLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_SUBLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_SUBLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_SUBLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_SUBLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_SUBLW GGS_instruction_SUBLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_SUBLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_SUBLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_SUBLW::actualTypeName (void) const {
  return "instruction_SUBLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_SUBLW ("instruction_SUBLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_XORLW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_XORLW::
cPtr_instruction_XORLW (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction_literalOperation (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_XORLW * GGS_instruction_XORLW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_XORLW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_XORLW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_XORLW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_XORLW * _p = dynamic_cast <const cPtr_instruction_XORLW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralValue._operator_isEqual (_p->mLiteralValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_XORLW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_XORLW:"
           << mLiteralValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORLW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_XORLW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_XORLW (& typeid (cPtr_instruction_XORLW), & typeid (cPtr_instruction_literalOperation), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_XORLW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_XORLW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_XORLW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_XORLW::
GGS_instruction_XORLW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORLW::
GGS_instruction_XORLW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_XORLW GGS_instruction_XORLW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_XORLW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_XORLW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_XORLW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_XORLW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_XORLW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_XORLW GGS_instruction_XORLW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_XORLW result ;
  macroMyNew (result.mPointer, cPtr_instruction_XORLW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_XORLW::actualTypeName (void) const {
  return "instruction_XORLW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_XORLW ("instruction_XORLW", gClassInfoFor__instruction_literalOperation) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LFSR'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LFSR::
cPtr_instruction_LFSR (const GGS_luint & argument_0,
                                const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mFSRindex (argument_0),
mRegisterExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LFSR * GGS_instruction_LFSR::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LFSR *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LFSR::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LFSR * _p = dynamic_cast <const cPtr_instruction_LFSR *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFSRindex._operator_isEqual (_p->mFSRindex).boolValue ()
         && mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 4U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LFSR::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LFSR:"
           << mFSRindex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LFSR::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LFSR (& typeid (cPtr_instruction_LFSR), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LFSR::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LFSR ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LFSR'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR::
GGS_instruction_LFSR (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_LFSR GGS_instruction_LFSR::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LFSR *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LFSR) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_LFSR (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LFSR),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LFSR GGS_instruction_LFSR::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_registerExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LFSR result ;
  macroMyNew (result.mPointer, cPtr_instruction_LFSR (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_LFSR::
reader_mFSRindex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mFSRindex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_LFSR::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LFSR *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LFSR *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LFSR::actualTypeName (void) const {
  return "instruction_LFSR" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LFSR ("instruction_LFSR", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVLB'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVLB::
cPtr_instruction_MOVLB (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mPageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVLB * GGS_instruction_MOVLB::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVLB *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVLB::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVLB * _p = dynamic_cast <const cPtr_instruction_MOVLB *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mPageIndex._operator_isEqual (_p->mPageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVLB::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVLB:"
           << mPageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVLB::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVLB (& typeid (cPtr_instruction_MOVLB), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVLB::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVLB ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVLB'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB::
GGS_instruction_MOVLB (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVLB GGS_instruction_MOVLB::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVLB *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVLB) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVLB (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVLB),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVLB GGS_instruction_MOVLB::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVLB result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVLB (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_instruction_MOVLB::
reader_mPageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVLB *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVLB *) mPointer)->mPageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVLB::actualTypeName (void) const {
  return "instruction_MOVLB" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVLB ("instruction_MOVLB", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_LABEL'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_LABEL::
cPtr_instruction_LABEL (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mTargetLabel (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_LABEL * GGS_instruction_LABEL::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_LABEL *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_LABEL::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_LABEL * _p = dynamic_cast <const cPtr_instruction_LABEL *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetLabel._operator_isEqual (_p->mTargetLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LABEL::
method_instructionLength (C_Compiler & /* _inLexique */,
                                GGS_uint & var_cas_outLength COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outLength = GGS_uint (true, 0U) ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_LABEL::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_LABEL:"
           << mTargetLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_LABEL::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_LABEL::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_LABEL (& typeid (cPtr_instruction_LABEL), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_LABEL::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_LABEL ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_LABEL'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_LABEL::
GGS_instruction_LABEL (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LABEL::
GGS_instruction_LABEL (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_LABEL GGS_instruction_LABEL::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_LABEL _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_LABEL *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_LABEL) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_LABEL (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_LABEL),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_LABEL GGS_instruction_LABEL::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_LABEL result ;
  macroMyNew (result.mPointer, cPtr_instruction_LABEL (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_instruction_LABEL::
reader_mTargetLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_LABEL *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_LABEL *) mPointer)->mTargetLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_LABEL::actualTypeName (void) const {
  return "instruction_LABEL" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_LABEL ("instruction_LABEL", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_MOVAW'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_MOVAW::
cPtr_instruction_MOVAW (const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mRegisterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_MOVAW * GGS_instruction_MOVAW::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_MOVAW *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_MOVAW::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_MOVAW * _p = dynamic_cast <const cPtr_instruction_MOVAW *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegisterExpression._operator_isEqual (_p->mRegisterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_MOVAW::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_MOVAW:"
           << mRegisterExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_MOVAW::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_MOVAW (& typeid (cPtr_instruction_MOVAW), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_MOVAW::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_MOVAW ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_MOVAW'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW::
GGS_instruction_MOVAW (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_MOVAW GGS_instruction_MOVAW::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_MOVAW *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_MOVAW) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_MOVAW (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_MOVAW),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_MOVAW GGS_instruction_MOVAW::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_registerExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_MOVAW result ;
  macroMyNew (result.mPointer, cPtr_instruction_MOVAW (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerExpression  GGS_instruction_MOVAW::
reader_mRegisterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_MOVAW *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_MOVAW *) mPointer)->mRegisterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_MOVAW::actualTypeName (void) const {
  return "instruction_MOVAW" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_MOVAW ("instruction_MOVAW", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'tableAccessOption' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_tableAccessOption::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_isNotEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_infOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_supOrEqual (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictInf (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tableAccessOption::
_operator_strictSup (const GGS_tableAccessOption inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tableAccessOption::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @tableAccessOption" ;
  switch (mValue) {
  case enum_simpleAccess:
    s << " simpleAccess>" ;
    break ;
  case enum_postIncrement:
    s << " postIncrement>" ;
    break ;
  case enum_postDecrement:
    s << " postDecrement>" ;
    break ;
  case enum_preIncrement:
    s << " preIncrement>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLRD'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLRD::
cPtr_instruction_TBLRD (const GGS_tableAccessOption& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mOption (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLRD * GGS_instruction_TBLRD::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLRD *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLRD::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLRD * _p = dynamic_cast <const cPtr_instruction_TBLRD *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLRD::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLRD:"
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLRD::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLRD (& typeid (cPtr_instruction_TBLRD), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLRD::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLRD ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLRD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD::
GGS_instruction_TBLRD (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLRD GGS_instruction_TBLRD::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLRD *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLRD) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLRD (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLRD),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLRD GGS_instruction_TBLRD::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_tableAccessOption& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLRD result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLRD (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLRD::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLRD *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLRD *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLRD::actualTypeName (void) const {
  return "instruction_TBLRD" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLRD ("instruction_TBLRD", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_instruction_TBLWT'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_instruction_TBLWT::
cPtr_instruction_TBLWT (const GGS_tableAccessOption& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_instruction (THERE),
mOption (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_instruction_TBLWT * GGS_instruction_TBLWT::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_instruction_TBLWT *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_instruction_TBLWT::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_instruction_TBLWT * _p = dynamic_cast <const cPtr_instruction_TBLWT *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOption._operator_isEqual (_p->mOption).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_instruction_TBLWT::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@instruction_TBLWT:"
           << mOption.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_instruction_TBLWT::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_instruction_TBLWT (& typeid (cPtr_instruction_TBLWT), & typeid (cPtr_instruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_instruction_TBLWT::galgasRTTI (void) const {
  return & gClassInfoFor__instruction_TBLWT ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_instruction_TBLWT'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT::
GGS_instruction_TBLWT (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_instruction_TBLWT GGS_instruction_TBLWT::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_instruction_TBLWT *> (inPointer) != NULL)
      : (typeid (cPtr_instruction_TBLWT) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_instruction_TBLWT (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_instruction_TBLWT),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_instruction_TBLWT GGS_instruction_TBLWT::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_tableAccessOption& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_instruction_TBLWT result ;
  macroMyNew (result.mPointer, cPtr_instruction_TBLWT (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tableAccessOption GGS_instruction_TBLWT::
reader_mOption (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tableAccessOption  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_instruction_TBLWT *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_instruction_TBLWT *) mPointer)->mOption ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_instruction_TBLWT::actualTypeName (void) const {
  return "instruction_TBLWT" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__instruction_TBLWT ("instruction_TBLWT", gClassInfoFor__instruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@interruptDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_interruptDefinitionList::
elementOf_GGS_interruptDefinitionList (const GGS_instructionList & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_interruptDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_interruptDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@interruptDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalAppendValues (const GGS_instructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_internalPrependValues (const GGS_instructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_addAssign_operation (const GGS_instructionList & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
_operator_concat (const GGS_interruptDefinitionList & inOperand) const {
  GGS_interruptDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_dotAssign_operation (const GGS_interruptDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_interruptDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_instructionList  p_0 = p->mInstructionList ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_instructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_emptyList (void) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList  GGS_interruptDefinitionList::
constructor_listWithValue (const GGS_instructionList & argument_0) {
  GGS_interruptDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
internalSubListWithRange (GGS_interruptDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_interruptDefinitionList GGS_interruptDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_interruptDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_interruptDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@interruptDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_instructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_instructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_instructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_instructionList & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_interruptDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_interruptDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_interruptDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@routineDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDefinitionList::
elementOf_GGS_routineDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_instructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mBanksel (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_instructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_instructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_instructionList & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
_operator_concat (const GGS_routineDefinitionList & inOperand) const {
  GGS_routineDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_dotAssign_operation (const GGS_routineDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_routineDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_luint  p_1 = p->mBanksel ;
          GGS_instructionList  p_2 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_instructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mBanksel,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_emptyList (void) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList  GGS_routineDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_instructionList & argument_2) {
  GGS_routineDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
internalSubListWithRange (GGS_routineDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mRoutineName, _p->mBanksel, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDefinitionList GGS_routineDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_routineDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_instructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_instructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_instructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_instructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mBanksel ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDefinitionList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_routineDefinitionList::
reader_mBankselAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBanksel ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instructionList  GGS_routineDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_instructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMBankselAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBanksel = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_instructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_routineDefinitionList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_routineDefinitionList::cEnumerator::_mBanksel (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mBanksel ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instructionList  & GGS_routineDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@ramDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ramDefinitionList::
elementOf_GGS_ramDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mSize (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ramDefinitionList::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ramDefinitionList::
appendForDescription (C_Compiler & /* _inLexique */,
                          C_String & /* ioString */,
                          const sint32 /* inIndentation */
                          COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@ramDefinitionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
_operator_concat (const GGS_ramDefinitionList & inOperand) const {
  GGS_ramDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_dotAssign_operation (const GGS_ramDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ramDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_luint  p_1 = p->mSize ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSize
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_emptyList (void) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList  GGS_ramDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1) {
  GGS_ramDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
internalSubListWithRange (GGS_ramDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mSize) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ramDefinitionList GGS_ramDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ramDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ramDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ramDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSize ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ramDefinitionList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_ramDefinitionList::
reader_mSizeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSize ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ramDefinitionList::
modifier_setMSizeAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSize = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ramDefinitionList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_ramDefinitionList::cEnumerator::_mSize (LOCATION_ARGS) const {
  macroValidPointerThere (mNextEnumeratedObject) ;
  return ((cElement *) mNextEnumeratedObject)->mSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of 'piccoloModel' struct                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_piccoloModel::GGS_piccoloModel (void) :
mProgramName (),
mDeviceName (),
mRamDefinitionList (),
mInterruptDefinitionList (),
mRoutineDefinitionList () {
}

//---------------------------------------------------------------------------*

GGS_piccoloModel::~GGS_piccoloModel (void) {
}

//---------------------------------------------------------------------------*

void GGS_piccoloModel::_drop (void) {
  mProgramName._drop () ;
  mDeviceName._drop () ;
  mRamDefinitionList._drop () ;
  mInterruptDefinitionList._drop () ;
  mRoutineDefinitionList._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_piccoloModel::_isBuilt (void) const {
  return mProgramName._isBuilt ()
    && mDeviceName._isBuilt ()
    && mRamDefinitionList._isBuilt ()
    && mInterruptDefinitionList._isBuilt ()
    && mRoutineDefinitionList._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isEqual (inOperand.mProgramName)
    ._operator_and (mDeviceName._operator_isEqual (inOperand.mDeviceName))
    ._operator_and (mRamDefinitionList._operator_isEqual (inOperand.mRamDefinitionList))
    ._operator_and (mInterruptDefinitionList._operator_isEqual (inOperand.mInterruptDefinitionList))
    ._operator_and (mRoutineDefinitionList._operator_isEqual (inOperand.mRoutineDefinitionList)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_piccoloModel::
_operator_isNotEqual (const GGS_piccoloModel & inOperand) const {
  return mProgramName._operator_isNotEqual (inOperand.mProgramName)
    ._operator_or (mDeviceName._operator_isNotEqual (inOperand.mDeviceName))
    ._operator_or (mRamDefinitionList._operator_isNotEqual (inOperand.mRamDefinitionList))
    ._operator_or (mInterruptDefinitionList._operator_isNotEqual (inOperand.mInterruptDefinitionList))
    ._operator_or (mRoutineDefinitionList._operator_isNotEqual (inOperand.mRoutineDefinitionList)) ;
}

//---------------------------------------------------------------------------*

GGS_piccoloModel GGS_piccoloModel::
constructor_new (const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_ramDefinitionList & argument_2,
                 const GGS_interruptDefinitionList & argument_3,
                 const GGS_routineDefinitionList & argument_4) {
  GGS_piccoloModel result ;
  result.mProgramName = argument_0 ;
  result.mDeviceName = argument_1 ;
  result.mRamDefinitionList = argument_2 ;
  result.mInterruptDefinitionList = argument_3 ;
  result.mRoutineDefinitionList = argument_4 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_piccoloModel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @piccoloModel" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mProgramName " ;
    _s << mProgramName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDeviceName " ;
    _s << mDeviceName.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRamDefinitionList " ;
    _s << mRamDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mInterruptDefinitionList " ;
    _s << mInterruptDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineDefinitionList " ;
    _s << mRoutineDefinitionList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

