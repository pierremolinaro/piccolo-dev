//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'piccolo_program.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     august 22th, 2008, at 19h33'39"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/F_DisplayException.h"
#include "utilities/MF_MemoryControl.h"
#include "collections/TC_UniqueArray.h"
#include "command_line_interface/F_Analyze_CLI_Options.h"
#include "command_line_interface/mainForLIBPM.h"
#include "utilities/MF_MemoryControl.h"

#ifdef TARGET_API_MAC_CARBON
  #include <SIOUX.H>
#endif

#ifdef COMPILE_FOR_WIN32
  #ifdef __MWERKS__
    #include <WINSIOUX.H>
  #endif
#endif

#include <typeinfo>

//---------------------------------------------------------------------------*

#include "pic18_metamodel.h"
#include "pic18_semantics.h"
#include "piccolo_grammar.h"
#include "piccolo_program.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_program.gProgram", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                C_options_for_piccolo_program  CONSTRUCTOR                 *
//                                                                           *
//---------------------------------------------------------------------------*

C_options_for_piccolo_program::
C_options_for_piccolo_program (const bool inAcceptsDebugOption) :
mBuiltinOptions (inAcceptsDebugOption),
mGalgasOptions (),
mOptions_piccolo_options (){
  add (& mBuiltinOptions) ;
  add (& mGalgasOptions) ;
  add (& mOptions_piccolo_options) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    P R O L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
piccolo_program_prologue (C_Compiler & _inLexique,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
  if ((GGS_bool (true, _inLexique.boolOptionValueFromKeys ("piccolo_options", "ouputDeviceList" COMMA_SOURCE_FILE_AT_LINE (11)))).isBuiltAndTrue ()) {
    GGS_stringlist  var_cas_allDevices ;
    var_cas_allDevices = GGS_filewrapper (gWrapperDirectory_0_embeddedDevices).reader_allFilePathes (_inLexique COMMA_SOURCE_FILE_AT_LINE (13)) ;
    GGS_stringlist  var_cas_pic18_devices ;
    var_cas_pic18_devices = GGS_stringlist ::constructor_emptyList () ;
    GGS_stringlist  var_cas_midrange_devices ;
    var_cas_midrange_devices = GGS_stringlist ::constructor_emptyList () ;
    GGS_stringlist  var_cas_baseline_devices ;
    var_cas_baseline_devices = GGS_stringlist ::constructor_emptyList () ;
    GGS_bool var_cas_ok ;
    var_cas_ok = GGS_bool (true, true) ;
    {
      GGS_stringlist::cEnumerator enumerator_738 (var_cas_allDevices, true) ;
      const GGS_stringlist::cElement * operand_738 = NULL ;
      while (((operand_738 = enumerator_738.nextObject ()))
          && (var_cas_ok.isBuiltAndTrue ())) {
        macroValidPointer (operand_738) ;
        GGS_piccoloDeviceModel var_cas_piccoloDeviceModel ;
        GGS_string var_cas_name ;
        var_cas_name = operand_738->mValue.reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (21)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (21)) ;
        ::routine_parseDeviceDefinition (_inLexique,  GGS_lstring ::constructor_new (_inLexique, var_cas_name, GGS_location (_inLexique) COMMA_HERE),  var_cas_piccoloDeviceModel COMMA_SOURCE_FILE_AT_LINE (22)) ;
        switch (var_cas_piccoloDeviceModel.reader_mProcessorType (_inLexique COMMA_SOURCE_FILE_AT_LINE (23)).enumValue ()) {
        case GGS_processorType::enum_pic18_60:
        case GGS_processorType::enum_pic18_80:
          {
          var_cas_pic18_devices._addAssign_operation (var_cas_name) ;
          }
          break ;
        case GGS_processorType::enum_midrange:
          {
          var_cas_midrange_devices._addAssign_operation (var_cas_name) ;
          }
          break ;
        case GGS_processorType::enum_baseline:
          {
          var_cas_baseline_devices._addAssign_operation (var_cas_name) ;
          }
          break ;
        case GGS_processorType::kNotBuilt:
          break ;
        }
        GGS_uint  var_cas_bankCount ;
        var_cas_bankCount = var_cas_piccoloDeviceModel.reader_mBankCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (28)).reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (28)) ;
        if (((var_cas_bankCount)._operator_isEqual (GGS_uint (true, 1U))).isBuiltAndTrue ()) {
          _inLexique.printMessage ((var_cas_name)._operator_concat (GGS_string (true, " has 1 bank\n")) COMMA_SOURCE_FILE_AT_LINE (30)) ;
        }else if ((((((var_cas_bankCount)._operator_isEqual (GGS_uint (true, 2U)))._operator_or ((var_cas_bankCount)._operator_isEqual (GGS_uint (true, 4U))))._operator_or ((var_cas_bankCount)._operator_isEqual (GGS_uint (true, 8U))))._operator_or ((var_cas_bankCount)._operator_isEqual (GGS_uint (true, 16U)))).isBuiltAndTrue ()) {
        }else{
          _inLexique.printMessage ((((var_cas_name)._operator_concat (GGS_string (true, " has ")))._operator_concat (var_cas_bankCount.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (36))))._operator_concat (GGS_string (true, " banks\n")) COMMA_SOURCE_FILE_AT_LINE (36)) ;
        }
      }
    }
    _inLexique.printMessage ((((var_cas_baseline_devices.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (40)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (40)))._operator_concat (GGS_string (true, " baseline devices supported by Piccolo ")))._operator_concat (GGS_string::constructor_stringWithVersionString (_inLexique COMMA_HERE)))._operator_concat (GGS_string (true, ":\n")) COMMA_SOURCE_FILE_AT_LINE (40)) ;
    GGS_uint  var_cas_index ;
    var_cas_index = GGS_uint (true, 0U) ;
    {
      GGS_stringlist::cEnumerator enumerator_1768 (var_cas_baseline_devices, true) ;
      const GGS_stringlist::cElement * operand_1768 = NULL ;
      while (((operand_1768 = enumerator_1768.nextObject ()))) {
        macroValidPointer (operand_1768) ;
        _inLexique.printMessage (operand_1768->mValue.reader_stringByRightPadding (_inLexique, GGS_uint (true, 15U), GGS_char (true, ' ') COMMA_SOURCE_FILE_AT_LINE (43)) COMMA_SOURCE_FILE_AT_LINE (43)) ;
        var_cas_index._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (44)) ;
        if (((var_cas_index)._operator_isEqual (GGS_uint (true, 5U))).isBuiltAndTrue ()) {
          var_cas_index = GGS_uint (true, 0U) ;
          _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (47)) ;
        }
      }
    }
    if (((var_cas_index)._operator_isNotEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (51)) ;
    }
    _inLexique.printMessage ((((var_cas_midrange_devices.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)))._operator_concat (GGS_string (true, " mid-range devices supported by Piccolo ")))._operator_concat (GGS_string::constructor_stringWithVersionString (_inLexique COMMA_HERE)))._operator_concat (GGS_string (true, ":\n")) COMMA_SOURCE_FILE_AT_LINE (54)) ;
    var_cas_index = GGS_uint (true, 0U) ;
    {
      GGS_stringlist::cEnumerator enumerator_2221 (var_cas_midrange_devices, true) ;
      const GGS_stringlist::cElement * operand_2221 = NULL ;
      while (((operand_2221 = enumerator_2221.nextObject ()))) {
        macroValidPointer (operand_2221) ;
        _inLexique.printMessage (operand_2221->mValue.reader_stringByRightPadding (_inLexique, GGS_uint (true, 15U), GGS_char (true, ' ') COMMA_SOURCE_FILE_AT_LINE (57)) COMMA_SOURCE_FILE_AT_LINE (57)) ;
        var_cas_index._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (58)) ;
        if (((var_cas_index)._operator_isEqual (GGS_uint (true, 5U))).isBuiltAndTrue ()) {
          var_cas_index = GGS_uint (true, 0U) ;
          _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (61)) ;
        }
      }
    }
    if (((var_cas_index)._operator_isNotEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (65)) ;
    }
    _inLexique.printMessage ((((var_cas_pic18_devices.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (68)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (68)))._operator_concat (GGS_string (true, " pic18 devices supported by Piccolo ")))._operator_concat (GGS_string::constructor_stringWithVersionString (_inLexique COMMA_HERE)))._operator_concat (GGS_string (true, ":\n")) COMMA_SOURCE_FILE_AT_LINE (68)) ;
    var_cas_index = GGS_uint (true, 0U) ;
    {
      GGS_stringlist::cEnumerator enumerator_2660 (var_cas_pic18_devices, true) ;
      const GGS_stringlist::cElement * operand_2660 = NULL ;
      while (((operand_2660 = enumerator_2660.nextObject ()))) {
        macroValidPointer (operand_2660) ;
        _inLexique.printMessage (operand_2660->mValue.reader_stringByRightPadding (_inLexique, GGS_uint (true, 15U), GGS_char (true, ' ') COMMA_SOURCE_FILE_AT_LINE (71)) COMMA_SOURCE_FILE_AT_LINE (71)) ;
        var_cas_index._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (72)) ;
        if (((var_cas_index)._operator_isEqual (GGS_uint (true, 5U))).isBuiltAndTrue ()) {
          var_cas_index = GGS_uint (true, 0U) ;
          _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (75)) ;
        }
      }
    }
    if (((var_cas_index)._operator_isNotEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (79)) ;
    }
  }
  if (((GGS_string (true, _inLexique.stringOptionValueFromKeys ("piccolo_options", "exportDeviceFiles" COMMA_SOURCE_FILE_AT_LINE (84))).reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (84)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_dir ;
    var_cas_dir = GGS_string (true, _inLexique.stringOptionValueFromKeys ("piccolo_options", "exportDeviceFiles" COMMA_SOURCE_FILE_AT_LINE (85))) ;
    if (((var_cas_dir.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)))._operator_not ()).isBuiltAndTrue ()) {
      const GGS_string _temp_3186 = var_cas_dir ;
      if (_temp_3186._isBuilt ()) {
        _temp_3186 (HERE)->method_makeDirectory (_inLexique COMMA_SOURCE_FILE_AT_LINE (87)) ;
      }
    }
    GGS_filewrapper  var_cas_fw ;
    var_cas_fw = GGS_filewrapper (gWrapperDirectory_0_embeddedDevices) ;
    GGS_stringlist  var_cas_allDevices ;
    var_cas_allDevices = GGS_filewrapper (gWrapperDirectory_0_embeddedDevices).reader_allFilePathes (_inLexique COMMA_SOURCE_FILE_AT_LINE (90)) ;
    {
      GGS_stringlist::cEnumerator enumerator_3358 (var_cas_allDevices, true) ;
      const GGS_stringlist::cElement * operand_3358 = NULL ;
      while (((operand_3358 = enumerator_3358.nextObject ()))) {
        macroValidPointer (operand_3358) ;
        GGS_string var_cas_definitionString ;
        var_cas_definitionString = var_cas_fw.reader_fileContentsAtPath (_inLexique, operand_3358->mValue COMMA_SOURCE_FILE_AT_LINE (92)) ;
        const GGS_string _temp_3465 = var_cas_definitionString ;
        if (_temp_3465._isBuilt ()) {
          _temp_3465 (HERE)->method_writeToFile (_inLexique, (var_cas_dir)._operator_concat (operand_3358->mValue) COMMA_SOURCE_FILE_AT_LINE (93)) ;
        }
      }
    }
    _inLexique.printMessage ((((var_cas_allDevices.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (95)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (95)))._operator_concat (GGS_string (true, " devices copied in '")))._operator_concat (var_cas_dir))._operator_concat (GGS_string (true, "' directory\n")) COMMA_SOURCE_FILE_AT_LINE (95)) ;
  }
  GGS_string var_cas_deviceForMemoryDescription ;
  var_cas_deviceForMemoryDescription = GGS_string (true, _inLexique.stringOptionValueFromKeys ("piccolo_options", "memoryDescription" COMMA_SOURCE_FILE_AT_LINE (98))) ;
  if (((var_cas_deviceForMemoryDescription.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (99)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_devicePath ;
    var_cas_devicePath = ((GGS_string (true, "/"))._operator_concat (var_cas_deviceForMemoryDescription))._operator_concat (GGS_string (true, ".piccoloDevice")) ;
    if ((GGS_filewrapper (gWrapperDirectory_0_embeddedDevices).reader_fileExistsAtPath (_inLexique, var_cas_devicePath COMMA_SOURCE_FILE_AT_LINE (101))).isBuiltAndTrue ()) {
      GGS_piccoloDeviceModel var_cas_piccoloDeviceModel ;
      ::routine_parseDeviceDefinition (_inLexique,  GGS_lstring ::constructor_new (_inLexique, var_cas_deviceForMemoryDescription, GGS_location (_inLexique) COMMA_HERE),  var_cas_piccoloDeviceModel COMMA_SOURCE_FILE_AT_LINE (103)) ;
      GGS_uint  var_cas_totalRam ;
      var_cas_totalRam = GGS_uint (true, 0U) ;
      {
        GGS_ramBankTable::cEnumerator enumerator_4154 (var_cas_piccoloDeviceModel.reader_mRamBankTable (_inLexique COMMA_SOURCE_FILE_AT_LINE (105)), true) ;
        const GGS_ramBankTable::cElement * operand_4154 = NULL ;
        while (((operand_4154 = enumerator_4154.nextObject ()))) {
          macroValidPointer (operand_4154) ;
          var_cas_totalRam = var_cas_totalRam._add_operation (_inLexique, operand_4154->mInfo.mLastAddressPlusOne COMMA_SOURCE_FILE_AT_LINE (106))._substract_operation (_inLexique, operand_4154->mInfo.mFirstFreeAddress COMMA_SOURCE_FILE_AT_LINE (106)) ;
        }
      }
      _inLexique.printMessage ((var_cas_deviceForMemoryDescription)._operator_concat (GGS_string (true, " device:\n")) COMMA_SOURCE_FILE_AT_LINE (108)) ;
      _inLexique.printMessage (((((GGS_string (true, "  "))._operator_concat (var_cas_piccoloDeviceModel.reader_mRamBankTable (_inLexique COMMA_SOURCE_FILE_AT_LINE (109)).reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (109)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (109))))._operator_concat (GGS_string (true, " RAM banks (total ")))._operator_concat (var_cas_totalRam.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (109))))._operator_concat (GGS_string (true, " bytes):\n")) COMMA_SOURCE_FILE_AT_LINE (109)) ;
      {
        GGS_ramBankTable::cEnumerator enumerator_4492 (var_cas_piccoloDeviceModel.reader_mRamBankTable (_inLexique COMMA_SOURCE_FILE_AT_LINE (110)), true) ;
        const GGS_ramBankTable::cElement * operand_4492 = NULL ;
        while (((operand_4492 = enumerator_4492.nextObject ()))) {
          macroValidPointer (operand_4492) ;
          _inLexique.printMessage (((((((((GGS_string (true, "    bank \""))._operator_concat (operand_4492->mKey))._operator_concat (GGS_string (true, "\" from ")))._operator_concat (operand_4492->mInfo.mFirstFreeAddress.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (111))))._operator_concat (GGS_string (true, " to ")))._operator_concat (operand_4492->mInfo.mLastAddressPlusOne._substract_operation (_inLexique, GGS_uint (true, 1U) COMMA_SOURCE_FILE_AT_LINE (112)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (112))))._operator_concat (GGS_string (true, " (")))._operator_concat (operand_4492->mInfo.mLastAddressPlusOne._substract_operation (_inLexique, operand_4492->mInfo.mFirstFreeAddress COMMA_SOURCE_FILE_AT_LINE (113)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (113))))._operator_concat (GGS_string (true, " bytes)")) COMMA_SOURCE_FILE_AT_LINE (111)) ;
          {
            GGS_uintlist::cEnumerator enumerator_4774 (operand_4492->mInfo.mMirrorOffsetList, true) ;
            const GGS_uintlist::cElement * operand_4774 = enumerator_4774.nextObject () ;
            if ((operand_4774 != NULL)) {
              _inLexique.printMessage (GGS_string (true, ", mirror at ") COMMA_SOURCE_FILE_AT_LINE (115)) ;
              bool _foreach_loop_4774 ;
              do{
                macroValidPointer (operand_4774) ;
                _inLexique.printMessage (operand_4492->mInfo.mFirstFreeAddress._add_operation (_inLexique, operand_4774->mValue COMMA_SOURCE_FILE_AT_LINE (116)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (116)) COMMA_SOURCE_FILE_AT_LINE (116)) ;
                operand_4774 = enumerator_4774.nextObject () ;
                _foreach_loop_4774 = ((operand_4774 != NULL)) ;
                if (_foreach_loop_4774) {
                  _inLexique.printMessage (GGS_string (true, ", ") COMMA_SOURCE_FILE_AT_LINE (117)) ;
                }
              }while (_foreach_loop_4774) ;
            }
          }
          _inLexique.printMessage (GGS_string (true, "\n") COMMA_SOURCE_FILE_AT_LINE (119)) ;
        }
      }
      _inLexique.printMessage (((GGS_string (true, "  ROM size: "))._operator_concat (var_cas_piccoloDeviceModel.reader_mRomSize (_inLexique COMMA_SOURCE_FILE_AT_LINE (121)).reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (121)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (121))))._operator_concat (GGS_string (true, " bytes\n")) COMMA_SOURCE_FILE_AT_LINE (121)) ;
      if (((var_cas_piccoloDeviceModel.reader_mEepromSize (_inLexique COMMA_SOURCE_FILE_AT_LINE (122)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
        _inLexique.printMessage (GGS_string (true, "  No EEPROM\n") COMMA_SOURCE_FILE_AT_LINE (123)) ;
      }else{
        _inLexique.printMessage (((((GGS_string (true, "  EEPROM size: "))._operator_concat (var_cas_piccoloDeviceModel.reader_mEepromSize (_inLexique COMMA_SOURCE_FILE_AT_LINE (125)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (125))))._operator_concat (GGS_string (true, " bytes (at ")))._operator_concat (var_cas_piccoloDeviceModel.reader_mEepromAddress (_inLexique COMMA_SOURCE_FILE_AT_LINE (126)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (126))))._operator_concat (GGS_string (true, ")\n")) COMMA_SOURCE_FILE_AT_LINE (125)) ;
      }
    }else{
      GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "The "))._operator_concat (var_cas_deviceForMemoryDescription))._operator_concat (GGS_string (true, " device is not supported or does not exist")) COMMA_SOURCE_FILE_AT_LINE (130)) ;
    }
  }
  GGS_string var_cas_deviceForRegistersDescription ;
  var_cas_deviceForRegistersDescription = GGS_string (true, _inLexique.stringOptionValueFromKeys ("piccolo_options", "registerDescription" COMMA_SOURCE_FILE_AT_LINE (133))) ;
  if (((var_cas_deviceForRegistersDescription.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (134)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_devicePath ;
    var_cas_devicePath = ((GGS_string (true, "/"))._operator_concat (var_cas_deviceForRegistersDescription))._operator_concat (GGS_string (true, ".piccoloDevice")) ;
    if ((GGS_filewrapper (gWrapperDirectory_0_embeddedDevices).reader_fileExistsAtPath (_inLexique, var_cas_devicePath COMMA_SOURCE_FILE_AT_LINE (136))).isBuiltAndTrue ()) {
      GGS_piccoloDeviceModel var_cas_piccoloDeviceModel ;
      ::routine_parseDeviceDefinition (_inLexique,  GGS_lstring ::constructor_new (_inLexique, var_cas_deviceForRegistersDescription, GGS_location (_inLexique) COMMA_HERE),  var_cas_piccoloDeviceModel COMMA_SOURCE_FILE_AT_LINE (138)) ;
      _inLexique.printMessage ((((var_cas_deviceForRegistersDescription)._operator_concat (GGS_string (true, " has ")))._operator_concat (var_cas_piccoloDeviceModel.reader_mRegisterTable (_inLexique COMMA_SOURCE_FILE_AT_LINE (139)).reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (139)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (139))))._operator_concat (GGS_string (true, " special registers:\n")) COMMA_SOURCE_FILE_AT_LINE (139)) ;
      {
        GGS_registerTable::cEnumerator enumerator_6154 (var_cas_piccoloDeviceModel.reader_mRegisterTable (_inLexique COMMA_SOURCE_FILE_AT_LINE (140)), true) ;
        const GGS_registerTable::cElement * operand_6154 = NULL ;
        while (((operand_6154 = enumerator_6154.nextObject ()))) {
          macroValidPointer (operand_6154) ;
          GGS_string var_cas_s ;
          var_cas_s = ((GGS_string (true, "  '"))._operator_concat (operand_6154->mKey))._operator_concat (GGS_string (true, "' at ")) ;
          {
            GGS_uintlist::cEnumerator enumerator_6273 (operand_6154->mInfo.mRegisterAddressList, true) ;
            const GGS_uintlist::cElement * operand_6273 = enumerator_6273.nextObject () ;
            if ((operand_6273 != NULL)) {
              bool _foreach_loop_6273 ;
              do{
                macroValidPointer (operand_6273) ;
                var_cas_s._dotAssign_operation (operand_6273->mValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (143))) ;
                operand_6273 = enumerator_6273.nextObject () ;
                _foreach_loop_6273 = ((operand_6273 != NULL)) ;
                if (_foreach_loop_6273) {
                  var_cas_s.writeString (", ") ;
                }
              }while (_foreach_loop_6273) ;
            }
          }
          var_cas_s._dotAssign_operation (operand_6154->mInfo.mBitDefinitionString) ;
          var_cas_s.writeString ("\n") ;
          _inLexique.printMessage (var_cas_s COMMA_SOURCE_FILE_AT_LINE (147)) ;
        }
      }
    }else{
      GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "The "))._operator_concat (var_cas_deviceForRegistersDescription))._operator_concat (GGS_string (true, " device is not supported or does not exist")) COMMA_SOURCE_FILE_AT_LINE (151)) ;
    }
  }
  GGS_string var_cas_deviceForConfigDescription ;
  var_cas_deviceForConfigDescription = GGS_string (true, _inLexique.stringOptionValueFromKeys ("piccolo_options", "configDescription" COMMA_SOURCE_FILE_AT_LINE (154))) ;
  if (((var_cas_deviceForConfigDescription.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (155)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_devicePath ;
    var_cas_devicePath = ((GGS_string (true, "/"))._operator_concat (var_cas_deviceForConfigDescription))._operator_concat (GGS_string (true, ".piccoloDevice")) ;
    if ((GGS_filewrapper (gWrapperDirectory_0_embeddedDevices).reader_fileExistsAtPath (_inLexique, var_cas_devicePath COMMA_SOURCE_FILE_AT_LINE (157))).isBuiltAndTrue ()) {
      GGS_piccoloDeviceModel var_cas_piccoloDeviceModel ;
      ::routine_parseDeviceDefinition (_inLexique,  GGS_lstring ::constructor_new (_inLexique, var_cas_deviceForConfigDescription, GGS_location (_inLexique) COMMA_HERE),  var_cas_piccoloDeviceModel COMMA_SOURCE_FILE_AT_LINE (159)) ;
      _inLexique.printMessage ((((var_cas_deviceForConfigDescription)._operator_concat (GGS_string (true, " has ")))._operator_concat (var_cas_piccoloDeviceModel.reader_mConfigRegisterMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (160)).reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (160)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (160))))._operator_concat (GGS_string (true, " configuration registers:\n")) COMMA_SOURCE_FILE_AT_LINE (160)) ;
      {
        GGS_configRegisterMap::cEnumerator enumerator_7259 (var_cas_piccoloDeviceModel.reader_mConfigRegisterMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (161)), true) ;
        const GGS_configRegisterMap::cElement * operand_7259 = NULL ;
        while (((operand_7259 = enumerator_7259.nextObject ()))) {
          macroValidPointer (operand_7259) ;
          GGS_string var_cas_s ;
          var_cas_s = ((((((GGS_string (true, "REGISTER '"))._operator_concat (operand_7259->mKey))._operator_concat (GGS_string (true, "' at ")))._operator_concat (operand_7259->mInfo.mRegisterAddress.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (162)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (162))))._operator_concat (GGS_string (true, ", width ")))._operator_concat (operand_7259->mInfo.mRegisterWidth.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (162)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (162))))._operator_concat (GGS_string (true, "\n")) ;
          {
            GGS_illegalMaskList::cEnumerator enumerator_7476 (operand_7259->mInfo.mIllegalMaskList, true) ;
            const GGS_illegalMaskList::cElement * operand_7476 = NULL ;
            while (((operand_7476 = enumerator_7476.nextObject ()))) {
              macroValidPointer (operand_7476) ;
              var_cas_s.writeString ("  illegal value ") ;
              var_cas_s._dotAssign_operation (operand_7476->mIllegalValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (164)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (164))) ;
              var_cas_s.writeString (" mask ") ;
              var_cas_s._dotAssign_operation (operand_7476->mIllegalMask.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (164)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (164))) ;
              var_cas_s.writeString (" description \"") ;
              var_cas_s._dotAssign_operation (operand_7476->mDescription) ;
              var_cas_s.writeString ("\"\n") ;
            }
          }
          {
            GGS_configRegisterMaskMap::cEnumerator enumerator_7700 (operand_7259->mInfo.mConfigRegisterMaskMap, true) ;
            const GGS_configRegisterMaskMap::cElement * operand_7700 = NULL ;
            while (((operand_7700 = enumerator_7700.nextObject ()))) {
              macroValidPointer (operand_7700) ;
              var_cas_s.writeString ("  setting '") ;
              var_cas_s._dotAssign_operation (operand_7700->mKey) ;
              var_cas_s.writeString ("': mask ") ;
              var_cas_s._dotAssign_operation (operand_7700->mInfo.mMaskValue.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (167)).reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (167))) ;
              var_cas_s.writeString (" description \"") ;
              var_cas_s._dotAssign_operation (operand_7700->mInfo.mDescription) ;
              var_cas_s.writeString ("\"\n") ;
              {
                GGS_fieldSettingMap::cEnumerator enumerator_7864 (operand_7700->mInfo.mFieldSettingMap, true) ;
                const GGS_fieldSettingMap::cElement * operand_7864 = NULL ;
                while (((operand_7864 = enumerator_7864.nextObject ()))) {
                  macroValidPointer (operand_7864) ;
                  var_cas_s.writeString ("    value ") ;
                  var_cas_s._dotAssign_operation (operand_7864->mInfo.mValue.reader_hexString (_inLexique COMMA_SOURCE_FILE_AT_LINE (169))) ;
                  var_cas_s.writeString (" description \"") ;
                  var_cas_s._dotAssign_operation (operand_7864->mKey) ;
                  var_cas_s.writeString ("\"\n") ;
                }
              }
            }
          }
          _inLexique.printMessage (var_cas_s COMMA_SOURCE_FILE_AT_LINE (172)) ;
        }
      }
    }else{
      GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "The "))._operator_concat (var_cas_deviceForConfigDescription))._operator_concat (GGS_string (true, " device is not supported or does not exist")) COMMA_SOURCE_FILE_AT_LINE (176)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    E P I L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
piccolo_program_epilogue (C_Compiler & /* _inLexique */,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      M A I N    F O R    L I B P M                        *
//                                                                           *
//---------------------------------------------------------------------------*

int mainForLIBPM  (const int argc, const char * argv []) {
  bool verboseOptionOn = true ;
  sint16 returnCode = 0 ; // No error
//--- Fix parameters for BDD package
  C_BDD::setHashMapSize (18) ;
  C_BDD::setITEcacheSize (15) ;
  C_BDD::setANDcacheSize (1) ;
  C_BDD::forAllOnBitsGreaterCacheSize (17) ;
  C_PrologueEpilogueAction::runPrologueActions () ;
  {
  //--- Input/output parameters
    C_options_for_piccolo_program options (false) ;
    const char * extensions [] = {"piccolo", NULL} ;
    const char * helpMessages [] = {"a source text file with the .piccolo extension", NULL} ;
    TC_UniqueArray <C_String> sourceFilesArray ;
  //--- Analyze Command Line Options
    bool cocoaOutput = false ;
    F_Analyze_CLI_Options (argc, argv,
                           "version PICCOLO_BETA_VERSION",
                           options,
                           sourceFilesArray,
                           extensions,
                           helpMessages,
                           cocoaOutput) ;
    C_galgas_io_parameters IOparameters  (& options,
      cocoaOutput,
      #ifndef DO_NOT_GENERATE_CHECKINGS
        "version PICCOLO_BETA_VERSION" " [debug]",
      #else
        "version PICCOLO_BETA_VERSION",
      #endif
      argv [1],
      10000,
      10000) ;
  //--- Build galgas io object
    C_galgas_io * galgasIOptr = NULL ;
    macroMyNew (galgasIOptr, C_galgas_io (IOparameters, C_galgas_io::kTerminalOutputKind COMMA_HERE)) ;
  //--- Common lexique object
    C_Compiler * _commonLexique = NULL ;
    macroMyNew (_commonLexique, C_Compiler (galgasIOptr COMMA_HERE)) ;
  //--- Ask Save On Close ? (Carbon and Windows SIOUX Only)
    #ifdef SIOUX_IS_IMPLEMENTED
      SIOUXSettings.asktosaveonclose = options.boolOptionValueFromKeys ("generic_cli_options",
                                                                        ASK_TO_SAVE_ON_CLOSE,
                                                                        false) ;
    #endif
  //--- Enable 64 bit alloc debug ? Only if compiled in 64 bit and in debug mode
    #ifndef DO_NOT_GENERATE_CHECKINGS
      #ifdef __LP64__
        if (options.boolOptionValueFromKeys ("generic_cli_options",
                                             "enable_allocation_debugging",
                                             false)) {
          enableAllocDebugFor64BitTool () ;
        }
      #endif
    #endif
    try{
      verboseOptionOn = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                                         "verbose_output",
                                                         false) ;
      piccolo_program_prologue (* _commonLexique, sourceFilesArray) ;
      for (sint32 i=0 ; i<sourceFilesArray.count () ; i++) {
        try {
          const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;
          sint16 r = 0 ;
          if (fileExtension.compare ("piccolo") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            piccolo_grammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile
                                            COMMA_SOURCE_FILE_AT_LINE (185)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else{
            printf ("*** Error: unhandled extension for file '%s' ***\n", sourceFilesArray (i COMMA_HERE).cString ()) ;
            r = 1 ;
          }
          if (r != 0) {
            returnCode = r ;
          }
        }catch (C_ScanOrParseOnlyException) { // Raised when scan only or parse only options are set
          // Do nothing: accept silently exception
        }
      }
    //--- Error or warnings ?
      if (_commonLexique->totalErrorCount () > 0) {
        returnCode = 1 ; // Error code
      }else if (_commonLexique->totalWarningCount () > 0) {
        const bool warningsAreTreatedAsError
            = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                               TREAT_WARNINGS_AS_ERRORS,
                                               false) ;
        if (warningsAreTreatedAsError) {
          returnCode = 1 ; // Error code
          if (verboseOptionOn) {
            printf ("** Note: warnings are treated as errors. **\n") ;
          }
        }
      }
    //--- Epilogue
      piccolo_program_epilogue (* _commonLexique, sourceFilesArray) ;
    }catch (const M_STD_NAMESPACE exception & e) {
      F_default_display_exception (e) ;
      returnCode = 1 ; // Error code
    }catch (...) {
      F_default_display_unknown_exception () ;
      returnCode = 2 ; // Error code
    }
    macroDetachPointer (galgasIOptr, C_galgas_io) ;
    macroDetachPointer (_commonLexique, C_Compiler) ;
    C_PrologueEpilogueAction::runEpilogueActions () ;
    runAllReleaseRoutines () ;
  }
  #ifndef DO_NOT_GENERATE_CHECKINGS
    C_GGS_Object::checkAllObjectsHaveBeenReleased () ;
  #endif
  if (verboseOptionOn) {
    #ifndef DO_NOT_GENERATE_CHECKINGS
      const uint64 maxUsedMemorySize = getMaxUsedMemorySize () ;
      const uint64 oneMegaByte = 1 << 20 ;
      const uint64 megaBytes = maxUsedMemorySize / oneMegaByte ;
      const uint64 fraction = ((maxUsedMemorySize % oneMegaByte) * 1000) / oneMegaByte ;
      co << getCreatedDynamicObjectsTotalCount ()
         << " C++ objects have been created ("
         << megaBytes << "." << widthWithZeroFill (3) << fraction
         << " MB).\n" ;
      deactivateMemoryControl () ;
      if ((getAllocationBalance () != 0) && (returnCode == 0)) {
        display_pointers () ;
      }
    #endif
  }
  return returnCode ;
}

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2


