//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'piccolo_semantics.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       july 16th, 2008, at 20h9'31"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "piccolo_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "piccolo_semantics.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_routineSymbolTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineSymbolTable::e_routineSymbolTable (void) :
mRoutineAddress () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@routineSymbolTable'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineSymbolTable::
elementOf_GGS_routineSymbolTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_routineSymbolTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineSymbolTable::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRoutineAddress.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineSymbolTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineSymbolTable * _p = dynamic_cast <const elementOf_GGS_routineSymbolTable *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRoutineAddress._operator_isEqual (_p->mInfo.mRoutineAddress)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineSymbolTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineSymbolTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineSymbolTable * info = (e_routineSymbolTable *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineSymbolTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineSymbolTable * info = (e_routineSymbolTable *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineSymbolTable GGS_routineSymbolTable::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineSymbolTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineSymbolTable info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineSymbolTable::
_operator_isEqual (const GGS_routineSymbolTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineSymbolTable::
_operator_isNotEqual (const GGS_routineSymbolTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_routineSymbolTable info  ;
    info.mRoutineAddress = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineAddress ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
modifier_setMRoutineAddressForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRoutineAddressForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRoutineAddress = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' routine is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineSymbolTable::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' routine is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineSymbolTable GGS_routineSymbolTable::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineSymbolTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineSymbolTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineSymbolTable GGS_routineSymbolTable::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineSymbolTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineSymbolTable::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @routineSymbolTable " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_routineSymbolTable::cEnumerator::_mRoutineAddress (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineAddress ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@instruction.enterLabelAtAddress'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__instruction__enterLabelAtAddress (C_Compiler &,
                                const cPtr_instruction * operand_566,
                                GGS_routineSymbolTable  & /* var_cas_ioRoutineSymbolTable */,
                                const GGS_uint   /* var_cas_inAddress */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_566 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category method '@instruction.enterLabelAtAddress'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__instruction__enterLabelAtAddress> gDispatchTableFor__instruction__enterLabelAtAddress ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__instruction__enterLabelAtAddress (typeCategoryMethod__instruction__enterLabelAtAddress inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__instruction__enterLabelAtAddress.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__instruction__enterLabelAtAddress
findCategoryMethod__instruction__enterLabelAtAddress (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__instruction__enterLabelAtAddress result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__instruction__enterLabelAtAddress.count ()) {
    result = gDispatchTableFor__instruction__enterLabelAtAddress (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__instruction__enterLabelAtAddress (superClassPtr) ;
      gDispatchTableFor__instruction__enterLabelAtAddress.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@instruction_LABEL.enterLabelAtAddress'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__instruction_LABEL__enterLabelAtAddress (C_Compiler & _inLexique,
                                const cPtr_instruction_LABEL * operand_761,
                                GGS_routineSymbolTable  & var_cas_ioRoutineSymbolTable,
                                const GGS_uint   var_cas_inAddress
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_761 != NULL) {
    var_cas_ioRoutineSymbolTable.modifier_insertKey (_inLexique, operand_761->mTargetLabel, var_cas_inAddress COMMA_SOURCE_FILE_AT_LINE (29)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_registerTable'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_registerTable::e_registerTable (void) :
mRegisterAddress (),
mSize () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@registerTable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_registerTable::
elementOf_GGS_registerTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_registerTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_registerTable::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRegisterAddress.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_registerTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_registerTable * _p = dynamic_cast <const elementOf_GGS_registerTable *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRegisterAddress._operator_isEqual (_p->mInfo.mRegisterAddress)).boolValue ()
           && (mInfo.mSize._operator_isEqual (_p->mInfo.mSize)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_registerTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_registerTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_registerTable * info = (e_registerTable *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_registerTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_registerTable * info = (e_registerTable *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_registerTable GGS_registerTable::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_registerTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_registerTable info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerTable::
_operator_isEqual (const GGS_registerTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_registerTable::
_operator_isNotEqual (const GGS_registerTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_registerTable info  ;
    info.mRegisterAddress = inParameter0 ;
    info.mSize = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegisterAddress ;
    outParameter1 = node->mInfo.mSize ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
modifier_setMRegisterAddressForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRegisterAddressForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRegisterAddress = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
modifier_setMSizeForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSizeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSize = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' register is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_registerTable::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' register is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_registerTable GGS_registerTable::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_registerTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_registerTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_registerTable GGS_registerTable::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_registerTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_registerTable::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @registerTable " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_registerTable::cEnumerator::_mRegisterAddress (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegisterAddress ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_registerTable::cEnumerator::_mSize (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSize ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@instruction.generateCodeAtAddress'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__instruction__generateCodeAtAddress (C_Compiler &,
                                const cPtr_instruction * operand_1266,
                                const GGS_routineSymbolTable   /* var_cas_inRoutineSymbolTable */,
                                const GGS_registerTable   /* var_cas_inRegisterTable */,
                                const GGS_uint   /* var_cas_inAddress */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_1266 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@instruction.generateCodeAtAddress'   *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__instruction__generateCodeAtAddress> gDispatchTableFor__instruction__generateCodeAtAddress ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__instruction__generateCodeAtAddress (typeCategoryMethod__instruction__generateCodeAtAddress inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__instruction__generateCodeAtAddress.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__instruction__generateCodeAtAddress
findCategoryMethod__instruction__generateCodeAtAddress (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__instruction__generateCodeAtAddress result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__instruction__generateCodeAtAddress.count ()) {
    result = gDispatchTableFor__instruction__generateCodeAtAddress (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__instruction__generateCodeAtAddress (superClassPtr) ;
      gDispatchTableFor__instruction__generateCodeAtAddress.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of routine "analyze"                     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_analyze (C_Compiler & _inLexique,
                                const GGS_piccoloModel  var_cas_inPiccoloModel COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_analyze at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  ::routine_parseDeviceDefinition (_inLexique,  var_cas_inPiccoloModel.reader_mDeviceName (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)) COMMA_SOURCE_FILE_AT_LINE (52)) ;
  GGS_uint  var_cas_currentROMaddress ;
  var_cas_currentROMaddress = GGS_uint (true, 26U) ;
  GGS_routineSymbolTable  var_cas_routineSymbolTable ;
  var_cas_routineSymbolTable = GGS_routineSymbolTable ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_interruptDefinitionList::cEnumerator enumerator_1766 (var_cas_inPiccoloModel.reader_mInterruptDefinitionList (_inLexique COMMA_SOURCE_FILE_AT_LINE (58)), true) ;
    const GGS_interruptDefinitionList::cElement * operand_1766 = NULL ;
    while (((operand_1766 = enumerator_1766.nextObject ()))) {
      macroValidPointer (operand_1766) ;
      {
        GGS_instructionList::cEnumerator enumerator_1823 (operand_1766->mInstructionList, true) ;
        const GGS_instructionList::cElement * operand_1823 = NULL ;
        while (((operand_1823 = enumerator_1823.nextObject ()))) {
          macroValidPointer (operand_1823) ;
          const GGS_instruction  _temp_1863 = operand_1823->mInstruction ;
          if (_temp_1863._isBuilt ()) {
            typeCategoryMethod__instruction__enterLabelAtAddress _method = findCategoryMethod__instruction__enterLabelAtAddress (_temp_1863._galgasObjectRunTimeInfo ()) ;
            if (_method != NULL) {
              _method (_inLexique, _temp_1863 (HERE), var_cas_routineSymbolTable, var_cas_currentROMaddress COMMA_SOURCE_FILE_AT_LINE (60)) ;
            }
          }
          GGS_uint  var_cas_length ;
          const GGS_instruction  _temp_1967 = operand_1823->mInstruction ;
          if (_temp_1967._isBuilt ()) {
            _temp_1967 (HERE)->method_instructionLength (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (62)) ;
          }
          var_cas_currentROMaddress = var_cas_currentROMaddress._add_operation (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (63)) ;
        }
      }
      var_cas_currentROMaddress = var_cas_currentROMaddress._add_operation (_inLexique, GGS_uint (true, 2U) COMMA_SOURCE_FILE_AT_LINE (66)) ;
    }
  }
  {
    GGS_routineDefinitionList::cEnumerator enumerator_2181 (var_cas_inPiccoloModel.reader_mRoutineDefinitionList (_inLexique COMMA_SOURCE_FILE_AT_LINE (68)), true) ;
    const GGS_routineDefinitionList::cElement * operand_2181 = NULL ;
    while (((operand_2181 = enumerator_2181.nextObject ()))) {
      macroValidPointer (operand_2181) ;
      var_cas_routineSymbolTable.modifier_insertKey (_inLexique, operand_2181->mRoutineName, var_cas_currentROMaddress COMMA_SOURCE_FILE_AT_LINE (69)) ;
      {
        GGS_instructionList::cEnumerator enumerator_2309 (operand_2181->mInstructionList, true) ;
        const GGS_instructionList::cElement * operand_2309 = NULL ;
        while (((operand_2309 = enumerator_2309.nextObject ()))) {
          macroValidPointer (operand_2309) ;
          const GGS_instruction  _temp_2349 = operand_2309->mInstruction ;
          if (_temp_2349._isBuilt ()) {
            typeCategoryMethod__instruction__enterLabelAtAddress _method = findCategoryMethod__instruction__enterLabelAtAddress (_temp_2349._galgasObjectRunTimeInfo ()) ;
            if (_method != NULL) {
              _method (_inLexique, _temp_2349 (HERE), var_cas_routineSymbolTable, var_cas_currentROMaddress COMMA_SOURCE_FILE_AT_LINE (71)) ;
            }
          }
          GGS_uint  var_cas_length ;
          const GGS_instruction  _temp_2453 = operand_2309->mInstruction ;
          if (_temp_2453._isBuilt ()) {
            _temp_2453 (HERE)->method_instructionLength (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (73)) ;
          }
          var_cas_currentROMaddress = var_cas_currentROMaddress._add_operation (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (74)) ;
        }
      }
    }
  }
  GGS_uint  var_cas_currentRamAddress ;
  var_cas_currentRamAddress = GGS_uint (true, 0U) ;
  GGS_registerTable  var_cas_registerTable ;
  var_cas_registerTable = GGS_registerTable ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_ramDefinitionList::cEnumerator enumerator_2876 (var_cas_inPiccoloModel.reader_mRamDefinitionList (_inLexique COMMA_SOURCE_FILE_AT_LINE (84)), true) ;
    const GGS_ramDefinitionList::cElement * operand_2876 = NULL ;
    while (((operand_2876 = enumerator_2876.nextObject ()))) {
      macroValidPointer (operand_2876) ;
      var_cas_registerTable.modifier_insertKey (_inLexique, operand_2876->mName, var_cas_currentRamAddress, operand_2876->mSize.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (85)) COMMA_SOURCE_FILE_AT_LINE (85)) ;
      var_cas_currentRamAddress = var_cas_currentRamAddress._add_operation (_inLexique, operand_2876->mSize.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)) COMMA_SOURCE_FILE_AT_LINE (86)) ;
    }
  }
  {
    GGS_interruptDefinitionList::cEnumerator enumerator_3192 (var_cas_inPiccoloModel.reader_mInterruptDefinitionList (_inLexique COMMA_SOURCE_FILE_AT_LINE (90)), true) ;
    const GGS_interruptDefinitionList::cElement * operand_3192 = NULL ;
    while (((operand_3192 = enumerator_3192.nextObject ()))) {
      macroValidPointer (operand_3192) ;
      {
        GGS_instructionList::cEnumerator enumerator_3249 (operand_3192->mInstructionList, true) ;
        const GGS_instructionList::cElement * operand_3249 = NULL ;
        while (((operand_3249 = enumerator_3249.nextObject ()))) {
          macroValidPointer (operand_3249) ;
          const GGS_instruction  _temp_3289 = operand_3249->mInstruction ;
          if (_temp_3289._isBuilt ()) {
            typeCategoryMethod__instruction__generateCodeAtAddress _method = findCategoryMethod__instruction__generateCodeAtAddress (_temp_3289._galgasObjectRunTimeInfo ()) ;
            if (_method != NULL) {
              _method (_inLexique, _temp_3289 (HERE), var_cas_routineSymbolTable, var_cas_registerTable, var_cas_currentROMaddress COMMA_SOURCE_FILE_AT_LINE (92)) ;
            }
          }
          GGS_uint  var_cas_length ;
          const GGS_instruction  _temp_3409 = operand_3249->mInstruction ;
          if (_temp_3409._isBuilt ()) {
            _temp_3409 (HERE)->method_instructionLength (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (94)) ;
          }
          var_cas_currentROMaddress = var_cas_currentROMaddress._add_operation (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (95)) ;
        }
      }
    }
  }
  {
    GGS_routineDefinitionList::cEnumerator enumerator_3538 (var_cas_inPiccoloModel.reader_mRoutineDefinitionList (_inLexique COMMA_SOURCE_FILE_AT_LINE (98)), true) ;
    const GGS_routineDefinitionList::cElement * operand_3538 = NULL ;
    while (((operand_3538 = enumerator_3538.nextObject ()))) {
      macroValidPointer (operand_3538) ;
      {
        GGS_instructionList::cEnumerator enumerator_3593 (operand_3538->mInstructionList, true) ;
        const GGS_instructionList::cElement * operand_3593 = NULL ;
        while (((operand_3593 = enumerator_3593.nextObject ()))) {
          macroValidPointer (operand_3593) ;
          const GGS_instruction  _temp_3633 = operand_3593->mInstruction ;
          if (_temp_3633._isBuilt ()) {
            typeCategoryMethod__instruction__generateCodeAtAddress _method = findCategoryMethod__instruction__generateCodeAtAddress (_temp_3633._galgasObjectRunTimeInfo ()) ;
            if (_method != NULL) {
              _method (_inLexique, _temp_3633 (HERE), var_cas_routineSymbolTable, var_cas_registerTable, var_cas_currentROMaddress COMMA_SOURCE_FILE_AT_LINE (100)) ;
            }
          }
          GGS_uint  var_cas_length ;
          const GGS_instruction  _temp_3753 = operand_3593->mInstruction ;
          if (_temp_3753._isBuilt ()) {
            _temp_3753 (HERE)->method_instructionLength (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (102)) ;
          }
          var_cas_currentROMaddress = var_cas_currentROMaddress._add_operation (_inLexique, var_cas_length COMMA_SOURCE_FILE_AT_LINE (103)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_analyze\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_piccolo_semantics (void) {
 enterCategoryMethod__instruction__enterLabelAtAddress (category_method__instruction__enterLabelAtAddress, gClassInfoFor__instruction.slotID ()) ;
 enterCategoryMethod__instruction__enterLabelAtAddress ((typeCategoryMethod__instruction__enterLabelAtAddress) category_method__instruction_LABEL__enterLabelAtAddress, gClassInfoFor__instruction_LABEL.slotID ()) ;
 enterCategoryMethod__instruction__generateCodeAtAddress (category_method__instruction__generateCodeAtAddress, gClassInfoFor__instruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_piccolo_semantics (prologueRoutineFor_piccolo_semantics,
                                   NULL) ;

//---------------------------------------------------------------------------*

