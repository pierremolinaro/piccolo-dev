semantics baseline_compilation :
import "baseline_ast.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "piccolo_embedded_devices.gSemantics" ;
import "piccolo_config.gSemantics" ;
import "piccolo_options.gOption" ;
import "ram_sections.gSemantics" ;
import "baseline_semantic_analysis.gSemantics" ;
import "baseline_intermediate_instruction_print.gSemantics" ;
import "baseline_build_assembly_code.gSemantics" ;
import "baseline_build_binary_code.gSemantics" ;
import "baseline_optimizations.gSemantics" ;
import "baseline_used_routines.gSemantics" ;

#----------------------------------------------------------------------------*

map @baseline_declaredRoutineMap {
  insert insertKey error message "the '%K' routine is already declared" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#    S H O U L D    T E R M I N A T E    W I T H    M O V L W                *
#                                                                            *
#----------------------------------------------------------------------------*

method @baseline_instruction shouldTerminateWithMOVLW
  ??@string inErrorMessage
:
  error mInstructionLocation : inErrorMessage ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_literalOperation shouldTerminateWithMOVLW
  ??@string inErrorMessage
:
  if mLiteralInstruction != [@baseline_literal_instruction_opcode MOVLW] then
    error mInstructionLocation : inErrorMessage ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_CALL shouldTerminateWithMOVLW
  ??@string unused inErrorMessage
:
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_structured_if shouldTerminateWithMOVLW
  ??@string unused inErrorMessage
:
#--- THEN branch
  if [mThenInstructionList length] == 0 then
    error mInstructionLocation : "the 'then' branch of this 'if' instruction does not have any instruction; it must terminate with a MOVLW instruction" ;
  else
   [mThenInstructionList last ?@baseline_instruction lastInstruction] ;
   [lastInstruction shouldTerminateWithMOVLW !"the 'then' branch of this 'if' instruction must terminate with a MOVLW instruction"] ;
  end if ;
#--- ELSE branch
  if [mElseInstructionList length] == 0 then
    error mInstructionLocation : "the 'else' branch of this 'if' instruction does not have any instruction; it must terminate with a MOVLW instruction" ;
  else
   [mElseInstructionList last ?@baseline_instruction lastInstruction] ;
   [lastInstruction shouldTerminateWithMOVLW !"the 'else' branch of this 'if' instruction must terminate with a MOVLW instruction"] ;
  end if ;

end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#    N O    R E T U R N    C H E C K I N G                                   *
#                                                                            *
#----------------------------------------------------------------------------*

method @baseline_instruction shouldNotContinueInSequence
  ??@string inErrorMessage
:
  error mInstructionLocation : inErrorMessage ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_GOTO shouldNotContinueInSequence
  ??@string unused inErrorMessage
:
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_JUMP shouldNotContinueInSequence
  ??@string unused inErrorMessage
:
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_FOREVER shouldNotContinueInSequence
  ??@string unused inErrorMessage
:
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine baseline_analysis
  ??@baseline_model inPiccoloModel
  ??@string inSourceFileName
:
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition !inPiccoloModel->mDeviceName ?piccoloDeviceModel ;
  switch [piccoloDeviceModel mProcessorType]
    when baseline :
    when pic18_60, pic18_80 : error [inPiccoloModel mDeviceName]: "a pic18 device is not accepted here : only a baseline device" ;
    when midrange : error [inPiccoloModel mDeviceName]: "a mid-ranfe device is not accepted here : only a baseline device" ;
  end switch ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  buildConfig
    ![piccoloDeviceModel mConfigRegisterMap]
    ![inPiccoloModel mConfigDefinitionList]
    !?listFileContents
    ?actualConfigurationMap
  ;
#-------------------------------- Ram definition
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  analyze_ram_sections
    !"DECLARED VARIABLES"
    !inPiccoloModel->mRamDefinitionList
    !?ramBank
    ![piccoloDeviceModel mRegisterTable]
    !?listFileContents
    !?registerTable
    ??@declaredByteMap declaredByteMap
  ;
#-------------------------------- Build routine map
  @baselineRoutineMap routineMap [emptyMap] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn !mPage] ;
  end foreach ;
#-------------------------------- Build constant map
  @constantMap constantMap [emptyMap] ;
#--- Add "ROM_SIZE" constant
#  @lstring romSizeString [new !"ROM_SIZE" !here] ;
#  [!?constantMap insertKey !romSizeString ![piccoloDeviceModel->mRomSize sint]] ;
#--- Add declared constants
  @stringset usedRegisters [emptySet] ;
  foreach [inPiccoloModel mConstantDefinitionList] do
    [mExpression eval !registerTable !constantMap ??@sint64 result !?usedRegisters] ;
    if [registerTable hasKey ![mConstantName string]] then
      error mConstantName: "'" . mConstantName . "' is already declared as ram register or special register" ;
    else
      [!?constantMap insertKey !mConstantName !result] ;
    end if ;
  end foreach ;
#-------------------------------- Print constant map
  if [option piccolo_options.ouputListingFile value] then
    print_constant_definition
      !constantMap
      !?listFileContents
    ;
  end if ;
#-------------------------------- Check the "main" routine is declared
  if [routineMap hasKey !"main"] then
    [routineMap searchKey ![@lstring new !"main" !here] ?@bool isNoReturn ?@luint page] ;
    if not isNoReturn then
      error [routineMap locationForKey !"main"] :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main page 0\"" ;
    end if ;
    if page->uint != 0 then
      error page :"the \"main\" should be declared in page 0: \"noreturn main page 0\"" ;
    end if ;
  else
    error [inPiccoloModel mEndOfProgram]: "the program should declare the \"main\" routine" ;
  end if ;
#-------------------------------- Check page routine specification is compatible with device
  @bool needsToSavePCLATH := false ;
  const @uint totalPageCount := ([piccoloDeviceModel->mRomSize uint] + 511) / 512 ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    if [mPage uint] > 0 then
      needsToSavePCLATH := true ;
    end if ;
    if [mPage uint] >= totalPageCount then
      error mPage:"invalid value (". mPage->uint . "); the device has " . totalPageCount . " 512 word page(s) on rom" ;
    end if ;
  end foreach ;
#-------------------------------- Order routines to place "main" routine first
  @baseline_routineDefinitionList sortedRoutineDefinitionList [emptyList] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    if mRoutineName->string == "main" then
      [!?sortedRoutineDefinitionList insertAtIndex 
        !mRoutineName
        !mPage
        !mIsNoReturn
        !mInstructionList
        !mEndOfRoutineLocation
        !0
      ] ;
    else
      sortedRoutineDefinitionList += 
        !mRoutineName
        !mPage
        !mIsNoReturn
        !mInstructionList
        !mEndOfRoutineLocation
      ;
    end if ;
  end foreach ;
#-------------------------------- Check and translate routines
  @baseline_intermediate_instructionList intermediateInstructionList [emptyList] ;
  if [@uint errorCount] == 0 then
    @uint currentPage := 0 ;
    @uint localLabelIndex := 0 ;
    loop totalPageCount : while currentPage < totalPageCount do
      @bool pseudo_PAGE_generated := false ;
      foreach sortedRoutineDefinitionList do
        if [mPage uint] == currentPage then
        #---
          if not pseudo_PAGE_generated then
            pseudo_PAGE_generated := true ;
            intermediateInstructionList += ![@baseline_intermediate_pseudo_PAGE new !currentPage] ;
          end if ;
        #---
          @routineKind routineKind ;
          if mIsNoReturn then
            routineKind := [@routineKind noReturnRoutine] ;
          #--- Check does not continue in sequence
            if [mInstructionList length] == 0 then
              error mRoutineName : "a noreturn routine should terminate by a GOTO or a FOREVER loop" ;
            else
             [mInstructionList last ?@baseline_instruction lastInstruction] ;
             [lastInstruction shouldNotContinueInSequence !"a noreturn routine should terminate by a GOTO or a FOREVER loop"] ;
            end if ;
          else
            routineKind := [@routineKind regularRoutine] ;
          #--- Check instruction list terminates by a MOVLW instruction
            if [mInstructionList length] == 0 then
              error mRoutineName : "a baseline routine must end with a MOVLW instruction" ;
            else
             [mInstructionList last ?@baseline_instruction lastInstruction] ;
             [lastInstruction shouldTerminateWithMOVLW !"the last routine instruction should be MOVLW"] ;
            end if ;
          end if ;
        #--- Check and translate instructions
          if mRoutineName->string != "main" then
            intermediateInstructionList += ![@baseline_intermediate_pseudo_BEGIN_ROUTINE new !mRoutineName !not mIsNoReturn] ;
            intermediateInstructionList += ![@baseline_intermediate_pseudo_LABEL new !mRoutineName] ;
          end if ;
          handleBaselineInstructionList
            !currentPage
            !mInstructionList
            !routineMap
            !registerTable
            !constantMap
            !?localLabelIndex
            !?intermediateInstructionList
            !?listFileContents
            ?@bool continuesInSequence
            !routineKind
            !not mIsNoReturn # Last instruction should be RETLW ?
            !?usedRegisters
          ;
          intermediateInstructionList += ![@baseline_intermediate_pseudo_END_ROUTINE new !mRoutineName !currentPage] ;
          if mIsNoReturn & continuesInSequence then
            error mRoutineName:"execution should not reach the end of a \"noreturn\" routine" ;
          end if ;
        end if ;
      end foreach ;
      currentPage ++ ;
    end loop ;
  end if ;
#-------------------------------- Compute used routine set
  const @stringset usedRoutineSet := baseline_computeUsedRoutines [
    !inPiccoloModel->mRoutineDefinitionList
  ] ;
  @baseline_declaredRoutineMap declaredRoutineMap [emptyMap] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    [!?declaredRoutineMap insertKey !mRoutineName] ;
  end foreach ;
#-------------------------------- Check used routines
  @stringset unusedRoutineDeclarationUnicity [emptySet] ;
  foreach inPiccoloModel->mUnusedRoutineList do
    if not [declaredRoutineMap hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' routine is not declared" ;
    elsif [unusedRoutineDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is already declared as unused" ;
    elsif [usedRoutineSet hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is declared as unused, but is used" ;
    end if ;
    unusedRoutineDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach declaredRoutineMap do
    if (not [usedRoutineSet hasKey !lkey->string]) & (not [unusedRoutineDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' routine is unused" ;
    end if ;
  end foreach ;
#----------------------------------------------------------- Check declared bytes are used
  @stringset unusedDeclarationUnicity [emptySet] ;
  foreach inPiccoloModel->mUnusedRegisterList do
    if not [registerTable hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' byte is not declared" ;
    elsif [unusedDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is already declared as unused" ;
    elsif [usedRegisters hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is declared as unused, but is used" ;
    end if ;
    unusedDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach declaredByteMap do
    if (not [usedRegisters hasKey !lkey->string]) & (not [unusedDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' byte is unused" ;
    end if ;
  end foreach ;
#-------------------------------- Print intermediate Instruction List
  if ([@uint errorCount] == 0) & [option piccolo_options.ouputListingFile value] then
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    listFileContents .= "*" . ["INTERMEDIATE INSTRUCTION LIST" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    listFileContents .= "Generated intermediate code:\n" ;
    listFileContents .= " Line Length Mnemonic\n" ;
    @uint currentAddress := 0 ;
    foreach intermediateInstructionList index idx do
      listFileContents .= [[idx string] stringByLeftPadding !5 !' '] . " " ;
      listFileContents .= [[[mInstruction length] string] stringByLeftPadding !6 !' '] . " " ;
      [mInstruction print !?listFileContents] ;
      listFileContents .= "\n" ;
      [mInstruction setCurrentAddress !?currentAddress] ;
    end foreach ;
    listFileContents .= "\n" ;
    listFileContents .= "Code size without optimization: " . [currentAddress string] . " words.\n\n" ;
  end if ;
#-------------------------------- Perform Code Optimization
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    perform_baseline_optimizations !?intermediateInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Build assembly instruction list
  initCodeGenerator ;
  const @registerExpression sr [new ![@lstring new !"STATUS" !here] ![@luint new !0 !here]] ;
  [sr resolveBaselineAccess
    !registerTable
    ?@baseline_intermediate_registerExpression statusRegister
    ?@bitSliceTable statusRegisterBitSliceTable
    !?usedRegisters
  ] ;
  @baseline_assembly_instructionList assemblyInstructionList [emptyList] ;
  if [@uint errorCount] == 0 then
    build_baseline_assembly_code
      !intermediateInstructionList
      !actualConfigurationMap
      !statusRegister
      !statusRegisterBitSliceTable
      !?assemblyInstructionList
    ;
  end if ;
#-------------------------------- Build binary code
  if [@uint errorCount] == 0 then
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    listFileContents .= "*" . ["GENERATED CODE" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    listFileContents .= "Address Code Mnemonic\n" ;
    build_baseline_binary_code
      !assemblyInstructionList
      ![piccoloDeviceModel->mRomSize uint]
      !?listFileContents
      ?@uint usedROMsize
    ;
  end if ;
#-------------------------------- Listing file
  if [option piccolo_options.ouputListingFile value] then
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile ?*] ;
  end if ;
#-------------------------------- Code generation
#--- If no error, generate object file(s)
  if [@uint errorCount] == 0 then
#  #--- Generate hex file
#    @uint usedROMsize ;
#    build_midrange_intermediate_binary_code
#      !registerTable
#      ![[piccoloDeviceModel mBankCount] uint]
#      !generatedInstructionList
#      ![[piccoloDeviceModel mRomSize] uint]
#      !actualConfigurationMap
#      ?usedROMsize
#    ;
    getGeneratedContents ?@string contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    if [option piccolo_options.output_C_Array value] then
      const @string baseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
      get_C_ArrayImplementation !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".c" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
      get_C_ArrayHeader !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".h" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    end if ;
#  #--- Write infos (if verbose mode)
#    if [option.verbose_output value] then
#      @string verboseMessage := "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " words;" ;
#      verboseMessage .= " used: " . [usedROMsize string] . " words (" ;
#      verboseMessage .= [(usedROMsize * 100) / [[piccoloDeviceModel mRomSize] uint] string] . "%).\n" ;
#      foreach ramBank do
#        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
#        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
#        verboseMessage .= "  RAM bank '" . lkey . "': " ;
#        verboseMessage .= [bankSize string] . " bytes, used " ;
#        verboseMessage .= [usedSize string] . " bytes (" ;
#        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
#      end foreach ;
#      message verboseMessage ;
#    end if ;
  #--- Generate asm file, if corresponding option enabled
    if [option piccolo_options.generateAssembly value] then
      @string assemblyCode := "  processor " . inPiccoloModel->mDeviceName . "\n\n" ;
      foreach assemblyInstructionList do
        [mInstruction print !?assemblyCode] ;
        assemblyCode .= "\n" ;
      end foreach ;
      assemblyCode .= "\n;--- Registers\n" ;
      foreach registerTable do
        [mRegisterAddressList first ?@uint address] ;
        assemblyCode .= lkey->string . " EQU " . [address hexString] . "\n" ;
      end foreach ;
      assemblyCode .= "W EQU 0\n\n" ;
      assemblyCode .= ";--- Configuration\n" ;
      foreach actualConfigurationMap do
        assemblyCode .= "  __config " . [mRegisterAddress hexString] . ", " . [mRegisterValue & 255 hexString] . "\n" ;
      end foreach ;
      assemblyCode .= "\n  END\n" ;
      @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !asmDestinationFile ?*] ;
    end if ;
  else # There are errors : delete hex and asm files
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    if [hexDestinationFile fileExists] then
      [@string deleteFile !hexDestinationFile] ;
    end if ;
    @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
    if [asmDestinationFile fileExists] then
      [@string deleteFile !asmDestinationFile] ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
