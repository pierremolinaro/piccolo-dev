semantics baseline_semantic_analysis :
import "generic_metamodel.gSemantics" ;
import "baseline_ast.gSemantics" ;
import "baseline_ipic_classes.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "ipic_generic.gSemantics" ;
import "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*

map @baselineRoutineMap {
  @bool mIsNoReturn ;
  @luint mPage ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#-------------------------------------------------------------------------------*

method @registerExpression resolveBaselineAccess
  ??@registerTable inRegisterTable
  !@baseline_ipic_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
  [registerAddressList first ?@uint registerAddress] ;
#---
  outIPICregisterDescription := [@baseline_ipic_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine handleBaselineInstructionList
  ??@baseline_instructionList inInstructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  !@bool outContinuesInSequence
  ??@routineKind inRoutineKind
:
  outContinuesInSequence := true ;
  foreach inInstructionList do
    if not outContinuesInSequence then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      outContinuesInSequence := true ;
    end if ;
    [mInstruction build_baseline_ipic_instructionList
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?outContinuesInSequence
      !inRoutineKind
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @baseline_instruction build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
;

#----------------------------------------------------------------------------*

override method @baseline_instruction_WO_OPERAND build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@baseline_ipic_WO_OPERAND new !mInstructionLocation !mInstruction] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_MNOP build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_MNOP new !mInstructionLocation !mOccurrenceFactor] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_literalOperation build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ?@sint immediatValue] ;
#---
   if (immediatValue > 255S) | (immediatValue < -128S) then
     error mInstructionLocation:"immediate value is evaluated as " . immediatValue . " (should be betwween -128 and 255)" ;
   end if ;
#---  
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_literalOperation new
    !mInstructionLocation
    !mLiteralInstruction
    ![immediatValue & 0x000000FFS uint]
  ] ;
end method ;


#----------------------------------------------------------------------------*

override method @baseline_instruction_FD build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression ipicRegisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_FD new
    !mInstructionLocation
    !mInstruction_FD_base_code
    !ipicRegisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_CALL build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint page] ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a GOTO or JUMP instruction" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@baseline_ipic_CALL new
    !mInstructionLocation
    !mTargetLabel
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_F build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_F new
    !mInstructionLocation
    !mFAinstruction
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_FB build_baseline_ipic_instructionList
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_FB new
    !mInstructionLocation
    !mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_GOTO build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint page] ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a CALL instruction" ;
  end if ;
  ioContinuesInSequence := false ;
#---
  ioGeneratedInstructionList += ![@baseline_ipic_GOTO new
    !mInstructionLocation
    !mTargetLabel
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_IF_BitTest build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_BitTestSkip new
    !mInstructionLocation
    !mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  ] ;
#--- Append Instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction build_baseline_ipic_instructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_IF_IncDec build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  @baseline_instruction_FD_base_code baseCode ;
  if mIncrement then
    baseCode := [@baseline_instruction_FD_base_code INCFSZ] ;
  else
    baseCode := [@baseline_instruction_FD_base_code DECFSZ] ;
  end if ;
#---
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
#---
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_FD new
    !mInstructionLocation
    !baseCode
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
#---
  @bool unusedContinuesInSequence := true ;
  [mInstruction build_baseline_ipic_instructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_FOREVER build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
#--- Check instruction list does not change bank
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation]] ;
  handleBaselineInstructionList
    !mInstructionList 
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?ioContinuesInSequence
    !inRoutineKind
  ;
#--- Generate JUMP to loop start
  ioGeneratedInstructionList += ![@baseline_ipic_GOTO new
    !mInstructionLocation
    ![@lstring new !label0 !mInstructionLocation]
  ] ;
#---
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_do_while build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Generate label
  @string labelInstructionBegin := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Define label
  ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !labelInstructionBegin !mInstructionLocation]] ;
#--- Repeated instructions
  handleBaselineInstructionList
    !mRepeatedInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?ioContinuesInSequence
    !inRoutineKind
  ;
#--- while parts
  foreach mWhilePartList do
    if [mInstructionList length] == 0 then
      [mCondition build_ipic_condition_instructions
        !inRegisterTable
        !?ioLocalLabelIndex
        !false
        !mInstructionLocation
        !labelInstructionBegin
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
    else
      @string nextBranchLabel := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
      [mCondition build_ipic_condition_instructions
        !inRegisterTable
        !?ioLocalLabelIndex
        !true
        !mInstructionLocation
        !nextBranchLabel
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
      handleBaselineInstructionList
        !mInstructionList
        !inRoutineMap
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioListFileContents
        ?ioContinuesInSequence
        !inRoutineKind
      ;
      ioGeneratedInstructionList += ![@baseline_ipic_GOTO new !mInstructionLocation ![@lstring new !labelInstructionBegin !mInstructionLocation]] ;
      ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !nextBranchLabel !mInstructionLocation]] ;
    end if ;
  end foreach ;
end method ;

#-------------------------------------------------------------------------------*

override method @baseline_instruction_structured_if build_baseline_ipic_instructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Translate condition
  [mIfCondition build_ipic_condition_instructions
    !inRegisterTable
    !?ioLocalLabelIndex
    !true
    !mInstructionLocation
    !label_nextCondition
    !?ioGeneratedInstructionList
    !?ioListFileContents
  ] ;
#--- 'then' instructions
  handleBaselineInstructionList
    !mThenInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?@bool thenContinuesInSequence
    !inRoutineKind
  ;
#--- 'else' instructions
  if [mElseInstructionList length] > 0 then
    ioGeneratedInstructionList += ![@baseline_ipic_GOTO new !mInstructionLocation ![@lstring new !label_endOfIfinstruction !mInstructionLocation]] ;
  end if ;
  ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation]] ;
  handleBaselineInstructionList
    !mElseInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?@bool elseContinuesInSequence
    !inRoutineKind
  ;
  if [mElseInstructionList length] > 0 then
    ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation]] ;
  end if ;
#---
  ioContinuesInSequence := thenContinuesInSequence | elseContinuesInSequence ;
end method ;

#-------------------------------------------------------------------------------*
#                                                                               *
#   B U I L D    I P I C    C O N D I T I O N    I N S T R U C T I O N S        *
#                                                                               *
#-------------------------------------------------------------------------------*

abstract method @baseline_conditionExpression build_ipic_condition_instructions
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
;

#----------------------------------------------------*

override method @baseline_incDecRegisterInCondition build_ipic_condition_instructions
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
#---
  ioGeneratedInstructionList += ![@baseline_ipic_incDecRegisterInCondition new
    !inInstructionLocation
    !IPICregisterDescription
    !inTargetLabel
    !mIncrement
    !m_W_isDestination
    !mBranchIfZero ^ inComplementaryBranch
  ] ;
end method ;

#----------------------------------------------------*

override method @baseline_negateCondition build_ipic_condition_instructions
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  [mCondition build_ipic_condition_instructions
    !inRegisterTable
    !?ioLocalLabelIndex
    !not inComplementaryBranch
    !inInstructionLocation
    !inTargetLabel
    !?ioGeneratedInstructionList
    !?ioListFileContents
  ] ;
end method ;

#----------------------------------------------------*

override method @baseline_andCondition build_ipic_condition_instructions
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  if inComplementaryBranch then
    [mLeftExpression build_ipic_condition_instructions
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression build_ipic_condition_instructions
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  else
    @string label0 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    [mLeftExpression build_ipic_condition_instructions
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !label0
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression build_ipic_condition_instructions
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    ioGeneratedInstructionList += ![@baseline_ipic_pseudo_LABEL new ![@lstring new !label0 !inInstructionLocation]] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @baseline_bitTest_in_structured_if_condition build_ipic_condition_instructions
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_ipic_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_instruction_BitTestSkip new
    !inInstructionLocation
    !mBTFSSinstruction ^ inComplementaryBranch
    !IPICregisterDescription
    !bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_ipic_GOTO new
    !inInstructionLocation
    ![@lstring new !inTargetLabel !inInstructionLocation]
   ] ;
end method ;

#-------------------------------------------------------------------------------*
#-------------------------------------------------------------------------------*
#-------------------------------------------------------------------------------*
#-------------------------------------------------------------------------------*

abstract method @baseline_ipic_instruction instructionLength !@uint outLength ;
abstract method @baseline_ipic_instruction displayIPICinstruction ?!@string ioListFileContents ;

method @baseline_ipic_instruction setCurrentAddress ?!@uint ioCurrentAddress :
  @uint length ;
  [selfcopy instructionLength ?length] ;
  ioCurrentAddress := ioCurrentAddress + length ;
end method ;

method @baseline_ipic_instruction isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := false ;
end method ;

method @baseline_ipic_instruction isNULL !@bool outIsNULL :
  outIsNULL := false ;
end method ;

method @baseline_ipic_instruction nextInstructionIsReachable !@bool outIsReachable :
  outIsReachable := true ;
end method ;

method @baseline_ipic_instruction isSkippingInstruction !@bool outIsSkipping :
  outIsSkipping := false ;
end method ;

method @baseline_ipic_instruction enterReferencedLabel ?!@stringset unused ioReferencedLabelSet :
end method ;


#-------------------------------------------------------------------------------*

override method @baseline_ipic_NULL instructionLength !@uint outLength :
  outLength := 0 ;
end method ;

override
method @baseline_ipic_NULL displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "-" ;
end method ;

override method @baseline_ipic_NULL isNULL !@bool outIsNULL :
  outIsNULL := true ;
end method ;

override
method @baseline_ipic_WO_OPERAND displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= [mInstruction mnemonic] ;
end method ;


#-------------------------------------------------------------------------------*

override method @baseline_ipic_pseudo_PAGE instructionLength !@uint outLength :
  outLength := 0 ;
end method ;

override method @baseline_ipic_pseudo_PAGE setCurrentAddress ?!@uint ioCurrentAddress :
  ioCurrentAddress := mPage * 256 ;
end method ;

override
method @baseline_ipic_pseudo_PAGE displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "ORG " . [mPage * 256 hexString] ;
end method ;

override method @baseline_ipic_pseudo_PAGE isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := true ;
end method ;

#-------------------------------------------------------------------------------*

override method @baseline_ipic_pseudo_LABEL instructionLength !@uint outLength :
  outLength := 0 ;
end method ;

override
method @baseline_ipic_pseudo_LABEL displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "LABEL " . mLabel ;
end method ;

override method @baseline_ipic_pseudo_LABEL isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := true ;
end method ;

#-------------------------------------------------------------------------------*

override method @baseline_ipic_actualInstruction instructionLength !@uint outLength :
  outLength := 1 ;
end method ;

#-------------------------------------------------------------------------------*

method @baseline_ipic_instruction_FD getBaseCode !@uint outBaseCode :
  outBaseCode := [mInstruction_FD_base_code basecode] ;
end method ;

override
method @baseline_ipic_instruction_FD displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= [mInstruction_FD_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioListFileContents .= ", W" ;
  end if ;
end method ;

#-------------------------------------------------------------------------------*

local routine getBaselineFinstructionBaseCode
  ??@baseline_F_instruction_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when CLRF   : outBaseCode := 0x0180 ;
  when MOVWF  : outBaseCode := 0x0080 ;
  end switch ;
end routine ;

#-------------------------------------------------------------------------------*

method @baseline_ipic_instruction_F getBaseCode !@uint outBaseCode :
  getBaselineFinstructionBaseCode !mFinstruction ?outBaseCode ;
end method ;

override
method @baseline_ipic_instruction_F displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= [mFinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
end method ;

#-------------------------------------------------------------------------------*

local routine getBaselineBitOrientedOpBaseCode ??@baseline_bit_oriented_op inInstruction !@uint outBaseCode :
  switch inInstruction
  when BCF : outBaseCode := 0x1000 ;
  when BSF : outBaseCode := 0x1400 ;
  end switch ;
end routine ;


#-------------------------------------------------------------------------------*


method @baseline_ipic_instruction_FB getBaseCode !@uint outBaseCode :
  getBaselineBitOrientedOpBaseCode !mBitOrientedOp ?outBaseCode ;
end method ;

override
method @baseline_ipic_instruction_FB displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= [mBitOrientedOp mnemonic] . " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
end method ;

#-------------------------------------------------------------------------------*


method @baseline_ipic_instruction_BitTestSkip getBaseCode !@uint outBaseCode :
  if mSkipIfSet then
    outBaseCode := 0x1C00 ; # BTFSS
  else
    outBaseCode := 0x1800 ; # BTFSC
  end if ;
end method ;

override
method @baseline_ipic_instruction_BitTestSkip displayIPICinstruction ?!@string ioListFileContents :
  if mSkipIfSet then
    ioListFileContents .= "BTFSS" ;
  else
    ioListFileContents .= "BTFSC" ;
  end if ;
  ioListFileContents .= " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
end method ;

override
method @baseline_ipic_instruction_BitTestSkip isSkippingInstruction !@bool outIsSkipping :
  outIsSkipping := true ;
end method ;

#-------------------------------------------------------------------------------*

enum @baseline_call_goto_bit {
  set, clear, noChange
}{

}

#-------------------------------------------------------------------------------*


override
method @baseline_ipic_GOTO instructionLength !@uint outLength :
  outLength := 1 ;
end method ;

override
method @baseline_ipic_GOTO displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "GOTO " . mTargetLabel ;
end method ;

override method @baseline_ipic_GOTO nextInstructionIsReachable !@bool outIsReachable :
  outIsReachable := false ;
end method ;

override method @baseline_ipic_GOTO enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#-------------------------------------------------------------------------------*


override
method @baseline_ipic_CALL displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "CALL " . mTargetLabel ;
end method ;

override method @baseline_ipic_CALL enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#-------------------------------------------------------------------------------*


method @baseline_ipic_instruction_literalOperation getBaseCode !@uint outBaseCode :
  outBaseCode := [mLiteralInstruction opcode] ;
end method ;

override
method @baseline_ipic_instruction_literalOperation displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] ;
end method ;

override method @baseline_ipic_instruction_literalOperation nextInstructionIsReachable !@bool outIsReachable :
  outIsReachable := mLiteralInstruction != [@baseline_literal_instruction_opcode RETLW] ;
end method ;

#-------------------------------------------------------------------------------*

override
method @baseline_ipic_instruction_MNOP instructionLength !@uint outLength :
  outLength := [mOccurrenceFactor uint] ;
end method ;

override
method @baseline_ipic_instruction_MNOP displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "MNOP " . [[mOccurrenceFactor uint] string] ;
end method ;

#-------------------------------------------------------------------------------*


override
method @baseline_ipic_incDecRegisterInCondition instructionLength !@uint outLength :
  if mBranchIfZero then
    outLength := 3 ;
  else
    outLength := 2 ;
  end if ; 
end method ;

override
method @baseline_ipic_incDecRegisterInCondition displayIPICinstruction ?!@string ioListFileContents :
  ioListFileContents .= "JUMP " ;
  if mIncrement then
    ioListFileContents .= "INCF " ;
  else
    ioListFileContents .= "DECF " ;
  end if ;
  ioListFileContents .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioListFileContents .= ", W" ;
  end if ;
  if mBranchIfZero then
    ioListFileContents .= " Z" ;
  else
    ioListFileContents .= " NZ" ;
  end if ;
  ioListFileContents .= " " . mTargetLabel ;
end method ;

override method @baseline_ipic_incDecRegisterInCondition enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !mTargetLabel ;
end method ;


#-------------------------------------------------------------------------------*

end semantics ;
