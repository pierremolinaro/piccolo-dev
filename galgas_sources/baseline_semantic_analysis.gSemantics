semantics baseline_semantic_analysis :
import "generic_metamodel.gSemantics" ;
import "baseline_ast.gSemantics" ;
import "baseline_intermediate_classes.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "intermediate_generic.gSemantics" ;
import "piccolo_options.gOption" ;
import "baseline_intermediate_instruction_length.gSemantics" ;

#----------------------------------------------------------------------------*

map @baselineRoutineMap {
  @bool mIsNoReturn ;
  @luint mPage ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @registerExpression resolveBaselineAccess
  ??@registerTable inRegisterTable
  !@baseline_intermediate_registerExpression outIntermediateRegisterDescription
  !@bitSliceTable outBitSliceTable
  ?!@stringset ioUsedRegisters
:
  ioUsedRegisters += !mRegisterName->string ;
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- Find register
  [inRegisterTable searchKey
    !mRegisterName
    ?@uintlist registerAddressList
    ?@uint size
    ?outBitSliceTable
    ?*
  ] ;
#--- Accept if one address is <= 0x1F
  @uint registerAddress := 0 ;
  if [registerAddressList length] > 0 then
    @bool found := false ;
    foreach registerAddressList while not found do
      registerAddress := mValue ;
      found := mValue <= 0x1F ;
    end foreach ;
    if not found then
      error mRegisterName : "the register cannot be accessed directly; use indirect addressing throught FSR register" ;
    end if ;
  end if ;
#---
  outIntermediateRegisterDescription := [@baseline_intermediate_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine handleBaselineInstructionList
  ??@uint inCurrentPage
  ??@baseline_instructionList inInstructionList
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  !@bool outContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  outContinuesInSequence := true ;
  foreach inInstructionList index idx do
    if not outContinuesInSequence then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      outContinuesInSequence := true ;
    end if ;
    [mInstruction build_baseline_intermediate_instructionList
      !inCurrentPage
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?outContinuesInSequence
      !inRoutineKind
      !if (idx + 1) == [inInstructionList length] then inLastInstructionShouldReturn else false end
      !?ioUsedRegisters
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @baseline_instruction build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
;

#----------------------------------------------------------------------------*

override method @baseline_instruction_WO_OPERAND build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "the last routine instruction should be MOVLW" ;
  end if ;
  ioGeneratedInstructionList += ![@baseline_intermediate_WO_OPERAND new !mInstructionLocation !mInstruction] ;
end method ;

#----------------------------------------------------------------------------*

once acceptableTRISoperand -> @stringset set :
  set := [@stringset emptySet] ;
  set += !"GPIO" ;
  set += !"PORTA" ;
  set += !"PORTB" ;
  set += !"PORTC" ;
  set += !"PORTD" ;
  set += !"PORTE" ;
end once ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_TRIS build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction but should be MOVLW" ;
  end if ;
#---
  if not [acceptableTRISoperand [] hasKey !mOperand->string] then
    @string s := "" ;
    foreach acceptableTRISoperand []
    do s .= key ;
    between s .= ", " ;    
    end foreach ;
    error mInstructionLocation : "invalid TRIS operand; accepted operand are: " . s ;
  end if ;
#---
  [inRegisterTable searchKey !mOperand ?@uintlist registerAddressList ?3*] ;
  [registerAddressList first ?@uint opcode] ;
#---
  ioGeneratedInstructionList += ![@baseline_intermediate_TRIS new !mInstructionLocation !mOperand !opcode] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_MNOP build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_MNOP new !mInstructionLocation !mOccurrenceFactor] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_literalOperation build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  if inLastInstructionShouldReturn & (mLiteralInstruction != [@baseline_literal_instruction_opcode MOVLW]) then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [mImmediatExpression eval !inRegisterTable !inConstantMap ?@sint64 immediatValue !?ioUsedRegisters] ;
#---
   if (immediatValue > 255LS) | (immediatValue < -128LS) then
     error mInstructionLocation:"immediate value is evaluated as " . immediatValue . " (should be betwween -128 and 255)" ;
   end if ;
#---  
  if inLastInstructionShouldReturn then
    ioGeneratedInstructionList += ![@baseline_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@baseline_literal_instruction_opcode RETLW]
      ![immediatValue & 0x000000FFS uint]
    ] ;
  else
    ioGeneratedInstructionList += ![@baseline_intermediate_instruction_literalOperation new
      !mInstructionLocation
      !mLiteralInstruction
      ![immediatValue & 0x000000FFS uint]
    ] ;
  end if ;
end method ;


#----------------------------------------------------------------------------*

override method @baseline_instruction_FD build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_FD new
    !mInstructionLocation
    !mInstruction_FD_base_code
    !intermediateRegisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_CALL build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint targetPage] ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a GOTO or a JUMP instruction" ;
  end if ;
  if inCurrentPage != targetPage->uint then
    error mTargetLabel:"for an inter-page regular routine call, use a JSR instruction" ;
  end if ;
#---
  if inLastInstructionShouldReturn then
    ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
      !mInstructionLocation
      !mTargetLabel
    ] ;
  else
    ioGeneratedInstructionList += ![@baseline_intermediate_CALL new
      !mInstructionLocation
      !mTargetLabel
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_JSR build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint targetPage] ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a GOTO or a JUMP instruction" ;
  end if ;
#---
  if inLastInstructionShouldReturn then
    ioGeneratedInstructionList += ![@baseline_intermediate_JUMP new
      !mInstructionLocation
      !mTargetLabel
      !inCurrentPage
      !targetPage->uint
    ] ;
  else
    ioGeneratedInstructionList += ![@baseline_intermediate_JSR new
      !mInstructionLocation
      !mTargetLabel
      !inCurrentPage
      !targetPage->uint
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_F build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_F new
    !mInstructionLocation
    !mFAinstruction
    !intermediateRegisterDescription
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_FB build_baseline_intermediate_instructionList
  ??@uint unused inCurrentPage
  ??@baselineRoutineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?@uint bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_FB new
    !mInstructionLocation
    !mBitOrientedOp
    !intermediateRegisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_GOTO build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint targetPage] ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a CALL or a JSR instruction" ;
  end if ;
  if inCurrentPage != targetPage->uint then
    error mTargetLabel:"for an inter-page noreturn routine call, use a JUMP instruction" ;
  end if ;
  ioContinuesInSequence := false ;
#---
  ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
    !mInstructionLocation
    !mTargetLabel
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_JUMP build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset unused ioUsedRegisters
:
  if inLastInstructionShouldReturn then
    error mInstructionLocation : "this instruction is the last routine instruction and should be MOVLW" ;
  end if ;
  [inRoutineMap searchKey !mTargetLabel ?@bool isNoReturn ?@luint targetPage] ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a CALL or a JSR instruction" ;
  end if ;
  ioContinuesInSequence := false ;
#---
  ioGeneratedInstructionList += ![@baseline_intermediate_JUMP new
    !mInstructionLocation
    !mTargetLabel
    !inCurrentPage
    !targetPage->uint
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_IF_BitTest build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_BitTestSkip new
    !mInstructionLocation
    !mSkipIfSet
    !intermediateRegisterDescription
    !bitNumber
  ] ;
#--- Append Instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction build_baseline_intermediate_instructionList
    !inCurrentPage
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?unusedContinuesInSequence
    !inRoutineKind
    !inLastInstructionShouldReturn
    !?ioUsedRegisters
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_IF_IncDec build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
#---
  @baseline_instruction_FD_base_code baseCode ;
  if mIncrement then
    baseCode := [@baseline_instruction_FD_base_code INCFSZ] ;
  else
    baseCode := [@baseline_instruction_FD_base_code DECFSZ] ;
  end if ;
#---
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
#---
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_FD new
    !mInstructionLocation
    !baseCode
    !intermediateRegisterDescription
    !m_W_isDestination
  ] ;
#---
  @bool unusedContinuesInSequence := true ;
  [mInstruction build_baseline_intermediate_instructionList
    !inCurrentPage
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?unusedContinuesInSequence
    !inRoutineKind
    !inLastInstructionShouldReturn
    !?ioUsedRegisters
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_FOREVER build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint  ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool unused inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
#--- Check instruction list does not change bank
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation]] ;
  handleBaselineInstructionList
    !inCurrentPage
    !mInstructionList 
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?ioContinuesInSequence
    !inRoutineKind
    !false # Instruction list does not need to end with MOVLW
    !?ioUsedRegisters
  ;
#--- Generate GOTO to the beginning of the loop
  ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
    !mInstructionLocation
    ![@lstring new !label0 !mInstructionLocation]
  ] ;
#---
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_STATIC_REPEAT build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint  ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool unused inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
  [mRepeatExpression eval !inRegisterTable !inConstantMap ??@sint64 repeatCount !?ioUsedRegisters] ;
#---
  if (repeatCount > 0xFFFFLS) | (repeatCount <= 0LS) then
    error mInstructionLocation:"immediate value is evaluated as " . repeatCount . " (should be > 0 and < 0xFFFF)" ;
  end if ;
#--- First pass
  handleBaselineInstructionList
    !inCurrentPage
    !mInstructionList 
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?ioContinuesInSequence
    !inRoutineKind
    !false # Instruction list does not need to end with MOVLW
    !?ioUsedRegisters
  ;
  if not ioContinuesInSequence then
    error mEndOfInstruction:"enclosed instruction list contains an endless loop";
  end if ;
#--- Other passes
  for idx in [@range new !0 ![repeatCount-1LS uint]] while [@uint errorCount] == 0 do
    handleBaselineInstructionList
      !inCurrentPage
      !mInstructionList 
      !inRoutineMap
      !inRegisterTable
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      ?ioContinuesInSequence
      !inRoutineKind
      !false # Instruction list does not need to end with MOVLW
      !?ioUsedRegisters
    ;
  end for ;
end method ;

#----------------------------------------------------------------------------*

override method @baseline_instruction_do_while build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
#--- Generate label
  @string labelInstructionBegin := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Define label
  ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !labelInstructionBegin !mInstructionLocation]] ;
#--- Repeated instructions
  handleBaselineInstructionList
    !inCurrentPage
    !mRepeatedInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?ioContinuesInSequence
    !inRoutineKind
    !inLastInstructionShouldReturn
    !?ioUsedRegisters
  ;
#--- while parts
  foreach mWhilePartList do
    if [mInstructionList length] == 0 then
      [mCondition build_intermediate_condition_instructions
        !inCurrentPage
        !inRegisterTable
        !?ioLocalLabelIndex
        !false
        !mInstructionLocation
        !labelInstructionBegin
        !?ioGeneratedInstructionList
        !?ioUsedRegisters
      ] ;
    else
      @string nextBranchLabel := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
      [mCondition build_intermediate_condition_instructions
        !inCurrentPage
        !inRegisterTable
        !?ioLocalLabelIndex
        !true
        !mInstructionLocation
        !nextBranchLabel
        !?ioGeneratedInstructionList
        !?ioUsedRegisters
      ] ;
      handleBaselineInstructionList
        !inCurrentPage
        !mInstructionList
        !inRoutineMap
        !inRegisterTable
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioListFileContents
        ?ioContinuesInSequence
        !inRoutineKind
        !inLastInstructionShouldReturn
        !?ioUsedRegisters
      ;
      ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
        !mInstructionLocation
        ![@lstring new !labelInstructionBegin !mInstructionLocation]
      ] ;
      ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !nextBranchLabel !mInstructionLocation]] ;
    end if ;
  end foreach ;
end method ;

#-------------------------------------------------------------------------------*

override method @baseline_instruction_structured_if build_baseline_intermediate_instructionList
  ??@uint inCurrentPage
  ??@baselineRoutineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
  ??@bool inLastInstructionShouldReturn
  ?!@stringset ioUsedRegisters
:
#---
  @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Translate condition
  [mIfCondition build_intermediate_condition_instructions
    !inCurrentPage
    !inRegisterTable
    !?ioLocalLabelIndex
    !true
    !mInstructionLocation
    !label_nextCondition
    !?ioGeneratedInstructionList
    !?ioUsedRegisters
  ] ;
#--- 'then' instructions
  handleBaselineInstructionList
    !inCurrentPage
    !mThenInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?@bool thenContinuesInSequence
    !inRoutineKind
    !inLastInstructionShouldReturn
    !?ioUsedRegisters
  ;
#--- 'else' instructions
  if ([mElseInstructionList length] > 0) & not inLastInstructionShouldReturn then
    ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
      !mInstructionLocation
      ![@lstring new !label_endOfIfinstruction !mInstructionLocation]
    ] ;
  end if ;
  ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation]] ;
  handleBaselineInstructionList
    !inCurrentPage
    !mElseInstructionList
    !inRoutineMap
    !inRegisterTable
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    ?@bool elseContinuesInSequence
    !inRoutineKind
    !inLastInstructionShouldReturn
    !?ioUsedRegisters
  ;
  if ([mElseInstructionList length] > 0) & not inLastInstructionShouldReturn then
    ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation]] ;
  end if ;
#---
  ioContinuesInSequence := thenContinuesInSequence | elseContinuesInSequence ;
end method ;

#-------------------------------------------------------------------------------*
#                                                                               *
#   B U I L D    I P I C    C O N D I T I O N    I N S T R U C T I O N S        *
#                                                                               *
#-------------------------------------------------------------------------------*

abstract method @baseline_conditionExpression build_intermediate_condition_instructions
  ??@uint inCurrentPage
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@stringset ioUsedRegisters
;

#----------------------------------------------------*

override method @baseline_incDecRegisterInCondition build_intermediate_condition_instructions
  ??@uint unused inCurrentPage
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@stringset ioUsedRegisters
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
#---
  ioGeneratedInstructionList += ![@baseline_intermediate_incDecRegisterInCondition new
    !inInstructionLocation
    !intermediateRegisterDescription
    !inTargetLabel
    !mIncrement
    !m_W_isDestination
    !mBranchIfZero ^ inComplementaryBranch
  ] ;
end method ;

#----------------------------------------------------*

override method @baseline_negateCondition build_intermediate_condition_instructions
  ??@uint inCurrentPage
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@stringset ioUsedRegisters
:
  [mCondition build_intermediate_condition_instructions
    !inCurrentPage
    !inRegisterTable
    !?ioLocalLabelIndex
    !not inComplementaryBranch
    !inInstructionLocation
    !inTargetLabel
    !?ioGeneratedInstructionList
    !?ioUsedRegisters
  ] ;
end method ;

#----------------------------------------------------*

override method @baseline_andCondition build_intermediate_condition_instructions
  ??@uint inCurrentPage
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@stringset ioUsedRegisters
:
  if inComplementaryBranch then
    [mLeftExpression build_intermediate_condition_instructions
      !inCurrentPage
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioUsedRegisters
    ] ;
    [mRightExpression build_intermediate_condition_instructions
      !inCurrentPage
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioUsedRegisters
    ] ;
  else
    @string label0 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    [mLeftExpression build_intermediate_condition_instructions
      !inCurrentPage
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !label0
      !?ioGeneratedInstructionList
      !?ioUsedRegisters
    ] ;
    [mRightExpression build_intermediate_condition_instructions
      !inCurrentPage
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioUsedRegisters
    ] ;
    ioGeneratedInstructionList += ![@baseline_intermediate_pseudo_LABEL new ![@lstring new !label0 !inInstructionLocation]] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @baseline_bitTest_in_structured_if_condition build_intermediate_condition_instructions
  ??@uint unused inCurrentPage
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@stringset ioUsedRegisters
:
  [mRegisterExpression resolveBaselineAccess
    !inRegisterTable
    ?@baseline_intermediate_registerExpression intermediateRegisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_instruction_BitTestSkip new
    !inInstructionLocation
    !mBTFSSinstruction ^ inComplementaryBranch
    !intermediateRegisterDescription
    !bitNumber
  ] ;
  ioGeneratedInstructionList += ![@baseline_intermediate_GOTO new
    !inInstructionLocation
    ![@lstring new !inTargetLabel !inInstructionLocation]
   ] ;
end method ;

#-------------------------------------------------------------------------------*

end semantics ;
