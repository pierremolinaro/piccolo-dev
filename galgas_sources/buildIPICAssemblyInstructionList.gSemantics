semantics buildIPICAssemblyInstructionList :
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;
import semantics ipic_metamodel in "ipic_metamodel.gSemantics" ;
import semantics piccoloDevice_semantics in "piccoloDevice_semantics.gSemantics" ;
import option piccolo_options in "piccolo_options.gOption" ;
import "ipic_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#                    IMMEDIAT EXPRESSION EVALUATION                          *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @immediatExpression.eval
  ??@registerTable inRegisterTable
  !@sint outResult
;

#----------------------------------------------------------------------------*

override method @immediatInteger.eval
  ??@registerTable unused inRegisterTable
  !@sint outResult
:
  outResult := [[mValue uint] sint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatRegister.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @uintlist registerAddressList ;
  @uint size ;
  [inRegisterTable searchKey ![mRegister mRegisterName] ?registerAddressList ?size ?* ?*] ;
  @uint registerAddress ; [registerAddressList first ?registerAddress] ;
  if [[mRegister mOffset] uint] >= size then
    error [mRegister mOffset]:"index (" . [[[mRegister mOffset] uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
  outResult := [registerAddress + [[mRegister mOffset] uint] sint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatAdd.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult + rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatSub.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult - rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatMul.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult * rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatDiv.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult * rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatMod.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult mod rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatAnd.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult & rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatOr.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult | rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatXor.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult ^ rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLeftShift.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult << [rightResult uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatRightShift.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  outResult := leftResult >> [rightResult uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatEqualTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult == rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatNotEqualTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult != rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatGreaterOrEqualTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult >= rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLowerOrEqualTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult <= rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatGreaterTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult > rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLowerTest.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint leftResult ; [mLeftExpression eval !inRegisterTable ?leftResult] ;
  @sint rightResult ; [mRightExpression eval !inRegisterTable ?rightResult] ;
  if leftResult < rightResult then
    outResult := 1S ;
  else
    outResult := 0S ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatNegate.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint result ; [mExpression eval !inRegisterTable ?result] ;
  outResult := - result ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatComplement.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @sint result ; [mExpression eval !inRegisterTable ?result] ;
  outResult := ~ result ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatSlice.eval
  ??@registerTable inRegisterTable
  !@sint outResult
:
  @bitSliceTable bitSliceTable ;
  outResult := 0S ;
  [inRegisterTable searchKey !mRegisterName ?* ?* ? bitSliceTable ?*] ;
  @stringset sliceNameSet [emptySet] ;
  foreach mSliceExpressionList do
    if [sliceNameSet hasKey ![mSliceName string]] then
      error mSliceName:"the '" . mSliceName . "' bit field has been already defined" ;
    else
      sliceNameSet += ![mSliceName string] ;
      @uint sliceIndex ;
      @uint sliceSize ;
      [bitSliceTable searchKey !mSliceName ?sliceIndex ?sliceSize] ;
      @sint result ; [mExpression eval !inRegisterTable ?result] ;
      if (result < 0S) | (result > (1S << (sliceSize - 1))) then
log mSliceName ;
        error mSliceName:"invalid immediat value associated to the '" . mSliceName . "' bit field, evaluated as " . [result string]
        . " (should be between 0 and " . [1S << (sliceSize - 1) string] . ")" ;
      end if ;
      outResult := outResult | (result << sliceIndex) ;
      end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#                        BIT NUMBER EXPRESSION                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
:
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
:
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
end method ;

#----------------------------------------------------*

method @registerExpression.resolveAccess
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  !@ipic_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  @uint registerAddress := 0 ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
    registerAddress := mValue ;
  end foreach ;
  @bool needsBSRaccess := false ;
  if not found then
    needsBSRaccess := true ;
    [registerAddressList first ?registerAddress] ;
  end if ;
#---
  outIPICregisterDescription := [@ipic_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
    !needsBSRaccess
  ] ;
end method ;

#----------------------------------------------------*
#           DECOMPOSE STRUCTURED INSTRUCTIONS        *
#----------------------------------------------------*

abstract method @piccolo_instruction.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
;

#----------------------------------------------------*

override method @instruction_nobanksel.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
#--- Generates no code
end method ;

#----------------------------------------------------*

override method @instruction_savebank.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
#--- Get values for BSR register
  @registerExpression BSRregister [new ![@lstring new !"BSR" !here] ![@luint new !0 !here]] ;
  @ipic_registerExpression BSR_IPICregisterDescription ;
  [BSRregister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?BSR_IPICregisterDescription
    ?*
  ] ;
#--- Get values for register used for saving
  @ipic_registerExpression save_IPICregisterDescription ;
  [mRegister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?save_IPICregisterDescription
    ?*
  ] ;
#--- Generate "MOVFF BSR, save_register" instruction
  ioGeneratedInstructionList += ![@ipic_instruction_MOVFF new
    !mInstructionLocation
    !BSR_IPICregisterDescription
    !save_IPICregisterDescription
  ] ;
#--- Generate instruction list
  foreach mInstructionList do
    [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
  end foreach ;
#--- Generate "MOVFF save_register, BSR" instruction
  ioGeneratedInstructionList += ![@ipic_instruction_MOVFF new
    !mInstructionLocation
    !save_IPICregisterDescription
    !BSR_IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_banksel.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_MOVLB new !mInstructionLocation !mBankIndex] ;
end method ;

#----------------------------------------------------*

override method @instruction_FDA.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_FDA new
    !mInstructionLocation
    !mInstruction_FDA_base_code
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FA.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_FA new
    !mInstructionLocation
    !mFAinstruction
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_MOVFF.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @ipic_registerExpression sourceIPICregisterDescription ;
  [mSourceRegisterName resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?sourceIPICregisterDescription
    ?*
  ] ;
  @ipic_registerExpression destinationIPICregisterDescription ;
  [mDestinationRegisterName resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?destinationIPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_MOVFF new
    !mInstructionLocation
    !sourceIPICregisterDescription
    !destinationIPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FBA.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @bitSliceTable bitSliceTable ;
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_FBA new
    !mInstructionLocation
    !mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JSR.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_JSR new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JUMP.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_JUMP new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JUMPCC.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @condionalBranchMode mode ;
  if mIsBcc then
    mode := [@condionalBranchMode native] ;
  else
    mode := [@condionalBranchMode native] ;
  end if ;
  ioGeneratedInstructionList += ![@ipic_instruction_conditionalBranch new
    !mInstructionLocation
    !mode
    !mConditionalBranch
    !mTargetLabel
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_CLRWDT.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_CLRWDT new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_DAW.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_DAW new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_NOP.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_NOP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_POP.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_POP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_PUSH.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_PUSH new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_RESET.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_RESET new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_SLEEP.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_SLEEP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_literalOperation.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @sint result ; [mImmediatExpression eval !inRegisterTable ?result] ;
#---
   if (result > 255S) | (result < -128S) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be betwween -128 and 255)" ;
   end if ;
#---  
  ioGeneratedInstructionList += ![@ipic_instruction_literalOperation new
    !mInstructionLocation
    !mLiteralInstruction
    ![result & 0x000000FFS uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_LFSR.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @sint result ; [mImmediatExpression eval !inRegisterTable ?result] ;
#---
   if (result > 0xFFFS) | (result < 0S) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 4095)" ;
   end if ;
  ioGeneratedInstructionList += ![@ipic_instruction_LFSR new
    !mInstructionLocation
    !mFSRindex
    ![result uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLRD.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_TBLRD new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLWT.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_TBLWT new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_retlw.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @sint size ; [mSizeExpression eval !inRegisterTable ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mImmediateExpressionList length] then
    error mInstructionLocation:"the constant list length (" . [[mImmediateExpressionList length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- 
  @uintlist literalValues [emptyList] ;
  foreach mImmediateExpressionList :idx do
    @sint v ; [mExpression eval !inRegisterTable ?v] ;
    if (v > 255S) | (v < -128S) then
      error mInstructionLocation:"immediate value with index " . [idx string] . " is evaluated as " . [v string] . " (should be <= 255)" ;
    end if ;
    literalValues += ![v & 0x000000FFS uint] ;
  end foreach ;
#---
  ioGeneratedInstructionList += ![@ipic_instruction_computed_retlw new
    !mInstructionLocation
    !literalValues
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_MNOP.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  ioGeneratedInstructionList += ![@ipic_instruction_MNOP new
    !mInstructionLocation
    !mOccurrenceFactor
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_bra.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @sint size ; [mSizeExpression eval !inRegisterTable ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@ipic_instruction_computed_bra new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_goto.buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @sint size ; [mSizeExpression eval !inRegisterTable ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@ipic_instruction_computed_goto new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FOREVER.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation]] ;
  foreach mInstructionList do
    [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
  end foreach ;
  ioGeneratedInstructionList += ![@ipic_JUMP new !mInstructionLocation ![@lstring new !label0 !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  @FA_instruction_base_code baseCode ;
  switch mOpCode
    when CPFSEQ : baseCode := [@FA_instruction_base_code CPFSEQ] ;
    when CPFSGT : baseCode := [@FA_instruction_base_code CPFSGT] ;
    when CPFSLT : baseCode := [@FA_instruction_base_code CPFSLT] ;
    when TSTFSZ : baseCode := [@FA_instruction_base_code TSTFSZ] ;
  end switch ;
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_FA new
    !mInstructionLocation
    !baseCode
    !IPICregisterDescription
  ] ;
#--- Append Instruction
  [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_BitTest.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  @bitSliceTable bitSliceTable ;
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_BitTestSkip new
    !mInstructionLocation
    !mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  ] ;
#--- Append Instruction
  [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
end method ;

#----------------------------------------------------*

abstract method @conditionExpression.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
;

#----------------------------------------------------*

abstract method @conditionExpression.computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition.buildIPICinstructionForCondition
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @conditional_branch condition ;
  if inComplementaryBranch then
    getComplementaryBcc !mCondition ?condition ;
  else
    condition := mCondition ;
  end if ;
  ioGeneratedInstructionList += ![@ipic_instruction_conditionalBranch new
    !inInstructionLocation
    ![@condionalBranchMode native]
    !condition
    ![@lstring new !inTargetLabel !inInstructionLocation]
  ] ;
end method ;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition.computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

override method @registerComparisonCondition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @registerComparison comparison ;
  if inComplementaryBranch then
    getRegisterComparisonComplementary !mComparison ?comparison ;
  else
    comparison := mComparison ;
  end if ;
#---
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@ipic_registerComparisonCondition new
    !inInstructionLocation
    !IPICregisterDescription
    !inTargetLabel
    !comparison
    !true # By Default, uses BRA
  ] ;
end method ;

#----------------------------------------------------*

override method @registerComparisonCondition.computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  @registerComparison comparison ;
  if inComplementaryBranch then
    getRegisterComparisonComplementary !mComparison ?comparison ;
  else
    comparison := mComparison ;
  end if ;
  getRegisterComparisonInstructionCount !comparison ?outInstructionCount ;
end method ;

#----------------------------------------------------*

override method @incDecRegisterInCondition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@ipic_incDecRegisterInCondition new
    !inInstructionLocation
    !IPICregisterDescription
    !inTargetLabel
    !mIncrement
    !m_W_isDestination
    !mBranchIfZero ^ inComplementaryBranch
    !true # By Default, uses BRA
  ] ;
end method ;

#----------------------------------------------------*

override method @incDecRegisterInCondition.computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

override method @registerTestCondition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@ipic_jump_test_register new
    !inInstructionLocation
    !IPICregisterDescription
    !inTargetLabel
    !mBranchIfZero ^ inComplementaryBranch
    !true # By Default, uses BRA
  ] ;
end method ;

#----------------------------------------------------*

override method @registerTestCondition.computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  if mBranchIfZero ^ inComplementaryBranch then
    outInstructionCount := 3 ;
  else
    outInstructionCount := 2 ;
  end if ;
end method ;

#----------------------------------------------------*

override method @negateCondition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  [mCondition buildIPICinstructionForCondition
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioLocalLabelIndex
    !not inComplementaryBranch
    !inInstructionLocation
    !inTargetLabel
    !?ioGeneratedInstructionList
    !?ioListFileContents
  ] ;
end method ;

#----------------------------------------------------*

override method @negateCondition.computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  [mCondition computeInstructionCountForCondition
    !not inComplementaryBranch
    ?outInstructionCount
  ] ;
end method ;

#----------------------------------------------------*

override method @andCondition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  if inComplementaryBranch then
    [mLeftExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  else
    @string label0 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    [mLeftExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !label0
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label0 !inInstructionLocation]] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @andCondition.computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  @uint countLeft ;
  [mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?countLeft
  ] ;
  @uint countRight ;
  [mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?countRight
  ] ;
  outInstructionCount := countLeft + countRight ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition.buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @bitSliceTable bitSliceTable ;
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@ipic_instruction_BitTestSkip new
    !inInstructionLocation
    !mBTFSSinstruction ^ inComplementaryBranch
    !IPICregisterDescription
    !bitNumber
  ] ;
  ioGeneratedInstructionList += ![@ipic_JUMP new !inInstructionLocation ![@lstring new !inTargetLabel !inInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition.computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

override method @instruction_structured_if.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  @bool generateComplementaryCondition := false ;
#--- Direct Test Instruction Count
  if [option piccolo_options.performOptimizations] then
    @uint directCount ; [mIfCondition computeInstructionCountForCondition !true ?directCount] ;
    if [mElseInstructionList length] > 0 then
      directCount ++ ;
    end if ;
    @uint complementaryCount ; [mIfCondition computeInstructionCountForCondition !false ?complementaryCount] ;
    if [mThenInstructionList length] > 0 then
      complementaryCount ++ ;
    end if ;
    if (complementaryCount < directCount) then
      generateComplementaryCondition := true ;
      ioListFileContents .= "  line " . [[ioGeneratedInstructionList length] string] . ": generates complementary test (saves "
      . [directCount - complementaryCount string] . " instruction" ;
      if (directCount - complementaryCount) > 1 then
        ioListFileContents .= "s" ;
      end if ;
      ioListFileContents .= ")\n" ;
    end if ;
  end if ;
  if generateComplementaryCondition then
  #---
    @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  #--- Translate condition
    [mIfCondition buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  #--- 'else' instructions
    foreach mElseInstructionList do
      [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
    end foreach ;
  #--- 'then' instructions
    if [mThenInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@ipic_JUMP new !mInstructionLocation ![@lstring new !label_endOfIfinstruction !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
    end if ;
    ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation]] ;
    foreach mThenInstructionList do
      [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
    end foreach ;
    if [mThenInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation]] ;
    end if ;
  else
  #---
    @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  #--- Translate condition
    [mIfCondition buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  #--- 'then' instructions
    foreach mThenInstructionList do
      [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
    end foreach ;
  #--- 'else' instructions
    if [mElseInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@ipic_JUMP new !mInstructionLocation ![@lstring new !label_endOfIfinstruction !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
    end if ;
    ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation]] ;
    foreach mElseInstructionList do
      [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
    end foreach ;
    if [mElseInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation]] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_do_while.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
#--- Generate label
  @string labelInstructionBegin := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Define label
  ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !labelInstructionBegin !mInstructionLocation]] ;
#--- Repeated instructions
  foreach mRepeatedInstructionList do
    [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
  end foreach ;
#--- while parts
  foreach mWhilePartList do
    if [mInstructionList length] == 0 then
      [mCondition buildIPICinstructionForCondition
        !inAccessBankSplitOffset
        !inRegisterTable
        !?ioLocalLabelIndex
        !false
        !mInstructionLocation
        !labelInstructionBegin
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
    else
      @string nextBranchLabel := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
      [mCondition buildIPICinstructionForCondition
        !inAccessBankSplitOffset
        !inRegisterTable
        !?ioLocalLabelIndex
        !true
        !mInstructionLocation
        !nextBranchLabel
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
      foreach mInstructionList do
        [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
      end foreach ;
      ioGeneratedInstructionList += ![@ipic_JUMP new !mInstructionLocation ![@lstring new !labelInstructionBegin !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
      ioGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !nextBranchLabel !mInstructionLocation]] ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_IncDec.buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
#---
  @instruction_FDA_base_code baseCode ;
  if mIncrement & mSkipIfZero then
    baseCode := [@instruction_FDA_base_code INCFSZ] ;
  elsif mIncrement & not mSkipIfZero then
    baseCode := [@instruction_FDA_base_code INFSNZ] ;
  elsif (not mIncrement) & mSkipIfZero then
    baseCode := [@instruction_FDA_base_code DECFSZ] ;
  else
    baseCode := [@instruction_FDA_base_code DCFSNZ] ;
  end if ;
#---
  @ipic_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@ipic_instruction_FDA new
    !mInstructionLocation
    !baseCode
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
#--- Repeated instructions
  [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?ioLocalLabelIndex !?ioGeneratedInstructionList !?ioListFileContents] ;
end method ;

#----------------------------------------------------*

routine buildIPICAssemblyInstructionList
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ??@piccoloModel inPiccoloModel
  ??@bool inHasHighInterrupt
  ??@bool inHasLowInterrupt
  !@ipic_instructionList outGeneratedInstructionList
  ?!@string ioListFileContents
:
  @string generationOptimizationMessages := "" ;
#-------------------------------- First Pass
  outGeneratedInstructionList := [@ipic_instructionList emptyList] ;
  @uint localLabelIndex := 0 ;
#--- At zero, generate 'jump main' instruction
  outGeneratedInstructionList += ![@ipic_JUMP new !here ![@lstring new !"main" !here] ![@jumpInstructionKind ipicRelative]] ;
#--- At 0x08, generate 'bra _fast_interrupt' instruction, if both interrupt are defined
  if inHasLowInterrupt & inHasHighInterrupt then
    outGeneratedInstructionList += ![@ipic_pseudo_ORG new !0x8] ;
    outGeneratedInstructionList += ![@ipic_JUMP new !here ![@lstring new !"_fast_interrupt" !here] ![@jumpInstructionKind ipicRelative]] ;
  end if ;
#--- First, handle low interrupt (if any)
  if inHasLowInterrupt then
    outGeneratedInstructionList += ![@ipic_pseudo_ORG new !0x18] ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        foreach mInstructionList do
          [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?localLabelIndex !?outGeneratedInstructionList !? generationOptimizationMessages] ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        outGeneratedInstructionList += ![@ipic_instruction_RETFIE new !here !mFastReturn] ;
      end if ;
    end foreach ;
  end if ;
#--- Then, handle high interrupt (if any)
  if inHasHighInterrupt then
    if inHasLowInterrupt then
      outGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !"_fast_interrupt" !here]] ;
    else
      outGeneratedInstructionList += ![@ipic_pseudo_ORG new !0x8] ;
    end if ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        foreach mInstructionList do
          [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?localLabelIndex !?outGeneratedInstructionList !? generationOptimizationMessages] ;
        end foreach ;
      #--- Add a REFFIE instruction
        outGeneratedInstructionList += ![@ipic_instruction_RETFIE new !here !true] ;
      end if ;
    end foreach ;
  end if ;
#--- Handle routines
  foreach [inPiccoloModel mRoutineDefinitionList] do
    outGeneratedInstructionList += ![@ipic_pseudo_LABEL new !mRoutineName] ;
    foreach mInstructionList do
      [mInstruction buildIPICinstructionList !inAccessBankSplitOffset !inRegisterTable !?localLabelIndex !?outGeneratedInstructionList !? generationOptimizationMessages] ;
    end foreach ;
  #--- Add a RETURN instruction (if it is a regular routine)
    if not mIsNoReturn then
      outGeneratedInstructionList += ![@ipic_instruction_RETURN new ![mRoutineName location]] ;
    end if ;
  end foreach ;
#--- Description of register WREG
  @registerExpression WREGregister [new ![@lstring new !"WREG" !here] ![@luint new !0 !here]] ;
  @ipic_registerExpression WREG_IPICregisterDescription ;
  [WREGregister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?WREG_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSL
  @registerExpression TOSLregister [new ![@lstring new !"TOSL" !here] ![@luint new !0 !here]] ;
  @ipic_registerExpression TOSL_IPICregisterDescription ;
  [TOSLregister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?TOSL_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSH
  @registerExpression TOSHregister [new ![@lstring new !"TOSH" !here] ![@luint new !0 !here]] ;
  @ipic_registerExpression TOSH_IPICregisterDescription ;
  [TOSHregister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?TOSH_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSU
  @registerExpression TOSUregister [new ![@lstring new !"TOSU" !here] ![@luint new !0 !here]] ;
  @ipic_registerExpression TOSU_IPICregisterDescription ;
  [TOSUregister resolveAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    ?TOSU_IPICregisterDescription
    ?*
  ] ;
#--- computed_goto2 routine needed ?
  if [inPiccoloModel mNeedsComputedGoto4] then
    outGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !"_computed_goto_4" !here]] ;
    outGeneratedInstructionList += ![@ipic_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      !WREG_IPICregisterDescription
      !true
    ] ; # ADDWF WREG, W
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] then
    outGeneratedInstructionList += ![@ipic_pseudo_LABEL new ![@lstring new !"_computed_goto_2" !here]] ;
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] | [inPiccoloModel mNeedsComputedGoto4] then
    outGeneratedInstructionList += ![@ipic_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      !WREG_IPICregisterDescription
      !true
    ] ; # ADDWF WREG, W
    outGeneratedInstructionList += ![@ipic_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      !TOSL_IPICregisterDescription
      !false
    ] ; # ADDWFC TOSL, F
    outGeneratedInstructionList += ![@ipic_instruction_literalOperation new
      !here
      ![@literal_instruction_opcode MOVLW]
      !0
    ] ; # MOVLW 0
    outGeneratedInstructionList += ![@ipic_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      !TOSH_IPICregisterDescription
      !false
    ] ; # ADDWFC TOSH, F
    outGeneratedInstructionList += ![@ipic_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      !TOSU_IPICregisterDescription
      !false
    ] ; # ADDWFC TOSU, F
    outGeneratedInstructionList += ![@ipic_instruction_RETURN new
      !here
    ] ; # RETURN 0
  end if ;
#--- Output a listing ?
  if [option piccolo_options.ouputListingFile] then
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . ["IPIC INSTRUCTION LIST" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    if [generationOptimizationMessages length] > 0 then
      ioListFileContents .= "Optimizations during generation:\n" ;
      ioListFileContents .= generationOptimizationMessages ;
      ioListFileContents .= "\n" ;
    end if ;
    ioListFileContents .= "Generated intermediate code:\n" ;
    @uint index := 0 ;
    @uint currentAddress := 0 ;
    foreach outGeneratedInstructionList do
      [mInstruction setCurrentAddress !?currentAddress] ;
      ioListFileContents .= [[index string] stringByLeftPadding !5 !' '] . ": " ;
      [mInstruction displayIPICinstruction !? ioListFileContents] ;
      ioListFileContents .= "\n" ;
      index ++ ;
    end foreach ;
    ioListFileContents .= "\n" ;
    ioListFileContents .= "Minimum code size without optimization: " . [currentAddress string] . " bytes.\n\n" ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
