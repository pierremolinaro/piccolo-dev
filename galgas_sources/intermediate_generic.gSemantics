semantics intermediate_generic :
import "piccoloDevice_semantics.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#                 EXTERN ROUTINES FOR EMITING HEX CODE                       *
#                                                                            *
#----------------------------------------------------------------------------*

extern routine setEmitAddress ??@uint inAddress ;

extern routine currentEmitAddress !@uint outAddress ;

extern routine emitCode ??@uint inCode ;

extern routine emitByte ??@uint inCode ;

extern routine getGeneratedContents !@string outContents ;

extern routine get_C_ArrayImplementation ??@string inSourceName !@string outContents ;

extern routine get_C_ArrayHeader ??@string inSourceName !@string outContents ;

#----------------------------------------------------------------------------*

reader @uint x4String ->@string outResult :
  if selfcopy > 0xFFFF then
    outResult := "****" ;
  else
    outResult := [selfcopy >> 12 xString] ;
    outResult .= [(selfcopy >> 8) & 0xF xString] ;
    outResult .= [(selfcopy >> 4) & 0xF xString] ;
    outResult .= [selfcopy & 0xF xString] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

routine checkCurrentEmitAddress ??@uint inCurrentAddress :
  @uint addr ; currentEmitAddress ? addr ;
  if ([@uint errorCount] == 0) & (addr != inCurrentAddress) then
    error here:"internal error: current emit address is " . [addr hexString]
    . "; it should be " . [inCurrentAddress hexString] ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#                          CONSTANT MAP                                      *
#----------------------------------------------------------------------------*

map @constantMap {
  @sint64 mValue ;
  insert insertKey error message "the '%K' constant is already declared in %L" ;
  search searchKey error message "the '%K' constant is not declared" ;
}

#----------------------------------------------------------------------------*
#                          ROUTINE MAP                                       *
#----------------------------------------------------------------------------*

map @routineMap {
  @bool mIsNoReturn ;
  @uint mRequiredBank ;
  @uint mReturnedBank ;
  @bool mPreservesBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*

enum @routineKind {
  regularRoutine, noReturnRoutine, interruptRoutine
}

#----------------------------------------------------------------------------*
#                                                                            *
#                    IMMEDIAT EXPRESSION EVALUATION                          *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @immediatExpression eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
;

#----------------------------------------------------------------------------*

override method @immediatInteger eval
  ??@registerTable unused inRegisterTable
  ??@constantMap unused inConstantMap
  !@sint64 outResult
  ?!@stringset unused ioUsedRegisters
:
  outResult := [[mValue uint] sint64] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatRegister eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  if [inRegisterTable hasKey ![[mRegister mRegisterName] string]] then
    ioUsedRegisters += ![mRegister mRegisterName]->string ;
    [inRegisterTable searchKey ![mRegister mRegisterName] ??@uintlist registerAddressList ??@uint size ?* ?*] ;
    @uint registerAddress ; [registerAddressList first ?registerAddress] ;
    if [[mRegister mOffset] uint] >= size then
      error [mRegister mOffset]:"index (" . [[[mRegister mOffset] uint] string] . ") should be lower than size (" . [size string] . ")" ;
    end if ;
    outResult := [registerAddress + [[mRegister mOffset] uint] sint64] ;
  elsif [inConstantMap hasKey ![[mRegister mRegisterName] string]] then
    [inConstantMap searchKey ![mRegister mRegisterName] ?outResult] ;
    if [[mRegister mOffset] uint] > 0 then
      error [mRegister mOffset]:"index notation (" . [[[mRegister mOffset] uint] string] . ") cannot be used with a constant" ;
    end if ;
  else
    error [mRegister mRegisterName]: "'" . [mRegister mRegisterName] . "' should be declared as ram register or as constant" : outResult ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatAdd eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult + rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatSub eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult - rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatMul eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult * rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatDiv eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult / rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatMod eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult mod rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatAnd eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult & rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatOr eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult | rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatXor eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult ^ rightResult ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLeftShift eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult << [rightResult uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatRightShift eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  outResult := leftResult >> [rightResult uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatEqualTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult == rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatNotEqualTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult != rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatGreaterOrEqualTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult >= rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLowerOrEqualTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult <= rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatGreaterTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult > rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatLowerTest eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mLeftExpression eval !inRegisterTable !inConstantMap ??@sint64 leftResult !?ioUsedRegisters] ;
  [mRightExpression eval !inRegisterTable !inConstantMap ??@sint64 rightResult !?ioUsedRegisters] ;
  if leftResult < rightResult then
    outResult := 1LS ;
  else
    outResult := 0LS ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatNegate eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
  outResult := - result ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatComplement eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  [mExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
  outResult := ~ result ;
end method ;

#----------------------------------------------------------------------------*

override method @immediatSlice eval
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  !@sint64 outResult
  ?!@stringset ioUsedRegisters
:
  @bitSliceTable bitSliceTable ;
  outResult := 0LS ;
  ioUsedRegisters += !mRegisterName->string ;
  [inRegisterTable searchKey !mRegisterName ?* ?* ? bitSliceTable ?*] ;
  @stringset sliceNameSet [emptySet] ;
  foreach mSliceExpressionList do
    if [sliceNameSet hasKey ![mSliceName string]] then
      error mSliceName:"the '" . mSliceName . "' bit field has been already defined" ;
    else
      sliceNameSet += ![mSliceName string] ;
      @uint sliceIndex ;
      @uint sliceSize ;
      [bitSliceTable searchKey !mSliceName ?sliceIndex ?sliceSize] ;
      [mExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
      if (result < 0LS) | (result > ((1LS << sliceSize) - 1LS)) then
        error mSliceName:"invalid immediat value associated to the '" . mSliceName . "' bit field, evaluated as " . [result string]
        . " (should be between 0 and " . [(1 << sliceSize) - 1 string] . ")" ;
      end if ;
      outResult := outResult | (result << sliceIndex) ;
      end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#                        BIT NUMBER EXPRESSION                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @bitNumberExpression getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
:
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
:
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
end method ;

#----------------------------------------------------------------------------*

map @symbolTableForOptimizations {
  @uint mDefinitionLineIndex ;
  @bool mIsDeletable ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
  remove removeKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               P R I N T    C O N S T A N T    M A P                        *
#                                                                            *
#----------------------------------------------------------------------------*

routine print_constant_definition
  ??@constantMap inConstantMap
  ?!@string ioListFileContents
:
  if [inConstantMap count] > 0 then
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . ["CONSTANTS" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    ioListFileContents .= ["Constant" stringByLeftPadding !40 !' '] . " Value\n" ;
    foreach inConstantMap do
      ioListFileContents .= [[lkey string] stringByLeftPadding !40 !' '] . " " . [mValue string] . "\n" ;
    end foreach ;
    ioListFileContents .= "\n" ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
