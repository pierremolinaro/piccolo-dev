semantics ipc18_convert_relatives :
import semantics ipic18_metamodel in "ipic18_metamodel.gSemantics" ;
import "ipic18_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*

map @ipic18_symbolTableForConvertingRelatives {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#                          defineLabelAtAddress                              *
#                                                                            *
#----------------------------------------------------------------------------*

method @ipic18_instruction defineLabelAtAddress
  ?!@ipic18_symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_LABEL defineLabelAtAddress
  ?!@ipic18_symbolTableForConvertingRelatives ioRoutineSymbolTable
  ?!@uint ioAddress
:
  [!?ioRoutineSymbolTable insertKey !mLabel !ioAddress] ;
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_ORG defineLabelAtAddress
  ?!@ipic18_symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  if (ioAddress > mOrigin) then
    error here :"internal error: current address ("
     . [ioAddress hexString] . ") is greater than origin (" . [mOrigin hexString] . ")" ;
  end if ;
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_actualInstruction defineLabelAtAddress
  ?!@ipic18_symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint instructionLength ;
  [self instructionLength ?instructionLength] ;
  ioAddress := ioAddress  + instructionLength ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               R E L A T I V E    B R A N C H    C H E C K I N G            *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @ipic18_instruction checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@ipic18_instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
  ?!@string unused ioListFileContents
;

#----------------------------------------------------------------------------*

override method @ipic_NULL checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@ipic18_instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
  ?!@string unused ioListFileContents
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic_actualInstruction checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@ipic18_instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
  ?!@string unused ioListFileContents
:
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_ORG checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@ipic18_instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
  ?!@string unused ioListFileContents
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_conditionalBranch checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  switch mBranchMode
  when native :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 127S) | (displacement < - 128S) then
      error mInstructionLocation: "displacement (" . [displacement string] . ") too large for Bcc instruction (limited to [-128, 127])" ;
    end if ;
  when ipicNative :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 127S) | (displacement < - 128S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  native Bcc overflow, converted to Bcc with BRA\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_conditionalBranch new
        !mInstructionLocation
        ![@condionalBranchMode ipicBRA]
        !mConditionalBranch
        !mTargetLabel
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when ipicBRA :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  Bcc with BRA overflow, converted to Bcc with GOTO\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_conditionalBranch new
        !mInstructionLocation
        ![@condionalBranchMode ipicGOTO]
        !mConditionalBranch
        !mTargetLabel
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when ipicGOTO : # No overflow, do nothing
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_jump_test_register checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesBra then
    @uint BRAaddress := ioAddress + 2 ;
    if mBranchIfZero then
      BRAaddress := BRAaddress + 2 ;
    end if ;
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [BRAaddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  JUMP with BRA overflow, converted to JUMP with GOTO\n" ;
      @ipic_actualInstruction instruction := [@ipic_jump_test_register new
        !mInstructionLocation
        !mRegisterDescription
        !mTargetLabel
        !mBranchIfZero
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_registerComparisonCondition checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  @bool uses ; [self usesIntermediateBRA ?uses] ;
  if mUsesBra then
    @uint BRAaddress := ioAddress + 2 ;
    if uses then
      BRAaddress := BRAaddress + 2 ;
    end if ;
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [BRAaddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  JUMP with BRA overflow, converted to JUMP with GOTO\n" ;
      @ipic_actualInstruction instruction := [@ipic_registerComparisonCondition new
        !mInstructionLocation
        !mRegisterDescription
        !mTargetLabel
        !mComparison
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_incDecRegisterInCondition checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesBra then
    @uint BRAaddress := ioAddress + 2 ;
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [BRAaddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  JUMP with BRA overflow, converted to JUMP with GOTO\n" ;
      @ipic_actualInstruction instruction := [@ipic_incDecRegisterInCondition new
        !mInstructionLocation
        !mRegisterDescription
        !mTargetLabel
        !mIncrement
        !m_W_isDestination
        !mBranchIfZero
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_JUMP checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  switch mKind
  when ipicRelative :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  JUMP with BRA overflow, converted to JUMP with GOTO\n" ;
      @ipic_actualInstruction instruction := [@ipic_JUMP new
        !mInstructionLocation
        !mTargetLabel
        ![@jumpInstructionKind ipicAbsolute]
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when ipicAbsolute : # Ok
  when relative :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      error mInstructionLocation: "displacement (" . [displacement string] . ") too large for BRA instruction (limited to [-1024, 1023])" ;
    end if ;
  when absolute : # Ok
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_JSR checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  switch mKind
  when ipicRelative :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioListFileContents .= "  line " . [inIndex string] . ":  JSR with RCALL overflow, converted to JSR with CALL\n" ;
      ioRelativeBranchOverflow := true ;
      @ipic_actualInstruction instruction := [@ipic_JSR new
        !mInstructionLocation
        !mTargetLabel
        ![@jumpInstructionKind ipicAbsolute]
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when ipicAbsolute : # Ok
  when relative :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      error mInstructionLocation: "displacement (" . [displacement string] . ") too large for RCALL instruction (limited to [-1024, 1023])" ;
    end if ;
  when absolute : # Ok
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_pseudo_LABEL checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@ipic18_instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
  ?!@string unused ioListFileContents
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mLabel ?targetAddress] ;
  if (targetAddress != ioAddress) then
    error mLabel: "Internal second pass error: the '" . mLabel
    . "' label gets " . [ioAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_retlw checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesRCALL then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_2" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  COMPUTED RETLW with RCALL overflow, converted to COMPUTED RETLW with CALL\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_computed_retlw new
        !mInstructionLocation
        !mLiteralValues
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_bra checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesRCALL then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_2" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  COMPUTED BRA with RCALL overflow, converted to COMPUTED BRA with CALL\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_computed_bra new
        !mInstructionLocation
        !mTargetLabels
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
  @uint addressForCheckingBRA := ioAddress + 2 ;
  if not mUsesRCALL then
    addressForCheckingBRA := addressForCheckingBRA + 2 ; # GOTO takes 2 more bytes
  end if ;
  foreach mTargetLabels do
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [addressForCheckingBRA sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      error mValue: "displacement (" . [displacement string] . ") too large for BRA instruction (limited to [-1024, 1023])" ;
    end if ;
    addressForCheckingBRA := addressForCheckingBRA + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_goto checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesRCALL then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_4" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  COMPUTED GOTO with RCALL overflow, converted to COMPUTED GOTO with CALL\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_computed_goto new
        !mInstructionLocation
        !mTargetLabels
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
#  foreach mTargetLabels do
#    [inRoutineSymbolTable searchKey !mValue ?*] ;
#  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_rcall checkRelativeBranch
  ??@ipic18_symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ??@uint inIndex
  ?!@string ioListFileContents
:
  if mUsesRCALL then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_4" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
      ioListFileContents .= "  line " . [inIndex string] . ":  COMPUTED RCALL with RCALL overflow, converted to COMPUTED RCALL with CALL\n" ;
      @ipic_actualInstruction instruction := [@ipic18_instruction_computed_rcall new
        !mInstructionLocation
        !mTargetLabels
        !mEndOfInstructionLabel
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
#  foreach mTargetLabels do
#    [inRoutineSymbolTable searchKey !mValue ?*] ;
#  end foreach ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine ipic18_convertRelativeBranchsToAbsoluteWhenNeeded
  ?!@ipic18_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["CONVERT RELATIVES" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
  @bool relativeBranchOverflow := true ;
  @uint iteration := 0 ;
  loop [ioGeneratedInstructionList length] :
  while relativeBranchOverflow
  do
    relativeBranchOverflow := false ;
    iteration ++ ;
    ioListFileContents .= "Pass " . [iteration string] . ":\n" ;
  #-------------------------------- First pass: build label map
    @ipic18_symbolTableForConvertingRelatives symbolTable [emptyMap] ;
    @uint currentAddress := 0 ;
    foreach ioGeneratedInstructionList do
      [mInstruction defineLabelAtAddress !?symbolTable !?currentAddress] ;
    end foreach ;
    @uint lastAddressForFirstPass := currentAddress ;
  #-------------------------------- Second pass: generate code
    currentAddress := 0 ;
    foreach ioGeneratedInstructionList index idx do
      @uint instructionLength ;
      [mInstruction instructionLength ?instructionLength] ;
      [mInstruction checkRelativeBranch !symbolTable !?currentAddress !?relativeBranchOverflow !?ioGeneratedInstructionList !idx !?ioListFileContents] ;
      currentAddress := currentAddress  + instructionLength ;
    end foreach ;
    if lastAddressForFirstPass != currentAddress then
      error here: "Internal second pass error: the last address gets " . [currentAddress hexString]
      . " value when checking relative branches, while it gets "
      . [lastAddressForFirstPass hexString] . " value when computing routine map" ;
    end if ;
    if not relativeBranchOverflow then
      ioListFileContents .= "  No relative to convert\n\n" ;
      ioListFileContents .= "Program size: " . [currentAddress string] . " bytes\n\n" ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
