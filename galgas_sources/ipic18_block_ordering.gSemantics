semantics ipic18_block_ordering :
import "ipic18_block_representation.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;
import "ipic18_display_block_list.gSemantics" ;
import "ipic18_cluster_ordering.gSemantics" ;
import "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*

#!--- Block invocation graph

#----------------------------------------------------------------------------*

graph @blockInvocationGraph (@stringlist) {
  insert addNode error message "the '%K' label is already declared at %L" ;
}

#----------------------------------------------------------------------------*

#!--- buildInstructionInvocationGraph

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction buildInstructionInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR buildInstructionInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mTargetLabel . "\" [color=red] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall buildInstructionInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"_computed_goto_4\" [color=red] ;\n" ;
  foreach mTargetInstructions do
    [mInstruction buildInstructionInvocationGraph
      !inBlockLabel
      !?ioGraphVizString
    ] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction buildInstructionInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
:
  [mEmbeddedInstruction buildInstructionInvocationGraph
    !inBlockLabel
    !?ioGraphVizString
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- buildTerminatorInvocationGraph

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator buildTerminatorInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator buildTerminatorInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator buildTerminatorInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"_computed_goto_4\" [color=red] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"_computed_goto_2\" [color=red] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"_computed_goto_2\" [color=red] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mSingleInstructionTerminatorIfConditionFalse buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mSingleInstructionTerminatorIfConditionFalse buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mSingleInstructionTerminatorIfConditionFalse buildTerminatorInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mLabel . "\"" ;
  if inDottedArrow then
    ioGraphVizString .= " [style=dashed]" ;
  end if ;
  ioGraphVizString .= " ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator buildTerminatorInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mTargetLabelWhenTrue . "\"" ;
  if inDottedArrow then
    ioGraphVizString .= " [style=dashed]" ;
  end if ;
  ioGraphVizString .= " ;\n" ;
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mTargetLabelWhenFalse . "\"" ;
  if inDottedArrow then
    ioGraphVizString .= " [style=dashed]" ;
  end if ;
  ioGraphVizString .= " ;\n" ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator noNeedToInsertJumpInstruction

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
;

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult := mLabel->string != inNextBlockLabel ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18AbstractConditionTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mSingleInstructionTerminatorIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
    &
    [mSingleInstructionTerminatorIfConditionFalse needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mSingleInstructionTerminatorIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mSingleInstructionTerminatorIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

#!--- buildTerminatorInvocationGraph

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator buildTerminatorOrderedGraph
  ??@lstring unused inBlockLabel
  ?!@blockInvocationGraph unused ioGraph
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [!?ioGraph addEdge !inBlockLabel !mLabel] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [!?ioGraph addEdge !inBlockLabel !mTargetLabelWhenTrue] ;
  [!?ioGraph addEdge !inBlockLabel !mTargetLabelWhenFalse] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator buildTerminatorOrderedGraph
  ??@lstring inBlockLabel
  ?!@blockInvocationGraph ioGraph
:
  [mSingleInstructionTerminatorIfConditionTrue buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse buildTerminatorOrderedGraph
    !inBlockLabel
    !?ioGraph
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Routines

#----------------------------------------------------------------------------*

routine buildOrderedGraph
  ?!@ipic18BlockList ioBlockList
  ??@string inSourceFileName
  ?!@string ioListFileContents
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["BLOCK ORDERING OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
  ioListFileContents .= "Block ordering optimization:\n" ;
  const @uint n := blockDiscontinuityCount [!ioBlockList] ;
  ioListFileContents .= "  count before optimization: " . n . "\n" ;
#---
  if [option.verbose_output value] then
    message "Block ordering optimization... " ;
  end if ;
#-------------------------------- Build label map
  @symbolTableForBlockOptimization symbolTable [emptyMap] ;
  foreach ioBlockList index blockIndex do
    [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
  end foreach ;
#---
  @blockInvocationGraph g [emptyGraph] ;
  foreach ioBlockList do
    if mBlock->mAddress == [@uint max] then # Only relocatable block
      [!?g addNode !mBlock->mLabel !mBlock->mLabel->string] ;
      [mBlock->mTerminator buildTerminatorOrderedGraph !mBlock->mLabel !?g] ;
    end if ;
  end foreach ;
#----
  [g nodesWithNoPredecessor ?* ??@lstringlist nodeList] ;
  @stringlist newOrderedLabelList [emptyList] ;
  @stringset visitedNodeSet [emptySet] ;
  @clusterList clusterList [emptyList] ;
  foreach nodeList do
    @blockInvocationGraph gg := [g subgraphFromNodes
      ![@lstringlist listWithValue !mValue]
      !visitedNodeSet
    ] ;
    foreach [gg keyList] do
      visitedNodeSet += ! mValue ;
    end foreach ;    
    [!?gg removeEdgesToDominators] ;
    [[gg reversedGraph] depthFirstTopologicalSort
      ??@stringlist partialOrderedLabelList
      ?3*
    ] ;
    newOrderedLabelList .= partialOrderedLabelList ;
    @ipic18BlockList cluster [emptyList] ;
    foreach partialOrderedLabelList do
      [symbolTable searchKey ![mValue nowhere] ??@uint blockIndex] ;
      const @ipic18Block b := [ioBlockList mBlockAtIndex !blockIndex] ;
      cluster += !b ;
    end foreach ;
    clusterList += !cluster ;
  end foreach ;
#----------------------- Add nodes that are involved in a circular dependance
  foreach ioBlockList do
    if (mBlock->mAddress == [@uint max]) # Only relocatable block
     & not [visitedNodeSet hasKey !mBlock->mLabel->string] then
      @blockInvocationGraph gg := [g subgraphFromNodes
        ![@lstringlist listWithValue !mBlock->mLabel]
        !visitedNodeSet
      ] ;
      foreach [gg keyList] do
        visitedNodeSet += ! mValue ;
      end foreach ;
      [!?gg removeEdgesToNode !mBlock->mLabel->string] ;
      [!?gg removeEdgesToDominators] ;
      [[gg reversedGraph] depthFirstTopologicalSort
        ??@stringlist partialOrderedLabelList
        ?3*
      ] ;
      newOrderedLabelList .= partialOrderedLabelList ;
      @ipic18BlockList cluster [emptyList] ;
      foreach partialOrderedLabelList do
        [symbolTable searchKey ![mValue nowhere] ??@uint blockIndex] ;
        const @ipic18Block b := [ioBlockList mBlockAtIndex !blockIndex] ;
        cluster += !b ;
      end foreach ;
      clusterList += !cluster ;
    end if ;
  end foreach ;
#----------------------- Build sorted block list
  @ipic18BlockList orderedBlockList [emptyList] ;
#--- First insert absolute blocks from 0
  @bool continue := true ;
  foreach ioBlockList while continue do
    continue := mBlock->mAddress != [@uint max] ;
    if continue then
      orderedBlockList += !mBlock ;
    end if ;
  end foreach ; 
#--- Insert sorted blocks 
  foreach newOrderedLabelList do
    [symbolTable searchKey ![mValue nowhere] ??@uint blockIndex] ;
    const @ipic18Block b := [ioBlockList mBlockAtIndex !blockIndex] ;
    orderedBlockList += !b ;
  end foreach ;
#--- First insert absolute blocks from the end
  const @uint insertionIndex := [orderedBlockList length] ;
  continue := true ;
  foreach > ioBlockList while continue do
    continue := mBlock->mAddress != [@uint max] ;
    if continue then
      [!?orderedBlockList insertAtIndex !mBlock !insertionIndex] ;
    end if ;
  end foreach ; 
#------------------------ Messaging
  const @uint p := blockDiscontinuityCount [!orderedBlockList] ;
  ioListFileContents .= "  count after optimization: " . p . "\n\n" ;
  if [option.verbose_output value] then
    message [n string] . " -> " . p . ".\n\n" ;
  end if ;
#--- Write Graphviz file
  if [option piccolo_options.generateGraphvizFiles value] then
    [[g graphviz] writeToFileWhenDifferentContents !inSourceFileName. ".blockOrderingConstraints.dot" ?*] ;
  end if ;
#--- Check block definition
  @stringset newSymbolSet [emptySet] ;
  @bool ok := true ;
  foreach orderedBlockList do
    if [newSymbolSet hasKey !mBlock->mLabel->string] then
      const @string s := "BLOCK REORDERING INTERNAL ERROR: block \""
      . mBlock->mLabel . "\" is duplicated"
      ;
      warning [@location nowhere]: s ;
      ioListFileContents .= s . ".\n\n" ;
      ok := false ;
    else
      newSymbolSet += !mBlock->mLabel->string ;
    end if ;
  end foreach ;
  foreach symbolTable do
    if not [newSymbolSet hasKey !lkey->string] then
      const @string s := "BLOCK REORDERING INTERNAL ERROR: block \""
      . lkey . "\" is missing"
      ;
      warning [@location nowhere]: s ;
      ioListFileContents .= s . ".\n\n" ;
      ok := false ;
    end if ;
  end foreach ;
#--- Perform list remplacement if no detected error
  if ok then
    ioBlockList := orderedBlockList ;
    displayBlockList !"ORDERED OPTIMIZED INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !orderedBlockList ;
  else
    const @string s := "BLOCK REORDERING INTERNAL ERROR: reordered block list is inconsistent, it is not used anymore" ;
    warning [@location nowhere]: s ;
    ioListFileContents .= s . ".\n\n" ;
    displayBlockList !"INCONSISTENT ORDERED OPTIMIZED INTERMEDIATE BLOCK REPRESENTATION (not used)" !?ioListFileContents !orderedBlockList ;
  end if ;
#--- if ok, perform cluster ordering
  if ok then
    perform_cluster_ordering
      !clusterList
      !?ioBlockList
      !?ioListFileContents
    ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

routine buildInvocationGraph
  ??@ipic18BlockList inBlockList
  !@string outGraphVizString
:
  outGraphVizString := "digraph G {\n" ;
  outGraphVizString .= "  node [fontname=courier]\n" ;
  foreach inBlockList do
    if mBlock->mAddress != [@uint max] then # Absolute bloc
      outGraphVizString .= "  \"" . mBlock->mLabel . "\" [shape=rectangle]\n" ;
    end if ;
    foreach mBlock->mInstructionList do
      [mInstruction buildInstructionInvocationGraph !mBlock->mLabel !?outGraphVizString] ;
    end foreach ;
    [mBlock->mTerminator buildTerminatorInvocationGraph !mBlock->mLabel !?outGraphVizString !false] ;
  end foreach ;
  outGraphVizString .= "}\n" ;
end routine ;

#----------------------------------------------------------------------------*

function blockDiscontinuityCount
  ?@ipic18BlockList inBlockList
  ->@uint outResult
:
  outResult := 0 ;
  foreach inBlockList index blockIndex do
    if mBlock->mAddress == [@uint max] then # Only relocatable block
      @string nextBlockLabel ;
      if (blockIndex+1) < [inBlockList length] then
        nextBlockLabel := [inBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
      else
        nextBlockLabel := "" ;
      end if ;
      if [mBlock->mTerminator needToInsertJumpInstruction !nextBlockLabel] then
        outResult ++ ;
      end if ;
    end if ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

routine ipic18OptimizeBlockOrdering
  ??@string inSourceFileName
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
  if [option piccolo_options.generateGraphvizFiles value] then
    buildInvocationGraph !ioGeneratedBlockList ??@string invocationGraph ;
    [invocationGraph writeToFileWhenDifferentContents !inSourceFileName. ".blockInvocation.dot" ?*] ;
  end if ;
#---
  const @bool optimize := [option piccolo_options.performOptimizations value]
    | [[option piccolo_options.optimizationFlags value] containsCharacter !'B'] ;
  if optimize then
    buildOrderedGraph !?ioGeneratedBlockList !inSourceFileName !?ioListFileContents ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
