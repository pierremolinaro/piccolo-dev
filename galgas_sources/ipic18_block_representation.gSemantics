semantics ipic18_block_representation :
import "pic18_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*

map @pic18_dataMap {
  @uintlist mData ;
  insert insertKey error message "the '%K' data is already declared" ;
  search searchKey error message "the '%K' data is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @ipic18SequentialInstruction {
  @location mInstructionLocation ;
}

#----------------------------------------------------------------------------*

list @ipic18SequentialInstructionList {
  @ipic18SequentialInstruction mInstruction ;
}

#----------------------------------------------------------------------------*

abstract class @ipic18AbstractBlockTerminator {
  @location mInstructionLocation ;
}

#----------------------------------------------------------------------------*

struct @ipic18Block {
  @uint mStartAddress ; # [@uint max] if relocatable
  @lstring mLabel ;
  @ipic18SequentialInstructionList mInstructionList ;
  @ipic18AbstractBlockTerminator mTerminator ;
}

#----------------------------------------------------------------------------*

list @ipic18BlockList {
  @ipic18Block mBlock ;
}

#----------------------------------------------------------------------------*

#!--- Block terminators

#----------------------------------------------------------------------------*

abstract class @ipic18SingleInstructionTerminator extends @ipic18AbstractBlockTerminator {
}

#----------------------------------------------------------------------------*

class @ipic18ReturnTerminator extends @ipic18SingleInstructionTerminator {
}

#----------------------------------------------------------------------------*

class @ipic18RetlwTerminator extends @ipic18SingleInstructionTerminator {
  @uint mLiteralValue ;
}

#----------------------------------------------------------------------------*

class @ipic18RetfieTerminator extends @ipic18SingleInstructionTerminator {
  @bool mFastReturn ;
}

#----------------------------------------------------------------------------*

class @ipic18JumpTerminator extends @ipic18SingleInstructionTerminator {
  @lstring mLabel ;
  @jumpInstructionKind mKind ;
}

#----------------------------------------------------------------------------*

class @ipic18ComputedGotoTerminator extends @ipic18AbstractBlockTerminator {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;
}

#----------------------------------------------------------------------------*

class @ipic18ComputedRETLWTerminator extends @ipic18AbstractBlockTerminator {
  @uintlist mLiteralValues ;
  @bool mUsesRCALL ;
}

#----------------------------------------------------------------------------*

enum @conditionalBranchMode {
  native, # Use Bcc instruction only
  ipicBRA, # Use BRA if possible (Bcc + BRA)
  ipicGOTO # use GOTO (Bcc + GOTO)
}{
}

#----------------------------------------------------------------------------*

class @ipic18ConditionalJumpTerminator extends @ipic18AbstractBlockTerminator {
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabelWhenTrue ;
  @conditionalBranchMode mBranchModeOnTrueLabel ;
  @lstring mTargetLabelWhenFalse ;
  @conditionalBranchMode mBranchModeOnFalseLabel ;
}

#----------------------------------------------------------------------------*

class @ipic18ComputedBraTerminator extends @ipic18AbstractBlockTerminator {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;
}

#----------------------------------------------------*

enum @ipic18RegisterComparison {
  registerEqualsToW,
  registerGreaterThanW,
  registerLowerThanW
}{
}

#----------------------------------------------------------------------------*

abstract class @ipic18AbstractConditionTerminator extends @ipic18AbstractBlockTerminator {
  @ipic18SingleInstructionTerminator mInstructionIfConditionTrue ;
  @ipic18SingleInstructionTerminator mInstructionIfConditionFalse ;
}

#----------------------------------------------------------------------------*

class @pic18RegisterComparisonTerminator extends @ipic18AbstractConditionTerminator {
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @ipic18RegisterComparison mComparison ;
}

#----------------------------------------------------------------------------*

class @ipic18IncDecRegisterTerminator extends @ipic18AbstractConditionTerminator {
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @bool mIncrement ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------------------------------*

class @pic18TestRegisterTerminator extends @ipic18AbstractConditionTerminator {
  @ipic18_intermediate_registerExpression mRegisterDescription ;
}

#----------------------------------------------------------------------------*

class @pic18BitTestTerminator extends @ipic18AbstractConditionTerminator {
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
}

#----------------------------------------------------------------------------*

#!--- Regular instructions

#----------------------------------------------------------------------------*

class @ipic18InstructionWithNoOperand extends @ipic18SequentialInstruction {
  @pic18InstructionWithNoOperandKind mKind ;
}

#----------------------------------------------------------------------------*

struct @ipic18_intermediate_registerExpression {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
  @bool mNeedsBSR ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_FDA extends @ipic18SequentialInstruction {
  @instruction_FDA_base_code_AST mInstruction_FDA_base_code ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------*

enum @FA_sequential_instruction_base_code {
  CLRF, MOVWF, MULWF, NEGF, SETF
}{
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_FA extends @ipic18SequentialInstruction {
  @FA_sequential_instruction_base_code mFAinstruction ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
}

#----------------------------------------------------------------------------*

struct @ipic18_intermediate_registerExpressionWithoutBSRIndication {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_MOVFF extends @ipic18SequentialInstruction {
  @ipic18_intermediate_registerExpressionWithoutBSRIndication mSourceRegisterDescription ;
  @ipic18_intermediate_registerExpressionWithoutBSRIndication mDestinationRegisterDescription ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_literalOperation extends @ipic18SequentialInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @uint mLiteralValue ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_LFSR extends @ipic18SequentialInstruction {
  @luint mFSRindex ;
  @uint mValue ;
}  

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_FBA extends @ipic18SequentialInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_JSR extends @ipic18SequentialInstruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_MOVLB extends @ipic18SequentialInstruction {
  @luint mBankIndex ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_BLANK extends @ipic18SequentialInstruction {
  @uint mBlankValue ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_TBLRD extends @ipic18SequentialInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_TBLWT extends @ipic18SequentialInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_MNOP extends @ipic18SequentialInstruction {
  @luint mOccurrenceFactor ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_MOV_LABEL_W extends @ipic18SequentialInstruction {
  @lstring mLabel ;
  @uint mOffset ;
  @uint mRightShift ;
}

#----------------------------------------------------------------------------*

class @ipic18_intermediate_instruction_computed_rcall extends @ipic18SequentialInstruction {
  @ipic18SequentialInstructionList mTargetInstructions ;
  @bool mUsesRCALL ;
}

#----------------------------------------------------------------------------*

abstract class @ipic18_condition_skip_instruction extends @ipic18SequentialInstruction {
  @ipic18SequentialInstruction mEmbeddedInstruction ;
}

#----------------------------------------------------------------------------*

class @ipic18_skip_instruction_BitTestSkip extends @ipic18_condition_skip_instruction {
  @bool mSkipIfSet ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
}

#----------------------------------------------------*

enum @ipic18_compare_register_instruction_base_code {
  CPFSEQ, CPFSGT, CPFSLT, TSTFSZ
}{
}

#----------------------------------------------------------------------------*

class @ipic18_skip_instruction_compare_register extends @ipic18_condition_skip_instruction {
  @ipic18_compare_register_instruction_base_code mCompareInstruction ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
}

#----------------------------------------------------*

enum @skip_instruction_FDA_base_code {
  DECFSZ, DCFSNZ, INCFSZ, INFSNZ
}{
}

#----------------------------------------------------------------------------*

class @ipic18_skip_instruction_FDA extends @ipic18_condition_skip_instruction {
  @skip_instruction_FDA_base_code mInstruction_FDA_base_code ;
  @ipic18_intermediate_registerExpression mRegisterDescription ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------------------------------*

#!--- Optimization

#----------------------------------------------------------------------------*

map @symbolTableForBlockOptimization {
  @uint mDefinitionBlockIndex ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*

#!--- Cluster ordering optimization

#----------------------------------------------------------------------------*

map @symbolTableForClusterOrdering {
  @uint mCluster ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*

listmap @branchOverflowMap (@stringlist) ;

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction instructionRelativeBranchOverflow
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ?!@branchOverflowMap unused ioOverflowMap
:
end method ;

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator terminatorRelativeBranchOverflow
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap unused ioOverflowMap
:
end method ;

#----------------------------------------------------------------------------*

#!--- @symbolTableForRelativesResolution

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator performTerminatorRelativeBranchResolution
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint unused ioConversionCount
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

map @symbolTableForRelativesResolution {
  @uint mLabelAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*

list @codeList {
  @string mAssemblyCode ;
  @uintlist mBinaryCode ;
}
  
#----------------------------------------------------------------------------*

map @pic18_dataAddressMap {
  @uint mDataAddress ;
  insert insertKey error message "the '%K' data is already declared" ;
  search searchKey error message "the '%K' data is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @ipic18SequentialInstruction generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap inDataMap
  !@codeList outCode
;

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:  outCode := [@codeList emptyList] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Check displacement

#----------------------------------------------------------------------------*

function pic18_checkBCC
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@lstring inTargetLabel
  ??@uint inCurrentAddress
  ->@bool outDisplacementOK
:
  [inSymbolTable searchKey !inTargetLabel ??@uint targetAddress] ;
  const @sint displacement := ([targetAddress sint] - 2S - [inCurrentAddress sint]) >> 1 ;
  outDisplacementOK :=  (displacement <= 127S) & (displacement >= - 128S) ;
end function ;

#----------------------------------------------------------------------------*

function pic18_checkBRA_RCALL
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@lstring inTargetLabel
  ??@uint inCurrentAddress
  ->@bool outDisplacementOK
:
  [inSymbolTable searchKey !inTargetLabel ??@uint targetAddress] ;
  const @sint displacement := ([targetAddress sint] - 2S - [inCurrentAddress sint]) >> 1 ;
  outDisplacementOK :=  (displacement <= 1023S) & (displacement >= - 1024S) ;
end function ;

#----------------------------------------------------------------------------*

function pic18_BRA_RCALL_displacement
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@lstring inTargetLabel
  ??@uint inCurrentAddress
  ->@sint outDisplacement
:
  [inSymbolTable searchKey !inTargetLabel ??@uint targetAddress] ;
  outDisplacement := ([targetAddress sint] - 2S - [inCurrentAddress sint]) >> 1 ;
end function ;

#----------------------------------------------------------------------------*

#!--- Generate branch instructions

#----------------------------------------------------------------------------*

function pic18_Bcc_instruction_code
  ??@uint inConditionalBranchInstructionAddress
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ??@conditional_branch inConditionalBranch
  ??@bool inComplemented
  ->@codeList outCode
:  
  const @sint displacement := ([inTargetAddress sint] - 2S - [inConditionalBranchInstructionAddress sint]) >> 1 ;
  if (displacement > 127S) | (displacement < - 128S) then
    error inTargetLabel: "** INTERNAL ERROR ** displacement too large for conditional branch instruction" ;
  end if ;

  @conditional_branch conditionalBranch ;
  if inComplemented then
    switch inConditionalBranch
    when bz   : conditionalBranch := [@conditional_branch bnz] ;
    when bnz  : conditionalBranch := [@conditional_branch bz] ;
    when bn   : conditionalBranch := [@conditional_branch bnn] ;
    when bnn  : conditionalBranch := [@conditional_branch bn] ;
    when bc   : conditionalBranch := [@conditional_branch bnc] ;
    when bnc  : conditionalBranch := [@conditional_branch bc] ;
    when bov  : conditionalBranch := [@conditional_branch bnov] ;
    when bnov : conditionalBranch := [@conditional_branch bov] ;
  end switch ;
  else
    conditionalBranch := inConditionalBranch ;
  end if ;
  
  @uint baseCode ;
  @string mnemonic ;
  switch conditionalBranch
  when bz   : baseCode := 0xE000 ; mnemonic := "BZ" ;
  when bnz  : baseCode := 0xE100 ; mnemonic := "BNZ" ;
  when bn   : baseCode := 0xE600 ; mnemonic := "BN" ;
  when bnn  : baseCode := 0xE700 ; mnemonic := "BNN" ;
  when bc   : baseCode := 0xE200 ; mnemonic := "BC" ;
  when bnc  : baseCode := 0xE300 ; mnemonic := "BNC" ;
  when bov  : baseCode := 0xE400 ; mnemonic := "BOV" ;
  when bnov : baseCode := 0xE500 ; mnemonic := "BNOV" ;
  end switch ;
  outCode := [@codeList listWithValue
    !"    " . mnemonic . " " . inTargetLabel
    ![@uintlist listWithValue !baseCode | [displacement & 0x0FFS uint]]
  ] ;
end function ;

#----------------------------------------------------------------------------*

function pic18_RCALL_instruction_code
  ??@uint inRCALLinstructionAddress
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ->@codeList outCode
:
  const @sint displacement := ([inTargetAddress sint] - 2S - [inRCALLinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inTargetLabel: "** INTERNAL ERROR ** displacement too large (". [displacement  string]
    . ") for RCALL instruction to '" . inTargetLabel . "' (should be between -1024 and 1023)" ;
  end if ;
  outCode := [@codeList listWithValue
    !"    RCALL " . inTargetLabel
    ![@uintlist listWithValue !0xD800 | [displacement & 0x07FFS uint]]
  ] ;
end function ;

#----------------------------------------------------------------------------*

function pic18_BRA_instruction_code
  ??@uint inRCALLinstructionAddress
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ->@codeList outCode
:
  const @sint displacement := ([inTargetAddress sint] - 2S - [inRCALLinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inTargetLabel: "** INTERNAL ERROR ** displacement too large (". [displacement  string]
    . ") for BRA instruction to '" . inTargetLabel . "' (should be between -1024 and 1023)" ;
  end if ;
  outCode := [@codeList listWithValue
    !"    BRA " . inTargetLabel
    ![@uintlist listWithValue !0xD000 | [displacement & 0x07FFS uint]]
  ] ;
end function ;

#----------------------------------------------------------------------------*

function pic18_CALL_instruction_code
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ->@codeList outCode
:
  @uintlist binaryCode [emptyList] ;
  binaryCode += !0xEC00 | ((inTargetAddress >> 1) & 255) ;
  binaryCode += !0xF000 | (inTargetAddress >> 9) ;
  outCode := [@codeList listWithValue
    !"    CALL " . inTargetLabel
    !binaryCode
  ] ;
end function ;

#----------------------------------------------------------------------------*

function pic18_GOTO_instruction_code
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ->@codeList outCode
:
  @uintlist binaryCode [emptyList] ;
  binaryCode += !0xEF00 | ((inTargetAddress >> 1) & 255) ;
  binaryCode += !0xF000 | (inTargetAddress >> 9) ;
  outCode := [@codeList listWithValue
    !"    GOTO " . inTargetLabel
    !binaryCode
  ] ;
end function ;

#----------------------------------------------------------------------------*

function pic18_definition_label
  ??@lstring inTargetLabel
  ->@codeList outCode
:
  outCode := [@codeList listWithValue
    !inTargetLabel->string . ":"
    ![@uintlist emptyList]
  ] ;
end function ;

#----------------------------------------------------------------------------*

end semantics ;

