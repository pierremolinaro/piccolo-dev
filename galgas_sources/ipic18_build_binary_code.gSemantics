semantics ipic18_build_binary_code :
import "ipic18_metamodel.gSemantics" ;
import "ipic18_build_assembly_code.gSemantics" ;

#----------------------------------------------------------------------------*

map @ipic18_symbolTable {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#                          enterLabelAtAddress                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @ipic18_instruction enterLabelAtAddress
  ?!@ipic18_symbolTable unused ioRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_LABEL enterLabelAtAddress
  ?!@ipic18_symbolTable ioRoutineSymbolTable
  ?!@uint ioAddress
:
  [!?ioRoutineSymbolTable insertKey !mLabel !ioAddress] ;
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_ORG enterLabelAtAddress
  ?!@ipic18_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_actualInstruction enterLabelAtAddress
  ?!@ipic18_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint instructionLength ;
  [selfcopy instructionLength ?instructionLength] ;
  ioAddress := ioAddress  + instructionLength ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

list @emittedCodeList {
  @uintlist mCode ;
}

#----------------------------------------------------------------------------*

abstract method @ipic18_instruction generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
;

#----------------------------------------------------------------------------*

override method @ipic_NULL generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList unused ioCode
:
end method ;

#----------------------------------------------------------------------------*

override
method @ipic_pseudo_ORG generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList unused ioCode
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_FDA generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
#--- Emit Code
  @uint code ; [selfcopy getBaseCode ? code] ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_FA generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
#--- Emit Code
  @uint code ; [selfcopy getBaseCode ? code] ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_MOVFF generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  @uintlist code [emptyList] ;
  code += !0xC000 | [mSourceRegisterDescription mRegisterAddress] ;
  code += !0xF000 | [mDestinationRegisterDescription mRegisterAddress] ;
  ioCode += !code ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_FBA generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
#--- Emit Code
  @uint code ; [selfcopy getBaseCode ? code] ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  code := code | (mBitNumber << 9) ;
  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_BitTestSkip generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
#--- Emit Code
  @uint code ; [selfcopy getBaseCode ? code] ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  code := code | (mBitNumber << 9) ;
  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------*

routine getBccBaseCode ??@conditional_branch inConditionalBranch !@uint outBaseCode :
  switch inConditionalBranch
  when bz   : outBaseCode := 0xE000 ;
  when bnz  : outBaseCode := 0xE100 ;
  when bn   : outBaseCode := 0xE600 ;
  when bnn  : outBaseCode := 0xE700 ;
  when bc   : outBaseCode := 0xE200 ;
  when bnc  : outBaseCode := 0xE300 ;
  when bov  : outBaseCode := 0xE400 ;
  when bnov : outBaseCode := 0xE500 ;
  end switch ;
end routine ;

#----------------------------------------------------------------------------*

routine emitConditionalBranchInstruction
  ??@uint inConditionalBranchInstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
  ??@conditional_branch inConditionalBranch
  ?!@emittedCodeList ioCode
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inConditionalBranchInstructionAddress sint]) >> 1 ;
  if (displacement > 127S) | (displacement < - 128S) then
    error inErrorLocation: "displacement too large for conditional branch instruction" ;
  end if ;
#  log displacement ;
  @uint baseCode ;
  getBccBaseCode !inConditionalBranch ?baseCode ;
  ioCode += ![@uintlist listWithValue !baseCode | [displacement & 0x0FFS uint]] ;
end routine ;

#----------------------------------------------------------------------------*

routine emitBRAinstruction
  ??@uint inBRAinstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
  ?!@emittedCodeList ioCode
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inBRAinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inErrorLocation: "displacement too large for BRA instruction" ;
  end if ;
#  log displacement ;
  ioCode += ![@uintlist listWithValue !0xD000 | [displacement & 0x07FFS uint]] ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_pic18_GOTOinstruction
  ??@uint inTargetAddress
  ?!@emittedCodeList ioCode
:
  @uintlist code [emptyList] ;
  code += !0xEF00 | ((inTargetAddress >> 1) & 255) ;
  code += !0xF000 | (inTargetAddress >> 9) ;
  ioCode += !code ;
end routine ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_conditionalBranch generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#--- Emit Code
  switch mBranchMode
  when native, ipicNative :
    emitConditionalBranchInstruction
      !ioAddress
      !targetAddress
      ![mTargetLabel location]
      !mConditionalBranch
      !?ioCode
    ;
  when ipicBRA :
    @conditional_branch complementary ;
    getComplementaryBcc !mConditionalBranch ?complementary ;
    emitConditionalBranchInstruction
      !ioAddress
      !ioAddress + 4
      ![mTargetLabel location]
      !complementary
      !?ioCode
    ;
    emitBRAinstruction
      !ioAddress + 2
      !targetAddress
      ![mTargetLabel location]
      !?ioCode
    ;
  when ipicGOTO :
    @conditional_branch complementary ;
    getComplementaryBcc !mConditionalBranch ?complementary ;
    emitConditionalBranchInstruction
      !ioAddress
      !ioAddress + 6
      ![mTargetLabel location]
      !complementary
      !?ioCode
    ;
    emit_pic18_GOTOinstruction
      !targetAddress
      !?ioCode
    ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_JUMP generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
  switch mKind
  when ipicRelative, relative :
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 0x800S) | (displacement < - 0x800S) then
      error mTargetLabel: "displacement too large for RCALL instruction" ;
    end if ;
    emitBRAinstruction
      !ioAddress
      !targetAddress
      ![mTargetLabel location]
      !?ioCode
    ;
  when ipicAbsolute, absolute :
    emit_pic18_GOTOinstruction
      !targetAddress
      !?ioCode
    ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

routine emit_pic18_CALLinstruction
  ??@uint inTargetAddress
  ?!@emittedCodeList ioCode
:
  @uintlist code [emptyList] ;
  code += !0xEC00 | ((inTargetAddress >> 1) & 255) ;
  code += !0xF000 | (inTargetAddress >> 9) ;
  ioCode += !code ;
end routine ;

#----------------------------------------------------------------------------*

routine emitRCALLinstruction
  ??@uint inRCALLinstructionAddress
  ??@uint inTargetAddress
  ??@lstring inTargetLabel
  ?!@emittedCodeList ioCode
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inRCALLinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inTargetLabel: "displacement too large (". [displacement  string]
    . ") for RCALL instruction to '" . inTargetLabel . "' (should be between -1024 and 1023)" ;
  end if ;
#  log displacement ;
  ioCode += ![@uintlist listWithValue !0xD800 | [displacement & 0x07FFS uint]] ;
end routine ;

#----------------------------------------------------------------------------*

override method @ipic_JSR generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
  switch mKind
  when ipicRelative, relative :
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 0x800S) | (displacement < - 0x800S) then
      error mTargetLabel: "displacement too large for RCALL instruction" ;
    end if ;
    emitRCALLinstruction
      !ioAddress
      !targetAddress
      !mTargetLabel
      !?ioCode
    ;
  when ipicAbsolute, absolute :
    emit_pic18_CALLinstruction
      !targetAddress
      !?ioCode
    ;
  end switch ;
end method ;

#----------------------------------------------------*

override method @ipic_jump_test_register generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:

#--- Generate TSTFSZ instruction
  @uint code := 0x6600 ; # TSTFSZ
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  ioCode += ![@uintlist listWithValue !code] ;
#--- Generate BRA and / or GOTO instructions
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
  if mBranchIfZero then
    @uint intermediateTargetAddress ;
    if mUsesBra then
      intermediateTargetAddress := ioAddress + 6 ;
    else
      intermediateTargetAddress := ioAddress + 8 ;
    end if ;
    emitBRAinstruction
      !ioAddress + 2
      !intermediateTargetAddress
      !mInstructionLocation
      !?ioCode
    ;
    if mUsesBra then
      emitBRAinstruction !ioAddress + 4 !targetAddress !mInstructionLocation !?ioCode ;
    else
      emit_pic18_GOTOinstruction !targetAddress !?ioCode ;
    end if ;
  else
    if mUsesBra then
      emitBRAinstruction !ioAddress + 2 !targetAddress !mInstructionLocation !?ioCode ;
    else
      emit_pic18_GOTOinstruction !targetAddress !?ioCode ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------*

override method @ipic_incDecRegisterInCondition generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @uint code ;
  if mBranchIfZero & mIncrement then
    code := 0x4800 ; # INFSNZ
  elsif mBranchIfZero & not mIncrement then
    code := 0x4C00 ; # DCFSNZ
  elsif (not mBranchIfZero) & mIncrement then
    code := 0x3C00 ; # INCFSZ
  else
    code := 0x2C00 ; # DECFSZ
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  ioCode += ![@uintlist listWithValue !code] ;
#--- Generate BRA and / or GOTO instructions
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
  if mUsesBra then
    emitBRAinstruction !ioAddress + 2 !targetAddress !mInstructionLocation !?ioCode ;
  else
    emit_pic18_GOTOinstruction !targetAddress!?ioCode ;
  end if ;
end method ;

#----------------------------------------------------*

override method @ipic_registerComparisonCondition generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
#--- Generate TSTFSZ instruction
  @uint code ; # TSTFSZ
  switch mComparison
    when notEqual       : code := 0x6200 ; # CPFSEQ 
    when equal          : code := 0x6200 ; # CPFSEQ + BRA
    when greaterOrEqual : code := 0x6000 ; # CPFLT
    when greater        : code := 0x6400 ; # CPFGT + BRA
    when lowerOrEqual   : code := 0x6400 ; # CPFGT
    when lower          : code := 0x6000 ; # CPFLT + BRA
  end switch ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  ioCode += ![@uintlist listWithValue !code] ;
#--- Generate BRA and / or GOTO instructions
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
  @bool usesIntermediateBRA ; [selfcopy usesIntermediateBRA ?usesIntermediateBRA] ;
  if usesIntermediateBRA then
    @uint intermediateTargetAddress ;
    if mUsesBra then
      intermediateTargetAddress := ioAddress + 6 ;
    else
      intermediateTargetAddress := ioAddress + 8 ;
    end if ;
    emitBRAinstruction
      !ioAddress + 2
      !intermediateTargetAddress
      !mInstructionLocation
      !?ioCode
    ;
    if mUsesBra then
      emitBRAinstruction !ioAddress + 4 !targetAddress !mInstructionLocation !?ioCode ;
    else
      emit_pic18_GOTOinstruction !targetAddress !?ioCode ;
    end if ;
  else
    if mUsesBra then
      emitBRAinstruction !ioAddress + 2 !targetAddress !mInstructionLocation !?ioCode ;
    else
      emit_pic18_GOTOinstruction !targetAddress !?ioCode ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_CLRWDT generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0004] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_DAW generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0007] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_NOP generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0000] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_POP generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0006] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_PUSH generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0005] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_RESET generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x00FF] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_RETURN generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0012] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_RETFIE generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  @uint code ;
  if mFastReturn then
    code := 0x0011 ; # RETFIE FAST
  else
    code := 0x0010 ; # RETFIE
  end if ;

  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_SLEEP generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0003] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_literalOperation generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
#--- Emit Code
  @uint code ; [selfcopy getBaseCode ? code] ;
  code := code | mLiteralValue ;
  ioCode += ![@uintlist listWithValue !code] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_LFSR generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  @uintlist code [emptyList] ;
  code += !0xEE00 | ([mFSRindex uint] << 4) | (mValue >> 8) ;
  code += !0xF000 | (mValue & 255) ;
  ioCode += !code ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_MOVLB generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  ioCode += ![@uintlist listWithValue !0x0100 | [mBankIndex uint]] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic_pseudo_LABEL generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList unused ioCode
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mLabel ?targetAddress] ;
  if (targetAddress != ioAddress) then
    error mLabel: "Internal second pass error: the '" . mLabel
    . "' label gets " . [ioAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_TBLRD generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  switch mOption
  when simpleAccess  : ioCode += ![@uintlist listWithValue !0x0008] ;
  when postIncrement : ioCode += ![@uintlist listWithValue !0x0009] ;
  when postDecrement : ioCode += ![@uintlist listWithValue !0x000A] ;
  when preIncrement  : ioCode += ![@uintlist listWithValue !0x000B] ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_TBLWT generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  switch mOption
  when simpleAccess  : ioCode += ![@uintlist listWithValue !0x000C] ;
  when postIncrement : ioCode += ![@uintlist listWithValue !0x000D] ;
  when postDecrement : ioCode += ![@uintlist listWithValue !0x000E] ;
  when preIncrement  : ioCode += ![@uintlist listWithValue !0x000F] ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_MNOP generateBinaryCodeAtAddress
  ??@ipic18_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@emittedCodeList ioCode
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    ioCode += ![@uintlist listWithValue !0x0000] ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_retlw generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @uint targetAddress ;
  @lstring target [new !"_computed_goto_2" !mInstructionLocation] ;
  [inRoutineSymbolTable searchKey !target ?targetAddress] ;
  if mUsesRCALL then
    emitRCALLinstruction !ioAddress !targetAddress !target !?ioCode ;
  else
    emit_pic18_CALLinstruction ! targetAddress !?ioCode ;
  end if ;
  foreach mLiteralValues do
    ioCode += ![@uintlist listWithValue !0x0C00 | mValue] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_bra generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @lstring target [new !"_computed_goto_2" !mInstructionLocation] ;
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !target ?targetAddress] ;
  if mUsesRCALL then
    emitRCALLinstruction !ioAddress !targetAddress !target!?ioCode ;
  else
    emit_pic18_CALLinstruction ! targetAddress!?ioCode ;
  end if ;
#---
  @uint addressForComputingBRA := ioAddress + 2 ;
  if not mUsesRCALL then
    addressForComputingBRA := addressForComputingBRA + 2 ; # GOTO takes 2 more bytes
  end if ;
#---
  foreach mTargetLabels do
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;
    emitBRAinstruction
      !addressForComputingBRA
      !targetAddress
      ![mValue location]
      !?ioCode
    ;
    addressForComputingBRA := addressForComputingBRA + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_goto generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @lstring target [new !"_computed_goto_4" !mInstructionLocation] ;
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !target ?targetAddress] ;
  if mUsesRCALL then
    emitRCALLinstruction !ioAddress !targetAddress !target!?ioCode ;
  else
    emit_pic18_CALLinstruction !targetAddress!?ioCode ;
  end if ;
  foreach mTargetLabels do
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;
    emit_pic18_GOTOinstruction
      !targetAddress
      !?ioCode
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_instruction_computed_rcall generateBinaryCodeAtAddress
  ??@ipic18_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@emittedCodeList ioCode
:
  @lstring target [new !"_computed_goto_4" !mInstructionLocation] ;
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !target ?targetAddress] ;
  @uint currentInstructionAddress ;
  if mUsesRCALL then
    emitRCALLinstruction !ioAddress !targetAddress !target!?ioCode ;
    currentInstructionAddress := ioAddress + 2 ;
  else
    emit_pic18_CALLinstruction !targetAddress!?ioCode ;
    currentInstructionAddress := ioAddress + 4 ;
  end if ;
  @uint nextInstructionAddress := currentInstructionAddress + [mTargetLabels length] * 4 - 2 ;
  @uint idx := 0 ;
  foreach mTargetLabels do
    idx ++ ;
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;
    emitRCALLinstruction !currentInstructionAddress !targetAddress !mValue!?ioCode ;
    currentInstructionAddress := currentInstructionAddress + 2 ;
    if idx < [mTargetLabels length] then
      emitBRAinstruction !currentInstructionAddress !nextInstructionAddress ![mValue location]!?ioCode ;
      currentInstructionAddress := currentInstructionAddress + 2 ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine build_ipic18_binary_code
  ??@ipic18_instructionList inGeneratedInstructionList
  ??@uint inROMsize
  ??@actualConfigurationMap inActualConfigurationMap
  !@uint outUsedROMsize
:
#-------------------------------- First pass: build label map
  @ipic18_symbolTable symbolTable [emptyMap] ;
  @uint currentAddress := 0 ;
  foreach inGeneratedInstructionList do
    [mInstruction enterLabelAtAddress !?symbolTable !?currentAddress] ;
  end foreach ;
  @uint lastAddressForFirstPass := currentAddress ;
  outUsedROMsize := currentAddress ;
#-------------------------------- Second pass: generate code
  currentAddress := 0 ;
  setEmitAddress !0 ;
  foreach inGeneratedInstructionList do
    @emittedCodeList code [emptyList] ;
    const @uint startAddress := currentAddress ;
    [mInstruction generateBinaryCodeAtAddress !symbolTable !?currentAddress !?code] ;
    if startAddress != currentAddress then
      setEmitAddress !currentAddress ;
    end if ;
    foreach code do
      foreach mCode do
        emitCode !mValue ;
      end foreach ;
    end foreach ;
    @uint instructionLength ;
    [mInstruction instructionLength ?instructionLength] ;
    currentAddress := currentAddress  + instructionLength ;
    checkCurrentEmitAddress !currentAddress ;
  end foreach ;
  if lastAddressForFirstPass != currentAddress then
    error here: "Internal second pass error: the last address gets " . [currentAddress hexString]
    . " value in second pass, while it gets "
    . [lastAddressForFirstPass hexString] . " value in first pass" ;
  elsif lastAddressForFirstPass > inROMsize then
    error here: "Program too large: " . [lastAddressForFirstPass string]
    . " bytes (rom size is "
    . [inROMsize string] . " bytes)" ;
  end if ;
#-------------------------------- Add Configuration
  foreach inActualConfigurationMap do
    setEmitAddress !mRegisterAddress ;
    emitByte !mRegisterValue ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
