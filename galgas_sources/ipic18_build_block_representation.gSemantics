semantics ipic18_build_block_representation :
import "ipic18_optimize_block.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "intermediate_generic.gSemantics" ;
import "ipic18_block_ordering.gSemantics" ;
import "ipic18_relatives_resolution.gSemantics" ;
import "ipic18_display_block_list.gSemantics" ;
import "piccolo_options.gOption" ;
import "ipic18_code_generation.gSemantics" ;
import "ipic18_stack_computations.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Register analysis

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpression
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  !@ipic18_intermediate_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
  ?!@stringset ioUsedRegisters
:
  ioUsedRegisters += !mRegisterName->string ;
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  @uint registerAddress := 0 ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
    registerAddress := mValue ;
  end foreach ;
  @bool needsBSRaccess := false ;
  if not found then
    needsBSRaccess := true ;
    [registerAddressList first ?registerAddress] ;
    @uint neededBank := registerAddress >> 8 ;
    if (neededBank != inCurrentBank) then
      @string errorMessage := "Accessing the '" . mRegisterName . "' needs the bank selection set to " . [neededBank string] ;
      if inCurrentBank == [@uint max] then
        errorMessage .= ", but current bank selection cannot be known" ;
      else
        errorMessage .= ", but current bank selection is set to " . [inCurrentBank string] ;
      end if ;
      error mRegisterName: errorMessage ;
    end if ;
  end if ;
#---
  outIPICregisterDescription := [@ipic18_intermediate_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
    !needsBSRaccess
  ] ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpressionWithoutCheckingBank
  ??@registerTable inRegisterTable
  !@ipic18_intermediate_registerExpressionWithoutBSRIndication outIPICregisterDescription
  ?!@stringset ioUsedRegisters
:
  ioUsedRegisters += !mRegisterName->string ;
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?@uint registerAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  outIPICregisterDescription := [@ipic18_intermediate_registerExpressionWithoutBSRIndication new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------------------------------*

reader @registerExpression getRegisterAddress
  ??@registerTable inRegisterTable
  -> @uint outRegisterAddress
:
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?outRegisterAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Simple Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloSimpleInstruction analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
;

#----------------------------------------------------------------------------*

override method @pic18Instruction_withNoOperand analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18InstructionWithNoOperand new
    !mInstructionLocation
    !mKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18Instruction_FDA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_FDA new
    !mInstructionLocation
    !mInstruction_FDA_base_code
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18Instruction_FA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  @FA_sequential_instruction_base_code code ;
  switch mFAinstruction
  when CLRF : code := [@FA_sequential_instruction_base_code CLRF] ;
  when MOVWF : code := [@FA_sequential_instruction_base_code MOVWF] ;
  when MULWF : code := [@FA_sequential_instruction_base_code MULWF] ;
  when NEGF : code := [@FA_sequential_instruction_base_code NEGF] ;
  when SETF : code := [@FA_sequential_instruction_base_code SETF] ;
  when CPFSEQ, CPFSGT, CPFSLT, TSTFSZ :
    error [@location nowhere] : "*** INTERNAL ERROR ***" : code ;
  end switch ;
  outInstruction := [@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    !code
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18Instruction_MOVFF analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mSourceRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication sourceIPICregisterDescription
    !?ioUsedRegisters
  ] ;
  [mDestinationRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication destinationIPICregisterDescription
    !?ioUsedRegisters
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !sourceIPICregisterDescription
    !destinationIPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_FBA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?@uint bitNumber
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_FBA new
    !mInstructionLocation
    !mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_literalOperation analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
#---
   if (result > 255LS) | (result < -128LS) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between -128 and 255)" ;
   end if ;
#---  
  outInstruction := [@ipic18_intermediate_instruction_literalOperation new
    !mInstructionLocation
    !mLiteralInstruction
    ![result & 0x000000FFS uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_fnop analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
#---
   if (result > 0xFFFLS) | (result < 0LS) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 4095)" ;
   end if ;
#---  
  outInstruction := [@ipic18_intermediate_instruction_FNOP new
    !mInstructionLocation
    ![result uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_LFSR analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  if [mFSRindex uint] > 2 then
    error mFSRindex:"the LFSR register idx (" . [[mFSRindex uint] string] . ") should be lower or equal to 2" ;
  end if ;
#---
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
#---
  if (result > 0xFFFLS) | (result < 0LS) then
    error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 4095)" ;
  end if ;
  outInstruction := [@ipic18_intermediate_instruction_LFSR new
    !mInstructionLocation
    !mFSRindex
    ![result uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_JSR analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires bank selection to be set to " . [requiredBank string] ;
    errorMessage .= ", but bank selection " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "is not defined" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a BRA, GOTO, Bcc or JUMP instruction" ;
  end if ;
  if not preservesBank then
    ioCurrentBank := returnedBank ;
    if inShouldPreserveBSR then
      error mTargetLabel:"the routine call should preserve bank selection" ;
    end if ;
  end if ;
#---
  outInstruction := [@ipic18_intermediate_JSR new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloInstruction analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
;

#----------------------------------------------------*

override method @pic18Instruction_checkbank analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
#--- Check instruction
  if mBankIndex > 15 then
    error mInstructionLocation:"Bank index should be <= 15" ;
  elsif ioCurrentBank == [@uint max] then
    error mInstructionLocation:"checkbank fail: there is no selected bank" ;
  elsif ioCurrentBank != mBankIndex then
    error mInstructionLocation:"checkbank fail: the selected bank is " . ioCurrentBank . ", required bank is " . mBankIndex ;
  end if ;
  ioCurrentBank := mBankIndex ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_checknobank analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
#--- Check instruction
  if ioCurrentBank != [@uint max] then
    error mInstructionLocation:"checknobank fail: the " . ioCurrentBank . " bank is selected" ;
    ioCurrentBank := [@uint max] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18PiccoloSimpleInstruction analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
  [selfcopy analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ??@ipic18SequentialInstruction instruction
  ] ;
  ioGeneratedInstructionList += !instruction ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_FOREVER analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
  const @uint finalBank := ioCurrentBank ;
#--- Get loop label
  const @lstring loopLabel [new !".L" . ioLocalLabelIndex !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Store current block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18JumpTerminator new !mInstructionLocation !loopLabel ![@jumpInstructionKind ipicRelative]]
  ] ;
#--- Analyze instruction list
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
  ioBlockLabel := loopLabel ;
  analyzeInstructionList
    !mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  ;
#--- Check instruction list does not change bank
  if ioBlockLabel->string == "" then
    error mEndOfInstructionList:"\"forever\" instruction list execution is endless";
  else
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      ![@ipic18JumpTerminator new !mInstructionLocation !loopLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#--- Check instruction list does not change bank
  if ioCurrentBank != finalBank then
    error mEndOfInstructionList:"\"forever\" instruction list does not leave bank selection unchanged";
  end if ;
#--- Indicate next code is not reacheable
  ioBlockLabel := ["" nowhere] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_nobanksel analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList unused ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"nobank\" here: bank selection should be preserved (use it in a \"banksave\" construct)" ;
  end if ;
  ioCurrentBank := [@uint max] ;
#--- Generates no code
end method ;

#----------------------------------------------------*

override method @pic18Instruction_savebank analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#--- Get values for BSR register
  const @registerExpression BSRregister [new ![@lstring new !"BSR" !here] ![@luint new !0 !here]] ;
  [BSRregister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication BSR_IPICregisterDescription
    !?ioUsedRegisters
  ] ;
#--- Get values for register used for saving
  [mRegister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication save_IPICregisterDescription
    !?ioUsedRegisters
  ] ;
#--- Generate "MOVFF BSR, save_register" instruction
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !BSR_IPICregisterDescription
    !save_IPICregisterDescription
  ] ;
#--- Generate instruction list
  @uint finalBank := ioCurrentBank ;
  analyzeInstructionList
    !mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?finalBank
    !false # Do not preserve bank now
    !inRoutineKind 
    !?ioUsedRegisters
  ;
  if ioBlockLabel->string == "" then
    error mEndOfSaveBankInstruction:"useless saving: execution does not reach the end of \"savebank\" instruction list" ;
  end if ;
#--- Generate "MOVFF save_register, BSR" instruction
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !save_IPICregisterDescription
    !BSR_IPICregisterDescription
  ] ;
end method ;
#----------------------------------------------------*

override method @pic18Instruction_repetitionStatique analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#--- Solve immediat expression
  [mRepeatExpression eval !inRegisterTable !inConstantMap ??@sint64 repeatCount !?ioUsedRegisters] ;
#---
  if (repeatCount > 0xFF_FFFF_LS) | (repeatCount <= 0LS) then
    error mInstructionLocation:"immediate value is evaluated as " . repeatCount . " (should be > 0 and <= 0xFF_FFFF)" ;
  end if ;
#--- Generate instruction list (first pass)
  @uint finalBank := ioCurrentBank ;
  analyzeInstructionList
    !mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?finalBank
    !true # Preserve bank now
    !inRoutineKind 
    !?ioUsedRegisters
  ;
  if ioBlockLabel->string == "" then
    error mEndOfInstruction:"useless do: execution does not reach the end of enclosed instruction list" ;
  end if ;
  if finalBank != ioCurrentBank then
    error mEndOfInstruction:"enclosed instruction list should not modify bank selection" ;
  end if ;
#--- Generate instruction list (other passes)
  for idx in [@range new !0 ![repeatCount-1S uint]] while [@uint errorCount] == 0 do
    analyzeInstructionList
      !mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?ioCurrentBank
      !true # Preserve bank now
      !inRoutineKind 
      !?ioUsedRegisters
    ;
  end for ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_banksel analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  if [mBankIndex uint] > 15 then
    error mBankIndex:"selected bank idx should be lower or equal to 15" ;
    ioCurrentBank := [@uint max] ; # No selected bank
  elsif [mBankIndex uint] != ioCurrentBank then
    ioCurrentBank := [mBankIndex uint] ;
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_MOVLB new !mInstructionLocation !mBankIndex] ;
  elsif mWarningOnUselessBanksel then
    warning mBankIndex:"useless instruction: the bank " . [ioCurrentBank string] . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_banksel_register analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  const @uint registerAddress := [mRegisterExpression getRegisterAddress !inRegisterTable] ;
  const @uint newBank := registerAddress >> 8 ;
  if ioCurrentBank != newBank then
    ioCurrentBank := newBank ;
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_MOVLB new
      !mInstructionLocation
      ![@luint new !newBank ![mRegisterExpression mRegisterName]->location]
    ] ;
  elsif mWarningOnUselessBanksel then
    warning [mRegisterExpression mRegisterName]:"useless instruction: the bank " . newBank . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_TBLRD analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18_intermediate_instruction_TBLRD new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_TBLWT analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@stringset unused ioUsedRegisters
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18_intermediate_instruction_TBLWT new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_MNOP analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
#---
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor:"occurrence argument is zero: no generated code" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_MNOP new
    !mInstructionLocation
    !mOccurrenceFactor
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_LTBLPTR analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
#---
  if (result > 0xFF_FFFF_LS) | (result < 0LS) then
    error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 0xFF_FFFF)" ;
  end if ;
  const @uint address := [result uint] ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  const @uint upper := address >> 16 ;
  if upper == 0 then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif upper == 0xFF then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !upper
    ] ;
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  const @uint high := (address >> 8) & 0xFF ;
  if high == 0 then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif high == 0xFF then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !high
    ] ;
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  const @uint low := address & 0xFF ;
  if low == 0 then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif low == 0xFF then
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !low
    ] ;
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_LDATAPTR analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
  [inDataMap searchKey !mDataName ??@uintlist data] ;
#--- Check index
  if [mDataIndex uint] >= [data length] then
    error mDataIndex: "index should be < " . [data length] ;
  end if ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !16
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !8
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !0
  ] ;
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
end method ;

#----------------------------------------------------*

override method @pic18Instruction_JUMP analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires bank selection to be set to " . [requiredBank string] ;
    errorMessage .= ", but bank selection " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "is not defined" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
#--- Build block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18JumpTerminator new !mInstructionLocation !mTargetLabel ![@jumpInstructionKind ipicRelative]]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- No following code
  ioBlockLabel := ["" nowhere] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_computed_rcall analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
#---
  @bool allPreserveBank := true ;
  @bool someReturnsBank := false ;
  @uint returnedBankSelection := ioCurrentBank ;
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires bank selection to be set to " . [requiredBank string] ;
      errorMessage .= ", but bank selection " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "is not defined" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if isNoReturn then
      error mValue:"for being named in a computed rcall, the '" . mValue . "' routine should be declared without the \"noreturn\" qualifier" ;
    end if ;
    if inShouldPreserveBSR & not preservesBank then
      error mValue:"the '" . mValue . "' routine should preserved bank selection" ;
    elsif (not inShouldPreserveBSR) & not preservesBank then
      if not someReturnsBank then
        returnedBankSelection := returnedBank ;
        someReturnsBank := true ;
      elsif returnedBankSelection != returnedBank then 
        @string errorMessage := "the '" . mValue . "' routine returns " ;
        if returnedBank == [@uint max] then
          errorMessage .= "no bank selection" ;
        else
          errorMessage .= "bank selection set to  ". [returnedBank string] ;
        end if ;
        errorMessage .= ", but previous routine(s) return(s) " ;
        if returnedBankSelection == [@uint max] then
          errorMessage .= "no bank selection" ;
        else
          errorMessage .= "bank selection set to  ". [returnedBankSelection string] ;
        end if ;
        error mValue: errorMessage ;
      end if ;
    elsif (not inShouldPreserveBSR) & preservesBank then
    end if ;
  end foreach ;
#---
  ioCurrentBank := returnedBankSelection ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint64 size !?ioUsedRegisters] ;
  if size < 2LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  @ipic18SequentialInstructionList targetInstructionList [emptyList] ;
  foreach mTargetLabels do
    targetInstructionList += ![@ipic18_intermediate_JSR new !mValue->location !mValue ![@jumpInstructionKind relative]] ;
  end foreach ;
#---
  ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_computed_rcall new
    !mInstructionLocation
    !targetInstructionList
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_computed_goto analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#---
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires bank selection to be set to " . [requiredBank string] ;
      errorMessage .= ", but bank selection " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "is not defined" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if ([@routineKind regularRoutine] != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed goto, the '" . mValue . "' routine should be declared with the \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
  switch inRoutineKind
  when regularRoutine : #ok
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed goto instruction" ;
  end switch ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint64 size !?ioUsedRegisters] ;
  if size < 2LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- Build block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18ComputedGotoTerminator new
      !mInstructionLocation
      !mTargetLabels
      !mUsesRelativeCall
    ]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- No following code
  ioBlockLabel := ["" nowhere] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_computed_bra analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#---
  @bool allPreserveBankSetting := true ;
  @bool allReturnBank := true ;
  @uint returnedBankValue [max] ;
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
  #--- Check bank "requires"
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires bank selection to be set to " . [requiredBank string] ;
      errorMessage .= ", but bank selection " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "is not defined" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;    
  #--- Check bank "preserved", "ensures"
    if preservesBank then
      allReturnBank := false ;
    elsif (returnedBankValue != [@uint max]) & (returnedBankValue != returnedBank) then
      error mValue:"this routine ensures setting of bank '" . [returnedBank string] . "', but "
      . "previous routine(s) ensure setting of bank '" . [returnedBankValue string] . "'." ;
    else
      allPreserveBankSetting := false ;
      returnedBankValue := returnedBank ;
    end if ;
    if ([@routineKind regularRoutine] != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed bra from a regular routine, the '" . mValue . "' routine should be declared without any \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
#---
  if allReturnBank & not allPreserveBankSetting then
    ioCurrentBank := returnedBankValue ;
  elsif (not allReturnBank) & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine should either all preserve bank, eihter return the same selected bank" ;
  end if ;
  if inShouldPreserveBSR & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine(s) do(es) not preserve bank selection" ;
  end if ;
#---
  switch inRoutineKind
  when regularRoutine :
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed bra instruction" ;
  end switch ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint64 size !?ioUsedRegisters] ;
  if size < 2LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- Build block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18ComputedBraTerminator new
      !mInstructionLocation
      !mTargetLabels
      !mUsesRelativeCall
    ] 
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- No following code
  ioBlockLabel := ["" nowhere] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_computed_retlw analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
  switch inRoutineKind
  when regularRoutine : # ok
  when noReturnRoutine :
    error mInstructionLocation:"a \"noreturn\" routine does not accept computed retlw instruction" ;
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed retlw instruction" ;
  end switch ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint64 size !?ioUsedRegisters] ;
  if size < 2LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128LS then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mImmediateExpressionList length] then
    error mInstructionLocation:"the constant list length (" . [[mImmediateExpressionList length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- 
  @uintlist literalValues [emptyList] ;
  foreach mImmediateExpressionList index idx do
    [mExpression eval !inRegisterTable !inConstantMap ??@sint64 v !?ioUsedRegisters] ;
    if (v > 255LS) | (v < -128LS) then
      error mInstructionLocation:"immediate value with idx " . [idx string] . " is evaluated as " . [v string] . " (should be <= 255)" ;
    end if ;
    literalValues += ![v & 0x000000FFS uint] ;
  end foreach ;
#--- Build block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18ComputedRETLWTerminator new
      !mInstructionLocation
      !literalValues
      !mUsesRelativeCall
    ]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- No following code
  ioBlockLabel := ["" nowhere] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_JUMPCC analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused  inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset unused ioUsedRegisters
:
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires bank selection to be set to " . [requiredBank string] ;
    errorMessage .= ", but bank selection " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "is not defined" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
#---
  @conditionalBranchMode mode ;
  if mIsBcc then
    mode := [@conditionalBranchMode native] ;
  else
    mode := [@conditionalBranchMode ipicBRA] ;
  end if ;
#--- Create the continuation label
  const @lstring label0 [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Build block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18ConditionalJumpTerminator new
      !mInstructionLocation
      !mConditionalBranch
      !mTargetLabel
      !mode
      !label0
      !mode
    ]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- Set label for following block
  ioBlockLabel := label0 ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_IF_BitTest analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
#--- Analyze condition
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ??@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ??@uint bitNumber
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioGeneratedInstructionList += ![@ipic18_skip_instruction_BitTestSkip new
    !mInstructionLocation
    !embeddedInstruction
    !mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_IF_FA_SEMI_COLON analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
  @ipic18_compare_register_instruction_base_code baseCode ;
  switch mOpCode
    when CPFSEQ : baseCode := [@ipic18_compare_register_instruction_base_code CPFSEQ] ;
    when CPFSGT : baseCode := [@ipic18_compare_register_instruction_base_code CPFSGT] ;
    when CPFSLT : baseCode := [@ipic18_compare_register_instruction_base_code CPFSLT] ;
    when TSTFSZ : baseCode := [@ipic18_compare_register_instruction_base_code TSTFSZ] ;
  end switch ;
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioGeneratedInstructionList += ![@ipic18_skip_instruction_compare_register new
    !mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_IF_IncDec analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring unused ioBlockLabel
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind unused inRoutineKind
  ?!@stringset ioUsedRegisters
:
#---
  @skip_instruction_FDA_base_code baseCode ;
  if mIncrement & mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code INCFSZ] ;
  elsif mIncrement & not mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code INFSNZ] ;
  elsif (not mIncrement) & mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code DECFSZ] ;
  else
    baseCode := [@skip_instruction_FDA_base_code DCFSNZ] ;
  end if ;
#---
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    !?ioUsedRegisters
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioGeneratedInstructionList += ![@ipic18_skip_instruction_FDA new
    !mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_structured_if analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#--- Save bank settings
  @uint elseBranchFinalBank := ioCurrentBank ;
  @uint thenBranchFinalBank := ioCurrentBank ;
#--- Labels
  const @lstring conditionTrueLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring exitLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#---- Analyze condition
  [mIfCondition analyzeCondition
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !conditionFalseLabel
    !?ioUsedRegisters
    ?@ipic18AbstractBlockTerminator testTerminator
  ] ;
#--- Save current block block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    !testTerminator
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- Analyze 'then' instruction list
  ioBlockLabel := conditionTrueLabel ;
  analyzeInstructionList
    !mThenInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?thenBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  ;
  const @bool thenContinuesInSequence := ioBlockLabel->string != "" ;
  if thenContinuesInSequence then
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- Build block
  ioBlockLabel := conditionFalseLabel ;
  analyzeInstructionList
    !mElseInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?elseBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  ;
  const @bool elseContinuesInSequence := ioBlockLabel->string != "" ;
  if elseContinuesInSequence then
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#---
  if elseBranchFinalBank == thenBranchFinalBank then
    ioCurrentBank := elseBranchFinalBank ;
  else
    error mEndOfElsePartLocation:"This branch does not leave bank selection value as the first one does";
    elseBranchFinalBank := [@uint max] ; # No available value for BSR
  end if ;
#---
  if thenContinuesInSequence | elseContinuesInSequence then
    ioBlockLabel := exitLabel ;
  else
    ioBlockLabel := ["" nowhere] ;
  end if ;
end method ;

#------------------------------------------------------------------------------*

#!--- Switch instruction

#------------------------------------------------------------------------------*

map @caseConstantMap {
  insert insertKey error message "the '%K' constant is already declared in %L" ;
}

#------------------------------------------------------------------------------*

abstract method @pic18AbstractCaseItem analyzeCaseItem
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ??@lstring inConditionTrueLabel
  ?!@stringset ioUsedRegisters
  ?!@caseConstantMap ioCaseConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@lstring ioBlockLabel
  ?!@sint64 ioLastComparisonValue
;

#------------------------------------------------------------------------------*

override method @pic18SimpleConstantCaseItem analyzeCaseItem
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ??@lstring inConditionTrueLabel
  ?!@stringset ioUsedRegisters
  ?!@caseConstantMap ioCaseConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@lstring ioBlockLabel
  ?!@sint64 ioLastComparisonValue
:
    [mCaseExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
  #---
    if (result > 255LS) | (result < 0LS) then
      error mCaseExpressionLocation:"case value is evaluated as " . result . " (should be between 0 and 255)" ;
    end if ;
  #--- Check constant is unique
    if [ioCaseConstantMap hasKey ![result string]] then
      error mCaseExpressionLocation : "the '" . result . "' constant is already used in switch instruction" ;
      error [ioCaseConstantMap locationForKey ![result string]] : "the '" . result . "' constant is used here" ;
    else
      [!?ioCaseConstantMap insertKey ![@lstring new ![result string] !mCaseExpressionLocation]] ;
    end if ;
  #--- Generate xorlw instruction  
    ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mCaseExpressionLocation
      ![@literal_instruction_opcode ADDLW]
      ![(ioLastComparisonValue - result) & 0xFFLS uint]
    ] ;
  #--- Update comparison value
    ioLastComparisonValue := result ;
  #--- Condition false label
    const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mCaseExpressionLocation] ; 
    ioLocalLabelIndex ++ ;
  #--- Terminate current block with a BZ instruction
    const @ipic18AbstractBlockTerminator t := [@ipic18ConditionalJumpTerminator new
      !mCaseExpressionLocation
      ![@conditional_branch bz]
      !inConditionTrueLabel
      ![@conditionalBranchMode native]
      !conditionFalseLabel
      ![@conditionalBranchMode native]
    ] ;
  #--- Save current block block
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !t
    ] ;
    ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
    ioBlockLabel := conditionFalseLabel ;
 end method ;

#------------------------------------------------------------------------------*

override method @pic18IntervalCaseItem analyzeCaseItem
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ??@lstring inConditionTrueLabel
  ?!@stringset ioUsedRegisters
  ?!@caseConstantMap ioCaseConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@lstring ioBlockLabel
  ?!@sint64 ioLastComparisonValue
:
    [mMinExpression eval !inRegisterTable !inConstantMap ??@sint64 minBound !?ioUsedRegisters] ;
    [mMaxExpression eval !inRegisterTable !inConstantMap ??@sint64 maxBound !?ioUsedRegisters] ;
  #---
    @bool ok := true ;
    if (minBound > 255LS) | (minBound < 0LS) then
      error mCaseExpressionLocation:"min bound is evaluated as " . minBound . " (should be between 0 and 255)" ;
      ok := false ;
    end if ;
    if (maxBound > 255LS) | (maxBound < 0LS) then
      error mCaseExpressionLocation:"max bound is evaluated as " . maxBound . " (should be between 0 and 255)" ;
      ok := false ;
    end if ;
    if maxBound <= minBound then
      error mCaseExpressionLocation:"max bound (" . maxBound . ") should be greater than low bound (" . minBound . ")" ;
      ok := false ;
    end if ;
    if ok then
    #--- Check constant is unique
      for n in [@range new ![minBound uint] ![maxBound - minBound + 1LS uint]] do
        if [ioCaseConstantMap hasKey ![n string]] then
          error mCaseExpressionLocation : "the '" . n . "' constant is already used in switch instruction" ;
          error [ioCaseConstantMap locationForKey ![n string]] : "the '" . n . "' constant is used here" ;
        else
          [!?ioCaseConstantMap insertKey ![@lstring new ![n string] !mCaseExpressionLocation]] ;
        end if ;
      end for ;
    #--- Generate first addlw instruction  
      ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
        !mCaseExpressionLocation
        ![@literal_instruction_opcode ADDLW]
        ! [(ioLastComparisonValue - minBound) & 0xFFLS uint]
      ] ;
    #--- Labels
      const @lstring greaterThanLowBoundLabel [new !".L" . [ioLocalLabelIndex string] !mCaseExpressionLocation] ; 
      ioLocalLabelIndex ++ ;
      const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mCaseExpressionLocation] ; 
      ioLocalLabelIndex ++ ;
    #--- Terminate current block with a BC instruction
      const @ipic18AbstractBlockTerminator t := [@ipic18ConditionalJumpTerminator new
        !mCaseExpressionLocation
        ![@conditional_branch bc]
        !greaterThanLowBoundLabel
        ![@conditionalBranchMode native]
        !conditionFalseLabel
        ![@conditionalBranchMode native]
      ] ;
    #--- Save current block
      ioGeneratedBlockList += ![@ipic18Block new
        ![@uint max] # relocatable
        !ioBlockLabel
        !ioGeneratedInstructionList
        !t
      ] ;
      ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
      ioBlockLabel := conditionFalseLabel ;
    #--- Generate second addlw instruction  
      ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
        !mCaseExpressionLocation
        ![@literal_instruction_opcode ADDLW]
        ! [(- (maxBound - minBound + 1LS)) & 0xFFLS uint]
      ] ;
    #--- Terminate current block with a BC instruction
      const @ipic18AbstractBlockTerminator t2 := [@ipic18ConditionalJumpTerminator new
        !mCaseExpressionLocation
        ![@conditional_branch bc]
        !conditionFalseLabel
        ![@conditionalBranchMode native]
        !inConditionTrueLabel
        ![@conditionalBranchMode native]
      ] ;
    #--- Save current block
      ioGeneratedBlockList += ![@ipic18Block new
        ![@uint max] # relocatable
        !greaterThanLowBoundLabel
        !ioGeneratedInstructionList
        !t2
      ] ;
      ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
      ioBlockLabel := conditionFalseLabel ;
    #--- Update comparison value
      ioLastComparisonValue := maxBound + 1 ;
    end if ;
 end method ;

#------------------------------------------------------------------------------*

override method @pic18Instruction_switch analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
  @caseConstantMap caseConstantMap [emptyMap] ;
#--- Labels
  const @lstring exitLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Comparison value
  @sint64 lastComparisonValue := 0LS ;
#--- By default, do not continue in sequence
  @bool continuesInSequence := false ;
#---
  const @uint initialBankSetting := ioCurrentBank ;
  @uint finalBankSetting [max] ; # Any value
  @bool finalBankSettingDefined := false ;
#---
  foreach mCaseList do
  #--- Label
    const @lstring conditionTrueLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
    ioLocalLabelIndex ++ ;
  #--- Generate test blocks
    foreach mCaseExpressionList do
      [mCaseItem analyzeCaseItem
        !inRegisterTable
        !inConstantMap
        !conditionTrueLabel
        !?ioUsedRegisters
        !?caseConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioGeneratedBlockList
        !?ioBlockLabel
        !?lastComparisonValue
      ] ;
#      [mCaseExpression eval !inRegisterTable !inConstantMap ??@sint64 result !?ioUsedRegisters] ;
#    #---
#      if (result > 255LS) | (result < 0LS) then
#        error mInstructionLocation:"case value is evaluated as " . result . " (should be between 0 and 255)" ;
#      end if ;
#    #--- Check constant is unique
#      if [caseConstantMap hasKey ![result string]] then
#        error mCaseExpressionLocation : "the '" . result . "' constant is already used in switch instruction" ;
#        error [caseConstantMap locationForKey ![result string]] : "the '" . result . "' constant is used here" ;
#      else
#        [!?caseConstantMap insertKey ![@lstring new ![result string] !mCaseExpressionLocation]] ;
#      end if ;
#    #--- Generate xorlw instruction  
#      ioGeneratedInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
#        !mInstructionLocation
#        ![@literal_instruction_opcode XORLW]
#        !lastComparisonValue ^ [result uint]
#      ] ;
#    #--- Update comparison value
#      lastComparisonValue := [result uint] ;
#    #--- Condition false label
#      const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
#      ioLocalLabelIndex ++ ;
#    #--- Terminate current block with a BZ instruction
#      const @ipic18AbstractBlockTerminator t := [@ipic18ConditionalJumpTerminator new
#        !mInstructionLocation
#        ![@conditional_branch bz]
#        !conditionTrueLabel
#        ![@conditionalBranchMode native]
#        !conditionFalseLabel
#        ![@conditionalBranchMode native]
#      ] ;
#    #--- Save current block block
#      ioGeneratedBlockList += ![@ipic18Block new
#        ![@uint max] # relocatable
#        !ioBlockLabel
#        !ioGeneratedInstructionList
#        !t
#      ] ;
#      ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#      ioBlockLabel := conditionFalseLabel ;
    end foreach ;
  #--- Analyze instruction list
    const @lstring conditionFalseLabel := ioBlockLabel ;
    ioBlockLabel := conditionTrueLabel ;
    @uint branchFinalBank := initialBankSetting ;
    analyzeInstructionList
      !mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?branchFinalBank
      !inShouldPreserveBSR
      !inRoutineKind
      !?ioUsedRegisters
    ;
    if ioBlockLabel->string != "" then
      continuesInSequence := true ;
      ioGeneratedBlockList += ![@ipic18Block new
        ![@uint max] # relocatable
        !ioBlockLabel
        !ioGeneratedInstructionList
        ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
      ] ;
    end if ;
    if finalBankSettingDefined then
      if finalBankSetting != branchFinalBank then
        error mStartOfCase: "this branch leaves bank setting to "
        . if branchFinalBank == [@uint max] then "'no selection'" else [branchFinalBank string] end
        . ", but first branch leaves bank setting to "
        . if finalBankSetting == [@uint max] then "'no selection'" else [finalBankSetting string] end
        . " (should be the same setting)"
        ;
      end if ;
    else
      finalBankSettingDefined := true ;
      finalBankSetting := branchFinalBank ;
    end if ;
    ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
    ioBlockLabel := conditionFalseLabel ;
  end foreach ;
#--- "else" instruction list
  @uint branchFinalBank := initialBankSetting ;
  analyzeInstructionList
    !mElseInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?branchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  ;
  const @bool thenContinuesInSequence := ioBlockLabel->string != "" ;
  if thenContinuesInSequence then
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- Bank setting
  if finalBankSetting != branchFinalBank then
    error mElseBranchStartLocation: "the 'else' branch leaves bank setting to "
    . if branchFinalBank == [@uint max] then "'no selection'" else [branchFinalBank string] end
    . ", but first branch leaves bank setting to "
    . if finalBankSetting == [@uint max] then "'no selection'" else [finalBankSetting string] end
    . " (should be the same setting)"
    ;
  end if ;
#---
  ioCurrentBank := finalBankSetting ;
  if continuesInSequence then
    ioBlockLabel := exitLabel ;
  else
    ioBlockLabel := ["" nowhere] ;
  end if ;

##--- Save bank settings
#  @uint elseBranchFinalBank := ioCurrentBank ;
#  @uint thenBranchFinalBank := ioCurrentBank ;
#  const @lstring exitLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
#  ioLocalLabelIndex ++ ;
##---- Analyze condition
#  [mIfCondition analyzeCondition
#    !inAccessBankSplitOffset
#    !ioCurrentBank
#    !inRegisterTable
#    !?ioLocalLabelIndex
#    !?ioGeneratedBlockList
#    !conditionTrueLabel
#    !conditionFalseLabel
#    !?ioUsedRegisters
#    ?@ipic18AbstractBlockTerminator testTerminator
#  ] ;
##--- Save current block block
#  ioGeneratedBlockList += ![@ipic18Block new
#    ![@uint max] # relocatable
#    !ioBlockLabel
#    !ioGeneratedInstructionList
#    !testTerminator
#  ] ;
#  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
##--- Analyze 'then' instruction list
#  ioBlockLabel := conditionTrueLabel ;
#  analyzeInstructionList
#    !mThenInstructionList
#    !?ioGeneratedBlockList
#    !inAccessBankSplitOffset
#    !inRoutineMap
#    !inRegisterTable
#    !inDataMap
#    !inConstantMap
#    !?ioLocalLabelIndex
#    !?ioGeneratedInstructionList
#    !?ioBlockLabel
#    !?ioListFileContents
#    !?thenBranchFinalBank
#    !inShouldPreserveBSR
#    !inRoutineKind
#    !?ioUsedRegisters
#  ;
#  const @bool thenContinuesInSequence := ioBlockLabel->string != "" ;
#  if thenContinuesInSequence then
#    ioGeneratedBlockList += ![@ipic18Block new
#      ![@uint max] # relocatable
#      !ioBlockLabel
#      !ioGeneratedInstructionList
#      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
#    ] ;
#  end if ;
#  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
##--- Build block
#  ioBlockLabel := conditionFalseLabel ;
#  analyzeInstructionList
#    !mElseInstructionList
#    !?ioGeneratedBlockList
#    !inAccessBankSplitOffset
#    !inRoutineMap
#    !inRegisterTable
#    !inDataMap
#    !inConstantMap
#    !?ioLocalLabelIndex
#    !?ioGeneratedInstructionList
#    !?ioBlockLabel
#    !?ioListFileContents
#    !?elseBranchFinalBank
#    !inShouldPreserveBSR
#    !inRoutineKind
#    !?ioUsedRegisters
#  ;
#  const @bool elseContinuesInSequence := ioBlockLabel->string != "" ;
#  if elseContinuesInSequence then
#    ioGeneratedBlockList += ![@ipic18Block new
#      ![@uint max] # relocatable
#      !ioBlockLabel
#      !ioGeneratedInstructionList
#      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
#    ] ;
#  end if ;
#  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
##---
#  if elseBranchFinalBank == thenBranchFinalBank then
#    ioCurrentBank := elseBranchFinalBank ;
#  else
#    error mEndOfElsePartLocation:"This branch does not leave bank selection value as the first one does";
#    elseBranchFinalBank := [@uint max] ; # No available value for BSR
#  end if ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_do_while analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#--- Labels
  const @lstring startLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#  const @lstring exitLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
#  ioLocalLabelIndex ++ ;
#--- Save current block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;



#  const @ipic18AbstractBlockTerminator currentBlockTerminator :=  ioCurrentBlock->mTerminator ;
##--- Close current block
#  ioCurrentBlock->mTerminator := [@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]] ;
#  ioGeneratedBlockList += !ioCurrentBlock ;
#--- Create an new block, for repeated instruction list
#  ioCurrentBlock := [@ipic18Block new
#    ![@uint max] # relocatable
#    !startLabel
#    ![@ipic18SequentialInstructionList emptyList]
#    !currentBlockTerminator
#  ] ;
#--- Repeated instruction list
  ioBlockLabel := startLabel ;
  @uint repeatedBranchFinalBank := ioCurrentBank ;
  analyzeInstructionList
    !mRepeatedInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioBlockLabel
    !?ioListFileContents
    !?repeatedBranchFinalBank
    !inShouldPreserveBSR
    !inRoutineKind
    !?ioUsedRegisters
  ;
  const @bool repeatedInstructionsContinuesInSequence := ioBlockLabel->string != "" ;
  if ioCurrentBank != repeatedBranchFinalBank then
    error mEndOfRepeatedInstructionList:"This branch does not leave bank selection value unchanged";
  end if ;
  if not repeatedInstructionsContinuesInSequence then
    error mEndOfRepeatedInstructionList:"This branch makes the next code unreachable";
  end if ;
#--- While branches
  foreach mWhilePartList do
  #--- Labels
    const @lstring conditionTrueLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
    ioLocalLabelIndex ++ ;
   const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
   ioLocalLabelIndex ++ ;
  #---- Analyze condition
    [mCondition analyzeCondition
      !inAccessBankSplitOffset
      !ioCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !?ioGeneratedBlockList
      !conditionTrueLabel
      !conditionFalseLabel
      !?ioUsedRegisters
      ?@ipic18AbstractBlockTerminator testTerminator
    ] ;
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      !testTerminator
    ] ;
    ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
    ioBlockLabel := conditionTrueLabel ;
#
#
#
#    ioCurrentBlock->mTerminator := testTerminator ;
#    ioGeneratedBlockList += !ioCurrentBlock ;
#    ioCurrentBlock := [@ipic18Block new
#      ![@uint max] # relocatable
#      !conditionTrueLabel
#      ![@ipic18SequentialInstructionList emptyList]
#      ![@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]]
#    ] ;
    @uint branchFinalBank := ioCurrentBank ;
    analyzeInstructionList
      !mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?branchFinalBank
      !inShouldPreserveBSR
      !inRoutineKind
      !?ioUsedRegisters
    ;
    if ioCurrentBank != branchFinalBank then
      error mEndOfPartLocation:"This branch does not leave bank selection value unchanged";
    end if ;
    if ioBlockLabel->string == "" then
      error mEndOfPartLocation:"This branch makes the next code unreachable";
    end if ;
    ioGeneratedBlockList += ![@ipic18Block new
      ![@uint max] # relocatable
      !ioBlockLabel
      !ioGeneratedInstructionList
      ![@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
    ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
    ioBlockLabel := conditionFalseLabel ;
  end foreach ;
end method ;

#----------------------------------------------------*

#!--- Block instruction

#----------------------------------------------------*

map @blockInstructionBlockMap {
  @pic18InstructionList mInstructionList ;
  @abstractBlockTerminationForBlockInstruction mBlockTerminaisonForBlockInstruction ;
  @location mEndOfBlock ;
  insert insertKey error message "the '%K' block is already declared" ;
  search searchKey error message "the '%K' block is not declared" ;
}

#----------------------------------------------------*

map @blockInitialBankSelectionMap {
  @uint mInitialBankSelection ;
  @string mSourceBlock ;
  insert insertKey error message "the '%K' block is already declared (internal error)" ;
  search searchKey error message "the '%K' block is not declared (internal error)" ;
}

#----------------------------------------------------*

abstract method @abstractBlockTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ??@blockInstructionBlockMap inBlockMap
  ??@string inCurrentBlockName
  ??@uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration
;

#----------------------------------------------------*

override method @exitBlockTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset unused ioVisitedBlockSet
  ??@blockInstructionBlockMap unused inBlockMap
  ??@string inCurrentBlockName
  ??@uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool unused ioContinueAccessibilityExploration
:
  ioContinuesInSequence := true ;
  if [ioBlockInitialBankSelectionMap hasKey !"-"] then
    [ioBlockInitialBankSelectionMap searchKey !["-" nowhere] ??@uint otherInitialBlockSetting ??@string otherBlockName] ;
    if otherInitialBlockSetting != inInitialBlockSetting then
      error mLocation: "this block exits from block instruction and sets bank selection to "
      . if inInitialBlockSetting == [@uint max] then "no bank" else [inInitialBlockSetting string] end
      . ", '" . otherBlockName . "' block also exits, but sets bank selection to "
      . if otherInitialBlockSetting == [@uint max] then "no bank" else [otherInitialBlockSetting string] end
      . "; theses two settings should be the same"
      ;
    end if ;
  else
    [!?ioBlockInitialBankSelectionMap insertKey !["-" nowhere] !inInitialBlockSetting !inCurrentBlockName] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @gotoTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ??@blockInstructionBlockMap inBlockMap
  ??@string inCurrentBlockName
  ??@uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool unused ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration
:
  if not [ioVisitedBlockSet hasKey !mNextBlock->string] then
    ioVisitedBlockSet += !mNextBlock->string ;
    ioContinueAccessibilityExploration := true ;
    [inBlockMap searchKey !mNextBlock ?* ?* ?*] ;
    if [ioBlockInitialBankSelectionMap hasKey !mNextBlock->string] then
      [ioBlockInitialBankSelectionMap searchKey !mNextBlock ??@uint otherInitialBlockSetting ??@string otherBlockName] ;
      if otherInitialBlockSetting != inInitialBlockSetting then
        error mNextBlock: "this block goes to '" . mNextBlock . "' block and sets bank selection to "
        . if inInitialBlockSetting == [@uint max] then "no bank" else [inInitialBlockSetting string] end
        . ", '" . otherBlockName . "' block goes to the same block, but sets bank selection to "
        . if otherInitialBlockSetting == [@uint max] then "no bank" else [otherInitialBlockSetting string] end
        . "; theses two settings should be the same"
        ;
      end if ;
    else
      [!?ioBlockInitialBankSelectionMap insertKey !mNextBlock !inInitialBlockSetting !inCurrentBlockName] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------*

override method @testTerminationForBlockInstruction addVisitedBlocks
  ?!@stringset ioVisitedBlockSet
  ??@blockInstructionBlockMap inBlockMap
  ??@string inCurrentBlockName
  ??@uint inInitialBlockSetting
  ?!@blockInitialBankSelectionMap ioBlockInitialBankSelectionMap
  ?!@bool ioContinuesInSequence
  ?!@bool ioContinueAccessibilityExploration
:
  [mTrueTermination addVisitedBlocks
    !?ioVisitedBlockSet 
    !inBlockMap 
    !inCurrentBlockName 
    !inInitialBlockSetting 
    !?ioBlockInitialBankSelectionMap 
    !?ioContinuesInSequence 
    !?ioContinueAccessibilityExploration
  ] ;
  [mFalseTermination addVisitedBlocks
    !?ioVisitedBlockSet
    !inBlockMap
    !inCurrentBlockName
    !inInitialBlockSetting
    !?ioBlockInitialBankSelectionMap
    !?ioContinuesInSequence
    !?ioContinueAccessibilityExploration
  ] ;
end method ;

#----------------------------------------------------*

abstract method @abstractBlockTerminationForBlockInstruction generateBlock
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@stringset ioUsedRegisters
  ??@string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator
;

#----------------------------------------------------*

override method @gotoTerminationForBlockInstruction generateBlock
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?!@stringset unused ioUsedRegisters
  ??@string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator
:
  outTerminator := [@ipic18JumpTerminator new
    !mNextBlock->location
    ![@lstring new !inLabelForBlock . mNextBlock !mNextBlock->location]
    ![@jumpInstructionKind ipicRelative]
  ] ;
end method ;

#----------------------------------------------------*

override method @exitBlockTerminationForBlockInstruction generateBlock
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ?!@stringset unused ioUsedRegisters
  ??@string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator
:
  outTerminator := [@ipic18JumpTerminator new
    !mLocation
    ![@lstring new !inLabelForBlock . "_exit" !mLocation]
    ![@jumpInstructionKind ipicRelative]
  ] ;
end method ;

#----------------------------------------------------*

override method @testTerminationForBlockInstruction generateBlock
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ?!@stringset ioUsedRegisters
  ??@string inLabelForBlock
  !@ipic18AbstractBlockTerminator outTerminator
:
  const @lstring conditionTrueLabel [new !".L" . [ioLocalLabelIndex string] !mLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring conditionFalseLabel [new !".L" . [ioLocalLabelIndex string] !mLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Generate condition
  [mCondition analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !conditionFalseLabel
    !?ioUsedRegisters
    ?outTerminator
  ] ;
#--- Generation true condition block
  [mTrueTermination generateBlock
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !?ioUsedRegisters
    !inLabelForBlock
    ??@ipic18AbstractBlockTerminator trueTerminator
  ] ;
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !conditionTrueLabel
    ![@ipic18SequentialInstructionList emptyList]
    !trueTerminator
  ] ;
#--- Generation false condition block
  [mFalseTermination generateBlock
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !?ioUsedRegisters
    !inLabelForBlock
    ??@ipic18AbstractBlockTerminator falseTerminator
  ] ;
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !conditionFalseLabel
    ![@ipic18SequentialInstructionList emptyList]
    !falseTerminator
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18Instruction_block analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
#----------------- Block labels prefix
  const @string labelForBlock := ".L" . [ioLocalLabelIndex string] . "_" ; 
  ioLocalLabelIndex ++ ;
#---------------- Save current block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !ioBlockLabel
    !ioGeneratedInstructionList
    ![@ipic18JumpTerminator new
      !mStartBlockName->location
      ![@lstring new !labelForBlock . mStartBlockName !mStartBlockName->location]
      ![@jumpInstructionKind ipicRelative]
    ]
  ] ;
  ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
#--- Compute block map
  @blockInstructionBlockMap blockMap [emptyMap] ;
  foreach mBlockList do
    [!?blockMap insertKey !mBlockName !mInstructionList !mBlockTerminaisonForBlockInstruction !mEndOfBlock] ;
  end foreach ;
#--- Check start block is declared
  [blockMap searchKey !mStartBlockName ?* ?* ?*] ;
  @blockInitialBankSelectionMap blockInitialBankSelectionMap [emptyMap] ;
  [!?blockInitialBankSelectionMap insertKey !mStartBlockName !ioCurrentBank !""] ;
#--- Compute block accessiblity
  @stringset accessibleBlockSet [setWithString !mStartBlockName->string] ;
  @stringset handledBlockSet [emptySet] ;
  @bool continueAccessibilityExploration := true ;
  @bool continuesInSequence := false ;
  loop [mBlockList length] + 1 : while continueAccessibilityExploration do
    continueAccessibilityExploration := false ;
    for currentBlockName in accessibleBlockSet - handledBlockSet do
      handledBlockSet += !currentBlockName ;
      [blockMap searchKey
        ![currentBlockName nowhere]
        ??@pic18InstructionList instructionList
        ??@abstractBlockTerminationForBlockInstruction blockTermination
        ??@location endOfBlock
      ] ;
    #--- Generate code
      [blockInitialBankSelectionMap searchKey ![currentBlockName nowhere] ?@uint currentBank ?*] ;
      ioBlockLabel := [@lstring new !labelForBlock . currentBlockName ![blockMap locationForKey !currentBlockName]] ;
      analyzeInstructionList
        !instructionList
        !?ioGeneratedBlockList
        !inAccessBankSplitOffset
        !inRoutineMap
        !inRegisterTable
        !inDataMap
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioBlockLabel
        !?ioListFileContents
        !?currentBank
        !inShouldPreserveBSR
        !inRoutineKind
        !?ioUsedRegisters
      ;
      [blockTermination generateBlock
        !inAccessBankSplitOffset
        !currentBank
        !inRegisterTable
        !?ioLocalLabelIndex
        !?ioGeneratedBlockList
        !?ioUsedRegisters
        !labelForBlock
        ??@ipic18AbstractBlockTerminator terminator
      ] ;
      if ioBlockLabel->string == "" then
        error endOfBlock : "execution will not reach the end of the block, but endless block is not allowed" ;
      end if ;
      ioGeneratedBlockList += ![@ipic18Block new
        ![@uint max] # relocatable
        !ioBlockLabel
        !ioGeneratedInstructionList
        !terminator
      ] ;
      ioGeneratedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
    #---
      [blockTermination addVisitedBlocks !?accessibleBlockSet !blockMap !currentBlockName !currentBank !?blockInitialBankSelectionMap !?continuesInSequence !?continueAccessibilityExploration] ;
    end for ;
  end loop ;
#--- Useless blocks ?
  foreach mBlockList do
    if not [accessibleBlockSet hasKey !mBlockName->string] then
      warning mBlockName:"this block is not accessible from '" . mStartBlockName . "' block" ;
    end if ;
  end foreach ;
#---
  if continuesInSequence then
    ioBlockLabel := [@lstring new !labelForBlock . "_exit" !mStartBlockName->location] ;
    [blockInitialBankSelectionMap searchKey !["-" nowhere] ?ioCurrentBank ?*] ;
  else
    ioBlockLabel := ["" nowhere] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- analyze condition

#----------------------------------------------------*

abstract method @pic18ConditionExpression analyzeCondition
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
;

#----------------------------------------------------*

override method @pic18BccInStructuredCondition analyzeCondition
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset unused ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
#--- Save terminator of current block
  outCurrentBlockTerminator := [@ipic18ConditionalJumpTerminator new
    !mConditionLocation
    !mCondition
    !inConditionTrueLabel
    ![@conditionalBranchMode native]
    !inConditionFalseLabel
    ![@conditionalBranchMode native]
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18RegisterComparisonCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
#--- Handle comparison
  @ipic18RegisterComparison ipicComparison ;
  @bool complementaryBranch ;
  switch mComparison
  when equal :
    ipicComparison := [@ipic18RegisterComparison registerEqualsToW] ;
    complementaryBranch := false ;
  when greater :
    ipicComparison := [@ipic18RegisterComparison registerGreaterThanW] ;
    complementaryBranch := false ;
  when lower :
    ipicComparison := [@ipic18RegisterComparison registerLowerThanW] ;
    complementaryBranch := false ;
  when greaterOrEqual :
    ipicComparison := [@ipic18RegisterComparison registerLowerThanW] ;
    complementaryBranch := true ;
  when lowerOrEqual :
    ipicComparison := [@ipic18RegisterComparison registerGreaterThanW] ;
    complementaryBranch := true ;
  when notEqual :
    ipicComparison := [@ipic18RegisterComparison registerEqualsToW] ;
    complementaryBranch := true ;
  end switch ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if complementaryBranch then
    outCurrentBlockTerminator := [@pic18RegisterComparisonTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !ipicComparison
    ] ;
  else
    outCurrentBlockTerminator := [@pic18RegisterComparisonTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !ipicComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18IncDecRegisterInCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBranchIfZero then
    outCurrentBlockTerminator := [@ipic18IncDecRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  else
    outCurrentBlockTerminator := [@ipic18IncDecRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18RegisterTestCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
    !?ioUsedRegisters
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBranchIfZero then
    outCurrentBlockTerminator := [@pic18TestRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
    ] ;
  else
    outCurrentBlockTerminator := [@pic18TestRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18BitTestInStructuredCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ??@bitSliceTable bitSliceTable
    !?ioUsedRegisters
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ??@uint bitNumber
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBTFSSinstruction then
    outCurrentBlockTerminator := [@pic18BitTestTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !bitNumber
    ] ;
  else
    outCurrentBlockTerminator := [@pic18BitTestTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !bitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @pic18NegateCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mCondition analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionFalseLabel
    !inConditionTrueLabel
    !?ioUsedRegisters
    ?outCurrentBlockTerminator
  ] ;
end method ;

#----------------------------------------------------*

override method @pic18AndCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  ?!@stringset ioUsedRegisters
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
#--- Create an intermdiate label for handling true condition of left expression
  const @lstring conditionTrueLabel [new !".L" . [ioLocalLabelIndex string] !inConditionTrueLabel->location] ; 
  ioLocalLabelIndex ++ ;
#--- Left expression
  [mLeftExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !inConditionFalseLabel
    !?ioUsedRegisters
    ?outCurrentBlockTerminator
  ] ;
#--- Right expression
  [mRightExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionTrueLabel
    !inConditionFalseLabel
    !?ioUsedRegisters
    ?@ipic18AbstractBlockTerminator secondTestBlockTerminator
  ] ;
#--- Create a new block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !conditionTrueLabel
    ![@ipic18SequentialInstructionList emptyList]
    !secondTestBlockTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Routines

#----------------------------------------------------------------------------*

local routine analyzeInstructionList
  ??@pic18InstructionList inInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18SequentialInstructionList ioGeneratedInstructionList
  ?!@lstring ioBlockLabel
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ??@routineKind inRoutineKind
  ?!@stringset ioUsedRegisters
:
  foreach inInstructionList do
    if ioBlockLabel->string == "" then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      ioBlockLabel := ["?" nowhere] ;
    end if ;
    [mInstruction analyze
      !inAccessBankSplitOffset
      !?ioGeneratedBlockList
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioBlockLabel
      !?ioListFileContents
      !?ioCurrentBank
      !inShouldPreserveBSR
      !inRoutineKind
      !?ioUsedRegisters
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               A N A L Y Z E    D A T A    S E C T I O N                    *
#                                                                            *
#----------------------------------------------------------------------------*

local routine pic18_analyze_data_sections
  ??@dataList inDataDefinitionList
  ??@registerTable inRegisterTable
  ??@constantMap inConstantMap
  ?!@string ioListFileContents
  !@pic18_dataMap outDataMap
  ?!@constantMap ioConstantMap
  ?!@stringset ioUsedRegisters
:
  outDataMap := [@pic18_dataMap emptyMap] ;
  foreach inDataDefinitionList
  before
    ioListFileContents .= "*******************************************************************************\n" ;
    ioListFileContents .= "*                    D A T A    D E C L A R A T I O N                         *\n" ;
    ioListFileContents .= "*******************************************************************************\n\n" ;
  do
    ioListFileContents .= "Data '" . mDataName . "', " . [mValueList length] . " words (" . [mValueList length] * 2 . " bytes).\n" ; 
    [!?ioConstantMap insertKey ![@lstring new !mDataName->string . "_BYTE_COUNT" !mDataName->location] ![[mValueList length] * 2 sint64]] ;
    @uintlist data [emptyList] ;
    foreach mValueList do
      [mExpression eval !inRegisterTable !inConstantMap ??@sint64 value !?ioUsedRegisters] ;
      if value < 0LS then
        error mErrorLocation: "data value is " . value . " (negative)" ;
      elsif value > 65535LS then
        error mErrorLocation: "data value is " . value . " (greater than 2**16-1)" ;
      else
        data += ![value uint] ;
      end if ;
    end foreach ;
    [!?outDataMap insertKey !mDataName !data] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine build_ipic18_block_representation_list
  ??@string inSourceFileName
  ??@sint64 inROMSize
  ??@sint64 inRAMSize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForBootloaderImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ??@luint inBootloaderReservedROMsize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForUserProgramImplementation
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ??@declaredByteMap inDeclaredByteMap
  ??@pic18RoutineDefinitionList inRoutineDefinitionList
  ??@programKind inProgramKind
  ??@constantDefinitionList inConstantDefinitionList
  ??@dataList inDataList
  ??@pic18InterruptDefinitionList inInterruptDefinitionList
  ??@lstringlist inUnusedRegisterList
  ??@ramBankTable inRamBank
  ??@bool inHasHighInterrupt
  ??@bool inHasLowInterrupt
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@actualConfigurationMap inActualConfigurationMap
  ??@location inEndOfProgram
  ?!@string ioListFileContents
:
#-------------------------------- Build routine map
  @routineMap routineMap [emptyMap] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach inRoutineDefinitionList do
    if ([mRequiredBank uint] != [@uint max]) & ([mRequiredBank uint] > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15" ;
    end if ;
    if ([mReturnedBank uint] != [@uint max]) & ([mReturnedBank uint] > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15" ;
    end if ;
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
#-------------------------------- Build constant map
  @constantMap constantMap [emptyMap] ;
#--- Add "ROM_SIZE" and "RAM_SIZE" constants
  [!?constantMap insertKey ![@lstring new !"ROM_SIZE" !here] !inROMSize] ;
  [!?constantMap insertKey ![@lstring new !"RAM_SIZE" !here] !inRAMSize] ;
#--- Add "BOOTLOADER_RESERVED_SIZE" constant
  if inProgramKind != [@programKind regularProgram] then
    @lstring bootloaderSizeString [new !"BOOTLOADER_RESERVED_SIZE" !here] ;
    [!?constantMap insertKey !bootloaderSizeString ![[inBootloaderReservedROMsize uint] sint64]] ;
  end if ;
#--- Add declared constants
  @stringset usedRegisters [emptySet] ;
  foreach inConstantDefinitionList do
    [mExpression eval !inRegisterTable !constantMap ??@sint64 result !?usedRegisters] ;
    if [inRegisterTable hasKey ![mConstantName string]] then
      error mConstantName: "'" . mConstantName . "' is already declared as ram register or special register" ;
    else
      [!?constantMap insertKey !mConstantName !result] ;
    end if ;
  end foreach ;
#-------------------------------- Analyze Data
  pic18_analyze_data_sections
    !inDataList
    !inRegisterTable
    !constantMap
    !?ioListFileContents
    ??@pic18_dataMap dataMap
    !?constantMap
    !?usedRegisters
  ;
#-------------------------------- Print constant map
  print_constant_definition
    !constantMap
    !?ioListFileContents
  ;
#-------------------------------- Check the "main" routine is declared
  if inProgramKind != [@programKind userProgram] then
    if [routineMap hasKey !"main"] then
      @bool isNoReturn ;
      @uint requiredBank ;
      [routineMap searchKey ![@lstring new !"main" !here] ?isNoReturn ?requiredBank ?* ?*] ;
      if not isNoReturn then
        error here :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
      if requiredBank != 0 then
        error here :"the \"main\" should be declared with \"requiresbank 0\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
    else
      error inEndOfProgram : "the program should declare the \"main\" routine" ;
    end if ;
  end if ;
#-------------------------------- Generate bootloader entry points for user program
  @ipic18BlockList generatedBlockList [emptyList] ;
  @uint entryPoint := 0x04 ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !mRoutineName
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18ReturnTerminator new ![@location nowhere]]
    ] ;
    entryPoint := entryPoint + 4 ;
    if entryPoint == 0x08 then
      entryPoint := 0x0C ;
    elsif entryPoint == 0x18 then
      entryPoint := 0x1C ;
    end if ;
  end foreach ;
#-------------------------------- Generate user program entry points for user program
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_user_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#-------------------------------- At zero, generate 'jump main' block
  if inProgramKind != [@programKind userProgram] then
    generatedBlockList += ![@ipic18Block new
      !0
      ![".START" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["main" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x04, generate the first bootloader entry point (if any)
  @routineDeclarationList tempBootloaderRoutineDeclarationList := inBootloaderRoutineDeclarationListForBootloaderImplementation ;
  if [tempBootloaderRoutineDeclarationList length] > 0 then
    [!?tempBootloaderRoutineDeclarationList popFirst ?@lstring routineName ?* ?* ?* ?*] ;
    generatedBlockList += ![@ipic18Block new
      !0x04
      !["_entry_bootloader_04" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !routineName->location !routineName ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x08, generate 'bra _high_interrupt' instruction, if fast interrupt is defined
  if inHasHighInterrupt then
    generatedBlockList += ![@ipic18Block new
      !0x08
      ![".HIGH_INTERRUPT" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["_high_interrupt" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x0C, 0x10, 0x14, generate the bootloader entry points (if they exists)
  entryPoint := 0x0C ;
  loop [tempBootloaderRoutineDeclarationList length] :
  while ([tempBootloaderRoutineDeclarationList length] > 0) & (entryPoint < 0x18) 
  do
    [!?tempBootloaderRoutineDeclarationList popFirst ?@lstring routineName ?* ?* ?* ?*] ;
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_bootloader_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !routineName->location !routineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 0x4 ;
  end loop ;
#-------------------------------- Generate JUMP to low interrupt (if any)
  if inHasLowInterrupt then
    generatedBlockList += ![@ipic18Block new
      !0x18
      ![".LOW_INTERRUPT" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["_low_interrupt" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- Generate entry points for remaining bootloader routines
  entryPoint := 0x1C ;
  foreach tempBootloaderRoutineDeclarationList do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_bootloader_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 0x4 ;
  end foreach ;
  drop tempBootloaderRoutineDeclarationList ;
#-------------------------------- Generate low interrupt routine (if any)
  @uint localLabelIndex := 0 ;
  if inHasLowInterrupt then
    foreach inInterruptDefinitionList do
      if [mInterruptName string] == "low" then
        @uint currentBank [max] ; # No bank
        @ipic18SequentialInstructionList generatedInstructionList[ emptyList] ;
        @lstring currentBlockLabel [new !"_low_interrupt" !mInterruptName->location] ;
        analyzeInstructionList
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !?localLabelIndex
          !?generatedInstructionList
          !?currentBlockLabel
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ![@routineKind interruptRoutine]
          !?usedRegisters
        ;
        if currentBlockLabel->string == "" then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
        end if ;
      #--- Enter last block
        generatedBlockList += ![@ipic18Block new
          ![@uint max] # relocatable
          !currentBlockLabel
          !generatedInstructionList
          ![@ipic18RetfieTerminator new !mInterruptName->location !mFastReturn]
        ] ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Generate high interrupt routine (if any)
  if inHasHighInterrupt then
    foreach inInterruptDefinitionList do
      if [mInterruptName string] == "high" then
        @uint currentBank [max] ; # No bank
        @ipic18SequentialInstructionList generatedInstructionList[ emptyList] ;
        @lstring currentBlockLabel [new !"_high_interrupt" !mInterruptName->location] ;
        analyzeInstructionList
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !?localLabelIndex
          !?generatedInstructionList
          !?currentBlockLabel
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ![@routineKind interruptRoutine]
          !?usedRegisters
        ;
        if currentBlockLabel->string == "" then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
        end if ;
      #--- Enter last block
        generatedBlockList += ![@ipic18Block new
          ![@uint max] # relocatable
          !currentBlockLabel
          !generatedInstructionList
          ![@ipic18RetfieTerminator new !mInterruptName->location !true]
        ] ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Generate routines
  foreach inRoutineDefinitionList do
    @uint currentBank := [mRequiredBank uint] ;
    @routineKind routineKind ;
    if mIsNoReturn then
      routineKind := [@routineKind noReturnRoutine] ;
    else
      routineKind := [@routineKind regularRoutine] ;
    end if ;
    @ipic18SequentialInstructionList generatedInstructionList[ emptyList] ;
    @lstring currentBlockLabel := mRoutineName ;
    analyzeInstructionList
      !mInstructionList
      !?generatedBlockList
      !inAccessBankSplitOffset
      !routineMap
      !inRegisterTable
      !dataMap
      !constantMap
      !?localLabelIndex
      !?generatedInstructionList
      !?currentBlockLabel
      !?ioListFileContents
      !?currentBank
      !mPreservesBank
      !routineKind
      !?usedRegisters
    ;
    const @bool continuesInSequence := currentBlockLabel->string != "" ;
    #--- Enter last block
    if continuesInSequence then
      generatedBlockList += ![@ipic18Block new
        ![@uint max] # relocatable
        !currentBlockLabel
        !generatedInstructionList
        ![@ipic18ReturnTerminator new !mRoutineName->location]
      ] ;
    end if ;
  #---
    if (not mIsNoReturn) & ([mReturnedBank uint] != [@uint max]) & (currentBank != [mReturnedBank uint]) then
      error mRoutineName:"execution will not set bank selection to " . [mReturnedBank uint] ;
    end if ;
    if mIsNoReturn & continuesInSequence then
      error mRoutineName:"execution should not reach the end of a \"noreturn\" routine" ;
    end if ;
  end foreach ;
#-------------------------------- Add computed goto, rcall, ... utility routines
#  They wil be removed by optimizer if there are useless
#--- Description of register WREG
  @registerExpression WREGregister [new ![@lstring new !"WREG" !here] ![@luint new !0 !here]] ;
  [WREGregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression WREG_IPICregisterDescription
    ?*
    !?usedRegisters
  ] ;
#--- Description of register TOSL
  @registerExpression TOSLregister [new ![@lstring new !"TOSL" !here] ![@luint new !0 !here]] ;
  [TOSLregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSL_IPICregisterDescription
    ?*
    !?usedRegisters
  ] ;
#--- Description of register TOSH
  @registerExpression TOSHregister [new ![@lstring new !"TOSH" !here] ![@luint new !0 !here]] ;
  [TOSHregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSH_IPICregisterDescription
    ?*
    !?usedRegisters
  ] ;
#--- Description of register TOSU
  @registerExpression TOSUregister [new ![@lstring new !"TOSU" !here] ![@luint new !0 !here]] ;
  [TOSUregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSU_IPICregisterDescription
    ?*
    !?usedRegisters
  ] ;
#---
  const @ipic18SequentialInstruction ADDWF_WREG := [@ipic18_intermediate_instruction_FDA new
    !here
    ![@pic18Instruction_FDA_base_code_AST ADDWF]
    !WREG_IPICregisterDescription
    !true
  ] ; # ADDWF WREG, W

#--- computed_goto4
  const @ipic18Block goto4Block [new
    ![@uint max] # Relocatable
    !["_computed_goto_4" nowhere]
    ![@ipic18SequentialInstructionList listWithValue !ADDWF_WREG]
    ![@ipic18JumpTerminator new ![@location nowhere] !["_computed_goto_2" nowhere] ![@jumpInstructionKind ipicRelative]]
  ] ;
  generatedBlockList += !goto4Block ;
#--- computed_goto2
  @ipic18SequentialInstructionList goto2InstructionList [emptyList] ;
  goto2InstructionList += !ADDWF_WREG ;
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@pic18Instruction_FDA_base_code_AST ADDWF]
    !TOSL_IPICregisterDescription
    !false
  ] ; # ADDWF TOSL, F
  goto2InstructionList += ![@ipic18_intermediate_instruction_literalOperation new
    !here
    ![@literal_instruction_opcode MOVLW]
    !0
  ] ; # MOVLW 0
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@pic18Instruction_FDA_base_code_AST ADDWFC]
    !TOSH_IPICregisterDescription
    !false
  ] ; # ADDWFC TOSH, F
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@pic18Instruction_FDA_base_code_AST ADDWFC]
    !TOSU_IPICregisterDescription
    !false
  ] ; # ADDWFC TOSU, F
#--- computed_goto2
  const @ipic18Block goto2Block [new
    ![@uint max] # Relocatable
    !["_computed_goto_2" nowhere]
    !goto2InstructionList
    ![@ipic18ReturnTerminator new ![@location nowhere]]
  ] ;
  generatedBlockList += !goto2Block ;
#-------------------------------- Generate default user routines
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    if mIsNoReturn then
      generatedBlockList += ![@ipic18Block new
        !entryPoint
        !mRoutineName
        ![@ipic18SequentialInstructionList emptyList]
        ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
      ] ;
    else
      @ipic18SequentialInstructionList instructionList [emptyList] ;
      if [mReturnedBank uint] != [@uint max] then
        instructionList += ![@ipic18_intermediate_instruction_MOVLB new !here !mReturnedBank] ;
      end if ;
      generatedBlockList += ![@ipic18Block new
        !entryPoint
        !mRoutineName
        !instructionList
        ![@ipic18ReturnTerminator new ![@location nowhere]]
      ] ;
      end if ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#----------------------------------------------------------- Check declared bytes are used
  @stringset unusedDeclarationUnicity [emptySet] ;
  foreach inUnusedRegisterList do
    if not [inRegisterTable hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' byte is not declared" ;
    elsif [unusedDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is already declared as unused" ;
    elsif [usedRegisters hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is declared as unused, but is used" ;
    end if ;
    unusedDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach inDeclaredByteMap do
    if (not [usedRegisters hasKey !lkey->string]) & (not [unusedDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' byte is unused" ;
    end if ;
  end foreach ;
#----------------------------------------------------------- Display block list
  displayBlockList !"INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList ;
#----------------------------------------------------------- Optimize
  if [@uint errorCount] == 0 then
    ipic18OptimizeBlocks !?ioListFileContents !?generatedBlockList ;
    displayBlockList !"OPTIMIZED INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList ;
  end if ;
#----------------------------------------------------------- Optimize block ordering
  if [@uint errorCount] == 0 then
    ipic18OptimizeBlockOrdering
      !inSourceFileName
      !?ioListFileContents
      !?generatedBlockList
    ;
  end if ;
#----------------------------------------------------------- relative branch and jump resolution
  if [@uint errorCount] == 0 then
    ipic18RelativesResolution
      !?ioListFileContents
      !?generatedBlockList
    ;
  end if ;
#----------------------------------------------------------- Check and compute stack requirements
  if ([@uint errorCount] == 0) & (inProgramKind != [@programKind userProgram]) then
    ipic18StackComputations
      !?ioListFileContents
      !generatedBlockList
    ;
  end if ;
#----------------------------------------------------------- Generate code
  if [@uint errorCount] == 0 then
    ipic18GenerateCode
      !inSourceFileName
      !inProgramKind
      ![inBootloaderReservedROMsize uint]
      ![inROMSize uint]
      !inProcessorName
      !inPredefinedRegisters
      !inRegisterTable
      !dataMap
      !inActualConfigurationMap
      !?ioListFileContents
      !generatedBlockList
      ??@uint usedROMsize
    ;
  #----------------------------------------------------------- Print usage
    if [option.verbose_output value] then
      @string verboseMessage := "Resource usage:\n" ;
      verboseMessage .= "  ROM size: " . inROMSize . " bytes;" ;
      verboseMessage .= " used: " . [usedROMsize string] . " bytes (" ;
      verboseMessage .= [(usedROMsize * 100) / inROMSize string] . "%).\n" ;
      foreach inRamBank do
        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
        verboseMessage .= "  RAM bank '" . lkey . "': " ;
        verboseMessage .= [bankSize string] . " bytes, used " ;
        verboseMessage .= [usedSize string] . " bytes (" ;
        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
      end foreach ;
      message verboseMessage ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;

