semantics ipic18_build_block_representation :
import "ipic18_optimize_block.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "intermediate_generic.gSemantics" ;
import "ipic18_block_ordering.gSemantics" ;
import "ipic18_relatives_resolution.gSemantics" ;
import "ipic18_display_block_list.gSemantics" ;
import "piccolo_options.gOption" ;
import "ipic18_code_generation.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Register analysis

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpression
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  !@ipic18_intermediate_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  @uint registerAddress := 0 ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
    registerAddress := mValue ;
  end foreach ;
  @bool needsBSRaccess := false ;
  if not found then
    needsBSRaccess := true ;
    [registerAddressList first ?registerAddress] ;
    @uint neededBank := registerAddress >> 8 ;
    if (neededBank != inCurrentBank) then
      @string errorMessage := "Accessing the '" . mRegisterName . "' needs the bank selection set to " . [neededBank string] ;
      if inCurrentBank == [@uint max] then
        errorMessage .= ", but current bank selection cannot be known" ;
      else
        errorMessage .= ", but current bank selection is set to " . [inCurrentBank string] ;
      end if ;
      error mRegisterName: errorMessage ;
    end if ;
  end if ;
#---
  outIPICregisterDescription := [@ipic18_intermediate_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
    !needsBSRaccess
  ] ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression analyzeRegisterExpressionWithoutCheckingBank
  ??@registerTable inRegisterTable
  !@ipic18_intermediate_registerExpressionWithoutBSRIndication outIPICregisterDescription
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?@uint registerAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  outIPICregisterDescription := [@ipic18_intermediate_registerExpressionWithoutBSRIndication new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------------------------------*

reader @registerExpression getRegisterAddress
  ??@registerTable inRegisterTable
  -> @uint outRegisterAddress
:
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?outRegisterAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Simple Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloSimpleInstruction analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
;

#----------------------------------------------------------------------------*

override method @instruction_withNoOperand analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18InstructionWithNoOperand new
    !mInstructionLocation
    !mKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FDA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_FDA new
    !mInstructionLocation
    !mInstruction_FDA_base_code
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
  @FA_sequential_instruction_base_code code ;
  switch mFAinstruction
  when CLRF : code := [@FA_sequential_instruction_base_code CLRF] ;
  when MOVWF : code := [@FA_sequential_instruction_base_code MOVWF] ;
  when MULWF : code := [@FA_sequential_instruction_base_code MULWF] ;
  when NEGF : code := [@FA_sequential_instruction_base_code NEGF] ;
  when SETF : code := [@FA_sequential_instruction_base_code SETF] ;
  when CPFSEQ, CPFSGT, CPFSLT, TSTFSZ :
    error [@location nowhere] : "*** INTERNAL ERROR ***" : code ;
  end switch ;
#enum @FA_sequential_instruction_base_code {
#  , , , , 
#}{
#}
  outInstruction := [@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    !code
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVFF analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  [mSourceRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication sourceIPICregisterDescription
  ] ;
  [mDestinationRegisterName analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication destinationIPICregisterDescription
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !sourceIPICregisterDescription
    !destinationIPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FBA analyzeSimpleInstruction
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression IPICregisterDescription
    ?@bitSliceTable bitSliceTable
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?@uint bitNumber
  ] ;
  outInstruction := [@ipic18_intermediate_instruction_FBA new
    !mInstructionLocation
    !mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_literalOperation analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint result] ;
#---
   if (result > 255S) | (result < -128S) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be betwween -128 and 255)" ;
   end if ;
#---  
  outInstruction := [@ipic18_intermediate_instruction_literalOperation new
    !mInstructionLocation
    !mLiteralInstruction
    ![result & 0x000000FFS uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_LFSR analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  if [mFSRindex uint] > 2 then
    error mFSRindex:"the LFSR register idx (" . [[mFSRindex uint] string] . ") should be lower or equal to 2" ;
  end if ;
#---
  @sint result ; [mImmediatExpression eval !inRegisterTable !inConstantMap ?result] ;
#---
  if (result > 0xFFFS) | (result < 0S) then
    error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 4095)" ;
  end if ;
  outInstruction := [@ipic18_intermediate_instruction_LFSR new
    !mInstructionLocation
    !mFSRindex
    ![result uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JSR analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a BRA, GOTO, Bcc or JUMP instruction" ;
  end if ;
  if not preservesBank then
    ioCurrentBank := returnedBank ;
    if inShouldPreserveBSR then
      error mTargetLabel:"the routine call should preserve bank selection" ;
    end if ;
  end if ;
#---
  outInstruction := [@ipic18_intermediate_JSR new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction analysis

#----------------------------------------------------------------------------*

abstract method @pic18PiccoloInstruction analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block unused ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
;

#----------------------------------------------------------------------------*

override method @pic18PiccoloSimpleInstruction analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [selfcopy analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioCurrentBank
    !inShouldPreserveBSR
    ??@ipic18SequentialInstruction instruction
  ] ;
  ioCurrentBlock->mInstructionList += !instruction ;
end method ;

#----------------------------------------------------*

override method @instruction_FOREVER analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
  const @uint finalBank := ioCurrentBank ;
#--- Get loop label
  const @lstring label0 [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Set a jump terminator to current block
  ioCurrentBlock->mTerminator := [@ipic18JumpTerminator new !mInstructionLocation !label0 ![@jumpInstructionKind ipicRelative]] ;
#--- Store current block
  ioGeneratedBlockList += !ioCurrentBlock ;
#--- Create a new block
  ioCurrentBlock := [@ipic18Block new
    ![@uint max] # relocatable
    !label0
    ![@ipic18SequentialInstructionList emptyList]
    ![@ipic18JumpTerminator new !mInstructionLocation !label0 ![@jumpInstructionKind ipicRelative]]
  ] ;
  analyzeInstructionList
    !mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioCurrentBlock
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind 
  ;
#--- Check instruction list does not change bank
  if ioCurrentBank != finalBank then
    error mEndOfInstructionList:"instruction list does not leave BSR value unchanged";
  end if ;
#---
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------*

override method @instruction_nobanksel analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block unused ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"nobank\" here: BSR should be preserved (use it in a \"banksave\" construct)" ;
  end if ;
  ioCurrentBank := [@uint max] ;
#--- Generates no code
end method ;

#----------------------------------------------------*

override method @instruction_savebank analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Get values for BSR register
  const @registerExpression BSRregister [new ![@lstring new !"BSR" !here] ![@luint new !0 !here]] ;
  [BSRregister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication BSR_IPICregisterDescription
  ] ;
#--- Get values for register used for saving
  [mRegister analyzeRegisterExpressionWithoutCheckingBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpressionWithoutBSRIndication save_IPICregisterDescription
  ] ;
#--- Generate "MOVFF BSR, save_register" instruction
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !BSR_IPICregisterDescription
    !save_IPICregisterDescription
  ] ;
#--- Generate instruction list
  @uint finalBank := ioCurrentBank ;
  analyzeInstructionList
    !mInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioCurrentBlock
    !?ioListFileContents
    !?finalBank
    !false # Do not preserve bank now
    ?ioContinuesInSequence
    !inRoutineKind 
  ;
  if not ioContinuesInSequence then
    error mEndOfSaveBankInstruction:"useless saving: execution does reach the end of \"savebank\" instruction list" ;
  end if ;
#--- Generate "MOVFF save_register, BSR" instruction
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !save_IPICregisterDescription
    !BSR_IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_banksel analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  if [mBankIndex uint] > 15 then
    error mBankIndex:"selected bank idx should be lower or equal to 15" ;
    ioCurrentBank := [@uint max] ; # No selected bank
  elsif [mBankIndex uint] != ioCurrentBank then
    ioCurrentBank := [mBankIndex uint] ;
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_MOVLB new !mInstructionLocation !mBankIndex] ;
  elsif mWarningOnUselessBanksel then
    warning mBankIndex:"useless instruction: the bank " . [ioCurrentBank string] . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_banksel_register analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  const @uint registerAddress := [mRegisterExpression getRegisterAddress !inRegisterTable] ;
  const @uint newBank := registerAddress >> 8 ;
  if ioCurrentBank != newBank then
    ioCurrentBank := newBank ;
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_MOVLB new
      !mInstructionLocation
      ![@luint new !newBank ![mRegisterExpression mRegisterName]->location]
    ] ;
  elsif mWarningOnUselessBanksel then
    warning [mRegisterExpression mRegisterName]:"useless instruction: the bank " . newBank . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLRD analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18_intermediate_instruction_TBLRD new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLWT analyzeSimpleInstruction
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  !@ipic18SequentialInstruction outInstruction
:
  outInstruction := [@ipic18_intermediate_instruction_TBLWT new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_MNOP analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor:"occurrence argument is zero: no generated code" ;
  end if ;
#---
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_MNOP new
    !mInstructionLocation
    !mOccurrenceFactor
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_LTBLPTR analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ??@sint result] ;
#---
  if (result > 0xFF_FFFF_S) | (result < 0S) then
    error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 0xFF_FFFF)" ;
  end if ;
  const @uint address := [result uint] ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
  ] ;
  const @uint upper := address >> 16 ;
  if upper == 0 then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif upper == 0xFF then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !upper
    ] ;
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  const @uint high := (address >> 8) & 0xFF ;
  if high == 0 then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif high == 0xFF then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !high
    ] ;
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  const @uint low := address & 0xFF ;
  if low == 0 then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif low == 0xFF then
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !low
    ] ;
    ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_sequential_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_LDATAPTR analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [inDataMap searchKey !mDataName ??@uintlist data] ;
#--- Check index
  if [mDataIndex uint] >= [data length] then
    error mDataIndex: "index should be < " . [data length] ;
  end if ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@ipic18_intermediate_registerExpression outIPICregisterDescription
    ?*
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !16
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !8
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !mDataName
    ![mDataIndex uint] * 2
    !0
  ] ;
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_sequential_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
end method ;

#----------------------------------------------------*

override method @instruction_JUMP analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#--- Check instruction
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
  ioContinuesInSequence := false ;
#--- Set terminator of current block
  ioCurrentBlock->mTerminator := [@ipic18JumpTerminator new !mInstructionLocation !mTargetLabel ![@jumpInstructionKind ipicRelative]] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_rcall analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  @bool allPreserveBank := true ;
  @bool someReturnsBank := false ;
  @uint returnedBankSelection := ioCurrentBank ;
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if isNoReturn then
      error mValue:"for being named in a computed rcall, the '" . mValue . "' routine should be declared without the \"noreturn\" qualifier" ;
  end if ;
     if inShouldPreserveBSR & not preservesBank then
       error mValue:"the '" . mValue . "' routine should preserved bank selection" ;
     elsif (not inShouldPreserveBSR) & not preservesBank then
       if not someReturnsBank then
         returnedBankSelection := returnedBank ;
         someReturnsBank := true ;
       elsif returnedBankSelection != returnedBank then 
         @string errorMessage := "the '" . mValue . "' routine returns " ;
         if returnedBank == [@uint max] then
           errorMessage .= "no bank selection" ;
         else
           errorMessage .= "bank selection set to  ". [returnedBank string] ;
         end if ;
         errorMessage .= ", but previous routine(s) return(s) " ;
         if returnedBankSelection == [@uint max] then
           errorMessage .= "no bank selection" ;
         else
           errorMessage .= "bank selection set to  ". [returnedBankSelection string] ;
         end if ;
         error mValue: errorMessage ;
       end if ;
     elsif (not inShouldPreserveBSR) & preservesBank then
     end if ;
  end foreach ;
#---
  ioContinuesInSequence := true ;
  ioCurrentBank := returnedBankSelection ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  @ipic18SequentialInstructionList targetInstructionList [emptyList] ;
  foreach mTargetLabels do
    targetInstructionList += ![@ipic18_intermediate_JSR new !mInstructionLocation !mValue ![@jumpInstructionKind relative]] ;
  end foreach ;
#---
  ioCurrentBlock->mInstructionList += ![@ipic18_intermediate_instruction_computed_rcall new
    !mInstructionLocation
    !targetInstructionList
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_goto analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if not isNoReturn then
      error mValue:"for being named in a computed goto, the '" . mValue . "' routine should be declared with the \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept computed goto instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed goto instruction" ;
  end switch ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- Set terminator of current block
  ioCurrentBlock->mTerminator := [@ipic18ComputedGotoTerminator new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_retlw analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine : # ok
  when noReturnRoutine :
    error mInstructionLocation:"a \"noreturn\" routine does not accept computed retlw instruction" ;
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed retlw instruction" ;
  end switch ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mImmediateExpressionList length] then
    error mInstructionLocation:"the constant list length (" . [[mImmediateExpressionList length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- 
  @uintlist literalValues [emptyList] ;
  foreach mImmediateExpressionList index idx do
    @sint v ; [mExpression eval !inRegisterTable !inConstantMap ?v] ;
    if (v > 255S) | (v < -128S) then
      error mInstructionLocation:"immediate value with idx " . [idx string] . " is evaluated as " . [v string] . " (should be <= 255)" ;
    end if ;
    literalValues += ![v & 0x000000FFS uint] ;
  end foreach ;
#--- Set terminator of current block
  ioCurrentBlock->mTerminator := [@ipic18ComputedRETLWTerminator new
    !mInstructionLocation
    !literalValues
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JUMPCC analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap unused  inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [inRoutineMap searchKey !mTargetLabel ??@bool isNoReturn ??@uint requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
#---
  @conditionalBranchMode mode ;
  if mIsBcc then
    mode := [@conditionalBranchMode native] ;
  else
    mode := [@conditionalBranchMode ipicBRA] ;
  end if ;
#--- Create the continuation label
  const @lstring label0 [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Save terminator of current block
  const @ipic18AbstractBlockTerminator terminator := ioCurrentBlock->mTerminator ;
#--- Save terminator of current block
  ioCurrentBlock->mTerminator := [@ipic18ConditionalJumpTerminator new
    !mInstructionLocation
    !mConditionalBranch
    !mTargetLabel
    !mode
    !label0
    !mode
  ] ;
#--- Create a new block with saved terminator
  ioCurrentBlock := [@ipic18Block new
    ![@uint max] # relocatable
    !label0
    ![@ipic18SequentialInstructionList emptyList]
    !terminator
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_bra analyze
  ??@uint unused inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  @bool allPreserveBankSetting := true ;
  @bool allReturnBank := true ;
  @uint returnedBankValue [max] ;
  foreach mTargetLabels do
    [inRoutineMap searchKey !mValue ??@bool isNoReturn ??@uint requiredBank ??@uint returnedBank ??@bool preservesBank] ;
  #--- Check bank "requires"
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;    
  #--- Check bank "preserved", "ensures"
    if preservesBank then
      allReturnBank := false ;
    elsif (returnedBankValue != [@uint max]) & (returnedBankValue != returnedBank) then
      error mValue:"this routine ensures setting of bank '" . [returnedBank string] . "', but "
      . "previous routine(s) ensure setting of bank '" . [returnedBankValue string] . "'." ;
    else
      allPreserveBankSetting := false ;
      returnedBankValue := returnedBank ;
    end if ;
    if ([@routineKind regularRoutine ] != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed bra from a regular routine, the '" . mValue . "' routine should be declared without any \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
#---
  if allReturnBank & not allPreserveBankSetting then
    ioCurrentBank := returnedBankValue ;
  elsif (not allReturnBank) & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine should either all preserve bank, eihter return the same selected bank" ;
  end if ;
  if inShouldPreserveBSR & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine(s) do(es) not preserve bank selection" ;
  end if ;
#---
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
#    error mInstructionLocation:"a regular routine does not accept computed bra instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed bra instruction" ;
  end switch ;
#---
  [mSizeExpression eval !inRegisterTable !inConstantMap ??@sint size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- Set terminator of current block
  ioCurrentBlock->mTerminator := [@ipic18ComputedBraTerminator new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_BitTest analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#--- Analyze condition
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ??@bitSliceTable bitSliceTable
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ??@uint bitNumber
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioCurrentBlock->mInstructionList += ![@ipic18_skip_instruction_BitTestSkip new
    !mInstructionLocation
    !embeddedInstruction
    !mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @ipic18_compare_register_instruction_base_code baseCode ;
  switch mOpCode
    when CPFSEQ : baseCode := [@ipic18_compare_register_instruction_base_code CPFSEQ] ;
    when CPFSGT : baseCode := [@ipic18_compare_register_instruction_base_code CPFSGT] ;
    when CPFSLT : baseCode := [@ipic18_compare_register_instruction_base_code CPFSLT] ;
    when TSTFSZ : baseCode := [@ipic18_compare_register_instruction_base_code TSTFSZ] ;
  end switch ;
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioCurrentBlock->mInstructionList += ![@ipic18_skip_instruction_compare_register new
    !mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_IncDec analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  @skip_instruction_FDA_base_code baseCode ;
  if mIncrement & mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code INCFSZ] ;
  elsif mIncrement & not mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code INFSNZ] ;
  elsif (not mIncrement) & mSkipIfZero then
    baseCode := [@skip_instruction_FDA_base_code DECFSZ] ;
  else
    baseCode := [@skip_instruction_FDA_base_code DCFSNZ] ;
  end if ;
#---
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
#--- Analyze embedded instruction
  @uint currentBank := ioCurrentBank ;
  [mEmbeddedInstruction analyzeSimpleInstruction
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?currentBank
    !inShouldPreserveBSR
    ??@ipic18SequentialInstruction embeddedInstruction
  ] ;
#--- Embedded instruction changes bank ?
  if currentBank != currentBank then
    error [mEmbeddedInstruction mInstructionLocation] : "this instruction does not preserve bank setting" ;
  end if ;
#--- Generate instruction
  ioCurrentBlock->mInstructionList += ![@ipic18_skip_instruction_FDA new
    !mInstructionLocation
    !embeddedInstruction
    !baseCode
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_structured_if analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Labels
  const @lstring conditionTrueLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring conditionFalseLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring exitLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#---- Analyze condition
  [mIfCondition analyzeCondition
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !conditionFalseLabel
    ?@ipic18AbstractBlockTerminator testTerminator
  ] ;
#--- Save terminator of current block
  @ipic18AbstractBlockTerminator currentBlockTerminator :=  ioCurrentBlock->mTerminator ;
#--- Close current block
  ioCurrentBlock->mTerminator := testTerminator ;
  ioGeneratedBlockList += !ioCurrentBlock ;
#--- Create an new block, for instruction exit
  ioCurrentBlock := [@ipic18Block new
    ![@uint max] # relocatable
    !exitLabel
    ![@ipic18SequentialInstructionList emptyList]
    !currentBlockTerminator
  ] ;
  @uint elseBranchFinalBank := ioCurrentBank ;
  @uint thenBranchFinalBank := ioCurrentBank ;
#--- Analyze 'then' instruction list
  @ipic18Block thenBlock [new
    ![@uint max] # relocatable
    !conditionTrueLabel
    ![@ipic18SequentialInstructionList emptyList]
    ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
  ] ;
  analyzeInstructionList
    !mThenInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?thenBlock
    !?ioListFileContents
    !?thenBranchFinalBank
    !inShouldPreserveBSR
    ??@bool thenContinuesInSequence
    !inRoutineKind
  ;
  ioGeneratedBlockList += !thenBlock ;
#--- Analyze 'else' instruction list
  @ipic18Block elseBlock [new
    ![@uint max] # relocatable
    !conditionFalseLabel
    ![@ipic18SequentialInstructionList emptyList]
    ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
  ] ;
  analyzeInstructionList
    !mElseInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?elseBlock
    !?ioListFileContents
    !?elseBranchFinalBank
    !inShouldPreserveBSR
    ??@bool elseContinuesInSequence
    !inRoutineKind
  ;
  ioGeneratedBlockList += !elseBlock ;
#---
  if elseBranchFinalBank == thenBranchFinalBank then
    ioCurrentBank := elseBranchFinalBank ;
  else
    error mEndOfElsePartLocation:"This branch does not leave BSR value as the first one does";
    elseBranchFinalBank := [@uint max] ; # No available value for BSR
  end if ;
#---
  ioContinuesInSequence := thenContinuesInSequence | elseContinuesInSequence ;
end method ;

#----------------------------------------------------*

override method @instruction_do_while analyze
  ??@uint inAccessBankSplitOffset
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Labels
  const @lstring startLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
  const @lstring exitLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
  ioLocalLabelIndex ++ ;
#--- Save terminator of current block
  const @ipic18AbstractBlockTerminator currentBlockTerminator :=  ioCurrentBlock->mTerminator ;
#--- Close current block
  ioCurrentBlock->mTerminator := [@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]] ;
  ioGeneratedBlockList += !ioCurrentBlock ;
#--- Create an new block, for repeated instruction list
  ioCurrentBlock := [@ipic18Block new
    ![@uint max] # relocatable
    !startLabel
    ![@ipic18SequentialInstructionList emptyList]
    !currentBlockTerminator
  ] ;
  @uint repeatedBranchFinalBank := ioCurrentBank ;
  analyzeInstructionList
    !mRepeatedInstructionList
    !?ioGeneratedBlockList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioCurrentBlock
    !?ioListFileContents
    !?repeatedBranchFinalBank
    !inShouldPreserveBSR
    ??@bool repeatedInstructionsContinuesInSequence
    !inRoutineKind
  ;
  if ioCurrentBank != repeatedBranchFinalBank then
    error mEndOfRepeatedInstructionList:"This branch does not leave BSR value unchanged";
  end if ;
  if not repeatedInstructionsContinuesInSequence then
    error mEndOfRepeatedInstructionList:"This branch makes the next code unreachable";
  end if ;
#--- While branches
  foreach mWhilePartList do
  #--- Labels
    const @lstring conditionTrueLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
    ioLocalLabelIndex ++ ;
    const @lstring conditionFalseLabel [new !"_label_" . [ioLocalLabelIndex string] !mInstructionLocation] ; 
    ioLocalLabelIndex ++ ;
  #---- Analyze condition
    [mCondition analyzeCondition
      !inAccessBankSplitOffset
      !ioCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !?ioGeneratedBlockList
      !conditionTrueLabel
      !conditionFalseLabel
      ?@ipic18AbstractBlockTerminator testTerminator
    ] ;
    ioCurrentBlock->mTerminator := testTerminator ;
    ioGeneratedBlockList += !ioCurrentBlock ;
    ioCurrentBlock := [@ipic18Block new
      ![@uint max] # relocatable
      !conditionTrueLabel
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mInstructionLocation !startLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
    @uint branchFinalBank := ioCurrentBank ;
    analyzeInstructionList
      !mInstructionList
      !?ioGeneratedBlockList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioCurrentBlock
      !?ioListFileContents
      !?branchFinalBank
      !inShouldPreserveBSR
      ??@bool branchInstructionsContinuesInSequence
      !inRoutineKind
    ;
    if ioCurrentBank != branchFinalBank then
      error mEndOfPartLocation:"This branch does not leave BSR value unchanged";
    end if ;
    if not branchInstructionsContinuesInSequence then
      error mEndOfPartLocation:"This branch makes the next code unreachable";
    end if ;
    ioGeneratedBlockList += !ioCurrentBlock ;
    ioCurrentBlock := [@ipic18Block new
      ![@uint max] # relocatable
      !conditionFalseLabel
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mInstructionLocation !exitLabel ![@jumpInstructionKind ipicRelative]]
    ] ;
  end foreach ;
  ioGeneratedBlockList += !ioCurrentBlock ;
#--- Create an new block, for instruction exit
  ioCurrentBlock := [@ipic18Block new
    ![@uint max] # relocatable
    !exitLabel
    ![@ipic18SequentialInstructionList emptyList]
    !currentBlockTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- analyze condition

#----------------------------------------------------*

abstract method @conditionExpression analyzeCondition
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition analyzeCondition
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
#--- Save terminator of current block
  outCurrentBlockTerminator := [@ipic18ConditionalJumpTerminator new
    !mConditionLocation
    !mCondition
    !inConditionTrueLabel
    ![@conditionalBranchMode native]
    !inConditionFalseLabel
    ![@conditionalBranchMode native]
  ] ;
end method ;

#----------------------------------------------------*

override method @registerComparisonCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
#--- Handle comparison
  @ipic18RegisterComparison ipicComparison ;
  @bool complementaryBranch ;
  switch mComparison
  when equal :
    ipicComparison := [@ipic18RegisterComparison registerEqualsToW] ;
    complementaryBranch := false ;
  when greater :
    ipicComparison := [@ipic18RegisterComparison registerGreaterThanW] ;
    complementaryBranch := false ;
  when lower :
    ipicComparison := [@ipic18RegisterComparison registerLowerThanW] ;
    complementaryBranch := false ;
  when greaterOrEqual :
    ipicComparison := [@ipic18RegisterComparison registerLowerThanW] ;
    complementaryBranch := true ;
  when lowerOrEqual :
    ipicComparison := [@ipic18RegisterComparison registerGreaterThanW] ;
    complementaryBranch := true ;
  when notEqual :
    ipicComparison := [@ipic18RegisterComparison registerEqualsToW] ;
    complementaryBranch := true ;
  end switch ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if complementaryBranch then
    outCurrentBlockTerminator := [@pic18RegisterComparisonTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !ipicComparison
    ] ;
  else
    outCurrentBlockTerminator := [@pic18RegisterComparisonTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !ipicComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @incDecRegisterInCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBranchIfZero then
    outCurrentBlockTerminator := [@ipic18IncDecRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  else
    outCurrentBlockTerminator := [@ipic18IncDecRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @registerTestCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBranchIfZero then
    outCurrentBlockTerminator := [@pic18TestRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
    ] ;
  else
    outCurrentBlockTerminator := [@pic18TestRegisterTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ?!@ipic18BlockList unused ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mRegisterExpression analyzeRegisterExpression
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression IPICregisterDescription
    ??@bitSliceTable bitSliceTable
  ] ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ??@uint bitNumber
  ] ;
#--- Save terminator of current block
  const @location location := [mRegisterExpression mRegisterName]->location ;
  if mBTFSSinstruction then
    outCurrentBlockTerminator := [@pic18BitTestTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !bitNumber
    ] ;
  else
    outCurrentBlockTerminator := [@pic18BitTestTerminator new
      !location
      ![@ipic18JumpTerminator new !location !inConditionFalseLabel ![@jumpInstructionKind ipicRelative]]
      ![@ipic18JumpTerminator new !location !inConditionTrueLabel ![@jumpInstructionKind ipicRelative]]
      !IPICregisterDescription
      !bitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @negateCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
  [mCondition analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionFalseLabel
    !inConditionTrueLabel
    ?outCurrentBlockTerminator
  ] ;
end method ;

#----------------------------------------------------*

override method @andCondition analyzeCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@lstring inConditionTrueLabel
  ??@lstring inConditionFalseLabel
  !@ipic18AbstractBlockTerminator outCurrentBlockTerminator
:
#--- Create an intermdiate label for handling true condition of left expression
  const @lstring conditionTrueLabel [new !"_label_" . [ioLocalLabelIndex string] !inConditionTrueLabel->location] ; 
  ioLocalLabelIndex ++ ;
#--- Left expression
  [mLeftExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !conditionTrueLabel
    !inConditionFalseLabel
    ?outCurrentBlockTerminator
  ] ;
#--- Right expression
  [mRightExpression analyzeCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !?ioGeneratedBlockList
    !inConditionTrueLabel
    !inConditionFalseLabel
    ?@ipic18AbstractBlockTerminator secondTestBlockTerminator
  ] ;
#--- Create a new block
  ioGeneratedBlockList += ![@ipic18Block new
    ![@uint max] # relocatable
    !conditionTrueLabel
    ![@ipic18SequentialInstructionList emptyList]
    !secondTestBlockTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Routines

#----------------------------------------------------------------------------*

local routine analyzeInstructionList
  ??@instructionList inInstructionList
  ?!@ipic18BlockList ioGeneratedBlockList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@pic18_dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@ipic18Block ioCurrentBlock
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  !@bool outContinuesInSequence
  ??@routineKind inRoutineKind
:
  outContinuesInSequence := true ;
  foreach inInstructionList do
    if not outContinuesInSequence then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      outContinuesInSequence := true ;
    end if ;
    [mInstruction analyze
      !inAccessBankSplitOffset
      !?ioGeneratedBlockList
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioCurrentBlock
      !?ioListFileContents
      !?ioCurrentBank
      !inShouldPreserveBSR
      !?outContinuesInSequence
      !inRoutineKind
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               A N A L Y Z E    D A T A    S E C T I O N                    *
#                                                                            *
#----------------------------------------------------------------------------*

local routine pic18_analyze_data_sections
  ??@dataList inDataDefinitionList
  ?!@string ioListFileContents
  !@pic18_dataMap outDataMap
  ?!@constantMap ioConstantMap
:
  outDataMap := [@pic18_dataMap emptyMap] ;
  foreach inDataDefinitionList
  before
    ioListFileContents .= "*******************************************************************************\n" ;
    ioListFileContents .= "*                    D A T A    D E C L A R A T I O N                         *\n" ;
    ioListFileContents .= "*******************************************************************************\n\n" ;
  do
    ioListFileContents .= "Data '" . mDataName . "', " . [mValueList length] . " words (" . [mValueList length] * 2 . " bytes).\n" ; 
    [!?ioConstantMap insertKey ![@lstring new !mDataName->string . "_BYTE_COUNT" !mDataName->location] ![[mValueList length] * 2 sint]] ;
    @uintlist data [emptyList] ;
    foreach mValueList do
      if mValue->uint > 65535 then
        error mValue: "data value is " . [mValue->uint hexString] . " (greater than 0xFFFF)" ;
      else
        data += !mValue->uint ;
      end if ;
    end foreach ;
    [!?outDataMap insertKey !mDataName !data] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine build_ipic18_block_representation_list
  ??@string inSourceFileName
  ??@piccoloDeviceModel inPiccoloDeviceModel
  ??@sint inRAMSize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForBootloaderImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ??@luint inBootloaderReservedROMsize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForUserProgramImplementation
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ??@piccoloModel inPiccoloModel
  ??@ramBankTable inRamBank
  ??@bool inHasHighInterrupt
  ??@bool inHasLowInterrupt
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@actualConfigurationMap inActualConfigurationMap
  ?!@string ioListFileContents
:
#-------------------------------- Build routine map
  @routineMap routineMap [emptyMap] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    if ([mRequiredBank uint] != [@uint max]) & ([mRequiredBank uint] > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15" ;
    end if ;
    if ([mReturnedBank uint] != [@uint max]) & ([mReturnedBank uint] > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15" ;
    end if ;
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
#-------------------------------- Build constant map
  @constantMap constantMap [emptyMap] ;
#--- Add "ROM_SIZE" and "RAM_SIZE" constants
  [!?constantMap insertKey ![@lstring new !"ROM_SIZE" !here] ![[[inPiccoloDeviceModel mRomSize] uint] sint]] ;
  [!?constantMap insertKey ![@lstring new !"RAM_SIZE" !here] !inRAMSize] ;
#--- Add "BOOTLOADER_RESERVED_SIZE" constant
  if inPiccoloModel->mProgramKind != [@programKind regularProgram] then
    @lstring bootloaderSizeString [new !"BOOTLOADER_RESERVED_SIZE" !here] ;
    [!?constantMap insertKey !bootloaderSizeString ![[inBootloaderReservedROMsize uint] sint]] ;
  end if ;
#--- Add declared constants
  foreach [inPiccoloModel mConstantDefinitionList] do
    @sint result ; [mExpression eval !inRegisterTable !constantMap ?result] ;
    if [inRegisterTable hasKey ![mConstantName string]] then
      error mConstantName: "'" . mConstantName . "' is already declared as ram register or special register" ;
    else
      [!?constantMap insertKey !mConstantName !result] ;
    end if ;
  end foreach ;
#-------------------------------- Analyze Data
  pic18_analyze_data_sections
    !inPiccoloModel->mDataList
    !?ioListFileContents
    ??@pic18_dataMap dataMap
    !?constantMap
  ;
#-------------------------------- Print constant map
  print_constant_definition
    !constantMap
    !?ioListFileContents
  ;
#-------------------------------- Check the "main" routine is declared
  if inPiccoloModel->mProgramKind != [@programKind userProgram] then
    if [routineMap hasKey !"main"] then
      @bool isNoReturn ;
      @uint requiredBank ;
      [routineMap searchKey ![@lstring new !"main" !here] ?isNoReturn ?requiredBank ?* ?*] ;
      if not isNoReturn then
        error here :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
      if requiredBank != 0 then
        error here :"the \"main\" should be declared with \"requiresbank 0\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
    else
      error [inPiccoloModel mEndOfProgram]: "the program should declare the \"main\" routine" ;
    end if ;
  end if ;
#-------------------------------- Generate bootloader entry points for user program
  @ipic18BlockList generatedBlockList [emptyList] ;
  @uint entryPoint := 0x04 ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !mRoutineName
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18ReturnTerminator new ![@location nowhere]]
    ] ;
    entryPoint := entryPoint + 4 ;
    if entryPoint == 0x08 then
      entryPoint := 0x0C ;
    elsif entryPoint == 0x18 then
      entryPoint := 0x1C ;
    end if ;
  end foreach ;
#-------------------------------- Generate user program entry points for user program
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForUserProgramImplementation do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_user_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#-------------------------------- At zero, generate 'jump main' block
  if inPiccoloModel->mProgramKind != [@programKind userProgram] then
    generatedBlockList += ![@ipic18Block new
      !0
      !["_entry_main" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["main" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x04, generate the first bootloader entry point (if any)
  @routineDeclarationList tempBootloaderRoutineDeclarationList := inBootloaderRoutineDeclarationListForBootloaderImplementation ;
  if [tempBootloaderRoutineDeclarationList length] > 0 then
    [!?tempBootloaderRoutineDeclarationList popFirst ?@lstring routineName ?* ?* ?* ?*] ;
    generatedBlockList += ![@ipic18Block new
      !0x04
      !["_entry_bootloader_04" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !routineName->location !routineName ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x08, generate 'bra _high_interrupt' instruction, if fast interrupt is defined
  if inHasHighInterrupt then
    generatedBlockList += ![@ipic18Block new
      !0x08
      !["_entry_high_interrupt" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["_high_interrupt" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- At 0x0C, 0x10, 0x14, generate the bootloader entry points (if they exists)
  entryPoint := 0x0C ;
  loop [tempBootloaderRoutineDeclarationList length] :
  while ([tempBootloaderRoutineDeclarationList length] > 0) & (entryPoint < 0x18) 
  do
    [!?tempBootloaderRoutineDeclarationList popFirst ?@lstring routineName ?* ?* ?* ?*] ;
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_bootloader_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !routineName->location !routineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 0x4 ;
  end loop ;
#-------------------------------- Generate JUMP to low interrupt (if any)
  if inHasLowInterrupt then
    generatedBlockList += ![@ipic18Block new
      !0x18
      !["_entry_low_interrupt" nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new ![@location nowhere] !["_low_interrupt" nowhere] ![@jumpInstructionKind ipicRelative]]
    ] ;
  end if ;
#-------------------------------- Generate entry points for remaining bootloader routines
  entryPoint := 0x1C ;
  foreach tempBootloaderRoutineDeclarationList do
    generatedBlockList += ![@ipic18Block new
      !entryPoint
      !["_entry_bootloader_" . [entryPoint xString] nowhere]
      ![@ipic18SequentialInstructionList emptyList]
      ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
    ] ;
    entryPoint := entryPoint + 0x4 ;
  end foreach ;
  drop tempBootloaderRoutineDeclarationList ;
#-------------------------------- Generate low interrupt routine (if any)
  @uint localLabelIndex := 0 ;
  if inHasLowInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        @ipic18Block currentBlock [new
          ![@uint max] # Relocatable
          ![@lstring new !"_low_interrupt" !mInterruptName->location]
          ![@ipic18SequentialInstructionList emptyList]
          ![@ipic18RetfieTerminator new !mInterruptName->location !mFastReturn]
        ] ;
        @uint currentBank [max] ; # No bank
        analyzeInstructionList
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !?localLabelIndex
          !?currentBlock
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ??@bool continuesInSequence
          ![@routineKind interruptRoutine]
        ;
        if not continuesInSequence then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
        end if ;
      #--- Enter last block
        generatedBlockList += !currentBlock ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Generate high interrupt routine (if any)
  if inHasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        @ipic18Block currentBlock [new
          ![@uint max] # Relocatable
          ![@lstring new !"_high_interrupt" !mInterruptName->location]
          ![@ipic18SequentialInstructionList emptyList]
          ![@ipic18RetfieTerminator new !mInterruptName->location !true]
        ] ;
        @uint currentBank [max] ; # No bank
        analyzeInstructionList
          !mInstructionList
          !?generatedBlockList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !dataMap
          !constantMap
          !?localLabelIndex
          !?currentBlock
          !?ioListFileContents
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ??@bool continuesInSequence
          ![@routineKind interruptRoutine]
        ;
        if not continuesInSequence then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
        end if ;
      #--- Enter last block
        generatedBlockList += !currentBlock ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Generate routines
#  const @lstring commonReturnTerminatorLabel [new !"_return_" ![@location nowhere]] ;
#  const @ipic18JumpTerminator commonReturnTerminator [new ![@location nowhere] !commonReturnTerminatorLabel ![@jumpInstructionKind ipicRelative]] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    @uint currentBank := [mRequiredBank uint] ;
    @routineKind routineKind ;
    if mIsNoReturn then
      routineKind := [@routineKind noReturnRoutine] ;
    else
      routineKind := [@routineKind regularRoutine] ;
    end if ;
    @ipic18Block currentBlock [new
      ![@uint max] # Relocatable
      !mRoutineName
      ![@ipic18SequentialInstructionList emptyList]
#      !commonReturnTerminator
      ![@ipic18ReturnTerminator new !mRoutineName->location]
    ] ;
    analyzeInstructionList
      !mInstructionList
      !?generatedBlockList
      !inAccessBankSplitOffset
      !routineMap
      !inRegisterTable
      !dataMap
      !constantMap
      !?localLabelIndex
      !?currentBlock
      !?ioListFileContents
      !?currentBank
      !mPreservesBank
      ??@bool continuesInSequence
      !routineKind
    ;
  #--- Enter last block
    generatedBlockList += !currentBlock ;
  #---
    if (not mIsNoReturn) & ([mReturnedBank uint] != [@uint max]) & (currentBank != [mReturnedBank uint]) then
      error mRoutineName:"execution will not set BSR to " . [[mReturnedBank uint] string] ;
    end if ;
    if mIsNoReturn & continuesInSequence then
      error mRoutineName:"execution should not reach the end of a \"noreturn\" routine" ;
    end if ;
  end foreach ;
#-------------------------------- Add common return block
#  generatedBlockList += ![@ipic18Block new
#    ![@uint max] # Relocatable
#    !commonReturnTerminatorLabel
#    ![@ipic18SequentialInstructionList emptyList]
#    ![@ipic18ReturnTerminator new ![@location nowhere]]
#  ] ;
#-------------------------------- Add computed goto, rcall, ... utility routines
#  They wil be removed by optimizer if there are useless
#--- Description of register WREG
  @registerExpression WREGregister [new ![@lstring new !"WREG" !here] ![@luint new !0 !here]] ;
  [WREGregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression WREG_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSL
  @registerExpression TOSLregister [new ![@lstring new !"TOSL" !here] ![@luint new !0 !here]] ;
  [TOSLregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSL_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSH
  @registerExpression TOSHregister [new ![@lstring new !"TOSH" !here] ![@luint new !0 !here]] ;
  [TOSHregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSH_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSU
  @registerExpression TOSUregister [new ![@lstring new !"TOSU" !here] ![@luint new !0 !here]] ;
  [TOSUregister analyzeRegisterExpression
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ??@ipic18_intermediate_registerExpression TOSU_IPICregisterDescription
    ?*
  ] ;
#---
  const @ipic18SequentialInstruction ADDWF_WREG := [@ipic18_intermediate_instruction_FDA new
    !here
    ![@instruction_FDA_base_code_AST ADDWF]
    !WREG_IPICregisterDescription
    !true
  ] ; # ADDWF WREG, W

#--- computed_goto4
  const @ipic18Block goto4Block [new
    ![@uint max] # Relocatable
    !["_computed_goto_4" nowhere]
    ![@ipic18SequentialInstructionList listWithValue !ADDWF_WREG]
    ![@ipic18JumpTerminator new ![@location nowhere] !["_computed_goto_2" nowhere] ![@jumpInstructionKind ipicRelative]]
  ] ;
  generatedBlockList += !goto4Block ;
#--- computed_goto2
  @ipic18SequentialInstructionList goto2InstructionList [emptyList] ;
  goto2InstructionList += !ADDWF_WREG ;
  goto2InstructionList += !ADDWF_WREG ;
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@instruction_FDA_base_code_AST ADDWF]
    !TOSL_IPICregisterDescription
    !false
  ] ; # ADDWF TOSL, F
  goto2InstructionList += ![@ipic18_intermediate_instruction_literalOperation new
    !here
    ![@literal_instruction_opcode MOVLW]
    !0
  ] ; # MOVLW 0
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@instruction_FDA_base_code_AST ADDWFC]
    !TOSH_IPICregisterDescription
    !false
  ] ; # ADDWFC TOSH, F
  goto2InstructionList += ![@ipic18_intermediate_instruction_FDA new
    !here
    ![@instruction_FDA_base_code_AST ADDWFC]
    !TOSU_IPICregisterDescription
    !false
  ] ; # ADDWFC TOSU, F
#--- computed_goto2
  const @ipic18Block goto2Block [new
    ![@uint max] # Relocatable
    !["_computed_goto_2" nowhere]
    !goto2InstructionList
    ![@ipic18ReturnTerminator new ![@location nowhere]]
  ] ;
  generatedBlockList += !goto2Block ;
#-------------------------------- Generate default user routines
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    if mIsNoReturn then
      generatedBlockList += ![@ipic18Block new
        !entryPoint
        !mRoutineName
        ![@ipic18SequentialInstructionList emptyList]
        ![@ipic18JumpTerminator new !mRoutineName->location !mRoutineName ![@jumpInstructionKind ipicRelative]]
      ] ;
    else
      @ipic18SequentialInstructionList instructionList [emptyList] ;
      if [mReturnedBank uint] != [@uint max] then
        instructionList += ![@ipic18_intermediate_instruction_MOVLB new !here !mReturnedBank] ;
      end if ;
      generatedBlockList += ![@ipic18Block new
        !entryPoint
        !mRoutineName
        !instructionList
        ![@ipic18ReturnTerminator new ![@location nowhere]]
      ] ;
      end if ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#----------------------------------------------------------- Display block list
  displayBlockList !"INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList ;
#----------------------------------------------------------- Optimize
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    ipic18OptimizeBlocks !?ioListFileContents !?generatedBlockList ;
    displayBlockList !"OPTIMIZED INTERMEDIATE BLOCK REPRESENTATION" !?ioListFileContents !generatedBlockList ;
  end if ;
#----------------------------------------------------------- Optimize block ordering
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    ipic18OptimizeBlockOrdering
      !inSourceFileName
      !?ioListFileContents
      !?generatedBlockList
    ;
  end if ;
#----------------------------------------------------------- relative branch and jump resolution
  if [@uint errorCount] == 0 then
    ipic18RelativesResolution
      !?ioListFileContents
      !?generatedBlockList
    ;
  end if ;
#----------------------------------------------------------- Generate code
  if [@uint errorCount] == 0 then
    ipic18GenerateCode
      !inSourceFileName
      !inProcessorName
      !inPredefinedRegisters
      !inRegisterTable
      !dataMap
      !inActualConfigurationMap
      !?ioListFileContents
      !generatedBlockList
      ??@uint usedROMsize
    ;
  #----------------------------------------------------------- Print usage
    if [option.verbose_output value] then
      @string verboseMessage := "Resource usage:\n" ;
      verboseMessage .= "  ROM size: " . [[[inPiccoloDeviceModel mRomSize] uint] string] . " bytes;" ;
      verboseMessage .= " used: " . [usedROMsize string] . " bytes (" ;
      verboseMessage .= [(usedROMsize * 100) / [[inPiccoloDeviceModel mRomSize] uint] string] . "%).\n" ;
      foreach inRamBank do
        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
        verboseMessage .= "  RAM bank '" . lkey . "': " ;
        verboseMessage .= [bankSize string] . " bytes, used " ;
        verboseMessage .= [usedSize string] . " bytes (" ;
        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
      end foreach ;
      message verboseMessage ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;

