semantics ipic18_cluster_ordering :
#import "ipic18_block_representation.gSemantics" ;
import "ipic18_relatives_resolution.gSemantics" ;

#----------------------------------------------------------------------------*

list @clusterList {
  @ipic18BlockList mBlockList ;
}

#----------------------------------------------------------------------------*

routine perform_cluster_ordering
  ??@clusterList inInitialClusterList
  ?!@ipic18BlockList ioBlockList
  ?!@string ioListFileContents
:
  const @uint clusterCount := [inInitialClusterList length] ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["CLUSTER ORDERING OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
  @string s := "Cluster ordering optimization (" . clusterCount . " cluster" . if clusterCount > 1 then "s" else "" end . "):\n" ;
  ioListFileContents .= s . "\n" ;
#---
  if [option.verbose_output value] then
    message s ;
  end if ;
#----
  @clusterList clusterList := inInitialClusterList ;
  @bool continue := true ;
  @uint pass := 0 ;
  loop [clusterList length] + 1 :
  while continue do
    pass ++ ;
    continue := false ;
    ioListFileContents .= "Pass " . pass . ":\n" ;
  #--- Build working block list and symbol table
    @ipic18BlockList workingBlockList [emptyList] ;
    @symbolTableForClusterOrdering symbolTable [emptyMap] ;
    foreach clusterList index clusterIndex do
      workingBlockList .= mBlockList ;
      foreach mBlockList do
#        message "   --  #" . clusterIndex . ": " . mBlock->mLabel . "\n" ;
        [!?symbolTable insertKey !mBlock->mLabel !clusterIndex] ;
      end foreach ;
    end foreach ;
  #--- Check for overflows
    ipic18RelativeBranchOverflow
      !workingBlockList
      ??@branchOverflowMap overflowMap
    ;
    @uint overflowCount := 0 ;
    foreach overflowMap do
      foreach mList do
        overflowCount ++ ;
        [symbolTable searchKey ![key nowhere] ??@uint sourceCluster] ;
        [symbolTable searchKey ![mValue nowhere] ??@uint targetCluster] ;
        ioListFileContents .= "  " . key . " (cluster #" . sourceCluster . ") --> " . mValue . " (cluster #" . targetCluster . ")\n" ;
      end foreach ;
    end foreach ;
    if [option.verbose_output value] then
      @string s := "  Pass " . pass . ": " ;
      if overflowCount == 0 then
        s .= "no branch overflow" ;
      elsif overflowCount == 1 then
        s .= "1 branch overflow" ;
      else
        s .= [overflowCount string] . " branch overflow" ;
      end if ;
      message s ;
    end if ;
  #--- Correction
    @bool correctionLoop := true ;
    foreach overflowMap while correctionLoop do
      foreach mList while correctionLoop do
        [symbolTable searchKey ![key nowhere] ??@uint sourceCluster] ;
        [symbolTable searchKey ![mValue nowhere] ??@uint targetCluster] ;
        if (sourceCluster + 1) == targetCluster then
          correctionLoop := false ;
          continue := true ;
          [!?clusterList removeAtIndex ??@ipic18BlockList last !targetCluster ] ;
          [!?clusterList removeAtIndex ??@ipic18BlockList first !sourceCluster ] ;
          [!?clusterList insertAtIndex !first . last !sourceCluster] ;
          ioListFileContents .= "  --> cluster #" . targetCluster . " merged into #" . sourceCluster . "\n" ;
          if [option.verbose_output value] then
            message " -> #" . targetCluster . " merged into #" . sourceCluster ;
          end if ;
        elsif sourceCluster == (targetCluster + 1) then
          correctionLoop := false ;
          continue := true ;
          [!?clusterList removeAtIndex ??@ipic18BlockList last !sourceCluster ] ;
          [!?clusterList removeAtIndex ??@ipic18BlockList first !targetCluster ] ;
          [!?clusterList insertAtIndex !first . last !targetCluster] ;
          ioListFileContents .= "  --> cluster #" . sourceCluster . " merged into #" . targetCluster . "\n" ;
          if [option.verbose_output value] then
            message " -> #" . sourceCluster . " merged into #" . targetCluster  ;
          end if ;
        elsif sourceCluster < targetCluster then
          correctionLoop := false ;
          continue := true ;
          [!?clusterList removeAtIndex ??@ipic18BlockList b !targetCluster ] ;
          [!?clusterList insertAtIndex !b !(targetCluster + sourceCluster) / 2 ] ;
          ioListFileContents .= "  --> cluster #" . targetCluster . " rolls downs to #" . ((targetCluster + sourceCluster) / 2) . "\n" ;
          if [option.verbose_output value] then
            message " -> #" . targetCluster . " rolls down to #" . ((targetCluster + sourceCluster) / 2) ;
          end if ;
        elsif sourceCluster > targetCluster then
          correctionLoop := false ;
          continue := true ;
          [!?clusterList removeAtIndex ??@ipic18BlockList b !sourceCluster ] ;
          [!?clusterList insertAtIndex !b !(targetCluster + sourceCluster) / 2 ] ;
          ioListFileContents .= "  --> cluster #" . sourceCluster . " rolls downs to #" . ((targetCluster + sourceCluster) / 2) . "\n" ;
          if [option.verbose_output value] then
            message " -> #" . sourceCluster . " rolls downs to #" . ((targetCluster + sourceCluster) / 2) ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
    if [option.verbose_output value] then
      message ".\n" ;
    end if ;
  end loop ;
  if [option.verbose_output value] then
    message "\n" ;
  end if ;
  ioListFileContents .= "\n" ;
#---------------------------------- Build the new ordered block list
  @ipic18BlockList newBlockList [emptyList] ;
#--- First insert absolute blocks from 0
  continue := true ;
  foreach ioBlockList while continue do
    continue := mBlock->mStartAddress != [@uint max] ;
    if continue then
      newBlockList += !mBlock ;
    end if ;
  end foreach ; 
#--- Insert sorted blocks 
  foreach clusterList do
    newBlockList .= mBlockList ;
  end foreach ;
#--- First insert absolute blocks from the end
  const @uint insertionIndex := [newBlockList length] ;
  continue := true ;
  foreach \down ioBlockList while continue do
    continue := mBlock->mStartAddress != [@uint max] ;
    if continue then
      [!?newBlockList insertAtIndex !mBlock !insertionIndex] ;
    end if ;
  end foreach ; 
#--- Set result
  ioBlockList := newBlockList ;
end routine ;      

#----------------------------------------------------------------------------*


end semantics ;