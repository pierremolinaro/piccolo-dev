semantics ipic18_cluster_ordering :
import "piccolo_options.gOption" ;
import "ipic18_relatives_resolution.gSemantics" ;

#----------------------------------------------------------------------------*

list @clusterList {
  @ipic18BlockList mBlockList ;
}

#----------------------------------------------------------------------------*

map @neededConversionForClusterOrder {
  @uint mConversions ;
  insert insertKey error message "the '%K' key is already declared in %L" ;
  search searchKey error message "the '%K' key is not declared" ;
}


#----------------------------------------------------------------------------*

local function sortKey ??@clusterList inClusterList -> @string outKey :
  outKey := "" ;
  foreach inClusterList
  do
    outKey .= [mBlockList mBlockAtIndex !0]->mLabel->string ;
  between 
    outKey .= "." ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

routine perform_cluster_ordering
  ??@clusterList inInitialClusterList
  ?!@ipic18BlockList ioBlockList
  ?!@string ioListFileContents
:
  const @bool optimize := [option piccolo_options.performOptimizations value]
    | [[option piccolo_options.optimizationFlags value] containsCharacter !'C'] ;
  if optimize then
    const @uint clusterCount := [inInitialClusterList length] ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . ["CLUSTER ORDERING OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    @string s := "Cluster ordering optimization (" . clusterCount . " cluster" . if clusterCount > 1 then "s" else "" end . "):\n" ;
    ioListFileContents .= s . "\n" ;
  #---
    if [option.verbose_output value] then
      message s ;
    end if ;
  #------------------- Optimization loop
    @clusterList clusterList := inInitialClusterList ;
    @neededConversionForClusterOrder neededConversionForClusterOrder [emptyMap] ;
    @bool continue := true ;
    @uint pass := 0 ;
    loop [clusterList length] * [clusterList length] :
    while continue do
      pass ++ ;
      ioListFileContents .= "Pass " . pass . ":\n" ;
    #--- Build working block list and symbol table
      @ipic18BlockList workingBlockList [emptyList] ;
      @symbolTableForClusterOrdering symbolTable [emptyMap] ;
      foreach clusterList index clusterIndex do
        workingBlockList .= mBlockList ;
        foreach mBlockList do
          [!?symbolTable insertKey !mBlock->mLabel !clusterIndex] ;
        end foreach ;
      end foreach ;
    #--- Add symbols from last relocatable blocks
      const @uint insertionIdx := [workingBlockList length] ;
      foreach > ioBlockList while continue do
        continue := mBlock->mAddress != [@uint max] ;
        if continue then
          [!?symbolTable insertKey !mBlock->mLabel ![@uint max]] ;
          [!?workingBlockList insertAtIndex !mBlock !insertionIdx] ;
        end if ;
      end foreach ; 
    #--- Check for overflows
      ipic18RelativeBranchOverflow
        !workingBlockList
        !ioBlockList # For entering absolute labels
        ??@branchOverflowMap overflowMap
      ;
      @uint overflowCount := 0 ;
      foreach overflowMap do
        foreach mList do
          overflowCount ++ ;
          [symbolTable searchKey ![key nowhere] ??@uint sourceCluster] ;
          [symbolTable searchKey ![mValue nowhere] ??@uint targetCluster] ;
          ioListFileContents .= "  " . key . " (cluster #" . sourceCluster . ") --> " . mValue . " (cluster #" . targetCluster . ")\n" ;
        end foreach ;
      end foreach ;
      [!?neededConversionForClusterOrder insertKey
        ![sortKey [!clusterList] nowhere]
        !overflowCount
      ] ;
      if [option.verbose_output value] then
        @string s := "  Pass " . pass . ": " ;
        if overflowCount == 0 then
          s .= "no branch overflow" ;
        elsif overflowCount == 1 then
          s .= "1 branch overflow" ;
        else
          s .= [overflowCount string] . " branch overflows" ;
        end if ;
        message s ;
      end if ;
    #--- Correction
      @bool correctionLoop := true ;
      foreach overflowMap while correctionLoop do
        foreach mList while correctionLoop do
          [symbolTable searchKey ![mValue nowhere] ??@uint targetCluster] ;
          if targetCluster != [@uint max] then
            [symbolTable searchKey ![key nowhere] ??@uint sourceCluster] ;
            if (sourceCluster + 1) == targetCluster then
              correctionLoop := false ;
              continue := true ;
              [!?clusterList removeAtIndex ??@ipic18BlockList last !targetCluster ] ;
              [!?clusterList removeAtIndex ??@ipic18BlockList first !sourceCluster ] ;
              [!?clusterList insertAtIndex !first . last !sourceCluster] ;
              const @string m := "merge #" . targetCluster . " into #" . sourceCluster . "]" ;
              ioListFileContents .= "  --> " . m . "\n" ;
              if [option.verbose_output value] then
                message " -> " . m ;
              end if ;
            elsif sourceCluster == (targetCluster + 1) then
              correctionLoop := false ;
              continue := true ;
              [!?clusterList removeAtIndex ??@ipic18BlockList last !sourceCluster ] ;
              [!?clusterList removeAtIndex ??@ipic18BlockList first !targetCluster ] ;
              [!?clusterList insertAtIndex !first . last !targetCluster] ;
              const @string m := "merge #" . sourceCluster . " into #" . targetCluster . "]" ;
              ioListFileContents .= "  --> " . m . "\n" ;
              if [option.verbose_output value] then
                message " -> " . m ;
              end if ;
            elsif sourceCluster < targetCluster then
              @clusterList candidate := clusterList ;
              [!?candidate removeAtIndex ??@ipic18BlockList b !targetCluster ] ;
              [!?candidate insertAtIndex !b !(targetCluster + sourceCluster) / 2 ] ;
              if not [neededConversionForClusterOrder hasKey !sortKey [!candidate]] then
                clusterList := candidate ;
                correctionLoop := false ;
                continue := true ;
                const @string m := "roll up [#" . ((targetCluster + sourceCluster) / 2) . ", #" . targetCluster . "]" ;
                ioListFileContents .= "  --> " . m . "\n" ;
                if [option.verbose_output value] then
                  message " -> " . m ;
                end if ;
              end if ;
            elsif sourceCluster > targetCluster then
              @clusterList candidate := clusterList ;
              [!?candidate removeAtIndex ??@ipic18BlockList b !sourceCluster ] ;
              [!?candidate insertAtIndex !b !(targetCluster + sourceCluster) / 2 ] ;
              if not [neededConversionForClusterOrder hasKey !sortKey [!candidate]] then
                clusterList := candidate ;
                correctionLoop := false ;
                continue := true ;
                const @string m := "roll up [#" . targetCluster. ", #" . ((targetCluster + sourceCluster) / 2) . "]" ;
                ioListFileContents .= "  --> " . m . "\n" ;
                if [option.verbose_output value] then
                  message " -> " . m ;
                end if ;
              end if ;
            end if ;
          end if ;
        end foreach ;
      end foreach ;
      if [option.verbose_output value] then
        message ".\n" ;
      end if ;
    end loop ;
    if [option.verbose_output value] then
      message "\n" ;
    end if ;
    ioListFileContents .= "\n" ;
  #---------------------------------- Build the new ordered block list
    @ipic18BlockList newBlockList [emptyList] ;
  #--- First insert absolute blocks from 0
    continue := true ;
    foreach ioBlockList while continue do
      continue := mBlock->mAddress != [@uint max] ;
      if continue then
        newBlockList += !mBlock ;
      end if ;
    end foreach ; 
  #--- Insert sorted blocks 
    foreach clusterList do
      newBlockList .= mBlockList ;
    end foreach ;
  #--- Insert absolute blocks from the end
    const @uint insertionIndex := [newBlockList length] ;
    continue := true ;
    foreach > ioBlockList while continue do
      continue := mBlock->mAddress != [@uint max] ;
      if continue then
        [!?newBlockList insertAtIndex !mBlock !insertionIndex] ;
      end if ;
    end foreach ; 
  #--- Set result
    ioBlockList := newBlockList ;
  end if ;
end routine ;      

#----------------------------------------------------------------------------*


end semantics ;