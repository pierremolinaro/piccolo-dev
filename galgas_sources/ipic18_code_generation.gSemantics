semantics ipic18_code_generation :
import "ipic18_relatives_resolution.gSemantics" ;
import "ipic18_display_block_list.gSemantics" ;
import "ipic18_regular_instructions.gSemantics" ;
import "ipic18_terminators.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "intermediate_generic.gSemantics" ;
import "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*

reader @uint x4string ->@string outResult :
  outResult := [selfcopy / 0x10_00 & 0xF xString] ;
  outResult .= [selfcopy / 0x10_0 & 0xF xString] ;
  outResult .= [selfcopy / 0x10_ & 0xF xString] ;
  outResult .= [selfcopy         & 0xF xString] ;
end reader ;

#----------------------------------------------------------------------------*

reader @uint x6string ->@string outResult :
  outResult := [selfcopy / 0x100_000 xString] ;
  outResult := [selfcopy / 0x10_000 & 0xF xString] ;
  outResult .= [selfcopy / 0x10_00 & 0xF xString] ;
  outResult .= [selfcopy / 0x10_0 & 0xF xString] ;
  outResult .= [selfcopy / 0x10_ & 0xF xString] ;
  outResult .= [selfcopy         & 0xF xString] ;
end reader ;

#----------------------------------------------------------------------------*

local routine generateLineWithCode
  ??@uint inAddress
  ??@codeList inCode
  ??@stringlist inIpicText
  ?!@string ioListFileContents
:
#--- Complete text with empty lines
  @stringlist ipicText := inIpicText ;
  loop [inCode length] + 1 :
  while [ipicText length] < [inCode length] do
    ipicText += !"" ;
  end loop ;
#---
  @uint address := inAddress ;
  foreach ipicText, inCode do
    ioListFileContents .= [address x6string] ;
    address := address + 2 * [mBinaryCode length] ;
    @string s := " " ;
    foreach mBinaryCode prefixedBy bin_ do
      s .= " " . [bin_mValue x4string] ;
    end foreach ;
    ioListFileContents .= [s stringByRightPadding !13 !' '];
    ioListFileContents .= [mAssemblyCode stringByRightPadding !50 !' '] ;
    ioListFileContents .= " " ;
    ioListFileContents .= mValue ;
    ioListFileContents .= "\n" ; 
  end foreach ;
#--- Display supplementary text
#  log ipicText, inCode ;
  foreach [ipicText subListFromIndex ![inCode length]] do
    ioListFileContents .= [address x6string] ;
    ioListFileContents .= ["" stringByRightPadding !64 !' '];
    ioListFileContents .= mValue ;
    ioListFileContents .= "\n" ; 
  end foreach ;
end routine ;
  
#----------------------------------------------------------------------------*

method @ipic18Block generateCode
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@uint inBlockAddress
  ??@string inNextBlockLabel
  ?!@string ioListFileContents
  ?!@string ioAssemblyString
:
  ioListFileContents .= "Addr.  Code       Assembly                                           Intermediate Representation\n" ;
  if mStartAddress == [@uint max] then # Relocatable
    generateLineWithCode
      !inBlockAddress
      ![@codeList listWithValue !mLabel->string . ":" ![@uintlist emptyList]]
      ![@stringlist listWithValue !"LABEL " . mLabel]
      !?ioListFileContents
    ;
    ioAssemblyString .= mLabel->string . ":\n" ;
  else
    @codeList cd [emptyList] ;
    cd += !"ORG " . [inBlockAddress hexString] ![@uintlist emptyList] ;
    cd += !mLabel->string . ":" ![@uintlist emptyList] ;
    generateLineWithCode
      !inBlockAddress
      !cd
      ![@stringlist listWithValue !"LABEL " . mLabel . ", ORG ". [inBlockAddress hexString]]
      !?ioListFileContents
    ;  
    ioAssemblyString .= "    ORG ". [inBlockAddress hexString] . "\n" ;
    ioAssemblyString .= mLabel->string . ":\n" ;
  end if ;
#--- Generate regular instructions
  @uint address := inBlockAddress ;
  foreach mInstructionList do
    [mInstruction generateCode
      !address
      !inSymbolTable
      ??@codeList code
    ] ;
    generateLineWithCode
      !address
      !code
      ![mInstruction instructionDisplay]
      !?ioListFileContents
    ;
    foreach code do
      foreach mBinaryCode do
        emitCode !mValue ;
      end foreach ;
      ioAssemblyString .= mAssemblyCode . "\n" ;
    end foreach ;
    address := address + [mInstruction instructionSize] ;
  #--- Check instruction size corresponds generated code size
    @uint generatedCodeSize := 0 ;
    foreach code do
      generatedCodeSize := generatedCodeSize + 2 * [mBinaryCode length] ;
    end foreach ;
    if generatedCodeSize != [mInstruction instructionSize] then
      @string s := "*** INTERNAL ERROR ** generated code size ("
      . generatedCodeSize . ") != instruction size (" . [mInstruction instructionSize] . ")" ;
      error [@location nowhere] : s ;
      ioListFileContents .= s . "\n" ;
    end if ;
  end foreach ;
#--- Generate block terminator
  [mTerminator generateCode
    !address
    !inSymbolTable
    !inNextBlockLabel
    ??@codeList code
  ] ;
  generateLineWithCode
    !address
    !code
    ![@stringlist listWithValue ![mTerminator terminatorDisplay !inNextBlockLabel]]
    !?ioListFileContents
  ;
  foreach code do
    foreach mBinaryCode do
      emitCode !mValue ;
    end foreach ;
    ioAssemblyString .= mAssemblyCode . "\n" ;
  end foreach ;
  #--- Check terminator size corresponds generated code size
    @uint generatedCodeSize := 0 ;
    foreach code do
      generatedCodeSize := generatedCodeSize + 2 * [mBinaryCode length] ;
    end foreach ;
    if generatedCodeSize != [mTerminator terminatorSize !inNextBlockLabel] then
      @string s := "*** INTERNAL ERROR ** generated code size ("
      . generatedCodeSize . ") != instruction size (" . [mTerminator terminatorSize !inNextBlockLabel] . ")" ;
      error [@location nowhere] : s ;
      ioListFileContents .= s . "\n" ;
    end if ;
#---
  ioListFileContents .= "\n" ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#        C O D E    G E N E R A T I O N                                      *
#                                                                            *
#----------------------------------------------------------------------------*

routine ipic18GenerateCode
  ??@string inSourceFileName
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@registerTable inAllRegisters
  ??@actualConfigurationMap inActualConfigurationMap
  ?!@string ioListFileContents
  ??@ipic18BlockList inGeneratedBlockList
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["CODE GENERATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
  if [option.verbose_output value] then
    message "Code generation:\n" ;
  end if ;
#--- Build address map
  computeLabelAbsoluteAddressMap
    !inGeneratedBlockList
    ??@symbolTableForRelativesResolution symbolTable
  ;
#--- Generate code
  @string assemblyString := "" ;
  @uint blockStartAddress := 0 ;
  foreach inGeneratedBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inGeneratedBlockList length] then
      nextBlockLabel := [inGeneratedBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
      setEmitAddress !blockStartAddress ;
    end if ;
    [mBlock generateCode !symbolTable !blockStartAddress !nextBlockLabel !?ioListFileContents !?assemblyString] ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
#----------------------------- Generate HEX file
#--- Add Configuration
  foreach inActualConfigurationMap do
    setEmitAddress !mRegisterAddress ;
    emitByte !mRegisterValue ;
  end foreach ;
#--- Generate file
  getGeneratedContents ??@string contents ;
  @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
  [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
#--- Generate contents in C file ?
  if [option piccolo_options.output_C_Array value] then
    const @string baseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
    get_C_ArrayImplementation !baseName ??@string cContents ;
    destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".c" ;
    [cContents writeToFileWhenDifferentContents !destinationFile ?*] ;
    get_C_ArrayHeader !baseName ??@string hContents ;
    destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".h" ;
    [hContents writeToFileWhenDifferentContents !destinationFile ?*] ;
  end if ;
#----------------------------- Generate assembly file ?
  if [option piccolo_options.generateAssembly value] & ([@uint errorCount] == 0) then
    pic18GenerateAssemblyFile
      !inSourceFileName
      !inProcessorName
      !inPredefinedRegisters
      !inAllRegisters
      !inActualConfigurationMap
      !assemblyString
    ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#        C O D E    G E N E R A T I O N                                      *
#                                                                            *
#----------------------------------------------------------------------------*

local routine pic18GenerateAssemblyFile
  ??@string inSourceFileName
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@registerTable inAllRegisters
  ??@actualConfigurationMap inActualConfigurationMap
  ??@string inAssemblyCode
:
  @string assemblyString := "  PROCESSOR " . inProcessorName . "\n" ;
#--- Code
  assemblyString .= ";--- Code\n" ;
  assemblyString .= inAssemblyCode ;
#--- Prefined registers
  assemblyString .= ";--- Prefefined registers\n" ;
  foreach inPredefinedRegisters do
    [mRegisterAddressList first ??@uint firstRegister] ;
    assemblyString .= [lkey string] . " EQU " . [firstRegister hexString] . "\n" ;
  end foreach ;
  assemblyString .= "\n\n" ;
#--- User defined registers in ram
  assemblyString .= ";--- User defined registers (in RAM)\n" ;
  foreach inAllRegisters do
    if not [inPredefinedRegisters hasKey ![lkey string]] then
      [mRegisterAddressList first ??@uint firstRegister] ;
      assemblyString .= [lkey string] . " EQU " . [firstRegister hexString] . "\n" ;
    end if ;
  end foreach ;
  assemblyString .= "\n\n" ;
#--- PICCOLO defined symbols
  assemblyString .= ";--- Piccolo defined symbols\n" ;
  assemblyString .= "W EQU 1\n" ;
  assemblyString .= "FAST EQU 1\n" ;
  assemblyString .= "BSR_ACCESS EQU 1\n\n" ;
#-------------------------------- Add Configuration
  if [inActualConfigurationMap count] > 0 then
    assemblyString .= ";--- Configuration\n\n" ;
    foreach inActualConfigurationMap do
      assemblyString .= "  __config " . [mRegisterAddress hexString] . ", " . [mRegisterValue & 255 hexString] . "\n" ;
    end foreach ;
  end if ;
#-------------------------------- End
  assemblyString .= ";---\n\n" ;
  assemblyString .= "  END\n\n" ;
#-------------------------------- Generate file
  const @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
 [assemblyString writeToFileWhenDifferentContents !asmDestinationFile ?*] ;
end routine ;

#----------------------------------------------------------------------------*



end semantics ;
