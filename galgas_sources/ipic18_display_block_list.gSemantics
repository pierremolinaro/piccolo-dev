semantics ipic18_display_block_list :
import "ipic18_block_representation.gSemantics" ;
import "ipic18_regular_instructions.gSemantics" ;
import "ipic18_terminators.gSemantics" ;

#----------------------------------------------------------------------------*

#! Block display

#----------------------------------------------------------------------------*

method @ipic18Block display
  ??@string inNextBlockLabel
  ?!@string ioListFileContents
:
  ioListFileContents .= "LABEL " . mLabel ;
  if mStartAddress != [@uint max] then
    ioListFileContents .= ", ORG " . [mStartAddress hexString] ;
  end if ;
  ioListFileContents .= ":\n" ;
#--- Instruction list
  foreach mInstructionList do
    const @stringlist d := [mInstruction instructionDisplay] ;
    foreach d do 
      ioListFileContents .= "  " . mValue . "\n" ;
    end foreach ;
  end foreach ;
#--- Terminator
  ioListFileContents .= "  " ;
  ioListFileContents .= [mTerminator terminatorDisplay !inNextBlockLabel] ;
  ioListFileContents .= "\n\n" ;
end method ;

#----------------------------------------------------------------------------*

#! Block list display

#----------------------------------------------------------------------------*

routine displayBlockList
  ??@string inTitle
  ?!@string ioListFileContents
  ??@ipic18BlockList inGeneratedBlockList
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . [inTitle stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
  foreach inGeneratedBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inGeneratedBlockList length] then
      nextBlockLabel := [inGeneratedBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    [mBlock display !nextBlockLabel !?ioListFileContents] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
