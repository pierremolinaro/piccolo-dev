semantics ipic18_metamodel :
import "pic18_metamodel.gSemantics" ;
import "ipic_generic.gSemantics" ;
import semantics pic18_metamodel in "pic18_metamodel.gSemantics" ;
import semantics ipic_generic in "ipic_generic.gSemantics" ;

#----------------------------------------------------*

struct @ipic_registerExpressionWithoutBSRIndication {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
}

#----------------------------------------------------*

struct @ipic_registerExpression {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
  @bool mNeedsBSR ;
}

#----------------------------------------------------*

method @registerExpression resolveAccess
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  !@ipic_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  @uint registerAddress := 0 ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
    registerAddress := mValue ;
  end foreach ;
  @bool needsBSRaccess := false ;
  if not found then
    needsBSRaccess := true ;
    [registerAddressList first ?registerAddress] ;
    @uint neededBank := registerAddress >> 8 ;
    if (neededBank != inCurrentBank) then
      @string errorMessage := "Accessing the '" . mRegisterName . "' needs the bank selection set to " . [neededBank string] ;
      if inCurrentBank == [@uint max] then
        errorMessage .= ", but current bank selection cannot be known" ;
      else
        errorMessage .= ", but current bank selection is set to " . [inCurrentBank string] ;
      end if ;
      error mRegisterName: errorMessage ;
    end if ;
  end if ;
#---
  outIPICregisterDescription := [@ipic_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
    !needsBSRaccess
  ] ;
end method ;

#----------------------------------------------------*

method @registerExpression resolveAccessWithoutCheckingBank
  ??@registerTable inRegisterTable
  !@ipic_registerExpressionWithoutBSRIndication outIPICregisterDescription
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?* ?*] ;
  @uint registerAddress ;
  [registerAddressList first ?registerAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  outIPICregisterDescription := [@ipic_registerExpressionWithoutBSRIndication new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------*

abstract class @ipic18_instruction {
  abstract method instructionLength !@uint outLength ;
  abstract method displayIPICinstruction ?!@string ioListFileContents ;

  method setCurrentAddress ?!@uint ioCurrentAddress :
    @uint length ;
    [self instructionLength ?length] ;
    ioCurrentAddress := ioCurrentAddress + length ;
  end method ;

  method isLABELorORG !@bool outIsLABELorORG :
    outIsLABELorORG := false ;
  end method ;

  method isNULL !@bool outIsNULL :
    outIsNULL := false ;
  end method ;

  method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := true ;
  end method ;

  method isSkippingInstruction !@bool outIsSkipping :
    outIsSkipping := false ;
  end method ;

  method enterReferencedLabel ?!@stringset unused ioReferencedLabelSet :
  end method ;
}

#----------------------------------------------------*

list @ipic18_instructionList {
  @ipic18_instruction mInstruction ;
}

#----------------------------------------------------*

class @ipic_NULL extends @ipic18_instruction {
  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "-" ;
  end method ;

  override method isNULL !@bool outIsNULL :
    outIsNULL := true ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_ORG extends @ipic18_instruction {
  @uint mOrigin ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;

  override method setCurrentAddress ?!@uint ioCurrentAddress :
    ioCurrentAddress := mOrigin ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "ORG " . [mOrigin hexString] ;
  end method ;

  override method isLABELorORG !@bool outIsLABELorORG :
    outIsLABELorORG := true ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_LABEL extends @ipic18_instruction {
  @lstring mLabel ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "LABEL " . mLabel ;
  end method ;

  override method isLABELorORG !@bool outIsLABELorORG :
    outIsLABELorORG := true ;
  end method ;
}

#----------------------------------------------------*

abstract class @ipic_actualInstruction extends @ipic18_instruction {
  @location mInstructionLocation ;

  override method instructionLength !@uint outLength :
    outLength := 2 ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_FDA extends @ipic_actualInstruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @ipic_registerExpression mRegisterDescription ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    getFDAinstructionBaseCode !mInstruction_FDA_base_code ?outBaseCode ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= [mInstruction_FDA_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
    if m_W_isDestination then
      ioListFileContents .= ", W" ;
    end if ;
  end method ;
}

#----------------------------------------------------*

routine getFAinstructionBaseCode
  ??@FA_instruction_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when CLRF   : outBaseCode := 0x6A00 ;
  when CPFSEQ : outBaseCode := 0x6200 ;
  when CPFSGT : outBaseCode := 0x6400 ;
  when CPFSLT : outBaseCode := 0x6000 ;
  when MOVWF  : outBaseCode := 0x6E00 ;
  when MULWF  : outBaseCode := 0x0200 ;
  when NEGF   : outBaseCode := 0x6C00 ;
  when SETF   : outBaseCode := 0x6800 ;
  when TSTFSZ : outBaseCode := 0x6600 ;
  end switch ;
end routine ;

#----------------------------------------------------*

routine FAinstructionIsSkippingInstruction
  ??@FA_instruction_base_code inInstruction
  !@bool outIsSkipping
:
  switch inInstruction
  when CLRF   : outIsSkipping := false ;
  when CPFSEQ : outIsSkipping := true ;
  when CPFSGT : outIsSkipping := true ;
  when CPFSLT : outIsSkipping := true ;
  when MOVWF  : outIsSkipping := false ;
  when MULWF  : outIsSkipping := false ;
  when NEGF   : outIsSkipping := false ;
  when SETF   : outIsSkipping := false ;
  when TSTFSZ : outIsSkipping := true ;
  end switch ;
end routine ;

#----------------------------------------------------*

class @ipic18_instruction_FA extends @ipic_actualInstruction {
  @FA_instruction_base_code mFAinstruction ;
  @ipic_registerExpression mRegisterDescription ;

  method getBaseCode !@uint outBaseCode :
    getFAinstructionBaseCode !mFAinstruction ?outBaseCode ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= [mFAinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  end method ;

  override
  method isSkippingInstruction !@bool outIsSkipping :
    FAinstructionIsSkippingInstruction !mFAinstruction ?outIsSkipping ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_MOVFF extends @ipic_actualInstruction {
  @ipic_registerExpressionWithoutBSRIndication mSourceRegisterDescription ;
  @ipic_registerExpressionWithoutBSRIndication mDestinationRegisterDescription ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "MOVFF " . [mSourceRegisterDescription mAssemblyString]  . ", " . [mDestinationRegisterDescription mAssemblyString] ;
  end method ;
}

#----------------------------------------------------*

routine getBitOrientedOpBaseCode ??@bit_oriented_op inInstruction !@uint outBaseCode :
  switch inInstruction
  when BCF : outBaseCode := 0x9000 ;
  when BSF : outBaseCode := 0x8000 ;
  when BTG : outBaseCode := 0x7000 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @ipic18_instruction_FBA extends @ipic_actualInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @ipic_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
  method getBaseCode !@uint outBaseCode :
    getBitOrientedOpBaseCode !mBitOrientedOp ?outBaseCode ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= [mBitOrientedOp mnemonic] . " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
  end method ;
}


#----------------------------------------------------*

class @ipic18_instruction_BitTestSkip extends @ipic_actualInstruction {
  @bool mSkipIfSet ;
  @ipic_registerExpression mRegisterDescription ;
  @uint mBitNumber ;

  method getBaseCode !@uint outBaseCode :
    if mSkipIfSet then
      outBaseCode := 0xA000 ; # BTFSS
    else
      outBaseCode := 0xB000 ; # BTFSC
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    if mSkipIfSet then
      ioListFileContents .= "BTFSS" ;
    else
      ioListFileContents .= "BTFSC" ;
    end if ;
    ioListFileContents .= " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
  end method ;

  override
  method isSkippingInstruction !@bool outIsSkipping :
    outIsSkipping := true ;
  end method ;
}

#----------------------------------------------------*

enum @condionalBranchMode {
  native, ipicNative, ipicBRA, ipicGOTO
}{
}

#----------------------------------------------------*

class @ipic18_instruction_conditionalBranch extends @ipic_actualInstruction {
  @condionalBranchMode mBranchMode ;
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabel ;

  override
  method instructionLength !@uint outLength :
    switch mBranchMode
      when native     : outLength := 2 ;
      when ipicNative : outLength := 2 ;
      when ipicBRA    : outLength := 4 ;
      when ipicGOTO   : outLength := 6 ;
    end switch ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "JUMP " . [mConditionalBranch condition] . " " . mTargetLabel ;
#    switch mBranchMode
#      when native     : ioListFileContents .= " (native)" ;
#      when ipicNative : ioListFileContents .= " (uses Bcc)" ;
#      when ipicBRA    : ioListFileContents .= " (uses BRA)" ;
#      when ipicGOTO   : ioListFileContents .= " (uses GOTO)" ;
#    end switch ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += ![mTargetLabel string] ;
  end method ;
}

#----------------------------------------------------*

class @ipic_JUMP extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;

  override
  method instructionLength !@uint outLength :
    switch mKind
      when ipicRelative : outLength := 2 ;
      when ipicAbsolute : outLength := 4 ;
      when relative     : outLength := 2 ;
      when absolute     : outLength := 4 ;
    end switch ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    switch mKind
      when ipicRelative : ioListFileContents .= "JUMP " . mTargetLabel ;
      when ipicAbsolute : ioListFileContents .= "JUMP " . mTargetLabel ;
      when relative     : ioListFileContents .= "BRA " . mTargetLabel ;
      when absolute     : ioListFileContents .= "GOTO " . mTargetLabel ;
    end switch ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += ![mTargetLabel string] ;
  end method ;
}

#----------------------------------------------------*

class @ipic_JSR extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;

  override
  method instructionLength !@uint outLength :
    switch mKind
      when ipicRelative : outLength := 2 ;
      when ipicAbsolute : outLength := 4 ;
      when relative     : outLength := 2 ;
      when absolute     : outLength := 4 ;
    end switch ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    switch mKind
      when ipicRelative : ioListFileContents .= "JSR " . mTargetLabel ;
      when ipicAbsolute : ioListFileContents .= "JSR " . mTargetLabel ;
      when relative     : ioListFileContents .= "RCALL " . mTargetLabel ;
      when absolute     : ioListFileContents .= "CALL " . mTargetLabel ;
    end switch ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += ![mTargetLabel string] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_CLRWDT extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "CLRWDT" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_DAW extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "DAW" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_NOP extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "NOP" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_POP extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "POP" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_PUSH extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "PUSH" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_RESET extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "RESET" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_RETURN extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "RETURN" ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_RETFIE extends @ipic_actualInstruction {
  @bool mFastReturn ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "RETFIE" ;
    if mFastReturn then
      ioListFileContents .= " FAST" ;
    end if ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_SLEEP extends @ipic_actualInstruction {

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "SLEEP" ;
  end method ;
}

#----------------------------------------------------*

routine getLiteralInstructionBaseCode ??@literal_instruction_opcode inInstruction !@uint outBaseCode :
  switch inInstruction
  when ADDLW : outBaseCode := 0x0F00 ;
  when ANDLW : outBaseCode := 0x0B00 ;
  when IORLW : outBaseCode := 0x0900 ;
  when MOVLW : outBaseCode := 0x0E00 ;
  when MULLW : outBaseCode := 0x0D00 ;
  when RETLW : outBaseCode := 0x0C00 ;
  when SUBLW : outBaseCode := 0x0800 ;
  when XORLW : outBaseCode := 0x0A00 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @ipic18_instruction_literalOperation extends @ipic_actualInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @uint mLiteralValue ;

  method getBaseCode !@uint outBaseCode :
    getLiteralInstructionBaseCode !mLiteralInstruction ?outBaseCode ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := mLiteralInstruction != [@literal_instruction_opcode RETLW] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_LFSR extends @ipic_actualInstruction {
  @luint mFSRindex ;
  @uint mValue ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "LFSR " . [[mFSRindex uint] string] . ", " . [mValue hexString] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_MOVLB extends @ipic_actualInstruction {
  @luint mBankIndex ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "MOVLB " . [[mBankIndex uint] string] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_TBLRD extends @ipic_actualInstruction {
  @tableAccessOption mOption ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "TBLRD " . [mOption mnemonic] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_TBLWT extends @ipic_actualInstruction {
  @tableAccessOption mOption ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "TBLWT " . [mOption mnemonic] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_MNOP extends @ipic_actualInstruction {
  @luint mOccurrenceFactor ;
  override
  method instructionLength !@uint outLength :
    outLength := [mOccurrenceFactor uint] * 2 ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "MNOP " . [[mOccurrenceFactor uint] string] ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_computed_retlw extends @ipic_actualInstruction {
  @uintlist mLiteralValues ;
  @bool mUsesRCALL ;

  override
  method instructionLength !@uint outLength :
    outLength := [mLiteralValues length] * 2 + 2 ;
    if not mUsesRCALL then
      outLength := outLength + 2 ;
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "COMPUTED RETLW " ;
    if mUsesRCALL then
      ioListFileContents .= " (uses RCALL)" ;
    else
      ioListFileContents .= " (uses CALL)" ;
    end if ;
    foreach mLiteralValues do
      ioListFileContents .= ", " . [mValue hexString] ;
    end foreach ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !"_computed_goto_2" ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_computed_bra extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 2 + 2 ;
    if not mUsesRCALL then
      outLength := outLength + 2 ;
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "COMPUTED BRA " ;
    if mUsesRCALL then
      ioListFileContents .= " (uses RCALL)" ;
    else
      ioListFileContents .= " (uses CALL)" ;
    end if ;
    foreach mTargetLabels do
      ioListFileContents .= ", " . mValue ;
    end foreach ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !"_computed_goto_2" ;
    foreach mTargetLabels do
      ioReferencedLabelSet += ![mValue string] ;
    end foreach ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_computed_goto extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 4 + 2 ;
    if not mUsesRCALL then
      outLength := outLength + 2 ;
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "COMPUTED GOTO " ;
    if mUsesRCALL then
      ioListFileContents .= " (uses RCALL)" ;
    else
      ioListFileContents .= " (uses CALL)" ;
    end if ;
    foreach mTargetLabels do
      ioListFileContents .= ", " . mValue ;
    end foreach ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := false ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !"_computed_goto_4" ;
    foreach mTargetLabels do
      ioReferencedLabelSet += ![mValue string] ;
    end foreach ;
  end method ;
}

#----------------------------------------------------*

class @ipic18_instruction_computed_rcall extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @string mEndOfInstructionLabel ;
  @bool mUsesRCALL ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 4 ;
    if not mUsesRCALL then
      outLength := outLength + 2 ;
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "COMPUTED RCALL " ;
    if mUsesRCALL then
      ioListFileContents .= "(uses RCALL)" ;
    else
      ioListFileContents .= "(uses CALL)" ;
    end if ;
    foreach mTargetLabels do
      ioListFileContents .= ", " . mValue ;
    end foreach ;
  end method ;

  override method nextInstructionIsReachable !@bool outIsReachable :
    outIsReachable := true ;
  end method ;


  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !"_computed_goto_4" ;
    foreach mTargetLabels do
      ioReferencedLabelSet += ![mValue string] ;
    end foreach ;
  end method ;
}

#----------------------------------------------------*

class @ipic_jump_test_register extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;

  override
  method instructionLength !@uint outLength :
    outLength := 2 ; # TSTFSZ
    if mBranchIfZero then
      outLength := outLength + 2 ; # Intermediate BRA
    end if ;
    if mUsesBra then
      outLength := outLength + 2 ; # Final BRA
    else
      outLength := outLength + 4 ; # Final GOTO
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "JUMP " . [mRegisterDescription mAssemblyString] ;
    if mBranchIfZero then
      ioListFileContents .= " Z" ;
    else
      ioListFileContents .= " NZ" ;
    end if ;
    ioListFileContents .= " " . mTargetLabel ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !mTargetLabel ;
  end method ;
}

#----------------------------------------------------*

class @ipic_incDecRegisterInCondition extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @bool mIncrement ;
  @bool m_W_isDestination ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;

  override
  method instructionLength !@uint outLength :
    if mUsesBra then
      outLength := 4 ;
    else
      outLength := 6 ;
    end if ; 
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "JUMP " ;
    if mIncrement then
      ioListFileContents .= "INCF " ;
    else
      ioListFileContents .= "DECF " ;
    end if ;
    ioListFileContents .= [mRegisterDescription mAssemblyString] ;
    if m_W_isDestination then
      ioListFileContents .= ", W " ;
    end if ;
    if mBranchIfZero then
      ioListFileContents .= "Z" ;
    else
      ioListFileContents .= "NZ" ;
    end if ;
    ioListFileContents .= " " . mTargetLabel ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !mTargetLabel ;
  end method ;
}

#----------------------------------------------------*

class @ipic_registerComparisonCondition extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @registerComparison mComparison ;
  @bool mUsesBra ;

  method usesIntermediateBRA !@bool outUses :
    switch mComparison
      when notEqual       : outUses := false ; # CPFSEQ 
      when equal          : outUses := true  ; # CPFSEQ + BRA
      when greaterOrEqual : outUses := false ; # CPFLT
      when greater        : outUses := true  ; # CPFGT + BRA
      when lowerOrEqual   : outUses := false ; # CPFGT
      when lower          : outUses := true  ; # CPFLT + BRA
    end switch ;
  end method ;

  override
  method instructionLength !@uint outLength :
    @bool usesIntermediateBRA ; [self usesIntermediateBRA ?usesIntermediateBRA] ;
    if usesIntermediateBRA then
      outLength := 4 ;
    else
      outLength := 2 ;
    end if ; 
   if mUsesBra then
      outLength := outLength + 2 ; # Final BRA
    else
      outLength := outLength + 4 ; # Final GOTO
    end if ;
  end method ;

  override
  method displayIPICinstruction ?!@string ioListFileContents :
    ioListFileContents .= "JUMP " ;
    ioListFileContents .= [mRegisterDescription mAssemblyString] ;
    ioListFileContents .= " " . [mComparison mnemonic] ;
    ioListFileContents .= " " . mTargetLabel ;
  end method ;

  override method enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += !mTargetLabel ;
  end method ;
}

#----------------------------------------------------*

end semantics ;
