semantics ipic18_optimize_block :
import "ipic18_display_block_list.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Terminator optimizeTerminator

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string unused inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
  if inBlockLabel != mLabel->string then
    [inSymbolTable searchKey !mLabel ??@uint targetBlockIndex] ;
    const @ipic18Block targetBlock := [inBlockList mBlockAtIndex !targetBlockIndex] ;
    if (targetBlock->mStartAddress == [@uint max]) # Relocatable
     & ([targetBlock->mInstructionList length] == 0) # Empty block
     & (targetBlock->mTerminator is @ipic18SingleInstructionTerminator) then
#     & not (targetBlock->mTerminator is @ipic18ReturnTerminator) then
      @bool optimize ;
      if (targetBlock->mTerminator is @ipic18JumpTerminator) then
        const @ipic18JumpTerminator candidate := (cast targetBlock->mTerminator : @ipic18JumpTerminator) ;
        optimize := mLabel->string != [candidate mLabel]->string ;
      else
        optimize := true ;
      end if ;
      if optimize then 
        outOptimizedTerminator := targetBlock->mTerminator ;
        ioOptimizationDone := true ;
        ioListFileContents .= "  " . inBlockLabel . ": " ;
        ioListFileContents .= [selfcopy terminatorDisplay !""] ;
        ioListFileContents .= " -> " ;
        ioListFileContents .= [outOptimizedTerminator terminatorDisplay !""] ;
        ioListFileContents .= "\n" ;
      end if ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
#---- Useless condition ?
  if mTargetLabelWhenTrue->string == mTargetLabelWhenFalse->string then
    outOptimizedTerminator := [@ipic18JumpTerminator new
      !mInstructionLocation
      !mTargetLabelWhenFalse
      ![@jumpInstructionKind ipicRelative]
    ] ;
    ioOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", useless terminator condition: replaced by JUMP " . mTargetLabelWhenFalse . "\n" ;
    warning mInstructionLocation : "useless condition deleted" ;
  else
    @bool optimized := false ;
  #--- Optimize true label
    @lstring targetLabelWhenTrue := mTargetLabelWhenTrue ;
    if inBlockLabel != mTargetLabelWhenTrue->string then
      [inSymbolTable searchKey !mTargetLabelWhenTrue ??@uint targetBlockIndex] ;
      const @ipic18Block targetBlock := [inBlockList mBlockAtIndex !targetBlockIndex] ;
      if (targetBlock->mStartAddress == [@uint max]) # Relocatable
       & ([targetBlock->mInstructionList length] == 0) # Empty block
       & (targetBlock->mTerminator is @ipic18JumpTerminator) then
        const @ipic18JumpTerminator jp := (cast targetBlock->mTerminator : @ipic18JumpTerminator) ;
        targetLabelWhenTrue := [jp mLabel] ;
        optimized := true ;
        ioListFileContents .= "  " . inBlockLabel . ", jump optimization: " ;
        ioListFileContents .= mTargetLabelWhenTrue->string ;
        ioListFileContents .= " -> " ;
        ioListFileContents .= targetLabelWhenTrue->string ;
        ioListFileContents .= "\n" ;
      end if ;
    end if ;
  #--- Optimize false label
    @lstring targetLabelWhenFalse := mTargetLabelWhenFalse ;
    if inBlockLabel != mTargetLabelWhenFalse->string then
      [inSymbolTable searchKey !mTargetLabelWhenFalse ??@uint targetBlockIndex] ;
      const @ipic18Block targetBlock := [inBlockList mBlockAtIndex !targetBlockIndex] ;
      if (targetBlock->mStartAddress == [@uint max]) # Relocatable
       & ([targetBlock->mInstructionList length] == 0) # Empty block
       & (targetBlock->mTerminator is @ipic18JumpTerminator) then
        const @ipic18JumpTerminator jp := (cast targetBlock->mTerminator : @ipic18JumpTerminator) ;
        targetLabelWhenFalse := [jp mLabel] ;
        optimized := true ;
        ioListFileContents .= "  " . inBlockLabel . ", jump optimization: " ;
        ioListFileContents .= mTargetLabelWhenFalse->string ;
        ioListFileContents .= " -> " ;
        ioListFileContents .= targetLabelWhenFalse->string ;
        ioListFileContents .= "\n" ;
      end if ;
    end if ;
  #--- Optimized ?
    if optimized then
      ioOptimizationDone := true ;
      outOptimizedTerminator := [@ipic18ConditionalJumpTerminator new
        !mInstructionLocation
        !mConditionalBranch
        !targetLabelWhenTrue
        !mBranchModeOnTrueLabel
        !targetLabelWhenFalse
        !mBranchModeOnFalseLabel
      ] ;  
    else
      outOptimizedTerminator := selfcopy ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

method @ipic18AbstractConditionTerminator getOptimizedTerminators
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SingleInstructionTerminator outOptimizedTrueTerminator
  !@ipic18SingleInstructionTerminator outOptimizedFalseTerminator
  !@bool outIdenticalTerminators
:
#---
  [mInstructionIfConditionTrue optimizeTerminator
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator optimizedTrueTerminator
  ] ;
  outOptimizedTrueTerminator := (cast optimizedTrueTerminator : @ipic18SingleInstructionTerminator) ;
#---
  [mInstructionIfConditionFalse optimizeTerminator
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?ioOptimizationDone
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator optimizedFalseTerminator
  ] ;
  outOptimizedFalseTerminator := (cast optimizedFalseTerminator : @ipic18SingleInstructionTerminator) ;
#---- Useless condition ?
  if (outOptimizedTrueTerminator is @ipic18ReturnTerminator) & (outOptimizedFalseTerminator is @ipic18ReturnTerminator) then
    outIdenticalTerminators := true ;
  elsif (outOptimizedTrueTerminator is @ipic18RetlwTerminator) & (outOptimizedFalseTerminator is @ipic18RetlwTerminator) then
    const @ipic18RetlwTerminator t := (cast outOptimizedTrueTerminator : @ipic18RetlwTerminator) ;
    const @ipic18RetlwTerminator f := (cast outOptimizedFalseTerminator : @ipic18RetlwTerminator) ;
    outIdenticalTerminators := [t mLiteralValue] == [f mLiteralValue] ;
  elsif (outOptimizedTrueTerminator is @ipic18JumpTerminator) & (outOptimizedFalseTerminator is @ipic18JumpTerminator) then
    const @ipic18JumpTerminator t := (cast outOptimizedTrueTerminator : @ipic18JumpTerminator) ;
    const @ipic18JumpTerminator f := (cast outOptimizedFalseTerminator : @ipic18JumpTerminator) ;
    outIdenticalTerminators := [t mLabel] == [f mLabel] ;
  else
    outIdenticalTerminators := false ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  @bool optimization := false ;
#---
  [selfcopy getOptimizedTerminators
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ??@ipic18SingleInstructionTerminator optimizedTrueTerminator
    ??@ipic18SingleInstructionTerminator optimizedFalseTerminator
    ??@bool identicalTerminators
  ] ;
  if identicalTerminators then
    outOptimizedTerminator := optimizedTrueTerminator ;
    ioOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", useless terminator condition: replaced by " . [optimizedTrueTerminator terminatorDisplay !""] . "\n" ;
    warning mInstructionLocation : "useless condition deleted" ;
  elsif optimization then
    outOptimizedTerminator := [@ipic18IncDecRegisterTerminator new
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
    ioOptimizationDone := true ;
  else
    outOptimizedTerminator := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  @bool optimization := false ;
#---
  [selfcopy getOptimizedTerminators
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ??@ipic18SingleInstructionTerminator optimizedTrueTerminator
    ??@ipic18SingleInstructionTerminator optimizedFalseTerminator
    ??@bool identicalTerminators
  ] ;
  if identicalTerminators then
    outOptimizedTerminator := optimizedTrueTerminator ;
    ioOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", useless terminator condition: replaced by " . [optimizedTrueTerminator terminatorDisplay !""] . "\n" ;
    warning mInstructionLocation : "useless condition deleted" ;
  elsif optimization then
    outOptimizedTerminator := [@pic18BitTestTerminator new
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mBitNumber
    ] ;
    ioOptimizationDone := true ;
  else
    outOptimizedTerminator := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  @bool optimization := false ;
  [selfcopy getOptimizedTerminators
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ??@ipic18SingleInstructionTerminator optimizedTrueTerminator
    ??@ipic18SingleInstructionTerminator optimizedFalseTerminator
    ??@bool identicalTerminators
  ] ;
  if identicalTerminators then
    outOptimizedTerminator := optimizedTrueTerminator ;
    ioOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", useless terminator condition: replaced by " . [optimizedTrueTerminator terminatorDisplay !""] . "\n" ;
    warning mInstructionLocation : "useless condition deleted" ;
  elsif optimization then
    outOptimizedTerminator := [@pic18RegisterComparisonTerminator new
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
      !mComparison
    ] ;
    ioOptimizationDone := true ;
  else
    outOptimizedTerminator := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@string inBlockLabel
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  @bool optimization := false ;
  [selfcopy getOptimizedTerminators
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    !?optimization
    !?ioListFileContents
    ??@ipic18SingleInstructionTerminator optimizedTrueTerminator
    ??@ipic18SingleInstructionTerminator optimizedFalseTerminator
    ??@bool identicalTerminators
  ] ;
  if identicalTerminators then
    outOptimizedTerminator := optimizedTrueTerminator ;
    ioOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", useless terminator condition: replaced by " . [optimizedTrueTerminator terminatorDisplay !""] . "\n" ;
    warning mInstructionLocation : "useless condition deleted" ;
  elsif optimization then
    outOptimizedTerminator := [@pic18TestRegisterTerminator new
      !mInstructionLocation
      !optimizedTrueTerminator
      !optimizedFalseTerminator 
      !mRegisterDescription
    ] ;
    ioOptimizationDone := true ;
  else
    outOptimizedTerminator := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator optimizeTerminator
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@string unused inBlockLabel
  ?!@bool unused ioOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outOptimizedTerminator
:
  outOptimizedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator enterTerminatorReferencedLabels

#----------------------------------------------------------------------------*

local routine enterGoto2block
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  if not [ioReferencedBlockSet hasKey !"_computed_goto_2"] then
    ioReferencedBlockSet += !"_computed_goto_2" ;
    [inSymbolTable searchKey !["_computed_goto_2" nowhere] ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ; 
end routine ;

#----------------------------------------------------------------------------*

local routine enterGoto4block
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  if not [ioReferencedBlockSet hasKey !"_computed_goto_4"] then
    ioReferencedBlockSet += !"_computed_goto_4" ;
    [inSymbolTable searchKey !["_computed_goto_4" nowhere] ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ; 
end routine ;

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  enterGoto2block
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  enterGoto2block
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ;
  foreach mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue->string] then
      ioReferencedBlockSet += !mValue->string ;
      [inSymbolTable searchKey !mValue ??@uint blockIndex] ;
      const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ] ;
    end if ; 
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  enterGoto4block
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ;
  foreach mTargetLabels do
    if not [ioReferencedBlockSet hasKey !mValue->string] then
      ioReferencedBlockSet += !mValue->string ;
      [inSymbolTable searchKey !mValue ??@uint blockIndex] ;
      const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
      [b enterReferencedLabels
        !inSymbolTable
        !inBlockList
        !?ioReferencedBlockSet
      ] ;
    end if ; 
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  if not [ioReferencedBlockSet hasKey !mLabel->string] then
    ioReferencedBlockSet += !mLabel->string ;
    [inSymbolTable searchKey !mLabel ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ; 
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  if not [ioReferencedBlockSet hasKey !mTargetLabelWhenTrue->string] then
    ioReferencedBlockSet += !mTargetLabelWhenTrue->string ;
    [inSymbolTable searchKey !mTargetLabelWhenTrue ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ;
  if not [ioReferencedBlockSet hasKey !mTargetLabelWhenFalse->string] then
    ioReferencedBlockSet += !mTargetLabelWhenFalse->string ;
    [inSymbolTable searchKey !mTargetLabelWhenFalse ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18SingleInstructionTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator enterTerminatorReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  [mInstructionIfConditionTrue enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet] ;
  [mInstructionIfConditionFalse enterTerminatorReferencedLabels !inSymbolTable !inBlockList !?ioReferencedBlockSet] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction enterInstructionReferencedLabels

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction enterInstructionReferencedLabels
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ?!@stringset unused ioReferencedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR enterInstructionReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  if not [ioReferencedBlockSet hasKey !mTargetLabel->string] then
    ioReferencedBlockSet += !mTargetLabel->string ;
    [inSymbolTable searchKey !mTargetLabel ??@uint blockIndex] ;
    const @ipic18Block b := [inBlockList mBlockAtIndex !blockIndex] ;
    [b enterReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;
  end if ; 
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall enterInstructionReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  enterGoto4block
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ;
  foreach mTargetInstructions do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;      
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction  enterInstructionReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  [mEmbeddedInstruction enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction optimizeInstruction
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@ipic18BlockList unused inBlockList
  ??@lstring unused inBlockLabel
  !@bool outOptimizationDone
  ?!@string unused ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outOptimizedInstruction := selfcopy ;
  outOptimizationDone := false ;
  outNOPsubstitution := false ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR optimizeInstruction
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outOptimizedInstruction := selfcopy ;
  outOptimizationDone := false ;
  outNOPsubstitution := false ;
#---
  [inSymbolTable searchKey !mTargetLabel ??@uint targetBlockIndex] ; 
  const @ipic18Block targetBloc := [inBlockList mBlockAtIndex !targetBlockIndex] ;  
#--- Remove empty routine calls
  if ([targetBloc->mInstructionList length] == 0) & (targetBloc->mTerminator is @ipic18ReturnTerminator) then
    outOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ": " ;
    ioListFileContents .= "call to empty " . mTargetLabel . " routine deleted" ;
    ioListFileContents .= "\n" ;
    outOptimizedInstruction := [@ipic18InstructionWithNoOperand new !mInstructionLocation ![@pic18InstructionWithNoOperandKind NOP]] ;
    outNOPsubstitution := true ;
#--- Replace call to a RETLW routine with a MOVLW instruction
  elsif ([targetBloc->mInstructionList length] == 0) & (targetBloc->mTerminator is @ipic18RetlwTerminator) then
    const @ipic18RetlwTerminator t := (cast targetBloc->mTerminator : @ipic18RetlwTerminator) ;
    outOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ": " ;
    ioListFileContents .= "call to RETLW " . mTargetLabel . " routine transformed to MOVLW" ;
    ioListFileContents .= "\n" ;
    outOptimizedInstruction := [@ipic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      ![t mLiteralValue]
    ] ;
#--- Replace call to a single instruction routine with the routine instruction
  elsif ([targetBloc->mInstructionList length] == 1)
      & (targetBloc->mTerminator is @ipic18ReturnTerminator) then
    outOptimizedInstruction := [targetBloc->mInstructionList mInstructionAtIndex !0] ;
    outOptimizationDone := true ;
    ioListFileContents .= "  " . inBlockLabel . ", " ;
    ioListFileContents .= "call to single instruction routine " . mTargetLabel . " replaced by this single instruction" ;
    ioListFileContents .= "\n" ;
  end if ;    
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall optimizeInstruction
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outOptimizationDone := false ;
  outNOPsubstitution := false ;
#---
  @ipic18SequentialInstructionList optimizedInstructionList [emptyList] ;
  foreach mTargetInstructions do
    @bool opt := false ;
    if (mInstruction is @ipic18_intermediate_JSR) then
      const @ipic18_intermediate_JSR jsr := (cast mInstruction : @ipic18_intermediate_JSR) ;
      [inSymbolTable searchKey ![jsr mTargetLabel] ??@uint targetBlockIndex] ; 
      const @ipic18Block targetBloc := [inBlockList mBlockAtIndex !targetBlockIndex] ;  
      if (targetBloc->mTerminator is @ipic18ReturnTerminator) then
        if [targetBloc->mInstructionList length] == 0 then # Empty block, replace by NOP
          opt := true ;
          outOptimizationDone := true ;
          optimizedInstructionList += ![@ipic18InstructionWithNoOperand new ![jsr mInstructionLocation] ![@pic18InstructionWithNoOperandKind NOP]] ;
          ioListFileContents .= "  " . inBlockLabel . ", " ;
          ioListFileContents .= "COMPUTED JSR " . [jsr mTargetLabel] . " to empty routine replaced by NOP" ;
          ioListFileContents .= "\n" ;
        elsif [targetBloc->mInstructionList length] == 1 then # One instruction block
          const @ipic18SequentialInstruction inst := [targetBloc->mInstructionList mInstructionAtIndex !0] ;
          if [inst instructionSize] == 2 then # Instruction size == 2, perform replacement
            opt := true ;
            outOptimizationDone := true ;
            optimizedInstructionList += !inst ;
            ioListFileContents .= "  " . inBlockLabel . ", " ;
            ioListFileContents .= "COMPUTED JSR " . [jsr mTargetLabel] . " to one instruction routine replaced by routine instruction" ;
            ioListFileContents .= "\n" ;
          end if ;
        end if ;
      end if ;
    end if ;
    if not opt then
      optimizedInstructionList += !mInstruction ;
    end if ;
  end foreach ;
  if outOptimizationDone then
    outOptimizedInstruction := [@ipic18_intermediate_instruction_computed_rcall new
      !mInstructionLocation
      !optimizedInstructionList
      !mUsesRCALL
    ] ;
  else
    outOptimizedInstruction := selfcopy ;
  end if ;  
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_BitTestSkip optimizeInstruction
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outNOPsubstitution := false ;
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?@ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ] ;
  if outOptimizationDone then
    outOptimizedInstruction := [@ipic18_skip_instruction_BitTestSkip new
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mSkipIfSet
      !mRegisterDescription
      !mBitNumber
    ] ;
  else
    outOptimizedInstruction := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_compare_register optimizeInstruction
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outNOPsubstitution := false ;
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?@ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ] ;
  if outOptimizationDone then
    outOptimizedInstruction := [@ipic18_skip_instruction_compare_register new
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mCompareInstruction
      !mRegisterDescription
    ] ;
  else
    outOptimizedInstruction := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_FDA optimizeInstruction
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outOptimizedInstruction
  !@bool outNOPsubstitution
:
  outNOPsubstitution := false ;
#---
  [mEmbeddedInstruction optimizeInstruction
    !inSymbolTable
    !inBlockList
    !inBlockLabel
    ?outOptimizationDone
    !?ioListFileContents
    ?@ipic18SequentialInstruction optimizedEmbeddedInstruction
    ?*
  ] ;
  if outOptimizationDone then
    outOptimizedInstruction := [@ipic18_skip_instruction_FDA new
      !mInstructionLocation
      !optimizedEmbeddedInstruction
      !mInstruction_FDA_base_code
      !mRegisterDescription
      !m_W_isDestination
    ] ;
  else
    outOptimizedInstruction := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction list optimization

#----------------------------------------------------------------------------*

local routine instructionListOptimization
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ??@ipic18SequentialInstructionList inInstructionList
  ??@lstring inBlockLabel
  !@bool outOptimizationDone
  ?!@string ioListFileContents
  !@ipic18SequentialInstructionList outOptimizedInstructionList
:
  outOptimizationDone := false ;
  outOptimizedInstructionList := [@ipic18SequentialInstructionList emptyList] ;
  foreach inInstructionList do
    [mInstruction optimizeInstruction
      !inSymbolTable
      !inBlockList
      !inBlockLabel
      ??@bool optimizationDone
      !?ioListFileContents
      ??@ipic18SequentialInstruction optimizedInstruction
      ??@bool NOPsubstitution
    ] ;
    if optimizationDone then
      outOptimizationDone := true ;
    end if ;
    if not NOPsubstitution then
      outOptimizedInstructionList += !optimizedInstruction ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

#!--- Block optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstructionList enterInstructionReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  foreach selfcopy do
    [mInstruction enterInstructionReferencedLabels
      !inSymbolTable
      !inBlockList
      !?ioReferencedBlockSet
    ] ;  
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

method @ipic18Block enterReferencedLabels
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@stringset ioReferencedBlockSet
:
  [mInstructionList enterInstructionReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ] ;
  [mTerminator enterTerminatorReferencedLabels
    !inSymbolTable
    !inBlockList
    !?ioReferencedBlockSet
  ] ;
end method ;

#----------------------------------------------------------------------------*

method @ipic18Block optimize
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@ipic18BlockList inBlockList
  ?!@bool ioOptimizationDone
  ?!@string ioListFileContents
  !@ipic18Block outOptimizedBlock
:
#----- Optimize instruction list
  instructionListOptimization
    !inSymbolTable
    !inBlockList
    !mInstructionList
    !mLabel
    ?@bool optimized
    !?ioListFileContents
    ?@ipic18SequentialInstructionList optimizedInstructionList
  ;
#  @bool optimized := false ;
#  @ipic18SequentialInstructionList optimizedInstructionList := mInstructionList ;
#--- Transform MOVLW k ; RETURN to RETLW
  @ipic18AbstractBlockTerminator optimizedTerminator := mTerminator ;
  if ([optimizedInstructionList length] > 0) & (mTerminator is @ipic18ReturnTerminator) then
    [optimizedInstructionList last ??@ipic18SequentialInstruction lastInstruction] ;
    cast lastInstruction
    when == @ipic18_intermediate_instruction_literalOperation op :
      if [op mLiteralInstruction] == [@literal_instruction_opcode MOVLW] then
        [!?optimizedInstructionList popLast ?*] ;
        optimizedTerminator := [@ipic18RetlwTerminator new ![op mInstructionLocation] ![op mLiteralValue]] ;
        optimized := true ;
        ioListFileContents .= "  " . mLabel . ": MOVLW k ; RETURN --> RETLW k\n" ;
      end if ;
  #--- Transform JSR label ; RETURN to JUMP label
    when == @ipic18_intermediate_JSR jsr :
      [!?optimizedInstructionList popLast ?*] ;
      optimizedTerminator := [@ipic18JumpTerminator new ![jsr mInstructionLocation] ![jsr mTargetLabel] ![jsr mKind]] ;
      optimized := true ;
      ioListFileContents .= "  " . mLabel . ": JSR " . [jsr mTargetLabel] . " ; RETURN --> JUMP " . [jsr mTargetLabel] . "\n" ;
    else
    end cast ;
  end if ;
#--- Optimize terminator 
# DO NOT OPTIMIZE WHEN TERMINATOR HAS BEEN CHANGED IN PREVIOUS INSTRUCTIONS
  if not optimized then
    [mTerminator optimizeTerminator
      !inSymbolTable
      !inBlockList
      !mLabel->string
      !?optimized
      !?ioListFileContents
      ?optimizedTerminator
    ] ;
  end if ;
#--- Return optimized block
  if optimized then
    ioOptimizationDone := true ;
    outOptimizedBlock := [@ipic18Block new
      !mStartAddress
      !mLabel
      !optimizedInstructionList
      !optimizedTerminator 
    ] ;
  else
    outOptimizedBlock := selfcopy ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

routine ipic18OptimizeBlocks
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["BLOCK REPRESENTATION OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  if [option.verbose_output value] then
    message "Optimizations:\n" ;
  end if ;
#--- Optimizations loops
  @bool optimizationDone := true ;
  @uint optimizationPass := 0 ;
  loop [ioGeneratedBlockList length] + 1
  while optimizationDone & ([@uint errorCount] == 0) do
    optimizationDone := false ;
    optimizationPass := optimizationPass + 1 ;
    ioListFileContents .= "\n--- Pass " . optimizationPass . " (" . [ioGeneratedBlockList length] . " blocks)\n" ;
    const @uint blockCountBeforeOptimization := [ioGeneratedBlockList length] ;
    if [option.verbose_output value] then
      message "  Pass " . optimizationPass . " : " . blockCountBeforeOptimization . " blocks.\n" ;
    end if ;
  #-------------------------------- Build label map
    @symbolTableForBlockOptimization symbolTable [emptyMap] ;
    foreach ioGeneratedBlockList index blockIndex do
      [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
    end foreach ;
  #-------------------------------- Build referenced label set
    @stringset referencedBlockSet [emptySet] ;
    foreach ioGeneratedBlockList do
      if mBlock->mStartAddress != [@uint max] then # Only absolute blocks
        [mBlock enterReferencedLabels
          !symbolTable
          !ioGeneratedBlockList
          !?referencedBlockSet
        ] ;
      end if ;
    end foreach ;
  #-------------------------------- Optimization loop
    @ipic18BlockList optimizedBlockList [emptyList] ;
    foreach ioGeneratedBlockList do
      if [referencedBlockSet hasKey !mBlock->mLabel->string] | (mBlock->mStartAddress != [@uint max]) then
        [mBlock optimize
          !symbolTable
          !ioGeneratedBlockList
          !?optimizationDone
          !?ioListFileContents
          ?@ipic18Block optimizedBlock
        ] ;
        optimizedBlockList += !optimizedBlock ;
      else
        ioListFileContents .= "  " . mBlock->mLabel . ": not referenced, deleted\n" ;
        optimizationDone := true ;
      end if ;
    end foreach ;
    ioGeneratedBlockList := optimizedBlockList ;
  end loop ;
  ioListFileContents .= "  No optimization.\n\n" ;
  if [option.verbose_output value] then
    message "\n" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*


end semantics ;
