semantics ipic18_regular_instructions :
import "ipic18_block_representation.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Instruction size

#----------------------------------------------------------------------------*

reader @ipic18SequentialInstruction instructionSize
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_condition_skip_instruction instructionSize
  -> @uint outSize
:
  outSize := 2 + [mEmbeddedInstruction instructionSize] ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution : instruction

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction performInstructionRelativeBranchResolution
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ?!@uint unused ioConversionCount
  ?!@string unused ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction instructionRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@branchOverflowMap ioOverflowMap
:
  [mEmbeddedInstruction instructionRelativeBranchOverflow
    !inAddress + 2
    !inBlockLabel
    !inSymbolTable
    !?ioOverflowMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate instruction display

#----------------------------------------------------------------------------*

abstract reader @ipic18SequentialInstruction instructionDisplay
  ->@stringlist outResult
;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18InstructionWithNoOperand

#----------------------------------------------------------------------------*

reader @pic18InstructionWithNoOperandKind mnemonic
  ->@string outResult
:
  switch selfcopy
  when CLRWDT : outResult := "CLRWDT" ;
  when DAW : outResult := "DAW" ;
  when NOP : outResult := "NOP" ;
  when POP : outResult := "POP" ;
  when PUSH : outResult := "PUSH" ;
  when RESET : outResult := "RESET" ;
  when SLEEP : outResult := "SLEEP" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18InstructionWithNoOperand instructionDisplay
  ->@stringlist outResult
:
  outResult := [@stringlist listWithValue ![mKind mnemonic]] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18InstructionWithNoOperand generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint c ;
  switch mKind
  when CLRWDT :
    c := 0x0004 ;
  when DAW :
    c := 0x0007 ;
  when NOP :
    c := 0x0000 ;
  when POP :
    c := 0x0006 ;
  when PUSH :
    c := 0x0005 ;
  when RESET :
    c := 0x00FF ;
  when SLEEP :
    c := 0x0003 ;
  end switch ;
  outCode := [@codeList listWithValue
    !"    " . [mKind mnemonic]
    ![@uintlist listWithValue !c]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FDA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FDA instructionDisplay
  ->@stringlist outResult
:
  @string s ;
  switch mInstruction_FDA_base_code
    when ADDWF : s := "ADDWF" ;
    when ADDWFC : s := "ADDWFC" ;
    when ANDWF : s := "ANDWF" ;
    when COMF : s := "COMF" ;
    when DECF : s := "DECF" ;
    when INCF : s := "INCF" ;
    when IORWF : s := "IORWF" ;
    when MOVF : s := "MOVF" ;
    when RLCF : s := "RLCF" ;
    when RLNCF : s := "RLNCF" ;
    when RRCF : s := "RRCF" ;
    when RRNCF : s := "RRNCF" ;
    when SUBFWB : s := "SUBFWB" ;
    when SUBWF : s := "SUBWF" ;
    when SUBWFB : s := "SUBWFB" ;
    when SWAPF : s := "SWAPF" ;
    when XORWF : s := "XORWF" ;
  end switch ;
  s .= " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination & [mRegisterDescription mNeedsBSR] then
    s .= ", W, BSR_ACCESS" ;
  elsif [mRegisterDescription mNeedsBSR] then
    s .= ", F, BSR_ACCESS" ;
  elsif m_W_isDestination then
    s .= ", W" ;
  else
    s .= ", F" ;
  end if ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FDA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mInstruction_FDA_base_code
  when ADDWF : code := 0x2400 ;
  when ADDWFC : code := 0x2000 ;
  when ANDWF : code := 0x1400 ;
  when COMF : code := 0x1C00 ;
  when DECF : code := 0x0400 ;
  when INCF : code := 0x2800 ;
  when IORWF : code := 0x1000 ;
  when MOVF : code := 0x5000 ;
  when RLCF : code := 0x3400 ;
  when RLNCF : code := 0x4400 ;
  when RRCF : code := 0x3000 ;
  when RRNCF : code := 0x4000 ;
  when SUBFWB : code := 0x5400 ;
  when SUBWF : code := 0x5C00 ;
  when SUBWFB :  code := 0x5800 ;
  when SWAPF : code := 0x3800 ;
  when XORWF : code := 0x1800 ;
  end switch ;

  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FDA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FA instructionDisplay ->@stringlist outResult :
  @string s ;
  switch mFAinstruction
  when CLRF   : s := "CLRF" ;
  when MOVWF  : s := "MOVWF" ;
  when MULWF  : s := "MULWF" ;
  when NEGF   : s := "NEGF" ;
  when SETF   : s := "SETF" ;
  end switch ;

  s .= " " . [mRegisterDescription mAssemblyString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mFAinstruction
  when CLRF   : code := 0x6A00 ;
  when MOVWF  : code := 0x6E00 ;
  when MULWF  : code := 0x0200 ;
  when NEGF   : code := 0x6C00 ;
  when SETF   : code := 0x6800 ;
  end switch ;

  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MOVFF

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVFF instructionSize
  -> @uint outSize
:
  outSize := 4 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVFF instructionDisplay ->@stringlist outResult :
  @string s := "MOVFF " . [mSourceRegisterDescription mAssemblyString]
  . ", " . [mDestinationRegisterDescription mAssemblyString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MOVFF generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uintlist code [emptyList] ;
  code += !0xC000 | [mSourceRegisterDescription mRegisterAddress] ;
  code += !0xF000 | [mDestinationRegisterDescription mRegisterAddress] ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    !code
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_literalOperation

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_literalOperation instructionDisplay ->@stringlist outResult :
  @string s := [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_literalOperation generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mLiteralInstruction
  when ADDLW : code := 0x0F00 ;
  when ANDLW : code := 0x0B00 ;
  when IORLW : code := 0x0900 ;
  when MOVLW : code := 0x0E00 ;
  when MULLW : code := 0x0D00 ;
  when SUBLW : code := 0x0800 ;
  when XORLW : code := 0x0A00 ;
  end switch ;
  code := code | mLiteralValue ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_LFSR

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_LFSR instructionSize
  -> @uint outSize
:
  outSize := 4 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_LFSR instructionDisplay ->@stringlist outResult :
  @string s := "LFSR " . [[mFSRindex uint] string] . ", " . [mValue hexString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_LFSR generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uintlist code [emptyList] ;
  code += !0xEE00 | ([mFSRindex uint] << 4) | (mValue >> 8) ;
  code += !0xF000 | (mValue & 255) ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    !code
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FBA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FBA instructionDisplay ->@stringlist outResult :
  @string s := [mBitOrientedOp mnemonic] . " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FBA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mBitOrientedOp
  when BCF : code := 0x9000 ;
  when BSF : code := 0x8000 ;
  when BTG : code := 0x7000 ;
  end switch ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  code := code | (mBitNumber << 9) ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MOVLB

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVLB instructionDisplay ->@stringlist outResult :
  @string s := "MOVLB " . [[mBankIndex uint] hexString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MOVLB generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  const @uint code := 0x0100 | [mBankIndex uint] ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_TBLRD

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_TBLRD instructionDisplay ->@stringlist outResult :
  @string s := "TBLRD " . [mOption mnemonic] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_TBLRD generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mOption
  when simpleAccess  : code := 0x0008 ;
  when postIncrement : code := 0x0009 ;
  when postDecrement : code := 0x000A ;
  when preIncrement  : code := 0x000B ;
  end switch ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_TBLWT

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_TBLWT instructionDisplay ->@stringlist outResult :
  @string s := "TBLWT " . [mOption mnemonic] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_TBLWT generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mOption
  when simpleAccess  : code := 0x000C ;
  when postIncrement : code := 0x000D ;
  when postDecrement : code := 0x000E ;
  when preIncrement  : code := 0x000F ;
  end switch ;
  outCode := [@codeList listWithValue
    !"    " . [[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MNOP

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MNOP instructionSize
  -> @uint outSize
:
  outSize := mOccurrenceFactor->uint * 2 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MNOP instructionDisplay ->@stringlist outResult :
  @string s := "MNOP " . [mOccurrenceFactor uint] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MNOP generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  outCode := [@codeList emptyList] ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    outCode += !"    NOP" ![@uintlist listWithValue !0x0000] ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_MOV_LABEL_W

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_MOV_LABEL_W instructionDisplay ->@stringlist outResult :
  @string s := "MOVLW ((" . mLabel . " + " . mOffset . ") >> " . mRightShift . ") & 0xFF"  ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_MOV_LABEL_W generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap inDataAddressMap
  !@codeList outCode
:
  [inDataAddressMap searchKey !mLabel ??@uint address] ;
  const @uint code := ((address + mOffset) >> mRightShift) & 0xFF ;
  const @uint code_MOVLW := 0x0E00 ;
  outCode := [@codeList listWithValue
    !"    MOVLW ((_data_" . mLabel . " + " . mOffset . ") >> " . mRightShift . ") & 0xFF"
    ![@uintlist listWithValue !code | code_MOVLW]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_BLANK

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_BLANK instructionDisplay ->@stringlist outResult :
  @string s := "BLANK " . [mBlankValue hexString]  ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_BLANK generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  const @uint code := 0xF000 | mBlankValue ;
  outCode := [@codeList listWithValue
    !"DW " . [code hexString]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_skip_instruction_compare_register

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_compare_register instructionDisplay ->@stringlist outResult :
  @string s := [mRegisterDescription mAssemblyString] . " " ;
  switch mCompareInstruction
  when CPFSEQ : s .= "!= W" ;
  when CPFSGT : s .= "<= W" ;
  when CPFSLT : s .= ">= W" ;
  when TSTFSZ : s .= "!= 0" ;
  end switch ;
  s .= " ? " . [[mEmbeddedInstruction instructionDisplay] mValueAtIndex !0] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_compare_register generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  switch mCompareInstruction
  when CPFSEQ : code := 0x6200 ;
  when CPFSGT : code := 0x6400 ;
  when CPFSLT : code := 0x6000 ;
  when TSTFSZ : code := 0x6600 ;
  end switch ;

  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
#--- Assembly string
  @string s := "    " ;
  switch mCompareInstruction
  when CPFSEQ : s .= "CPFSEQ" ;
  when CPFSGT : s .= "CPFSGT" ;
  when CPFSLT : s .= "CPFSLT" ;
  when TSTFSZ : s .= "TSTFSZ" ;
  end switch ;
  s .= " " . [mRegisterDescription mAssemblyString] ;
  if [mRegisterDescription mNeedsBSR] then
    s .= ", BSR_ACCESS" ;
  end if ;
#---
  outCode := [@codeList listWithValue
    !s
    ![@uintlist listWithValue !code]
  ] ;
  [mEmbeddedInstruction generateCode
    !inAddress + 2
    !inSymbolTable
    !inDataAddressMap
    ??@codeList c
  ] ;
  outCode .= c ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_compare_register performInstructionRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  const @uint n := ioConversionCount ;
  [mEmbeddedInstruction performInstructionRelativeBranchResolution
    !inAddress + 2
    !inBlockLabel
    !inSymbolTable
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18SequentialInstruction outModifiedEmbeddedInstruction
  ] ;
  if n != ioConversionCount then
    outModifiedInstruction := [@ipic18_skip_instruction_compare_register new 
      !mInstructionLocation
      !outModifiedEmbeddedInstruction
      !mCompareInstruction
      !mRegisterDescription
    ] ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_skip_instruction_BitTestSkip

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_BitTestSkip instructionDisplay ->@stringlist outResult :
  @string s := "" ;
  if mSkipIfSet then
    s .= "!" ;
  end if ;
  s .= [mRegisterDescription mAssemblyString] . "." . [mBitNumber string]
  . " ? " ;
  const @stringlist x := [mEmbeddedInstruction instructionDisplay] ;
  s .= [x mValueAtIndex !0] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_BitTestSkip generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap inDataAddressMap
  !@codeList outCode
:
  @uint code ;
  if mSkipIfSet then
    code := 0xA000 ; # BTFSS
  else
    code := 0xB000 ; # BTFSC
  end if ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  code := code | (mBitNumber << 9) ;
#--- Assembly string
  @string s := "    " ;
  if mSkipIfSet then
    s .= "BTFSS" ;
  else
    s .= "BTFSC" ;
  end if ;
  s .= " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
#---
  outCode := [@codeList listWithValue
    !s
    ![@uintlist listWithValue !code]
  ] ;
  [mEmbeddedInstruction generateCode
    !inAddress + 2
    !inSymbolTable
    !inDataAddressMap
    ??@codeList c
  ] ;
  outCode .= c ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_BitTestSkip performInstructionRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  const @uint n := ioConversionCount ;
  [mEmbeddedInstruction performInstructionRelativeBranchResolution
    !inAddress + 2
    !inBlockLabel
    !inSymbolTable
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18SequentialInstruction outModifiedEmbeddedInstruction
  ] ;
  if n != ioConversionCount then
    outModifiedInstruction := [@ipic18_skip_instruction_BitTestSkip new 
      !mInstructionLocation
      !outModifiedEmbeddedInstruction
      !mSkipIfSet
      !mRegisterDescription
      !mBitNumber
    ] ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_skip_instruction_FDA

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_FDA instructionDisplay ->@stringlist outResult :
  @string s ;
  switch mInstruction_FDA_base_code
  when DECFSZ : s := "DECFSZ" ;
  when DCFSNZ : s := "DCFSNZ" ;
  when INCFSZ : s := "INCFSZ" ;
  when INFSNZ : s := "INFSNZ" ;
  end switch ;
  s .= " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    s .= ", W" ;
  end if ;
  s .= " ? " ;
  const @stringlist x := [mEmbeddedInstruction instructionDisplay] ;
  s .= [x mValueAtIndex !0] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_FDA generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap inDataAddressMap
  !@codeList outCode
:
  @uint binCode ;
  switch mInstruction_FDA_base_code
  when DECFSZ : binCode := 0x2C00 ;
  when DCFSNZ : binCode := 0x4C00 ;
  when INCFSZ : binCode := 0x3C00 ;
  when INFSNZ : binCode := 0x4800 ;
  end switch ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
  end if ;
  binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
#--- Assembly string
  @string assemblyCode := "    " ;
  switch mInstruction_FDA_base_code
  when DECFSZ : assemblyCode .= "DECFSZ" ;
  when DCFSNZ : assemblyCode .= "DCFSNZ" ;
  when INCFSZ : assemblyCode .= "INCFSZ" ;
  when INFSNZ : assemblyCode .= "INFSNZ" ;
  end switch ;
  assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    assemblyCode .= ", W" ;
  else
    binCode := binCode | 0x0200 ;
    assemblyCode .= ", F" ;
  end if ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
    assemblyCode .= ", BSR_ACCESS" ;
  end if ;
#---
  outCode := [@codeList listWithValue
    !assemblyCode
    ![@uintlist listWithValue !binCode]
  ] ;
  [mEmbeddedInstruction generateCode
    !inAddress + 2
    !inSymbolTable
    !inDataAddressMap
    ??@codeList c
  ] ;
  outCode .= c ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction_FDA performInstructionRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  const @uint n := ioConversionCount ;
  [mEmbeddedInstruction performInstructionRelativeBranchResolution
    !inAddress + 2
    !inBlockLabel
    !inSymbolTable
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18SequentialInstruction outModifiedEmbeddedInstruction
  ] ;
  if n != ioConversionCount then
    outModifiedInstruction := [@ipic18_skip_instruction_FDA new 
      !mInstructionLocation
      !outModifiedEmbeddedInstruction
      !mInstruction_FDA_base_code
      !mRegisterDescription
      !m_W_isDestination
    ] ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_JSR

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_JSR instructionSize
  -> @uint outSize
:
  switch mKind
  when ipicRelative, relative :
    outSize := 2 ;
  when absolute :
    outSize := 4 ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR instructionRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@branchOverflowMap ioOverflowMap
:
  switch mKind
  when ipicRelative, relative :
    if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabel !inAddress] then
      ioOverflowMap += !inBlockLabel !mTargetLabel->string ;
    end if ;
  when absolute : # Allways ok
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR performInstructionRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  switch mKind
  when ipicRelative :
    if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabel !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": JSR " . mTargetLabel . " --> CALL " . mTargetLabel . "\n" ;
      outModifiedInstruction := [@ipic18_intermediate_JSR new !mInstructionLocation !mTargetLabel ![@jumpInstructionKind absolute]] ;
    end if ;
  when relative :
    if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabel !inAddress] then
      error mInstructionLocation: "displacement ("
      . pic18_BRA_RCALL_displacement [!inSymbolTable !mTargetLabel !inAddress]
      . ") too large for RCALL " . mTargetLabel . " instruction (limited to [-1024, 1023])" ;
    end if ;
  when absolute : # Allways ok
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_JSR instructionDisplay ->@stringlist outResult :
    @string s ;
    switch mKind
    when ipicRelative : s := "JSR " . mTargetLabel ;
    when relative     : s := "RCALL " . mTargetLabel ;
    when absolute     : s := "CALL " . mTargetLabel ;
  end switch ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap unused inDataAddressMap
  !@codeList outCode
:
  [inSymbolTable searchKey !mTargetLabel ??@uint targetAddress] ;
  switch mKind
  when ipicRelative, relative :
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !mTargetLabel] ;
  when absolute :
    outCode := pic18_CALL_instruction_code [!targetAddress !mTargetLabel] ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_computed_rcall

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_computed_rcall instructionSize
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 4 * [mTargetInstructions length] - 2 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_computed_rcall instructionDisplay ->@stringlist outResult :
  @string s := "COMPUTED " ;
  if not mUsesRCALL then
    s .= "(uses CALL)" ;
  end if ;
  outResult := [@stringlist listWithValue !s] ;
  foreach mTargetInstructions do
    foreach [mInstruction instructionDisplay] do
      outResult += !"   " . mValue ;
    end foreach ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall instructionRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@branchOverflowMap ioOverflowMap
:
  @uint address := inAddress + if mUsesRCALL then 2 else 4 end ;
  foreach mTargetInstructions do
    [mInstruction instructionRelativeBranchOverflow
      !address
      !inBlockLabel
      !inSymbolTable
      !?ioOverflowMap
    ] ;
    address := address + 4 ;
  end foreach ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_4" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_4" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall performInstructionRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  @uint unusedConversionCount := 0 ;
  @string unusedListing := "" ;
  @uint address := inAddress + if mUsesRCALL then 2 else 4 end ;
  foreach mTargetInstructions do
    #--- NEVER CONVERT: ONLY PERFORM CHECKING
    [mInstruction performInstructionRelativeBranchResolution
      !address
      !inBlockLabel
      !inSymbolTable
      !?unusedConversionCount
      !?unusedListing
      ?* # ?@ipic18SequentialInstruction outModifiedInstruction
    ] ;
    address := address + 4 ;
  end foreach ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_4" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed rcall needs to use CALL _computed_goto_4\n" ;
      outModifiedInstruction := [@ipic18_intermediate_instruction_computed_rcall new
        !mInstructionLocation
        !mTargetInstructions
        !false # Uses GOTO
      ] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@pic18_dataAddressMap inDataAddressMap
  !@codeList outCode
:
  const @lstring target [new !"_computed_goto_4" !mInstructionLocation] ;

  [inSymbolTable searchKey !target ??@uint computetedGoto4Address] ;

  @uint currentInstructionAddress ;
  if mUsesRCALL then
    currentInstructionAddress := inAddress + 2 ;
    outCode := pic18_RCALL_instruction_code [!inAddress !computetedGoto4Address !target] ;
  else
    currentInstructionAddress := inAddress + 4 ;
    outCode := pic18_CALL_instruction_code [!computetedGoto4Address !target] ;
  end if ;
  const @uint instructionFollowingComputedRcallAddress := currentInstructionAddress + [mTargetInstructions length] * 4 - 1 ;
  const @lstring nextInstructionLabel [new !"_computed_" . [inAddress xString] !mInstructionLocation] ;
  @uint idx := 0 ;
  foreach mTargetInstructions do
    idx ++ ;
    [mInstruction generateCode
      !currentInstructionAddress
      !inSymbolTable
      !inDataAddressMap
      ??@codeList instructionCode
    ] ;
    outCode .= instructionCode ;
    currentInstructionAddress := currentInstructionAddress + 2 ;
    if idx < [mTargetInstructions length] then
      outCode .= pic18_BRA_instruction_code [!currentInstructionAddress !instructionFollowingComputedRcallAddress !nextInstructionLabel] ;
      currentInstructionAddress := currentInstructionAddress + 2 ;
    end if ;
  end foreach ;
#--- Emit label instruction
  outCode .= pic18_definition_label [!nextInstructionLabel] ;
end method ;

#----------------------------------------------------------------------------*



end semantics ;
