semantics ipic18_regular_instructions :
import "ipic18_block_representation.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Instruction size

#----------------------------------------------------------------------------*

reader @ipic18SequentialInstruction instructionSize
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_JSR instructionSize
  -> @uint outSize
:
  switch mKind
  when ipicRelative, relative :
    outSize := 2 ;
  when absolute :
    outSize := 4 ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_computed_rcall instructionSize
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 4 * [mTargetLabels length] - 2 ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution : instruction

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction checkRelativesResolution
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ?!@uint unused ioConversionCount
  ?!@string unused ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate instruction display

#----------------------------------------------------------------------------*

abstract reader @ipic18SequentialInstruction instructionDisplay
  ->@stringlist outResult
;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18InstructionWithNoOperand

#----------------------------------------------------------------------------*

reader @pic18InstructionWithNoOperandKind mnemonic
  ->@string outResult
:
  switch selfcopy
  when CLRWDT : outResult := "CLRWDT" ;
  when DAW : outResult := "DAW" ;
  when NOP : outResult := "NOP" ;
  when POP : outResult := "POP" ;
  when PUSH : outResult := "PUSH" ;
  when RESET : outResult := "RESET" ;
  when SLEEP : outResult := "SLEEP" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18InstructionWithNoOperand instructionDisplay
  ->@stringlist outResult
:
  outResult := [@stringlist listWithValue ![mKind mnemonic]] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18InstructionWithNoOperand generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint c ;
  switch mKind
  when CLRWDT :
    c := 0x0004 ;
  when DAW :
    c := 0x0007 ;
  when NOP :
    c := 0x0000 ;
  when POP :
    c := 0x0006 ;
  when PUSH :
    c := 0x0005 ;
  when RESET :
    c := 0x00FF ;
  when SLEEP :
    c := 0x0003 ;
  end switch ;
  outCode := [@codeList listWithValue
    ![mKind mnemonic]
    ![@uintlist listWithValue !c]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FDA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FDA instructionDisplay
  ->@stringlist outResult
:
  @string s := [mInstruction_FDA_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination & [mRegisterDescription mNeedsBSR] then
    s .= ", W, BSR_ACCESS" ;
  elsif [mRegisterDescription mNeedsBSR] then
    s .= ", F, BSR_ACCESS" ;
  elsif m_W_isDestination then
    s .= ", W" ;
  else
    s .= ", F" ;
  end if ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FDA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mInstruction_FDA_base_code
  when ADDWF : code := 0x2400 ;
  when ADDWFC : code := 0x2000 ;
  when ANDWF : code := 0x1400 ;
  when COMF : code := 0x1C00 ;
  when DECF : code := 0x0400 ;
  when DECFSZ : code := 0x2C00 ;
  when DCFSNZ : code := 0x4C00 ;
  when INCF : code := 0x2800 ;
  when INCFSZ : code := 0x3C00 ;
  when INFSNZ : code := 0x4800 ;
  when IORWF : code := 0x1000 ;
  when MOVF : code := 0x5000 ;
  when RLCF : code := 0x3400 ;
  when RLNCF : code := 0x4400 ;
  when RRCF : code := 0x3000 ;
  when RRNCF : code := 0x4000 ;
  when SUBFWB : code := 0x5400 ;
  when SUBWF : code := 0x5C00 ;
  when SUBWFB :  code := 0x5800 ;
  when SWAPF : code := 0x3800 ;
  when XORWF : code := 0x1800 ;
  end switch ;

  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FDA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FA instructionDisplay ->@stringlist outResult :
  @string s := [mFAinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mFAinstruction
  when CLRF   : code := 0x6A00 ;
  when CPFSEQ : code := 0x6200 ;
  when CPFSGT : code := 0x6400 ;
  when CPFSLT : code := 0x6000 ;
  when MOVWF  : code := 0x6E00 ;
  when MULWF  : code := 0x0200 ;
  when NEGF   : code := 0x6C00 ;
  when SETF   : code := 0x6800 ;
  when TSTFSZ : code := 0x6600 ;
  end switch ;

  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MOVFF

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVFF instructionSize
  -> @uint outSize
:
  outSize := 4 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVFF instructionDisplay ->@stringlist outResult :
  @string s := "MOVFF " . [mSourceRegisterDescription mAssemblyString]
  . ", " . [mDestinationRegisterDescription mAssemblyString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MOVFF generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uintlist code [emptyList] ;
  code += !0xC000 | [mSourceRegisterDescription mRegisterAddress] ;
  code += !0xF000 | [mDestinationRegisterDescription mRegisterAddress] ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    !code
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_literalOperation

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_literalOperation instructionDisplay ->@stringlist outResult :
  @string s := [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_literalOperation generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mLiteralInstruction
  when ADDLW : code := 0x0F00 ;
  when ANDLW : code := 0x0B00 ;
  when IORLW : code := 0x0900 ;
  when MOVLW : code := 0x0E00 ;
  when MULLW : code := 0x0D00 ;
  when SUBLW : code := 0x0800 ;
  when XORLW : code := 0x0A00 ;
  end switch ;
  code := code | mLiteralValue ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_LFSR

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_LFSR instructionSize
  -> @uint outSize
:
  outSize := 4 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_LFSR instructionDisplay ->@stringlist outResult :
  @string s := "LFSR " . [[mFSRindex uint] string] . ", " . [mValue hexString] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_LFSR generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uintlist code [emptyList] ;
  code += !0xEE00 | ([mFSRindex uint] << 4) | (mValue >> 8) ;
  code += !0xF000 | (mValue & 255) ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    !code
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_FBA

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_FBA instructionDisplay ->@stringlist outResult :
  @string s := [mBitOrientedOp mnemonic] . " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_FBA generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mBitOrientedOp
  when BCF : code := 0x9000 ;
  when BSF : code := 0x8000 ;
  when BTG : code := 0x7000 ;
  end switch ;
  if [mRegisterDescription mNeedsBSR] then
    code := code | 0x0100 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 255) ;
  code := code | (mBitNumber << 9) ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MOVLB

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MOVLB instructionDisplay ->@stringlist outResult :
  @string s := "MOVLB " . [[mBankIndex uint] string] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MOVLB generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  const @uint code := 0x0100 | [mBankIndex uint] ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_TBLRD

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_TBLRD instructionDisplay ->@stringlist outResult :
  @string s := "TBLRD " . [mOption mnemonic] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_TBLRD generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mOption
  when simpleAccess  : code := 0x0008 ;
  when postIncrement : code := 0x0009 ;
  when postDecrement : code := 0x000A ;
  when preIncrement  : code := 0x000B ;
  end switch ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_TBLWT

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_TBLWT instructionDisplay ->@stringlist outResult :
  @string s := "TBLWT " . [mOption mnemonic] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_TBLWT generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  @uint code ;
  switch mOption
  when simpleAccess  : code := 0x000C ;
  when postIncrement : code := 0x000D ;
  when postDecrement : code := 0x000E ;
  when preIncrement  : code := 0x000F ;
  end switch ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_instruction_MNOP

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MNOP instructionSize
  -> @uint outSize
:
  outSize := mOccurrenceFactor->uint * 2 ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_MNOP instructionDisplay ->@stringlist outResult :
  @string s := "MNOP " . [mOccurrenceFactor uint] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_MNOP generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  outCode := [@codeList emptyList] ;
  if mOccurrenceFactor->uint == 0 then
    outCode += !"MNOP 0" ![@uintlist emptyList] ;
  else
    outCode += !"MNOP " . mOccurrenceFactor->uint ![@uintlist listWithValue !0x0000] ;
    @uint idx := 1 ;
    loop [mOccurrenceFactor uint] :
    while idx < [mOccurrenceFactor uint]
    do
      outCode += !"" ![@uintlist listWithValue !0x0000] ;
      idx ++ ;
    end loop ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_intermediate_MOV_LABEL_W

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_MOV_LABEL_W instructionDisplay ->@stringlist outResult :
  @string s := "MOVLW ((" . mLabel . " + " . mOffset . ") >> " . mRightShift . ") & 0xFF"  ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_MOV_LABEL_W generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@ipic18BlockList unused inGeneratedBlockList
  !@codeList outCode
:
  [inSymbolTable searchKey !mLabel ??@uint address] ;
  const @uint code := ((address + mOffset) >> mRightShift) & 0xFF ;
  const @uint code_MOVLW := 0x0E00 ;
  outCode := [@codeList listWithValue
    ![[selfcopy instructionDisplay] mValueAtIndex !0]
    ![@uintlist listWithValue !code | code_MOVLW]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Intermediate @ipic18_skip_instruction_FA

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_FA instructionDisplay ->@stringlist outResult :
  @string s := [mFAinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] . " ?" ;
  outResult := [@stringlist listWithValue !s] ;
  outResult .= [mEmbeddedInstruction instructionDisplay] ;
end reader ;

#----------------------------------------------------------------------------*

#!*******************************************

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_instruction_computed_rcall instructionDisplay ->@stringlist outResult :
  @string s := "COMPUTED RCALL " ;
  if mUsesRCALL then
    s .= "(uses RCALL)" ;
  else
    s .= "(uses CALL)" ;
  end if ;
  outResult := [@stringlist listWithValue !s] ;
  foreach mTargetLabels do
    outResult += !"  " . mValue ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_BitTestSkip instructionDisplay ->@stringlist outResult :
  @string s := "" ;
  if mSkipIfSet then
    s .= "!" ;
  end if ;
  s .= [mRegisterDescription mAssemblyString] . "." . [mBitNumber string]
  . " ? " ;
  const @stringlist x := [mEmbeddedInstruction instructionDisplay] ;
  s .= [x mValueAtIndex !0] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_skip_instruction_FDA instructionDisplay ->@stringlist outResult :
  @string s := [mInstruction_FDA_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    s .= ", W" ;
  end if ;
  s .= " ? " ;
  const @stringlist x := [mEmbeddedInstruction instructionDisplay] ;
  s .= [x mValueAtIndex !0] ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18_intermediate_JSR instructionDisplay ->@stringlist outResult :
    @string s ;
    switch mKind
    when ipicRelative : s := "JSR " . mTargetLabel ;
    when relative     : s := "RCALL " . mTargetLabel ;
    when absolute     : s := "CALL " . mTargetLabel ;
  end switch ;
  outResult := [@stringlist listWithValue !s] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  switch mKind
  when ipicRelative :
    checkBRA_RCALL !inSymbolTable !mTargetLabel !inAddress ??@bool ok ?* ;
    if not ok then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": JSR " . mTargetLabel . " --> CALL " . mTargetLabel . "\n" ;
      outModifiedInstruction := [@ipic18_intermediate_JSR new !mInstructionLocation !mTargetLabel ![@jumpInstructionKind absolute]] ;
    end if ;
  when relative :
    checkBRA_RCALL !inSymbolTable !mTargetLabel !inAddress ??@bool ok ??@sint d ;
    if not ok then
      error mInstructionLocation: "displacement (" . d . ") too large for RCALL " . mTargetLabel . " instruction (limited to [-1024, 1023])" ;
    end if ;
  when absolute : # Allways ok
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18SequentialInstruction outModifiedInstruction
:
  outModifiedInstruction := selfcopy ;
  foreach mTargetLabels do
    checkBRA_RCALL !inSymbolTable !mValue !inAddress ??@bool ok ?@sint d ;
    if not ok then
      error mInstructionLocation: "displacement (" . d . ") too large for rcall " . mValue . " instruction (limited to [-1024, 1023])" ;
    end if ;
  end foreach ;
  if mUsesRCALL then
    checkBRA_RCALL !inSymbolTable !["_computed_goto_2" nowhere] !inAddress ??@bool ok ?* ;
    if not ok then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed rcall needs to use CALL _computed_goto_2\n" ;
      outModifiedInstruction := [@ipic18_intermediate_instruction_computed_rcall new
        !mInstructionLocation
        !mTargetLabels
        !mEndOfInstructionLabel
        !false # Uses GOTO
      ] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*



end semantics ;
