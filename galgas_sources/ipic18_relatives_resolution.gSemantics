semantics ipic18_relatives_resolution :
import "ipic18_regular_instructions.gSemantics" ;
import "ipic18_terminators.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution : terminator

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator checkRelativesResolution
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint unused ioConversionCount
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if inNextBlockLabel != mLabel->string then
    switch mKind
    when ipicRelative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        ioConversionCount ++ ;
        ioListFileContents .= "  " . inBlockLabel . ": JUMP " . mLabel . " --> GOTO " . mLabel . "\n" ;
        outModifiedTerminator := [@ipic18JumpTerminator new !mInstructionLocation !mLabel ![@jumpInstructionKind absolute]] ;
      end if ;
    when relative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        error mInstructionLocation: "displacement ("
        . pic18_BRA_RCALL_displacement [!inSymbolTable !mLabel !inAddress] . ") too large for BRA "
        . mLabel . " instruction (limited to [-1024, 1023])" ;
      end if ;
    when absolute : # Allways ok
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  @conditionalBranchMode branchModeOnFalseLabel := mBranchModeOnFalseLabel ;
  @conditionalBranchMode branchModeOnTrueLabel := mBranchModeOnTrueLabel ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenTrue . "\n" ;
      end if ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+2] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+4] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+6] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
  if (branchModeOnFalseLabel == mBranchModeOnFalseLabel) & (branchModeOnTrueLabel == mBranchModeOnTrueLabel) then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18ConditionalJumpTerminator new
      !mInstructionLocation
      !mConditionalBranch
      !mTargetLabelWhenTrue
      !branchModeOnTrueLabel
      !mTargetLabelWhenFalse
      !branchModeOnFalseLabel
    ] ;
    ioConversionCount ++ ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedRETLWTerminator new !mInstructionLocation !mLiteralValues !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  foreach mTargetLabels do
    if not pic18_checkBRA_RCALL [!inSymbolTable !mValue !inAddress] then
      error mInstructionLocation: "displacement ("
      . pic18_BRA_RCALL_displacement [!inSymbolTable !mValue !inAddress] . ") too large for rcall "
      . mValue . " instruction (limited to [-1024, 1023])" ;
    end if ;
  end foreach ;
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress ] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedBraTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed GOTO needs CALL _computed_goto_4\n" ;
      outModifiedTerminator := [@ipic18ComputedGotoTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18RegisterComparisonTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18IncDecRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18TestRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18BitTestTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mBitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution

#----------------------------------------------------------------------------*

method @ipic18Block checkRelativesResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ??@uint inBlockStartAddress
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18Block outModifiedBlock
:
#--- Instruction
  @ipic18SequentialInstructionList modifiedInstructionList [emptyList] ;
  @uint address := inBlockStartAddress ;
  foreach mInstructionList do
    [mInstruction checkRelativesResolution
      !address
      !mLabel->string
      !inSymbolTable
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18SequentialInstruction modifiedInstruction
    ] ;
    modifiedInstructionList += !modifiedInstruction ;
    address := address + [mInstruction instructionSize] ;
  end foreach ;
#--- Terminator
  [mTerminator checkRelativesResolution
    !address
    !mLabel->string
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18AbstractBlockTerminator modifiedTerminator
  ] ;
#---
  outModifiedBlock := [@ipic18Block new
    !mStartAddress
    !mLabel
    !modifiedInstructionList
    !modifiedTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine checkRelativeResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@ipic18BlockList ioBlockList
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
:
  @ipic18BlockList modifiedBlockList [emptyList] ;
  @uint blockStartAddress := 0 ;
  foreach ioBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [ioBlockList length] then
      nextBlockLabel := [ioBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [mBlock checkRelativesResolution
      !inSymbolTable
      !nextBlockLabel
      !blockStartAddress
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18Block modifiedBlock
    ] ;
    modifiedBlockList += !modifiedBlock ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
  ioBlockList := modifiedBlockList ;
end routine ;

#----------------------------------------------------------------------------*

#!--- Block Size and address

#----------------------------------------------------------------------------*

reader @ipic18Block blockSize
  ??@string inNextBlockLabel
  ->@uint outResult
:
  outResult := [mTerminator terminatorSize !inNextBlockLabel] ;
  foreach mInstructionList do
    outResult := outResult + [mInstruction instructionSize] ;  
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

routine computeLabelAbsoluteAddressMap
  ??@ipic18BlockList inGeneratedBlockList
  !@symbolTableForRelativesResolution outSymbolTable
  !@uint outFreeAddress
:
  outSymbolTable := [@symbolTableForRelativesResolution emptyMap] ;
  @uint blockStartAddress := 0 ;
  foreach inGeneratedBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inGeneratedBlockList length] then
      nextBlockLabel := [inGeneratedBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [!?outSymbolTable insertKey !mBlock->mLabel !blockStartAddress] ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
  outFreeAddress := blockStartAddress ;
end routine ;

#----------------------------------------------------------------------------*

routine ipic18RelativesResolution
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
#---
  if [option.verbose_output value] then
    message "Relative branch conversion to absolute:\n" ;
  end if ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["RELATIVES RESOLUTION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
#---
  @bool resolutionDone := false ;
  @uint pass := 0 ;
  loop [ioGeneratedBlockList length] + 1 :
  while (not resolutionDone) & ([@uint errorCount] == 0) do
    pass ++ ;
    computeLabelAbsoluteAddressMap
      !ioGeneratedBlockList
      ??@symbolTableForRelativesResolution symbolTable
      ?*
    ;
    ioListFileContents .= "\nPass " . pass . ":\n" ;
    @uint conversionCount := 0 ;
    checkRelativeResolution
      !symbolTable
      !?ioGeneratedBlockList
      !?conversionCount
      !?ioListFileContents
    ;
    resolutionDone := conversionCount == 0 ;
    if [option.verbose_output value] then
      @string s := "  Pass " . pass . ": " ;
      if conversionCount == 0 then
        s .= "none." ;
      elsif conversionCount == 1 then
        s .= "1 conversion" ;
      else
        s .= [conversionCount string] . " conversions" ;
      end if ;
      message s . "\n" ;
    end if ;
  end loop ;
  if [option.verbose_output value] then
    ioListFileContents .= "  No conversion.\n\n" ;
    message "\n" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
