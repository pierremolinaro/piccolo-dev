semantics ipic18_relatives_resolution :
import "ipic18_regular_instructions.gSemantics" ;
import "ipic18_terminators.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution : terminator

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator checkRelativesResolution
  ??@uint unused inAddress
  ??@string unused inBlockLabel
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint unused ioConversionCount
  ?!@string unused ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if inNextBlockLabel != mLabel->string then
    switch mKind
    when ipicRelative :
      checkBRA_RCALL !inSymbolTable !mLabel !inAddress ??@bool ok ?* ;
      if not ok then
        ioConversionCount ++ ;
        ioListFileContents .= "  " . inBlockLabel . ": JUMP " . mLabel . " --> GOTO " . mLabel . "\n" ;
        outModifiedTerminator := [@ipic18JumpTerminator new !mInstructionLocation !mLabel ![@jumpInstructionKind absolute]] ;
      end if ;
    when relative :
      checkBRA_RCALL !inSymbolTable !mLabel !inAddress ??@bool ok ??@sint d ;
      if not ok then
        error mInstructionLocation: "displacement (" . d . ") too large for BRA " . mLabel . " instruction (limited to [-1024, 1023])" ;
      end if ;
    when absolute : # Allways ok
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    checkBRA_RCALL !inSymbolTable !["_computed_goto_2" nowhere] !inAddress ??@bool ok ?* ;
    if not ok then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedRETLWTerminator new !mInstructionLocation !mLiteralValues !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  foreach mTargetLabels do
    checkBRA_RCALL !inSymbolTable !mValue !inAddress ??@bool ok ?@sint d ;
    if not ok then
      error mInstructionLocation: "displacement (" . d . ") too large for rcall " . mValue . " instruction (limited to [-1024, 1023])" ;
    end if ;
  end foreach ;
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    checkBRA_RCALL !inSymbolTable !["_computed_goto_2" nowhere] !inAddress ??@bool ok ?* ;
    if not ok then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedBraTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    checkBRA_RCALL !inSymbolTable !["_computed_goto_2" nowhere] !inAddress ??@bool ok ?* ;
    if not ok then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed GOTO needs CALL _computed_goto_4\n" ;
      outModifiedTerminator := [@ipic18ComputedGotoTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18RegisterComparisonTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18IncDecRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18TestRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator checkRelativesResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse checkRelativesResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18BitTestTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mBitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Check relative resolution

#----------------------------------------------------------------------------*

method @ipic18Block checkRelativesResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ??@uint inBlockStartAddress
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18Block outModifiedBlock
:
#--- Instruction
  @ipic18SequentialInstructionList modifiedInstructionList [emptyList] ;
  @uint address := inBlockStartAddress ;
  foreach mInstructionList do
    [mInstruction checkRelativesResolution
      !address
      !mLabel->string
      !inSymbolTable
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18SequentialInstruction modifiedInstruction
    ] ;
    modifiedInstructionList += !modifiedInstruction ;
    address := address + [mInstruction instructionSize] ;
  end foreach ;
#--- Terminator
  [mTerminator checkRelativesResolution
    !address
    !mLabel->string
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18AbstractBlockTerminator modifiedTerminator
  ] ;
#---
  outModifiedBlock := [@ipic18Block new
    !mStartAddress
    !mLabel
    !modifiedInstructionList
    !modifiedTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine checkRelativeResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@ipic18BlockList ioBlockList
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
:
  @ipic18BlockList modifiedBlockList [emptyList] ;
  @uint blockStartAddress := 0 ;
  foreach ioBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [ioBlockList length] then
      nextBlockLabel := [ioBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [mBlock checkRelativesResolution
      !inSymbolTable
      !nextBlockLabel
      !blockStartAddress
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18Block modifiedBlock
    ] ;
    modifiedBlockList += !modifiedBlock ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
  ioBlockList := modifiedBlockList ;
end routine ;

#----------------------------------------------------------------------------*

#!--- Block Size and address

#----------------------------------------------------------------------------*

reader @ipic18Block blockSize
  ??@string inNextBlockLabel
  ->@uint outResult
:
  outResult := [mTerminator terminatorSize !inNextBlockLabel] ;
  foreach mInstructionList do
    outResult := outResult + [mInstruction instructionSize] ;  
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

routine computeLabelAbsoluteAddressMap
  ??@ipic18BlockList inGeneratedBlockList
  !@symbolTableForRelativesResolution outSymbolTable
:
  outSymbolTable := [@symbolTableForRelativesResolution emptyMap] ;
  @uint blockStartAddress := 0 ;
  foreach inGeneratedBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inGeneratedBlockList length] then
      nextBlockLabel := [inGeneratedBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [!?outSymbolTable insertKey !mBlock->mLabel !blockStartAddress] ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine ipic18RelativesResolution
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
#---
  if [option.verbose_output value] then
    message "Relative branch conversion to absolute:\n" ;
  end if ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["RELATIVES RESOLUTION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
#---
  @bool resolutionDone := false ;
  @uint pass := 0 ;
  loop [ioGeneratedBlockList length] + 1 :
  while (not resolutionDone) & ([@uint errorCount] == 0) do
    pass ++ ;
    computeLabelAbsoluteAddressMap
      !ioGeneratedBlockList
      ??@symbolTableForRelativesResolution symbolTable
    ;
    ioListFileContents .= "  Pass " . pass . ":\n" ;
    @uint conversionCount := 0 ;
    checkRelativeResolution
      !symbolTable
      !?ioGeneratedBlockList
      !?conversionCount
      !?ioListFileContents
    ;
    if [option.verbose_output value] then
      @string s := "--- Pass " . pass . ": " ;
      if conversionCount == 0 then
        resolutionDone := true ; 
        s .= "none." ;
      elsif conversionCount == 1 then
        s .= "1 conversion" ;
      else
        s .= [conversionCount string] . " conversions" ;
      end if ;
      message s . "\n" ;
    end if ;
  end loop ;
  if [option.verbose_output value] then
    message "\n" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
