semantics ipic18_relatives_resolution :
import "ipic18_regular_instructions.gSemantics" ;
import "ipic18_terminators.gSemantics" ;

#----------------------------------------------------------------------------*

method @ipic18Block performRelativesResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ??@uint inBlockStartAddress
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18Block outModifiedBlock
:
#--- Instruction
  @ipic18SequentialInstructionList modifiedInstructionList [emptyList] ;
  @uint address := inBlockStartAddress ;
  foreach mInstructionList do
    [mInstruction performInstructionRelativeBranchResolution
      !address
      !mLabel->string
      !inSymbolTable
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18SequentialInstruction modifiedInstruction
    ] ;
    modifiedInstructionList += !modifiedInstruction ;
    address := address + [mInstruction instructionSize] ;
  end foreach ;
#--- Terminator
  [mTerminator performTerminatorRelativeBranchResolution
    !address
    !mLabel->string
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ??@ipic18AbstractBlockTerminator modifiedTerminator
  ] ;
#---
  outModifiedBlock := [@ipic18Block new
    !mStartAddress
    !mLabel
    !modifiedInstructionList
    !modifiedTerminator
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine performRelativesResolution
  ??@symbolTableForRelativesResolution inSymbolTable
  ?!@ipic18BlockList ioBlockList
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
:
  @ipic18BlockList modifiedBlockList [emptyList] ;
  @uint blockStartAddress := 0 ;
  foreach ioBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [ioBlockList length] then
      nextBlockLabel := [ioBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [mBlock performRelativesResolution
      !inSymbolTable
      !nextBlockLabel
      !blockStartAddress
      !?ioConversionCount
      !?ioListFileContents
      ??@ipic18Block modifiedBlock
    ] ;
    modifiedBlockList += !modifiedBlock ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
  ioBlockList := modifiedBlockList ;
end routine ;

#----------------------------------------------------------------------------*

#!--- Block Size and address

#----------------------------------------------------------------------------*

reader @ipic18Block blockSize
  ??@string inNextBlockLabel
  ->@uint outResult
:
  outResult := [mTerminator terminatorSize !inNextBlockLabel] ;
  foreach mInstructionList do
    outResult := outResult + [mInstruction instructionSize] ;  
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

routine computeLabelAbsoluteAddressMap
  ??@ipic18BlockList inGeneratedBlockList
  !@symbolTableForRelativesResolution outSymbolTable
  !@uint outFreeAddress
:
  outSymbolTable := [@symbolTableForRelativesResolution emptyMap] ;
  @uint blockStartAddress := 0 ;
  foreach inGeneratedBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inGeneratedBlockList length] then
      nextBlockLabel := [inGeneratedBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [!?outSymbolTable insertKey !mBlock->mLabel !blockStartAddress] ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
  outFreeAddress := blockStartAddress ;
end routine ;

#----------------------------------------------------------------------------*

routine ipic18RelativesResolution
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
#---
  if [option.verbose_output value] then
    message "Relative branch conversion to absolute:\n" ;
  end if ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["RELATIVES RESOLUTION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
#---
  @bool resolutionDone := false ;
  @uint pass := 0 ;
  loop [ioGeneratedBlockList length] + 1 :
  while (not resolutionDone) & ([@uint errorCount] == 0) do
    pass ++ ;
    computeLabelAbsoluteAddressMap
      !ioGeneratedBlockList
      ??@symbolTableForRelativesResolution symbolTable
      ?*
    ;
    ioListFileContents .= "\nPass " . pass . ":\n" ;
    @uint conversionCount := 0 ;
    performRelativesResolution
      !symbolTable
      !?ioGeneratedBlockList
      !?conversionCount
      !?ioListFileContents
    ;
    resolutionDone := conversionCount == 0 ;
    if [option.verbose_output value] then
      @string s := "  Pass " . pass . ": " ;
      if conversionCount == 0 then
        s .= "none." ;
      elsif conversionCount == 1 then
        s .= "1 conversion" ;
      else
        s .= [conversionCount string] . " conversions" ;
      end if ;
      message s . "\n" ;
    end if ;
  end loop ;
  if [option.verbose_output value] then
    ioListFileContents .= "  No conversion.\n\n" ;
    message "\n" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

#! Relative Branch overflow

#----------------------------------------------------------------------------*

method @ipic18Block relativeBranchOverflow
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ??@uint inBlockStartAddress
  ?!@branchOverflowMap ioOverflowMap
:
#--- Instruction
  @uint address := inBlockStartAddress ;
  foreach mInstructionList do
    [mInstruction instructionRelativeBranchOverflow
      !address
      !mLabel->string
      !inSymbolTable
      !?ioOverflowMap
    ] ;
    address := address + [mInstruction instructionSize] ;
  end foreach ;
#--- Terminator
  [mTerminator terminatorRelativeBranchOverflow
    !address
    !mLabel->string
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine ipic18RelativeBranchOverflow
  ??@ipic18BlockList inBlockList
  !@branchOverflowMap outOverflowMap
:
#--- Compute label map
  computeLabelAbsoluteAddressMap
    !inBlockList
    ??@symbolTableForRelativesResolution symbolTable
    ?*
  ;
#---
  outOverflowMap := [@branchOverflowMap emptyMap] ;
  @uint blockStartAddress := 0 ;
  foreach inBlockList index blockIndex do
    @string nextBlockLabel ;
    if (blockIndex+1) < [inBlockList length] then
      nextBlockLabel := [inBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
    else
      nextBlockLabel := "" ;
    end if ;
    if mBlock->mStartAddress != [@uint max] then # Absolute block
      blockStartAddress := mBlock->mStartAddress ;
    end if ;
    [mBlock relativeBranchOverflow
      !symbolTable
      !nextBlockLabel
      !blockStartAddress
      !?outOverflowMap
    ] ;
    const @uint blockSize := [mBlock blockSize !nextBlockLabel] ;
    blockStartAddress := blockStartAddress + blockSize ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
