semantics ipic18_stack_computations :
import "piccolo_options.gOption" ;
import "ipic18_relatives_resolution.gSemantics" ;

#------------------------------------------------------------------------------*

map @blockMapForStackComputation {
  @ipic18Block mBlock ;
  insert insertKey error message "the '%K' block is already declared in %L" ;
  search searchKey error message "the '%K' block is not declared" ;
}

#------------------------------------------------------------------------------*

map @routineCallMap {
  @stringset mCalledRoutineSet ;
  insert insertKey error message "the '%K' entry is already declared in %L" ;
}

#------------------------------------------------------------------------------*

map @routineStackRequirementMap {
  @uint mLevels ;
  insert insertKey error message "the '%K' entry is already declared in %L" ;
  search searchKey error message "the '%K' entry is not declared" ;
}

#----------------------------------------------------------------------------*

#!--- exploreAccessibleBlocks

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator exploreAccessibleBlocks
  ?!@stringset unused ioBlockToExploreSet
  ?!@stringset unused ioExploredBlockSet
;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator exploreAccessibleBlocks
  ?!@stringset ioBlockToExploreSet
  ?!@stringset ioExploredBlockSet
:
  [mSingleInstructionTerminatorIfConditionTrue exploreAccessibleBlocks !?ioBlockToExploreSet !?ioExploredBlockSet] ;
  [mSingleInstructionTerminatorIfConditionFalse exploreAccessibleBlocks !?ioBlockToExploreSet !?ioExploredBlockSet] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator exploreAccessibleBlocks
  ?!@stringset ioBlockToExploreSet
  ?!@stringset ioExploredBlockSet
:
  foreach mTargetLabels do
    if not [ioExploredBlockSet hasKey !mValue->string] then
      ioBlockToExploreSet += !mValue->string ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator exploreAccessibleBlocks
  ?!@stringset ioBlockToExploreSet
  ?!@stringset ioExploredBlockSet
:
  foreach mTargetLabels do
    if not [ioExploredBlockSet hasKey !mValue->string] then
      ioBlockToExploreSet += !mValue->string ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator exploreAccessibleBlocks
  ?!@stringset ioBlockToExploreSet
  ?!@stringset ioExploredBlockSet
:
  if not [ioExploredBlockSet hasKey !mLabel->string] then
    ioBlockToExploreSet += !mLabel->string ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator exploreAccessibleBlocks
  ?!@stringset ioBlockToExploreSet
  ?!@stringset ioExploredBlockSet
:
  if not [ioExploredBlockSet hasKey !mTargetLabelWhenTrue->string] then
    ioBlockToExploreSet += !mTargetLabelWhenTrue->string ;
  end if ;
  if not [ioExploredBlockSet hasKey !mTargetLabelWhenFalse->string] then
    ioBlockToExploreSet += !mTargetLabelWhenFalse->string ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator exploreAccessibleBlocks
  ?!@stringset unused ioBlockToExploreSet
  ?!@stringset unused ioExploredBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator exploreAccessibleBlocks
  ?!@stringset unused ioBlockToExploreSet
  ?!@stringset unused ioExploredBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator exploreAccessibleBlocks
  ?!@stringset unused ioBlockToExploreSet
  ?!@stringset unused ioExploredBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator exploreAccessibleBlocks
  ?!@stringset unused ioBlockToExploreSet
  ?!@stringset unused ioExploredBlockSet
:
end method ;

#----------------------------------------------------------------------------*

#!--- buildCalledRoutineSet

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction buildCalledRoutineSet
  ?!@stringset unused ioRoutineCalledSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR buildCalledRoutineSet
  ?!@stringset ioRoutineCalledSet
:
  ioRoutineCalledSet += !mTargetLabel->string ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall buildCalledRoutineSet
  ?!@stringset ioRoutineCalledSet
:
  foreach mTargetInstructions do
    [mInstruction buildCalledRoutineSet !?ioRoutineCalledSet] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_condition_skip_instruction buildCalledRoutineSet
  ?!@stringset ioRoutineCalledSet
:
  [mEmbeddedInstruction buildCalledRoutineSet !?ioRoutineCalledSet] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Routine ipic18StackComputations

#----------------------------------------------------------------------------*

routine ipic18StackComputations
  ?!@string ioListFileContents
  ??@ipic18BlockList inBlockList
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["STACK COMPUTATIONS" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
#--- Find all absolute blocks
  @stringset startLabelsToExplore [emptySet] ;
  @blockMapForStackComputation blockMapForStackComputation [emptyMap] ;
  foreach inBlockList do
    if mBlock->mAddress != [@uint max] then # Absolute block
      startLabelsToExplore += !mBlock->mLabel->string ;    
    end if ;  
    [!?blockMapForStackComputation insertKey !mBlock->mLabel !mBlock] ;
  end foreach ;
#--- Explore all blokcs to find called routines
  @routineCallMap routineCallMap [emptyMap] ;
  loop [inBlockList length] + 1 :
  while [startLabelsToExplore count] > 0
  do
    const @string startLabel := [startLabelsToExplore anyString] ;
    [!?startLabelsToExplore removeKey !startLabel] ;
  #--- Explore accessible blocks
    @stringset blockToExploreSet [emptySet] ;
    blockToExploreSet += !startLabel ;
    @stringset exploredBlockSet [emptySet] ;
    @stringset calledRoutineSet [emptySet] ;
    loop [inBlockList length] + 1 :
    while [blockToExploreSet count] > 0
    do
      const @string b := [blockToExploreSet anyString] ;
      [!?blockToExploreSet removeKey !b] ;
      exploredBlockSet += !b ;
      [blockMapForStackComputation searchKey ![b nowhere] ??@ipic18Block aBlock] ;
      [aBlock->mTerminator exploreAccessibleBlocks !?blockToExploreSet !?exploredBlockSet] ;
      foreach aBlock->mInstructionList do
        [mInstruction buildCalledRoutineSet !?calledRoutineSet] ;
      end foreach ;
    end loop ;
    [!?routineCallMap insertKey ![startLabel nowhere] !calledRoutineSet] ;
    foreach calledRoutineSet do
      if not [routineCallMap hasKey !key] then
        startLabelsToExplore += !key ;
      end if ;
    end foreach ;
  end loop ;
#  log routineCallMap ;
#--- Compute stack requirement of every routine
  @routineStackRequirementMap routineStackRequirementMap [emptyMap] ;
  @bool progress := true ;
  loop [routineCallMap count] + 1 :
  while progress
  do
    progress := false ;
    @routineCallMap tempRoutineCallMap := routineCallMap ;
    routineCallMap := [@routineCallMap emptyMap] ;
    foreach tempRoutineCallMap do
      @uint levels := 0 ;
      @bool solved := true ;
      foreach mCalledRoutineSet while solved do
        solved := [routineStackRequirementMap hasKey !key] ;
        if solved then
          [routineStackRequirementMap searchKey ![key nowhere] ??@uint rLevel] ;
          if levels <= rLevel then
            levels := rLevel + 1 ;
          end if ;
        end if ;
      end foreach ;
      if solved then
        [!?routineStackRequirementMap insertKey !lkey !levels] ;
        progress := true ;
      else
        [!?routineCallMap insertKey !lkey !mCalledRoutineSet] ;
      end if ;
    end foreach ;
  end loop ;
  ioListFileContents .= "Levels Routine\n" ;
  foreach routineStackRequirementMap do
    ioListFileContents .= [[mLevels string]stringByLeftPadding !6 !' '] . " " . lkey . "\n" ;
  end foreach ;
  ioListFileContents .= "\n" ;
#--- Recursive routines
  const @bool noRecursiveRoutine := [routineCallMap count] == 0 ;
  if not noRecursiveRoutine then
    if not [option piccolo_options.doNotWarnRecursive value] then
      warning [@location nowhere]: "There are recursive routines" ;
    end if ;
    ioListFileContents .= "The following routines are recursive:\n" ;
    foreach routineCallMap do
      ioListFileContents .= "  - " . lkey . "\n" ;
    end foreach ;  
    ioListFileContents .= "\n" ;
  end if ;
#--- Total stack requirements
  if noRecursiveRoutine then
    [routineStackRequirementMap searchKey ![".START" nowhere] ??@uint mainLevels] ;
    @uint totalLevels := mainLevels ;
    if [routineStackRequirementMap hasKey !".HIGH_INTERRUPT"] then
      [routineStackRequirementMap searchKey ![".HIGH_INTERRUPT" nowhere] ??@uint highIntLevels] ;
      totalLevels := totalLevels + highIntLevels + 1 ;
    end if ;
    if [routineStackRequirementMap hasKey !".LOW_INTERRUPT"] then
      [routineStackRequirementMap searchKey ![".LOW_INTERRUPT" nowhere] ??@uint lowIntLevels] ;
      totalLevels := totalLevels + lowIntLevels + 1 ;
    end if ;
    message "Max stack depth: " . totalLevels . "\n\n" ;
    if totalLevels > 31 then
      error [@location nowhere]: "Max stack depth is greater than 31" ;
    end if ;
  end if ;
end routine ;      

#----------------------------------------------------------------------------*


end semantics ;