semantics ipic18_terminators :
import "ipic18_block_representation.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Abstract readers

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
;

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ReturnTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETURN" ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator generateTerminatorCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    RETURN"
    ![@uintlist listWithValue !0x0012]
  ] ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18ReturnTerminator) ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18RetfieTerminator

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETFIE" ;
  if mFastReturn then
    outResult .= " FAST" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator generateTerminatorCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    " . [selfcopy terminatorDisplay !inNextBlockLabel]
    ![@uintlist listWithValue !if mFastReturn then 0x0011 else 0x0010 end]
  ] ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18RetfieTerminator) ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18RetlwTerminator

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETLW " . [mLiteralValue hexString] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator generateTerminatorCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    " .[selfcopy terminatorDisplay !inNextBlockLabel]
    ![@uintlist listWithValue !0x0C00 | mLiteralValue]
  ] ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18RetlwTerminator) ;
  if outResult then
    const @ipic18RetlwTerminator t := (cast inTerminator : @ipic18RetlwTerminator) ;
    outResult := mLiteralValue == [t mLiteralValue] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- @ipic18JumpTerminator

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  if mLabel->string == inNextBlockLabel then
    outSize := 0 ;
  else
    switch mKind
    when ipicRelative, relative :
      outSize := 2 ;
    when absolute :
      outSize := 4 ;
    end switch ;  
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mLabel->string != inNextBlockLabel then
    switch mKind
    when ipicRelative, relative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        ioOverflowMap += !inBlockLabel !mLabel->string ;
      end if ;
    when absolute :
    end switch ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if inNextBlockLabel != mLabel->string then
    switch mKind
    when ipicRelative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        ioConversionCount ++ ;
        ioListFileContents .= "  " . inBlockLabel . ": JUMP " . mLabel . " --> GOTO " . mLabel . "\n" ;
        outModifiedTerminator := [@ipic18JumpTerminator new !mInstructionLocation !mLabel ![@jumpInstructionKind absolute]] ;
      end if ;
    when relative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        error mInstructionLocation: "displacement ("
        . pic18_BRA_RCALL_displacement [!inSymbolTable !mLabel !inAddress] . ") too large for BRA "
        . mLabel . " instruction (limited to [-1024, 1023])" ;
      end if ;
    when absolute : # Allways ok
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  @string name ;
  switch mKind
    when ipicRelative : name := "JUMP "  ;
    when relative     : name := "BRA " ;
    when absolute     : name := "GOTO " ;
  end switch ;
  if inNextBlockLabel == mLabel->string then
    outResult := "(" . name . mLabel . ")" ;
  else
    outResult := name . mLabel ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if mLabel->string == inNextBlockLabel then
    outCode := [@codeList emptyList] ;
  else
    [inSymbolTable searchKey !mLabel ??@uint targetAddress] ;
    switch mKind
    when ipicRelative, relative :
      outCode := pic18_BRA_instruction_code [!inAddress !targetAddress !mLabel] ;
    when absolute :
      outCode := pic18_GOTO_instruction_code [!targetAddress !mLabel] ;
    end switch ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18JumpTerminator) ;
  if outResult then
    const @ipic18JumpTerminator t := (cast inTerminator : @ipic18JumpTerminator) ;
    outResult := (mLabel->string == [t mLabel]->string) & (mKind == [t mKind]) ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- @ipic18AbstractConditionTerminator

#----------------------------------------------------------------------------*

override reader @ipic18AbstractConditionTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel]
  ;    
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  [mSingleInstructionTerminatorIfConditionTrue terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18RegisterComparisonTerminator

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
  ;    
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] . " " ;
  switch mComparison
  when registerEqualsToW :
    outResult .= "==" ;
  when registerGreaterThanW :
    outResult .= ">" ;
  when registerLowerThanW :
    outResult .= "<" ;
  end switch ;
  outResult .= " W ? " ;
  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18RegisterComparisonTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  @uint binCode ;
  @string assemblyCode ;
  switch mComparison
  when registerEqualsToW :
    binCode := 0x6200 ;
    assemblyCode := "    CPFSEQ" ;
  when registerGreaterThanW :
    binCode := 0x6400 ;
    assemblyCode := "    CPFSGT" ;
  when registerLowerThanW :
    binCode := 0x6000 ;
    assemblyCode := "    CPFSLT" ;
  end switch ;
  assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
  binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
    assemblyCode .= ", BSR_ACCESS" ;
  end if ;
  outCode := [@codeList listWithValue
    !assemblyCode
    ![@uintlist listWithValue !binCode]
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ??@codeList falseTerminatorCode
   ] ;
   outCode .= falseTerminatorCode ;
  [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ??@codeList trueTerminatorCode
   ] ;
   outCode .= trueTerminatorCode ;
end method ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @pic18RegisterComparisonTerminator) ;
  if outResult then
    const @pic18RegisterComparisonTerminator t := (cast inTerminator : @pic18RegisterComparisonTerminator) ;
    outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
    if outResult then
      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
    end if ;
    if outResult then
      outResult := mComparison == [t mComparison] ;
    end if ;
    if outResult then
      outResult := [mRegisterDescription isEqualToRegister ![t mRegisterDescription]] ;
    end if ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18TestRegisterTerminator

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""] # False cannot be ommitted
  ;    
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] ;
  outResult .= " Z ? " ;
  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !""] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18TestRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  @uint binCode := 0x6600 ;
  @string assemblyCode := "    TSTFSZ " . [mRegisterDescription mAssemblyString] ;
  binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
    assemblyCode .= ", BSR_ACCESS" ;
  end if ;
  outCode := [@codeList listWithValue
    !assemblyCode
    ![@uintlist listWithValue !binCode]
  ] ;
#--- Generate complementary code (true terminator first terminator)
  [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
    !inAddress + 2
    !inSymbolTable
    !""
    ??@codeList falseTerminatorCode
   ] ;
   outCode .= falseTerminatorCode ;
  [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
    !inAddress + 2 + [mSingleInstructionTerminatorIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ??@codeList trueTerminatorCode
   ] ;
   outCode .= trueTerminatorCode ;
end method ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @pic18TestRegisterTerminator) ;
  if outResult then
    const @pic18TestRegisterTerminator t := (cast inTerminator : @pic18TestRegisterTerminator) ;
    outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
    if outResult then
      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
    end if ;
    if outResult then
      outResult := [mRegisterDescription isEqualToRegister ![t mRegisterDescription]] ;
    end if ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18BitTestTerminator

#----------------------------------------------------------------------------*

override reader @pic18BitTestTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] . "." . [mBitNumber string] . " ? " ;
  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18BitTestTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mBitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode := 0xB000 ;
    @string assemblyCode := "    BTFSC " . [mRegisterDescription mAssemblyString] . ", " . mBitNumber ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    binCode := binCode | (mBitNumber << 9) ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode := 0xA000 ;
    @string assemblyCode := "    BTFSS " . [mRegisterDescription mAssemblyString] . ", " . mBitNumber ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    binCode := binCode | (mBitNumber << 9) ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ??@codeList trueTerminatorCode
     ] ;
     outCode .= trueTerminatorCode ;
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @pic18BitTestTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @pic18BitTestTerminator) ;
  if outResult then
    const @pic18BitTestTerminator t := (cast inTerminator : @pic18BitTestTerminator) ;
    outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
    if outResult then
      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
    end if ;
    if outResult then
      outResult := mBitNumber == [t mBitNumber] ;
    end if ;
    if outResult then
      outResult := [mRegisterDescription isEqualToRegister ![t mRegisterDescription]] ;
    end if ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18IncDecRegisterTerminator

#----------------------------------------------------------------------------*

override reader @ipic18IncDecRegisterTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  if mIncrement then
    outResult := "INCF " ;
  else
    outResult := "DECF " ;
  end if ;
  outResult .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    outResult .= ", W" ;
  else
    outResult .= ", F" ;
  end if ;
  outResult .= " Z ? " ;
  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mSingleInstructionTerminatorIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mSingleInstructionTerminatorIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18IncDecRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode :=        if mIncrement then 0x3C00   else 0x2C00 end ;
    @string assemblyCode := if mIncrement then "    INCFSZ" else "    DECFSZ" end ;
    assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    if m_W_isDestination then
      assemblyCode .= ", W" ;
    else
      binCode := binCode | 0x0200 ;
      assemblyCode .= ", F" ;
    end if ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode :=        if mIncrement then 0x4800   else 0x4C00 end ;
    @string assemblyCode := if mIncrement then "    INFSNZ" else "    DCFSNZ" end ;
    assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    if m_W_isDestination then
      assemblyCode .= ", W" ;
    else
      binCode := binCode | 0x0200 ;
      assemblyCode .= ", F" ;
    end if ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode
      !inAddress + 2
      !inSymbolTable
      !""
      ??@codeList trueTerminatorCode
     ] ;
     outCode .= trueTerminatorCode ;
    [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode
      !inAddress + 2 + [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18IncDecRegisterTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18IncDecRegisterTerminator) ;
  if outResult then
    const @ipic18IncDecRegisterTerminator t := (cast inTerminator : @ipic18IncDecRegisterTerminator) ;
    outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
    if outResult then
      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
    end if ;
    if outResult then
      outResult := mIncrement == [t mIncrement] ;
    end if ;
    if outResult then
      outResult := m_W_isDestination == [t m_W_isDestination] ;
    end if ;
    if outResult then
      outResult := [mRegisterDescription isEqualToRegister ![t mRegisterDescription]] ;
    end if ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedRETLWTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 2 * [mLiteralValues length] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED RETLW" ;
  foreach mLiteralValues do
    outResult .= " " . [mValue hexString] ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedRETLWTerminator new !mInstructionLocation !mLiteralValues !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto2label := ["_computed_goto_2" nowhere] ;
  [inSymbolTable searchKey !goto2label ??@uint targetAddress] ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto2label] ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto2label] ;
  end if ;
  foreach mLiteralValues do
    outCode +=
      !"    RETLW " . [mValue hexString]
      ![@uintlist listWithValue !0x0C00 | mValue]
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18ComputedRETLWTerminator) ;
  if outResult then
    const @ipic18ComputedRETLWTerminator t := (cast inTerminator : @ipic18ComputedRETLWTerminator) ;
    outResult := [mLiteralValues length] == [[t mLiteralValues] length] ;
    foreach mLiteralValues, [t mLiteralValues] : t_ while outResult do
      outResult := mValue == t_mValue ;
    end foreach ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedGotoTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED GOTO " ;
  if mUsesRCALL then
    outResult .= " (uses RCALL)" ;
  else
    outResult .= " (uses CALL)" ;
  end if ;
  foreach mTargetLabels do
    outResult .= "\n                                                                       " . mValue ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 4 * [mTargetLabels length] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed GOTO needs CALL _computed_goto_4\n" ;
      outModifiedTerminator := [@ipic18ComputedGotoTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_4" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_4" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto4label := ["_computed_goto_4" nowhere] ;
  [inSymbolTable searchKey !goto4label ??@uint targetAddress] ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto4label] ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto4label] ;
  end if ;
  foreach mTargetLabels do
    [inSymbolTable searchKey !mValue ??@uint targetLabelAddress] ;
    outCode .= pic18_GOTO_instruction_code [!targetLabelAddress !mValue] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18ComputedGotoTerminator) ;
  if outResult then
    const @ipic18ComputedGotoTerminator t := (cast inTerminator : @ipic18ComputedGotoTerminator) ;
    outResult := [mTargetLabels length] == [[t mTargetLabels] length] ;
    foreach mTargetLabels, [t mTargetLabels] : t_ while outResult do
      outResult := mValue->string == t_mValue->string ;
    end foreach ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedBraTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 2 * [mTargetLabels length] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED BRA" ;
  foreach mTargetLabels do
    outResult .= " " . mValue ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  foreach mTargetLabels do
    if not pic18_checkBRA_RCALL [!inSymbolTable !mValue !inAddress] then
      error mInstructionLocation: "displacement ("
      . pic18_BRA_RCALL_displacement [!inSymbolTable !mValue !inAddress] . ") too large for rcall "
      . mValue . " instruction (limited to [-1024, 1023])" ;
    end if ;
  end foreach ;
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress ] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedBraTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  @uint address ;
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2" ;
    end if ;
    address := inAddress + 2 ;
  else
    address := inAddress + 4 ;
  end if ;
  foreach mTargetLabels do
    if not pic18_checkBRA_RCALL [!inSymbolTable !mValue !address] then
      ioOverflowMap += !inBlockLabel !mValue->string ;
    end if ;
    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto2label := ["_computed_goto_2" nowhere] ;
  [inSymbolTable searchKey !goto2label ??@uint targetAddress] ;
  @uint address ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto2label] ;
    address := inAddress + 2 ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto2label] ;
    address := inAddress + 4 ;
  end if ;
  foreach mTargetLabels do
    [inSymbolTable searchKey !mValue ??@uint labelAddress] ;
    outCode .= pic18_BRA_instruction_code [!address !labelAddress !mValue] ;
    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18ComputedBraTerminator) ;
  if outResult then
    const @ipic18ComputedBraTerminator t := (cast inTerminator : @ipic18ComputedBraTerminator) ;
    outResult := [mTargetLabels length] == [[t mTargetLabels] length] ;
    foreach mTargetLabels, [t mTargetLabels] : t_ while outResult do
      outResult := mValue->string == t_mValue->string ;
    end foreach ;
  end if ;
end reader ;


#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ConditionalBranchTerminator

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator terminatorDisplay
#  ??@string inNextBlockLabel
#  ->@string outResult
#:
#  switch mConditionalBranch
#  when bz : outResult := "Z" ;
#  when bn  : outResult := "N" ;
#  when bc :  outResult := "C" ;
#  when bov :  outResult := "OV" ;
#  when bnz : outResult := "NZ" ;
#  when bnn  : outResult := "NN" ;
#  when bnc :  outResult := "NC" ;
#  when bnov :  outResult := "NOV" ;
#  end switch ;
#  outResult .= " ? " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
#  outResult .= " : " ;
#  outResult .= [mSingleInstructionTerminatorIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
#end reader ;

#----------------------------------------------------------------------------*

#override method @ipic18ConditionalBranchTerminator generateTerminatorCode
#  ??@uint inAddress
#  ??@symbolTableForRelativesResolution inSymbolTable
#  ??@string inNextBlockLabel
#  !@codeList outCode
#:
#  if [mSingleInstructionTerminatorIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionFalse is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : !Bcc F
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#    else # False terminator is not a jump : just skip it : Bcc T ; <<false terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#      [mSingleInstructionTerminatorIfConditionFalse generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  elsif [mSingleInstructionTerminatorIfConditionFalse terminatorSize !inNextBlockLabel] == 0 then
#    if (mSingleInstructionTerminatorIfConditionTrue is == @ipic18JumpTerminator) then
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionTrue : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#    #--- Code : Bcc T
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !true] ;
#    else # True terminator is not a jump : just skip it : !Bcc f ; <<true terminator >>
#      const @ipic18JumpTerminator t := (cast mSingleInstructionTerminatorIfConditionFalse : @ipic18JumpTerminator) ;
#      [inSymbolTable searchKey ![t mLabel]  ??@uint targetAddress] ;
#      outCode := pic18_Bcc_instruction_code [!inAddress !targetAddress ![t mLabel] !mConditionalBranch !false] ;
#      [mSingleInstructionTerminatorIfConditionTrue generateTerminatorCode !inAddress + 2 !inSymbolTable !"" ??@codeList code] ;
#      outCode .= code ;
#    end if ;
#  else
#  
#  end if ;
#end method ;

#----------------------------------------------------------------------------*

#override reader @ipic18ConditionalBranchTerminator isEqualToTerminator
#  ??@ipic18AbstractBlockTerminator inTerminator
#  -> @bool outResult
#:
#  outResult := (inTerminator is == @ipic18ConditionalBranchTerminator) ;
#  if outResult then
#    const @ipic18ConditionalBranchTerminator t := (cast inTerminator : @ipic18ConditionalBranchTerminator) ;
#    outResult := mConditionalBranch == [t mConditionalBranch] ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionTrue isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionTrue]] ;
#    end if ;
#    if outResult then
#      outResult := [mSingleInstructionTerminatorIfConditionFalse isEqualToTerminator ![t mSingleInstructionTerminatorIfConditionFalse]] ;
#    end if ;
#  end if ;
#end reader ;


#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ConditionalJumpTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  switch mConditionalBranch
  when bz : outResult := "Z" ;
  when bn  : outResult := "N" ;
  when bc :  outResult := "C" ;
  when bov :  outResult := "OV" ;
  when bnz : outResult := "NZ" ;
  when bnn  : outResult := "NN" ;
  when bnc :  outResult := "NC" ;
  when bnov :  outResult := "NOV" ;
  end switch ;
  outResult .= " ? " ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    outResult .= "(" . mTargetLabelWhenTrue->string . ")" ;
  else
    outResult .= mTargetLabelWhenTrue->string ;
  end if ;
  outResult .= " : " ;
  if mTargetLabelWhenFalse->string == inNextBlockLabel then
    outResult .= "(" . mTargetLabelWhenFalse->string . ")" ;
  else
    outResult .= mTargetLabelWhenFalse->string ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  @conditionalBranchMode branchModeOnFalseLabel := mBranchModeOnFalseLabel ;
  @conditionalBranchMode branchModeOnTrueLabel := mBranchModeOnTrueLabel ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenTrue . "\n" ;
      end if ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+2] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+4] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+6] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
  if (branchModeOnFalseLabel == mBranchModeOnFalseLabel) & (branchModeOnTrueLabel == mBranchModeOnTrueLabel) then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18ConditionalJumpTerminator new
      !mInstructionLocation
      !mConditionalBranch
      !mTargetLabelWhenTrue
      !branchModeOnTrueLabel
      !mTargetLabelWhenFalse
      !branchModeOnFalseLabel
    ] ;
    ioConversionCount ++ ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
      end if ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
      end if ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
      end if ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
      end if ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+4] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+6] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native  : outSize := 2 ;  # !Bcc F
    when ipicBRA  : outSize := 4 ; # Bcc Z ; BRA F ; Z:
    when ipicGOTO : outSize := 6 ; # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native   : outSize := 2 ; # Bcc T
    when ipicBRA  : outSize := 4 ; # !Bcc Z ; BRA T ; Z:
    when ipicGOTO : outSize := 6 ; # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : outSize := 4 ; # !Bcc F ; BRA T
      when ipicGOTO : outSize := 6 ; # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : outSize := 4 ; # Bcc T ; BRA F
      when ipicBRA  : outSize := 6 ; # Bcc Z ; BRA F ; Z: BRA T
      when ipicGOTO : outSize := 8 ; # Bcc Z ; BRA F ; Z: GOTO T
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : outSize := 6 ; # Bcc T ; GOTO F
      when ipicBRA  : outSize := 8 ; # Bcc Z ; GOTO F ; Z: BRA T
      when ipicGOTO : outSize := 10 ; # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator generateTerminatorCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  [inSymbolTable searchKey !mTargetLabelWhenTrue  ??@uint trueTargetAddress] ;
  [inSymbolTable searchKey !mTargetLabelWhenFalse ??@uint falseTargetAddress] ;
  const @lstring Zlabel [new !"_Bcc_" . [inAddress xString] !mInstructionLocation] ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !false] ;
      outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !false] ;
      outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !false] ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
      outCode .= pic18_BRA_instruction_code [!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
      outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # !Bcc F ; GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_BRA_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+6 !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator isEqualToTerminator
  ??@ipic18AbstractBlockTerminator inTerminator
  -> @bool outResult
:
  outResult := (inTerminator is == @ipic18ConditionalJumpTerminator) ;
  if outResult then
    const @ipic18ConditionalJumpTerminator t := (cast inTerminator : @ipic18ConditionalJumpTerminator) ;
    outResult := mConditionalBranch == [t mConditionalBranch] ;
    if outResult then
      outResult := mTargetLabelWhenTrue->string == [t mTargetLabelWhenTrue]->string ;
    end if ;
    if outResult then
      outResult := mBranchModeOnTrueLabel == [t mBranchModeOnTrueLabel] ;
    end if ;
    if outResult then
      outResult := mTargetLabelWhenFalse->string == [t mTargetLabelWhenFalse]->string ;
    end if ;
    if outResult then
      outResult := mBranchModeOnFalseLabel == [t mBranchModeOnFalseLabel] ;
    end if ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

end semantics ;
