semantics ipic18_terminators :
import "ipic18_block_representation.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Abstract readers

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
;

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
;

#----------------------------------------------------------------------------*

override reader @ipic18SingleInstructionTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  outSize := 2 ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ReturnTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETURN" ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    RETURN"
    ![@uintlist listWithValue !0x0012]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18RetfieTerminator

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETFIE" ;
  if mFastReturn then
    outResult .= " FAST" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    " . [selfcopy terminatorDisplay !inNextBlockLabel]
    ![@uintlist listWithValue !if mFastReturn then 0x0011 else 0x0010 end]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18RetfieTerminator

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "RETLW " . [mLiteralValue hexString] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator generateCode
  ??@uint unused inAddress
  ??@symbolTableForRelativesResolution unused inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  outCode := [@codeList listWithValue
    !"    " .[selfcopy terminatorDisplay !inNextBlockLabel]
    ![@uintlist listWithValue !0x0C00 | mLiteralValue]
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- @ipic18JumpTerminator

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  if mLabel->string == inNextBlockLabel then
    outSize := 0 ;
  else
    switch mKind
    when ipicRelative, relative :
      outSize := 2 ;
    when absolute :
      outSize := 4 ;
    end switch ;  
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mLabel->string != inNextBlockLabel then
    switch mKind
    when ipicRelative, relative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        ioOverflowMap += !inBlockLabel !mLabel->string ;
      end if ;
    when absolute :
    end switch ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if inNextBlockLabel != mLabel->string then
    switch mKind
    when ipicRelative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        ioConversionCount ++ ;
        ioListFileContents .= "  " . inBlockLabel . ": JUMP " . mLabel . " --> GOTO " . mLabel . "\n" ;
        outModifiedTerminator := [@ipic18JumpTerminator new !mInstructionLocation !mLabel ![@jumpInstructionKind absolute]] ;
      end if ;
    when relative :
      if not pic18_checkBRA_RCALL [!inSymbolTable !mLabel !inAddress] then
        error mInstructionLocation: "displacement ("
        . pic18_BRA_RCALL_displacement [!inSymbolTable !mLabel !inAddress] . ") too large for BRA "
        . mLabel . " instruction (limited to [-1024, 1023])" ;
      end if ;
    when absolute : # Allways ok
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  @string name ;
  switch mKind
    when ipicRelative : name := "JUMP "  ;
    when relative     : name := "BRA " ;
    when absolute     : name := "GOTO " ;
  end switch ;
  if inNextBlockLabel == mLabel->string then
    outResult := "(" . name . mLabel . ")" ;
  else
    outResult := name . mLabel ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if mLabel->string == inNextBlockLabel then
    outCode := [@codeList emptyList] ;
  else
    [inSymbolTable searchKey !mLabel ??@uint targetAddress] ;
    switch mKind
    when ipicRelative, relative :
      outCode := pic18_BRA_instruction_code [!inAddress !targetAddress !mLabel] ;
    when absolute :
      outCode := pic18_GOTO_instruction_code [!targetAddress !mLabel] ;
    end switch ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator size

#----------------------------------------------------------------------------*

override reader @ipic18AbstractConditionTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mInstructionIfConditionFalse terminatorSize !inNextBlockLabel]
  ;    
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  [mInstructionIfConditionTrue terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ] ;
  [mInstructionIfConditionFalse terminatorRelativeBranchOverflow
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioOverflowMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18RegisterComparisonTerminator

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mInstructionIfConditionFalse terminatorSize !""]
  ;    
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] . " " ;
  switch mComparison
  when registerEqualsToW :
    outResult .= "==" ;
  when registerGreaterThanW :
    outResult .= ">" ;
  when registerLowerThanW :
    outResult .= "<" ;
  end switch ;
  outResult .= " W ? " ;
  outResult .= [mInstructionIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mInstructionIfConditionFalse terminatorDisplay !""] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18RegisterComparisonTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mComparison
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  @uint binCode ;
  @string assemblyCode ;
  switch mComparison
  when registerEqualsToW :
    binCode := 0x6200 ;
    assemblyCode := "    CPFSEQ" ;
  when registerGreaterThanW :
    binCode := 0x6400 ;
    assemblyCode := "    CPFSGT" ;
  when registerLowerThanW :
    binCode := 0x6000 ;
    assemblyCode := "    CPFSLT" ;
  end switch ;
  assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
  binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
    assemblyCode .= ", BSR_ACCESS" ;
  end if ;
  outCode := [@codeList listWithValue
    !assemblyCode
    ![@uintlist listWithValue !binCode]
  ] ;
  [mInstructionIfConditionFalse generateCode
    !inAddress + 2
    !inSymbolTable
    !""
    ??@codeList falseTerminatorCode
   ] ;
   outCode .= falseTerminatorCode ;
  [mInstructionIfConditionTrue generateCode
    !inAddress + 2 + [mInstructionIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ??@codeList trueTerminatorCode
   ] ;
   outCode .= trueTerminatorCode ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18TestRegisterTerminator

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  outSize := 2
    + [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel]
    + [mInstructionIfConditionFalse terminatorSize !""] # False cannot be ommitted
  ;    
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] ;
  outResult .= " Z ? " ;
  outResult .= [mInstructionIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mInstructionIfConditionFalse terminatorDisplay !""] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18TestRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  @uint binCode := 0x6600 ;
  @string assemblyCode := "    TSTFSZ " . [mRegisterDescription mAssemblyString] ;
  binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
  if [mRegisterDescription mNeedsBSR] then
    binCode := binCode | 0x0100 ;
    assemblyCode .= ", BSR_ACCESS" ;
  end if ;
  outCode := [@codeList listWithValue
    !assemblyCode
    ![@uintlist listWithValue !binCode]
  ] ;
#--- Generate complementary code (true terminator first terminator)
  [mInstructionIfConditionFalse generateCode
    !inAddress + 2
    !inSymbolTable
    !""
    ??@codeList falseTerminatorCode
   ] ;
   outCode .= falseTerminatorCode ;
  [mInstructionIfConditionTrue generateCode
    !inAddress + 2 + [mInstructionIfConditionFalse terminatorSize !""]
    !inSymbolTable
    !inNextBlockLabel
    ??@codeList trueTerminatorCode
   ] ;
   outCode .= trueTerminatorCode ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @pic18BitTestTerminator

#----------------------------------------------------------------------------*

override reader @pic18BitTestTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  outResult := [mRegisterDescription mAssemblyString] . "." . [mBitNumber string] . " ? " ;
  outResult .= [mInstructionIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mInstructionIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
end reader ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@pic18BitTestTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mBitNumber
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18BitTestTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode := 0xB000 ;
    @string assemblyCode := "    BTFSC " . [mRegisterDescription mAssemblyString] . ", " . mBitNumber ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    binCode := binCode | (mBitNumber << 9) ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mInstructionIfConditionFalse generateCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode := 0xA000 ;
    @string assemblyCode := "    BTFSS " . [mRegisterDescription mAssemblyString] . ", " . mBitNumber ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    binCode := binCode | (mBitNumber << 9) ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mInstructionIfConditionTrue generateCode
      !inAddress + 2
      !inSymbolTable
      !""
      ??@codeList trueTerminatorCode
     ] ;
     outCode .= trueTerminatorCode ;
    [mInstructionIfConditionFalse generateCode
      !inAddress + 2 + [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18IncDecRegisterTerminator

#----------------------------------------------------------------------------*

override reader @ipic18IncDecRegisterTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  if mIncrement then
    outResult := "INCF " ;
  else
    outResult := "DECF " ;
  end if ;
  outResult .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    outResult .= ", W" ;
  else
    outResult .= ", F" ;
  end if ;
  outResult .= " Z ? " ;
  outResult .= [mInstructionIfConditionTrue terminatorDisplay !inNextBlockLabel] ;
  outResult .= " : " ;
  outResult .= [mInstructionIfConditionFalse terminatorDisplay !inNextBlockLabel] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  const @uint n := ioConversionCount ;
  [mInstructionIfConditionTrue performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedTrueTerminator
  ] ;
  [mInstructionIfConditionFalse performTerminatorRelativeBranchResolution
    !inAddress
    !inBlockLabel
    !inSymbolTable
    !inNextBlockLabel
    !?ioConversionCount
    !?ioListFileContents
    ?@ipic18AbstractBlockTerminator outModifiedFalseTerminator
  ] ;
  if ioConversionCount == n then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18IncDecRegisterTerminator new
      !mInstructionLocation
      !(cast outModifiedTrueTerminator : @ipic18SingleInstructionTerminator)
      !(cast outModifiedFalseTerminator : @ipic18SingleInstructionTerminator)
      !mRegisterDescription
      !mIncrement
      !m_W_isDestination
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18IncDecRegisterTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  if [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel] == 0 then
  #--- Generate direct code (no code for true terminator)
    @uint binCode :=        if mIncrement then 0x3C00   else 0x2C00 end ;
    @string assemblyCode := if mIncrement then "    INCFSZ" else "    DECFSZ" end ;
    assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    if m_W_isDestination then
      assemblyCode .= ", W" ;
    else
      binCode := binCode | 0x0200 ;
      assemblyCode .= ", F" ;
    end if ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mInstructionIfConditionFalse generateCode
      !inAddress + 2
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  else
  #--- Generate complementary code (true terminator first terminator)
    @uint binCode :=        if mIncrement then 0x4800   else 0x4C00 end ;
    @string assemblyCode := if mIncrement then "    INFSNZ" else "    DCFSNZ" end ;
    assemblyCode .= " " . [mRegisterDescription mAssemblyString] ;
    binCode := binCode | ([mRegisterDescription mRegisterAddress] & 255) ;
    if m_W_isDestination then
      assemblyCode .= ", W" ;
    else
      binCode := binCode | 0x0200 ;
      assemblyCode .= ", F" ;
    end if ;
    if [mRegisterDescription mNeedsBSR] then
      binCode := binCode | 0x0100 ;
      assemblyCode .= ", BSR_ACCESS" ;
    end if ;
    outCode := [@codeList listWithValue
      !assemblyCode
      ![@uintlist listWithValue !binCode]
    ] ;
    [mInstructionIfConditionTrue generateCode
      !inAddress + 2
      !inSymbolTable
      !""
      ??@codeList trueTerminatorCode
     ] ;
     outCode .= trueTerminatorCode ;
    [mInstructionIfConditionFalse generateCode
      !inAddress + 2 + [mInstructionIfConditionTrue terminatorSize !inNextBlockLabel]
      !inSymbolTable
      !inNextBlockLabel
      ??@codeList falseTerminatorCode
     ] ;
     outCode .= falseTerminatorCode ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedRETLWTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 2 * [mLiteralValues length] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED RETLW" ;
  foreach mLiteralValues do
    outResult .= " " . [mValue hexString] ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedRETLWTerminator new !mInstructionLocation !mLiteralValues !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto2label := ["_computed_goto_2" nowhere] ;
  [inSymbolTable searchKey !goto2label ??@uint targetAddress] ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto2label] ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto2label] ;
  end if ;
  foreach mLiteralValues do
    outCode +=
      !"    RETLW " . [mValue hexString]
      ![@uintlist listWithValue !0x0C00 | mValue]
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedGotoTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED GOTO " ;
  if mUsesRCALL then
    outResult .= " (uses RCALL)" ;
  else
    outResult .= " (uses CALL)" ;
  end if ;
  foreach mTargetLabels do
    outResult .= "\n    " . mValue ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 4 * [mTargetLabels length] ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed GOTO needs CALL _computed_goto_4\n" ;
      outModifiedTerminator := [@ipic18ComputedGotoTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_4" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_4" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto4label := ["_computed_goto_4" nowhere] ;
  [inSymbolTable searchKey !goto4label ??@uint targetAddress] ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto4label] ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto4label] ;
  end if ;
  foreach mTargetLabels do
    outCode .= pic18_GOTO_instruction_code [!targetAddress !mValue] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ComputedBraTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator terminatorSize
  ??@string unused inNextBlockLabel
  -> @uint outSize
:
  if mUsesRCALL then
    outSize := 2 ;
  else
    outSize := 4 ;
  end if ;
  outSize := outSize + 2 * [mTargetLabels length] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator terminatorDisplay
  ??@string unused inNextBlockLabel
  ->@string outResult
:
  outResult := "COMPUTED BRA" ;
  foreach mTargetLabels do
    outResult .= " " . mValue ;
  end foreach ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  foreach mTargetLabels do
    if not pic18_checkBRA_RCALL [!inSymbolTable !mValue !inAddress] then
      error mInstructionLocation: "displacement ("
      . pic18_BRA_RCALL_displacement [!inSymbolTable !mValue !inAddress] . ") too large for rcall "
      . mValue . " instruction (limited to [-1024, 1023])" ;
    end if ;
  end foreach ;
  outModifiedTerminator := selfcopy ;
  if mUsesRCALL then
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress ] then
      ioConversionCount ++ ;
      ioListFileContents .= "  " . inBlockLabel . ": computed RETLW needs CALL _computed_goto_2\n" ;
      outModifiedTerminator := [@ipic18ComputedBraTerminator new !mInstructionLocation !mTargetLabels !false] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  @uint address ;
  if mUsesRCALL then  
    if not pic18_checkBRA_RCALL [!inSymbolTable !["_computed_goto_2" nowhere] !inAddress] then
      ioOverflowMap += !inBlockLabel !"_computed_goto_2" ;
    end if ;
    address := inAddress + 2 ;
  else
    address := inAddress + 4 ;
  end if ;
  foreach mTargetLabels do
    if not pic18_checkBRA_RCALL [!inSymbolTable !mValue !address] then
      ioOverflowMap += !inBlockLabel !mValue->string ;
    end if ;
    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string unused inNextBlockLabel
  !@codeList outCode
:
  const @lstring goto2label := ["_computed_goto_2" nowhere] ;
  [inSymbolTable searchKey !goto2label ??@uint targetAddress] ;
  @uint address ;
  if mUsesRCALL then
    outCode := pic18_RCALL_instruction_code [!inAddress !targetAddress !goto2label] ;
    address := inAddress + 2 ;
  else
    outCode := pic18_CALL_instruction_code [!targetAddress !goto2label] ;
    address := inAddress + 4 ;
  end if ;
  foreach mTargetLabels do
    outCode .= pic18_BRA_instruction_code [!address !targetAddress !mValue] ;
    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator @ipic18ConditionalJumpTerminator

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator terminatorDisplay
  ??@string inNextBlockLabel
  ->@string outResult
:
  switch mConditionalBranch
  when bz : outResult := "Z" ;
  when bn  : outResult := "N" ;
  when bc :  outResult := "C" ;
  when bov :  outResult := "OV" ;
  when bnz : outResult := "NZ" ;
  when bnn  : outResult := "NN" ;
  when bnc :  outResult := "NC" ;
  when bnov :  outResult := "NOV" ;
  end switch ;
  outResult .= " ? " ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    outResult .= "(" . mTargetLabelWhenTrue->string . ")" ;
  else
    outResult .= mTargetLabelWhenTrue->string ;
  end if ;
  outResult .= " : " ;
  if mTargetLabelWhenFalse->string == inNextBlockLabel then
    outResult .= "(" . mTargetLabelWhenFalse->string . ")" ;
  else
    outResult .= mTargetLabelWhenFalse->string ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator performTerminatorRelativeBranchResolution
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@uint ioConversionCount
  ?!@string ioListFileContents
  !@ipic18AbstractBlockTerminator outModifiedTerminator
:
  @conditionalBranchMode branchModeOnFalseLabel := mBranchModeOnFalseLabel ;
  @conditionalBranchMode branchModeOnTrueLabel := mBranchModeOnTrueLabel ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2] then
        branchModeOnFalseLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
      end if ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2] then
        branchModeOnTrueLabel := [@conditionalBranchMode ipicGOTO] ;
        ioListFileContents .= "  " . inBlockLabel . ", terminator will use GOTO " . mTargetLabelWhenTrue . "\n" ;
      end if ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+2] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+4] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          branchModeOnFalseLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenFalse . "\n" ;
        end if ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+6] then
          branchModeOnTrueLabel := [@conditionalBranchMode ipicBRA] ;
          ioListFileContents .= "  " . inBlockLabel . ", terminator will use BRA " . mTargetLabelWhenTrue . "\n" ;
        end if ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
  if (branchModeOnFalseLabel == mBranchModeOnFalseLabel) & (branchModeOnTrueLabel == mBranchModeOnTrueLabel) then
    outModifiedTerminator := selfcopy ;
  else
    outModifiedTerminator := [@ipic18ConditionalJumpTerminator new
      !mInstructionLocation
      !mConditionalBranch
      !mTargetLabelWhenTrue
      !branchModeOnTrueLabel
      !mTargetLabelWhenFalse
      !branchModeOnFalseLabel
    ] ;
    ioConversionCount ++ ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator terminatorRelativeBranchOverflow
  ??@uint inAddress
  ??@string inBlockLabel
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  ?!@branchOverflowMap ioOverflowMap
:
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
      end if ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse !inAddress + 2] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
      end if ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
      end if ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress + 2] then
        ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
      end if ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenFalse !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+4] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenFalse!inAddress+2] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenFalse->string ;
        end if ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        if not pic18_checkBCC [!inSymbolTable !mTargetLabelWhenTrue !inAddress] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        if not pic18_checkBRA_RCALL [!inSymbolTable !mTargetLabelWhenTrue !inAddress+6] then
          ioOverflowMap += !inBlockLabel !mTargetLabelWhenTrue->string ;
        end if ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator terminatorSize
  ??@string inNextBlockLabel
  -> @uint outSize
:
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native  : outSize := 2 ;  # !Bcc F
    when ipicBRA  : outSize := 4 ; # Bcc Z ; BRA F ; Z:
    when ipicGOTO : outSize := 6 ; # Bcc Z ; GOTO F ; Z:
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native   : outSize := 2 ; # Bcc T
    when ipicBRA  : outSize := 4 ; # !Bcc Z ; BRA T ; Z:
    when ipicGOTO : outSize := 6 ; # !Bcc Z ; GOTO T ; Z:
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : outSize := 4 ; # !Bcc F ; BRA T
      when ipicGOTO : outSize := 6 ; # !Bcc F ; GOTO T
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : outSize := 4 ; # Bcc T ; BRA F
      when ipicBRA  : outSize := 6 ; # Bcc Z ; BRA F ; Z: BRA T
      when ipicGOTO : outSize := 8 ; # Bcc Z ; BRA F ; Z: GOTO T
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : outSize := 6 ; # Bcc T ; GOTO F
      when ipicBRA  : outSize := 8 ; # Bcc Z ; GOTO F ; Z: BRA T
      when ipicGOTO : outSize := 10 ; # Bcc Z ; GOTO F ; Z: GOTO T
      end switch ;
    end switch ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override method @ipic18ConditionalJumpTerminator generateCode
  ??@uint inAddress
  ??@symbolTableForRelativesResolution inSymbolTable
  ??@string inNextBlockLabel
  !@codeList outCode
:
  [inSymbolTable searchKey !mTargetLabelWhenTrue  ??@uint trueTargetAddress] ;
  [inSymbolTable searchKey !mTargetLabelWhenFalse ??@uint falseTargetAddress] ;
  const @lstring Zlabel [new !"_Bcc_" . [inAddress xString] !mInstructionLocation] ;
  if mTargetLabelWhenTrue->string == inNextBlockLabel then
    switch mBranchModeOnFalseLabel
    when native : # !Bcc F
      outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
    when ipicBRA : # Bcc Z ; BRA F ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !false] ;
      outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    when ipicGOTO : # Bcc Z ; GOTO F ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !false] ;
      outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    end switch ;
  elsif mTargetLabelWhenFalse->string == inNextBlockLabel then
    switch mBranchModeOnTrueLabel
    when native : # Bcc T
      outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !false] ;
    when ipicBRA : # !Bcc Z ; BRA T ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
      outCode .= pic18_BRA_instruction_code [!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    when ipicGOTO : # !Bcc Z ; GOTO T ; Z:
      outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
      outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      outCode .= pic18_definition_label [!Zlabel] ;
    end switch ;
  else
    switch mBranchModeOnFalseLabel
    when native :
      switch mBranchModeOnTrueLabel
      when native, ipicBRA : # !Bcc F ; BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # !Bcc F ; GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !falseTargetAddress !mTargetLabelWhenFalse !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    when ipicBRA :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; BRA F
        outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
      when ipicBRA  : # Bcc Z ; BRA F ; Z: BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_BRA_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # Bcc Z ; BRA F ; Z: GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 4 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+2 !falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    when ipicGOTO :
      switch mBranchModeOnTrueLabel
      when native   : # Bcc T ; GOTO F
        outCode := pic18_Bcc_instruction_code [!inAddress !trueTargetAddress !mTargetLabelWhenTrue !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
      when ipicBRA  : # Bcc Z ; GOTO F ; Z: BRA T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_BRA_instruction_code [!inAddress+6 !trueTargetAddress !mTargetLabelWhenTrue] ;
      when ipicGOTO : # Bcc Z ; GOTO F ; Z: GOTO T
        outCode := pic18_Bcc_instruction_code [!inAddress !inAddress + 6 !Zlabel !mConditionalBranch !true] ;
        outCode .= pic18_GOTO_instruction_code [!falseTargetAddress !mTargetLabelWhenFalse] ;
        outCode .= pic18_definition_label [!Zlabel] ;
        outCode .= pic18_GOTO_instruction_code [!trueTargetAddress !mTargetLabelWhenTrue] ;
      end switch ;
    end switch ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
