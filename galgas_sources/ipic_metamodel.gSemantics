semantics ipic_metamodel :
import "piccolo_metamodel.gSemantics" ;
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;

#----------------------------------------------------*

abstract class @ipic_instruction {
  abstract method instructionLength !@uint outLength ;
}

#----------------------------------------------------*

list @ipic_instructionList {
  @ipic_instruction mInstruction ;
}

#----------------------------------------------------*

class @ipic_pseudo_NULL extends @ipic_instruction {
  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_ORG extends @ipic_instruction {
  @uint mOrigin ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_LABEL extends @ipic_instruction {
  @lstring mTargetLabel ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

abstract class @ipic_actualInstruction extends @ipic_instruction {
  @location mInstructionLocation ;

  override method instructionLength !@uint outLength :
    outLength := 2 ;
  end method ;
}

#----------------------------------------------------*

#class @registerExpression {
#  @lstring mRegisterName ;
#  @luint mOffset ;
#}

#----------------------------------------------------*

#enum @instruction_FDA_base_code {
#  constructor ADDWF ;
#  constructor ADDWFC ;
#  constructor ANDWF ;
#  constructor COMF ;
#  constructor DECF ;
#  constructor DECFSZ ;
#  constructor DCFSNZ ;
#  constructor INCF ;
#  constructor INCFSZ ;
#  constructor INFSNZ ;
#  constructor IORWF ;
#  constructor MOVF ;
#  constructor RLCF ;
#  constructor RLNCF ;
#  constructor RRCF ;
#  constructor RRNCF ;
#  constructor SUBFWB ;
#  constructor SUBWF ;
#  constructor SUBWFB ;
#  constructor SWAPF ;
#  constructor XORWF ;
#}{
#  reader mnemonic :
#    ADDWF -> "ADDWF" ;
#    ADDWFC -> "ADDWFC" ;
#    ANDWF -> "ANDWF" ;
#    COMF -> "COMF" ;
#    DECF -> "DECF" ;
#    DECFSZ -> "DECFSZ" ;
#    DCFSNZ -> "DCFSNZ" ;
#    INCF -> "INCF" ;
#    INCFSZ -> "INCFSZ" ;
#    INFSNZ -> "INFSNZ" ;
#    IORWF -> "IORWF" ;
#    MOVF -> "MOVF" ;
#    RLCF -> "RLCF" ;
#    RLNCF -> "RLNCF" ;
#    RRCF -> "RRCF" ;
#    RRNCF -> "RRNCF" ;
#    SUBFWB -> "SUBFWB" ;
#    SUBWF -> "SUBWF" ;
#    SUBWFB -> "SUBWFB" ;
#    SWAPF -> "SWAPF" ;
#    XORWF -> "XORWF" ;
#  end reader ;
#}

#----------------------------------------------------*

#routine getFDAinstructionBaseCode
#  ??@instruction_FDA_base_code inInstruction
#  !@uint outBaseCode
#:
#  switch inInstruction
#  when ADDWF : outBaseCode := 0x2400 ;
#  when ADDWFC : outBaseCode := 0x2000 ;
#  when ANDWF : outBaseCode := 0x1400 ;
#  when COMF : outBaseCode := 0x1C00 ;
#  when DECF : outBaseCode := 0x0400 ;
#  when DECFSZ : outBaseCode := 0x2C00 ;
#  when DCFSNZ : outBaseCode := 0x4C00 ;
#  when INCF : outBaseCode := 0x2800 ;
#  when INCFSZ : outBaseCode := 0x3C00 ;
#  when INFSNZ : outBaseCode := 0x4800 ;
#  when IORWF : outBaseCode := 0x1000 ;
#  when MOVF : outBaseCode := 0x5000 ;
#  when RLCF : outBaseCode := 0x3400 ;
#  when RLNCF : outBaseCode := 0x4400 ;
#  when RRCF : outBaseCode := 0x3000 ;
#  when RRNCF : outBaseCode := 0x4000 ;
#  when SUBFWB : outBaseCode := 0x5400 ;
#  when SUBWF : outBaseCode := 0x5C00 ;
#  when SUBWFB :  outBaseCode := 0x5800 ;
#  when SWAPF : outBaseCode := 0x3800 ;
#  when XORWF : outBaseCode := 0x1800 ;
#  end switch ;
#end routine ;

#----------------------------------------------------*

class @ipic_instruction_FDA extends @ipic_actualInstruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    getFDAinstructionBaseCode !mInstruction_FDA_base_code ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

#enum @FA_instruction_base_code {
#  constructor CLRF ;
#  constructor CPFSEQ ;
#  constructor CPFSGT ;
#  constructor CPFSLT ;
#  constructor MOVWF  ;
#  constructor MULWF  ;
#  constructor NEGF  ;
#  constructor SETF  ;
#  constructor TSTFSZ ;
#}{
#  reader mnemonic :
#    CLRF   -> "CLRF" ;
#    CPFSEQ -> "CPFSEQ" ;
#    CPFSGT -> "CPFSGT" ;
#    CPFSLT -> "CPFSLT" ;
#    MOVWF  -> "MOVWF" ;
#    MULWF  -> "MULWF" ;
#    NEGF   -> "NEGF";
#    SETF   -> "SETF"  ;
#    TSTFSZ -> "TSTFSZ" ;
#  end reader ;
#}

#----------------------------------------------------*

#routine getFAinstructionBaseCode
#  ??@FA_instruction_base_code inInstruction
#  !@uint outBaseCode
#:
#  switch inInstruction
#  when CLRF   : outBaseCode := 0x6A00 ;
#  when CPFSEQ : outBaseCode := 0x6200 ;
#  when CPFSGT : outBaseCode := 0x6400 ;
#  when CPFSLT : outBaseCode := 0x6000 ;
#  when MOVWF  : outBaseCode := 0x6E00 ;
#  when MULWF  : outBaseCode := 0x0200 ;
#  when NEGF   : outBaseCode := 0x6C00 ;
#  when SETF   : outBaseCode := 0x6800 ;
#  when TSTFSZ : outBaseCode := 0x6600 ;
#  end switch ;
#end routine ;

#----------------------------------------------------*

class @ipic_instruction_FA extends @ipic_actualInstruction {
  @FA_instruction_base_code mFAinstruction ;
  @registerExpression mRegisterExpression ;

  method getBaseCode !@uint outBaseCode :
   getFAinstructionBaseCode !mFAinstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVFF extends @ipic_actualInstruction {
  @registerExpression mSourceRegisterName ;
  @registerExpression mDestinationRegisterName ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

#abstract class @bitNumberExpression {
#}

#----------------------------------------------------*

#class @bitNumberLiteralValue extends @bitNumberExpression {
#  @luint mBitNumberLiteralValue ;
#}

#----------------------------------------------------*

#class @bitNumberLabelValue extends @bitNumberExpression {
#  @lstring mBitNumberLabelValue ;
#  @luint mBitNumberIndexValue ;
#}

#----------------------------------------------------*

#enum @bit_oriented_op {
#  constructor BCF ;
#  constructor BSF ;
#  constructor BTFSC ;
#  constructor BTFSS ;
#  constructor BTG ;
#}{
#  reader mnemonic :
#    BCF -> "BCF" ;
#    BSF -> "BSF" ;
#    BTFSC -> "BTFSC" ;
#    BTFSS -> "BTFSS" ;
#    BTG -> "BTG" ;
#  end reader ;
#}

#----------------------------------------------------*

#routine getBitOrientedOpBaseCode ??@bit_oriented_op inInstruction !@uint outBaseCode :
#  switch inInstruction
#  when BCF : outBaseCode := 0x9000 ;
#  when BSF : outBaseCode := 0x8000 ;
#  when BTFSC : outBaseCode := 0xB000 ;
#  when BTFSS : outBaseCode := 0xA000 ;
#  when BTG : outBaseCode := 0x7000 ;
#  end switch ;
#end routine ;


#----------------------------------------------------*

class @ipic_instruction_FBA extends @ipic_actualInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
  method getBaseCode !@uint outBaseCode :
    getBitOrientedOpBaseCode !mBitOrientedOp ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

#enum @conditional_branch {
#  constructor bz ;
#  constructor bnz ;
#  constructor bn ;
#  constructor bnn ;
#  constructor bc ;
#  constructor bnc ;
#  constructor bov ;
#  constructor bnov ;
#}{
#  reader mnemonic :
#    bz   -> "BZ" ;
#    bnz  -> "BNZ" ;
#    bn   -> "BN" ;
#    bnn  -> "BNN" ;
#    bc   -> "BC" ;
#    bnc  -> "BNC" ;
#    bov  -> "BOV" ;
#    bnov -> "BNOV" ;
#  end reader ;
#}

#----------------------------------------------------*

#routine getBccBaseCode ??@conditional_branch inConditionalBranch !@uint outBaseCode :
#  switch inConditionalBranch
#  when bz   : outBaseCode := 0xE000 ;
#  when bnz  : outBaseCode := 0xE100 ;
#  when bn   : outBaseCode := 0xE600 ;
#  when bnn  : outBaseCode := 0xE700 ;
#  when bc   : outBaseCode := 0xE200 ;
#  when bnc  : outBaseCode := 0xE300 ;
#  when bov  : outBaseCode := 0xE400 ;
#  when bnov : outBaseCode := 0xE500 ;
#  end switch ;
#end routine ;

#----------------------------------------------------*

#routine getComplementaryBcc ??@conditional_branch inConditionalBranch !@conditional_branch outComplementary :
#  switch inConditionalBranch
#  when bz   : outComplementary := [@conditional_branch bnz] ;
#  when bnz  : outComplementary := [@conditional_branch bz] ;
#  when bn   : outComplementary := [@conditional_branch bnn] ;
#  when bnn  : outComplementary := [@conditional_branch bn] ;
#  when bc   : outComplementary := [@conditional_branch bnc] ;
#  when bnc  : outComplementary := [@conditional_branch bc] ;
#  when bov  : outComplementary := [@conditional_branch bnov] ;
#  when bnov : outComplementary := [@conditional_branch bov] ;
#  end switch ;
#end routine ;

#----------------------------------------------------*

#enum @condionalBranchMode {
#  constructor native ;
#  constructor usesBRA ;
#  constructor usesGOTO ;
#}{
#}

#----------------------------------------------------*

class @ipic_instruction_conditionalBranch extends @ipic_actualInstruction {
  @condionalBranchMode mBranchMode ;
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabel ;

  override
  method instructionLength !@uint outLength :
    switch mBranchMode
      when native   : outLength := 2 ;
      when usesBRA  : outLength := 4 ;
      when usesGOTO : outLength := 6 ;
    end switch ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_BRA extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @ipic_instruction_CALL extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_GOTO extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_RCALL extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @ipic_instruction_CLRWDT extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_DAW extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_NOP extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_POP extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_PUSH extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RESET extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RETURN extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RETFIE extends @ipic_actualInstruction {
  @bool mFastReturn ;
}

#----------------------------------------------------*

class @ipic_instruction_SLEEP extends @ipic_actualInstruction {
}

##----------------------------------------------------*
#
#enum @literal_instruction_opcode {
#  constructor ADDLW ;
#  constructor ANDLW ;
#  constructor IORLW ;
#  constructor MOVLW ;
#  constructor MULLW ;
#  constructor RETLW ;
#  constructor SUBLW ;
#  constructor XORLW ;
#}{
#  reader mnemonic :
#    ADDLW -> "ADDLW" ;
#    ANDLW -> "ANDLW" ;
#    IORLW -> "IORLW" ;
#    MOVLW -> "MOVLW" ;
#    MULLW -> "MULLW" ;
#    RETLW -> "RETLW" ;
#    SUBLW -> "SUBLW" ;
#    XORLW -> "XORLW" ;
#  end reader ;
#}
#
#----------------------------------------------------*

#routine getLiteralInstructionBaseCode ??@literal_instruction_opcode inInstruction !@uint outBaseCode :
#  switch inInstruction
#  when ADDLW : outBaseCode := 0x0F00 ;
#  when ANDLW : outBaseCode := 0x0B00 ;
#  when IORLW : outBaseCode := 0x0900 ;
#  when MOVLW : outBaseCode := 0x0E00 ;
#  when MULLW : outBaseCode := 0x0D00 ;
#  when RETLW : outBaseCode := 0x0C00 ;
#  when SUBLW : outBaseCode := 0x0800 ;
#  when XORLW : outBaseCode := 0x0A00 ;
#  end switch ;
#end routine ;

#----------------------------------------------------*

class @ipic_instruction_literalOperation extends @ipic_actualInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @luint mLiteralValue ;
  method getBaseCode !@uint outBaseCode :
    getLiteralInstructionBaseCode !mLiteralInstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_LFSR extends @ipic_actualInstruction {
  @luint mFSRindex ;
  @registerExpression mRegisterExpression ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVLB extends @ipic_actualInstruction {
  @luint mPageIndex ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVAW extends @ipic_actualInstruction {
  @registerExpression mRegisterExpression ;
}

#----------------------------------------------------*

#enum @tableAccessOption {
#  constructor simpleAccess ;
#  constructor postIncrement ;
#  constructor postDecrement ;
#  constructor preIncrement ;
#}{
#  reader mnemonic :
#    simpleAccess -> "*" ;
#    postIncrement -> "*+" ;
#    postDecrement -> "*-" ;
#    preIncrement -> "+*" ;
#  end reader ;
#}

#----------------------------------------------------*

class @ipic_instruction_TBLRD extends @ipic_actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @ipic_instruction_TBLWT extends @ipic_actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @ipic_instruction_MNOP extends @ipic_actualInstruction {
  @luint mOccurrenceFactor ;
  override
  method instructionLength !@uint outLength :
    outLength := [mOccurrenceFactor uint] * 2 ;
  end method ;
}

#----------------------------------------------------*

#class @ipic_instruction_FOREVER extends @ipic_actualInstruction {
#  @instructionList mInstructionList ;
#  override
#  method instructionLength !@uint outLength :
#    outLength := 2 ; # BRA at the end of instruction list
#    foreach mInstructionList do
#      @uint lg ; [mInstruction instructionLength ?lg] ;
#      outLength := outLength + lg ;
#    end foreach ;
#  end method ;
#}

#----------------------------------------------------*

#enum @if_semi_colon_op {
#  constructor CPFSEQ ;
#  constructor CPFSGT ;
#  constructor CPFSLT ;
#  constructor TSTFSZ ;
#}{
#  reader mnemonic :
#    CPFSEQ -> "CPFSEQ" ;
#    CPFSGT -> "CPFSGT" ;
#    CPFSLT -> "CPFSLT" ;
#    TSTFSZ -> "TSTFSZ" ;
#  end reader ;
#}

#----------------------------------------------------*

#routine getBaseCodeForIfSemiColonOp ??@if_semi_colon_op inInstruction !@uint outBaseCode :
#  switch inInstruction
#    when CPFSEQ : outBaseCode := 0x6200 ;
#    when CPFSGT : outBaseCode := 0x6400 ;
#    when CPFSLT : outBaseCode := 0x6000 ;
#    when TSTFSZ : outBaseCode := 0x6600 ;
#  end switch ; 
#end routine ;

#----------------------------------------------------*

abstract class @ipic_instruction_IF_SEMI_COLON extends @ipic_actualInstruction {
  @ipic_instruction mInstruction ;

  override
  method instructionLength !@uint outLength :
    [mInstruction instructionLength ?outLength] ;
    outLength := outLength + 2 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_IF_FA_SEMI_COLON extends @instruction_IF_SEMI_COLON {
  @if_semi_colon_op mOpCode ;
  @registerExpression mRegisterExpression ;

  method getBaseCode !@uint outBaseCode :
    getBaseCodeForIfSemiColonOp !mOpCode ?outBaseCode ;
  end method ;

}

#----------------------------------------------------*

class @ipic_instruction_IF_BitTest extends @instruction_IF_SEMI_COLON {
  @bool mSkipIfSet ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;

  method getBaseCode !@uint outBaseCode :
    if mSkipIfSet then
      outBaseCode := 0xA000 ; # BTFSS
    else
      outBaseCode := 0xB000 ; # BTFSC
    end if ;
  end method ; 

  method getMnemonic !@string outMnemonic :
    if mSkipIfSet then
      outMnemonic := "BTFSS" ;
    else
      outMnemonic := "BTFSC" ;
    end if ;
  end method ; 
}

#----------------------------------------------------*

class @ipic_instruction_IF_IncDec extends @instruction_IF_SEMI_COLON {
  @bool mIncrement ;
  @bool mSkipIfZero ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    if mIncrement & mSkipIfZero then
      outBaseCode := 0x3C00 ; # INCFSZ
    elsif mIncrement & not mSkipIfZero then
      outBaseCode := 0x4800 ; # INFSNZ
    elsif (not mIncrement) & mSkipIfZero then
      outBaseCode := 0x2C00 ; # DECFSZ
    else
      outBaseCode := 0x4C00 ; # DCFSNZ
    end if ;
  end method ; 

  method getMnemonic !@string outMnemonic :
    if mIncrement & mSkipIfZero then
      outMnemonic := "INCFSZ" ;
    elsif mIncrement & not mSkipIfZero then
      outMnemonic := "INFSNZ" ;
    elsif (not mIncrement) & mSkipIfZero then
      outMnemonic := "DECFSZ" ;
    else
      outMnemonic := "DCFSNZ" ;
    end if ;
  end method ; 
}

#----------------------------------------------------*

class @ipic_instruction_computed_retlw extends @ipic_actualInstruction {
  @luintlist mLiteralValues ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mLiteralValues length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_computed_bra extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_computed_goto extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 4 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_jump_test_register extends @ipic_actualInstruction {
  @registerExpression mRegisterExpression ;
  @string mTargetLabel ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;

  override
  method instructionLength !@uint outLength :
    outLength := 2 ; # TSTFSZ
    if mBranchIfZero then
      outLength := outLength + 2 ; # Intermediate BRA
    end if ;
    if mUsesBra then
      outLength := outLength + 2 ; # Final BRA
    else
      outLength := outLength + 4 ; # Final GOTO
    end if ;
  end method ;
}

#----------------------------------------------------*

end semantics ;
