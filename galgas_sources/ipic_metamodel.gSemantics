semantics ipic_metamodel :
import "piccolo_metamodel.gSemantics" ;
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;

#----------------------------------------------------*

abstract class @ipic_instruction {
  abstract method instructionLength !@uint outLength ;
}

#----------------------------------------------------*

list @ipic_instructionList {
  @ipic_instruction mInstruction ;
}

#----------------------------------------------------*

class @ipic_pseudo_NULL extends @ipic_instruction {
  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_ORG extends @ipic_instruction {
  @uint mOrigin ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_pseudo_LABEL extends @ipic_instruction {
  @lstring mTargetLabel ;

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

abstract class @ipic_actualInstruction extends @ipic_instruction {
  @location mInstructionLocation ;

  override method instructionLength !@uint outLength :
    outLength := 2 ;
  end method ;
}

#----------------------------------------------------*

struct @ipic_registerExpression {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
  @bool mNeedsBSR ;
}

#----------------------------------------------------*

class @ipic_instruction_FDA extends @ipic_actualInstruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @ipic_registerExpression mRegisterDescription ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    getFDAinstructionBaseCode !mInstruction_FDA_base_code ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

routine getFAinstructionBaseCode
  ??@FA_instruction_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when CLRF   : outBaseCode := 0x6A00 ;
  when CPFSEQ : outBaseCode := 0x6200 ;
  when CPFSGT : outBaseCode := 0x6400 ;
  when CPFSLT : outBaseCode := 0x6000 ;
  when MOVWF  : outBaseCode := 0x6E00 ;
  when MULWF  : outBaseCode := 0x0200 ;
  when NEGF   : outBaseCode := 0x6C00 ;
  when SETF   : outBaseCode := 0x6800 ;
  when TSTFSZ : outBaseCode := 0x6600 ;
  end switch ;
end routine ;

#----------------------------------------------------*

class @ipic_instruction_FA extends @ipic_actualInstruction {
  @FA_instruction_base_code mFAinstruction ;
  @ipic_registerExpression mRegisterDescription ;

  method getBaseCode !@uint outBaseCode :
   getFAinstructionBaseCode !mFAinstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVFF extends @ipic_actualInstruction {
  @ipic_registerExpression mSourceRegisterDescription ;
  @ipic_registerExpression mDestinationRegisterDescription ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

routine getBitOrientedOpBaseCode ??@bit_oriented_op inInstruction !@uint outBaseCode :
  switch inInstruction
  when BCF : outBaseCode := 0x9000 ;
  when BSF : outBaseCode := 0x8000 ;
  when BTFSC : outBaseCode := 0xB000 ;
  when BTFSS : outBaseCode := 0xA000 ;
  when BTG : outBaseCode := 0x7000 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @ipic_instruction_FBA extends @ipic_actualInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @ipic_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
  method getBaseCode !@uint outBaseCode :
    getBitOrientedOpBaseCode !mBitOrientedOp ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

enum @condionalBranchMode {
  constructor native ;
  constructor usesBRA ;
  constructor usesGOTO ;
}{
}

#----------------------------------------------------*

class @ipic_instruction_conditionalBranch extends @ipic_actualInstruction {
  @condionalBranchMode mBranchMode ;
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabel ;

  override
  method instructionLength !@uint outLength :
    switch mBranchMode
      when native   : outLength := 2 ;
      when usesBRA  : outLength := 4 ;
      when usesGOTO : outLength := 6 ;
    end switch ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_BRA extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @ipic_instruction_CALL extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_GOTO extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_RCALL extends @ipic_actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @ipic_instruction_CLRWDT extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_DAW extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_NOP extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_POP extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_PUSH extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RESET extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RETURN extends @ipic_actualInstruction {
}

#----------------------------------------------------*

class @ipic_instruction_RETFIE extends @ipic_actualInstruction {
  @bool mFastReturn ;
}

#----------------------------------------------------*

class @ipic_instruction_SLEEP extends @ipic_actualInstruction {
}

#----------------------------------------------------*

routine getLiteralInstructionBaseCode ??@literal_instruction_opcode inInstruction !@uint outBaseCode :
  switch inInstruction
  when ADDLW : outBaseCode := 0x0F00 ;
  when ANDLW : outBaseCode := 0x0B00 ;
  when IORLW : outBaseCode := 0x0900 ;
  when MOVLW : outBaseCode := 0x0E00 ;
  when MULLW : outBaseCode := 0x0D00 ;
  when RETLW : outBaseCode := 0x0C00 ;
  when SUBLW : outBaseCode := 0x0800 ;
  when XORLW : outBaseCode := 0x0A00 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @ipic_instruction_literalOperation extends @ipic_actualInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @luint mLiteralValue ;
  method getBaseCode !@uint outBaseCode :
    getLiteralInstructionBaseCode !mLiteralInstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_LFSR extends @ipic_actualInstruction {
  @luint mFSRindex ;
  @ipic_registerExpression mRegisterDescription ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVLB extends @ipic_actualInstruction {
  @luint mPageIndex ;
}

#----------------------------------------------------*

class @ipic_instruction_MOVAW extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
}

#----------------------------------------------------*

class @ipic_instruction_TBLRD extends @ipic_actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @ipic_instruction_TBLWT extends @ipic_actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @ipic_instruction_MNOP extends @ipic_actualInstruction {
  @luint mOccurrenceFactor ;
  override
  method instructionLength !@uint outLength :
    outLength := [mOccurrenceFactor uint] * 2 ;
  end method ;
}

#----------------------------------------------------*

abstract class @ipic_instruction_IF_SEMI_COLON extends @ipic_actualInstruction {
  @ipic_instruction mInstruction ;

  override
  method instructionLength !@uint outLength :
    [mInstruction instructionLength ?outLength] ;
    outLength := outLength + 2 ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_computed_retlw extends @ipic_actualInstruction {
  @luintlist mLiteralValues ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mLiteralValues length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_computed_bra extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_instruction_computed_goto extends @ipic_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 4 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_jump_test_register extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;

  override
  method instructionLength !@uint outLength :
    outLength := 2 ; # TSTFSZ
    if mBranchIfZero then
      outLength := outLength + 2 ; # Intermediate BRA
    end if ;
    if mUsesBra then
      outLength := outLength + 2 ; # Final BRA
    else
      outLength := outLength + 4 ; # Final GOTO
    end if ;
  end method ;
}

#----------------------------------------------------*

class @ipic_incDecRegisterInCondition extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @bool mIncrement ;
  @bool m_W_isDestination ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;

  override
  method instructionLength !@uint outLength :
    if mUsesBra then
      outLength := 4 ;
    else
      outLength := 6 ;
    end if ; 
  end method ;
}

#----------------------------------------------------*

class @ipic_registerComparisonCondition extends @ipic_actualInstruction {
  @ipic_registerExpression mRegisterDescription ;
  @string mTargetLabel ;
  @registerComparison mComparison ;
  @bool mUsesBra ;

  method usesIntermediateBRA !@bool outUses :
    switch mComparison
      when notEqual       : outUses := false ; # CPFSEQ 
      when equal          : outUses := true  ; # CPFSEQ + BRA
      when greaterOrEqual : outUses := false ; # CPFLT
      when greater        : outUses := true  ; # CPFGT + BRA
      when lowerOrEqual   : outUses := false ; # CPFGT
      when lower          : outUses := true  ; # CPFLT + BRA
    end switch ;
  end method ;

  override
  method instructionLength !@uint outLength :
    @bool usesIntermediateBRA ; [self usesIntermediateBRA ?usesIntermediateBRA] ;
    if usesIntermediateBRA then
      outLength := 4 ;
    else
      outLength := 2 ;
    end if ; 
   if mUsesBra then
      outLength := outLength + 2 ; # Final BRA
    else
      outLength := outLength + 4 ; # Final GOTO
    end if ;
  end method ;
}

#----------------------------------------------------*

end semantics ;
