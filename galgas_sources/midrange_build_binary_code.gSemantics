semantics midrange_build_binary_code :
import "ipic_generic.gSemantics" ;
import "midrange_intermediate_classes.gSemantics" ;
import "midrange_display_intermediate_instruction.gSemantics" ;

#----------------------------------------------------------------------------*

map @midrange_symbolTable {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#                          enterLabelAtAddress                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @midrange_intermediate_instruction enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_intermediate_pseudo_LABEL enterLabelAtAddress
  ?!@midrange_symbolTable ioRoutineSymbolTable
  ?!@uint ioAddress
:
  [!?ioRoutineSymbolTable insertKey !mLabel !ioAddress] ;
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_intermediate_pseudo_ORG enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_intermediate_actualInstruction enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := ioAddress  + [selfcopy instructionLength] ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @midrange_intermediate_instruction generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_NULL generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_intermediate_pseudo_ORG generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
  setEmitAddress ! mOrigin + mOrigin ;
end method ;

#----------------------------------------------------*

reader @midrange_instruction_FD_base_code basecode -> @uint outBaseCode :
  switch selfcopy
  when ADDWF : outBaseCode := 0x0700 ;
  when ANDWF : outBaseCode := 0x0500 ;
  when COMF : outBaseCode := 0x0900 ;
  when DECF : outBaseCode := 0x0300 ;
  when DECFSZ : outBaseCode := 0x0B00 ;
  when INCF : outBaseCode := 0x0A00 ;
  when INCFSZ : outBaseCode := 0x0F00 ;
  when IORWF : outBaseCode := 0x0400 ;
  when MOVF : outBaseCode := 0x0800 ;
  when RLF : outBaseCode := 0x0D00 ;
  when RRF : outBaseCode := 0x0C00 ;
  when SUBWF : outBaseCode := 0x0200 ;
  when SWAPF : outBaseCode := 0x0E00 ;
  when XORWF : outBaseCode := 0x0600 ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_FD generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code := [mInstruction_FD_base_code basecode] ;
  if not m_W_isDestination then
    code := code | 0x80 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
end method ;

#----------------------------------------------------*

reader @midrange_F_instruction_base_code baseCode -> @uint outBaseCode
:
  switch selfcopy
  when CLRF   : outBaseCode := 0x0180 ;
  when MOVWF  : outBaseCode := 0x0080 ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_F generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code := [mFinstruction baseCode] ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
end method ;

#----------------------------------------------------*

reader @midrange_bit_oriented_op baseCode -> @uint outBaseCode :
  switch selfcopy
  when BCF : outBaseCode := 0x1000 ;
  when BSF : outBaseCode := 0x1400 ;
  end switch ;
end reader ;


#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_FB generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code := [mBitOrientedOp baseCode] ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  code := code | (mBitNumber << 7) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_BitTestSkip generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ;
  if mSkipIfSet then
    code := 0x1C00 ; # BTFSS
  else
    code := 0x1800 ; # BTFSC
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  code := code | (mBitNumber << 7) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

routine emit_midrange_GOTOinstruction_nocheck
  ??@uint inTargetAddress
:
  emitCode !0x2800 | (inTargetAddress & 0x7FF) ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_GOTOinstruction
  ??@location inIntructionLocation
  ??@uint inOriginAddress
  ??@uint inTargetAddress
:
  if ((inOriginAddress ^ inTargetAddress) & 0xF800) != 0 then
    error inIntructionLocation : "GOTO (from " . [inOriginAddress hexString] . " to " . [inTargetAddress hexString] . ") crosses page boundary" ;
  end if ;
  emit_midrange_GOTOinstruction_nocheck  !inTargetAddress ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_CALLinstruction_nocheck
  ??@uint inTargetAddress
:
  emitCode !0x2000 | (inTargetAddress & 0x7FF) ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_CALLinstruction
  ??@location inIntructionLocation
  ??@uint inOriginAddress
  ??@uint inTargetAddress
:
  if ((inOriginAddress ^ inTargetAddress) & 0xF800) != 0 then
    error inIntructionLocation : "CALL (from " . [inOriginAddress hexString] . " to " . [inTargetAddress hexString] . ") crosses page boundary" ;
  end if ;
  emit_midrange_CALLinstruction_nocheck  !inTargetAddress ;
end routine ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_JUMP generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#--- Get values for PCLATH register
  @registerExpression PCLATH_register [new ![@lstring new !"PCLATH" !here] ![@luint new !0 !here]] ;
  @midrange_intermediate_registerExpression PCLATH_IPICregisterDescription ;
  [PCLATH_register resolveMidrangeAccess
    !inTotalBankCount
    ![@uint max] # Means unknown bank
    !inRegisterTable
    ?PCLATH_IPICregisterDescription
    ?*
  ] ;
#---
  switch mBit11 
  when set   : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when clear : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when clear : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when noChange :
  end switch ;
#---
  emit_midrange_GOTOinstruction_nocheck !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_GOTO generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#---
  emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_JSR generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#--- Get values for PCLATH register
  @registerExpression PCLATH_register [new ![@lstring new !"PCLATH" !here] ![@luint new !0 !here]] ;
  @midrange_intermediate_registerExpression PCLATH_IPICregisterDescription ;
  [PCLATH_register resolveMidrangeAccess
    !inTotalBankCount
    ![@uint max] # Means unknown bank
    !inRegisterTable
    ?PCLATH_IPICregisterDescription
    ?*
  ] ;
#---
  switch mBit11 
  when set   : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when clear : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when clear : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when noChange :
  end switch ;
  emit_midrange_CALLinstruction_nocheck !targetAddress ;
  switch mBit11 
  when set   : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when clear : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when clear : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when noChange :
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_CALL generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#---
  emit_midrange_CALLinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_incDecRegisterInCondition generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint code ;
  if mIncrement then
    code := 0x0F00 ; # INCFSZ
  else
    code := 0x0B00 ; # DECFSZ
  end if ;
  if not m_W_isDestination then
    code := code | 0x0080 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
#---
  if mBranchIfZero then
    emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !ioAddress + 3 ;
  end if ;
#--- Generate GOTO instruction
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
  emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_CLRWDT generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0064 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_CLRW generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0100 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_NOP generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0000 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_RETURN generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0008 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_RETFIE generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0009 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_SLEEP generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0063 ;
end method ;

#----------------------------------------------------*

reader @midrange_literal_instruction_opcode baseCode -> @uint outBaseCode :
  switch selfcopy
  when ADDLW : outBaseCode := 0x3E00 ;
  when ANDLW : outBaseCode := 0x3900 ;
  when IORLW : outBaseCode := 0x3800 ;
  when MOVLW : outBaseCode := 0x3000 ;
  when RETLW : outBaseCode := 0x3400 ;
  when SUBLW : outBaseCode := 0x3C00 ;
  when XORLW : outBaseCode := 0x3A00 ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_literalOperation generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code := [mLiteralInstruction baseCode] ;
  code := code | mLiteralValue ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_pseudo_LABEL generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mLabel ?targetAddress] ;
  if (targetAddress != ioAddress) then
    error mLabel: "Internal second pass error: the '" . mLabel
    . "' label gets " . [ioAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_instruction_MNOP generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    emitCode !0x0000 ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine build_midrange_ipic_binary_code
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_intermediate_instructionList inGeneratedInstructionList
  ??@uint inROMsize
  ??@actualConfigurationMap inActualConfigurationMap
  !@uint outUsedROMsize
:
#-------------------------------- First pass: build label map
  @midrange_symbolTable symbolTable [emptyMap] ;
  @uint currentAddress := 0 ;
  foreach inGeneratedInstructionList do
    [mInstruction enterLabelAtAddress !?symbolTable !?currentAddress] ;
  end foreach ;
  @uint lastAddressForFirstPass := currentAddress ;
  outUsedROMsize := currentAddress ;
#-------------------------------- Second pass: generate code
  currentAddress := 0 ;
  setEmitAddress !0 ;
  foreach inGeneratedInstructionList do
    [mInstruction generateBinaryCodeAtAddress
      !inRegisterTable
      !inTotalBankCount
      !symbolTable
      !?currentAddress
    ] ;
    currentAddress := currentAddress  + [mInstruction instructionLength] ;
    checkCurrentEmitAddress !currentAddress * 2 ;
  end foreach ;
  if lastAddressForFirstPass != currentAddress then
    error here: "Internal second pass error: the last address gets " . [currentAddress hexString]
    . " value in second pass, while it gets "
    . [lastAddressForFirstPass hexString] . " value in first pass" ;
  elsif lastAddressForFirstPass > inROMsize then
    error here: "Program too large: " . [lastAddressForFirstPass string]
    . " bytes (rom size is "
    . [inROMsize string] . " bytes)" ;
  end if ;
#-------------------------------- Add Configuration
  foreach inActualConfigurationMap do
    setEmitAddress ! mRegisterAddress + mRegisterAddress ;
    emitCode !mRegisterValue ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
