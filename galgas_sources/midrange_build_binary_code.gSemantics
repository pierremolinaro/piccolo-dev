semantics midrange_build_binary_code :
import semantics midrange_metamodel in "midrange_metamodel.gSemantics" ;
import semantics midrange_ipic_metamodel in "midrange_ipic_metamodel.gSemantics" ;
import "ipic_generic.gSemantics" ;
import "midrange_ipic_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*

map @midrange_symbolTable {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#                          enterLabelAtAddress                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @midrange_ipic_instruction.enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_ipic_pseudo_LABEL.enterLabelAtAddress
  ?!@midrange_symbolTable ioRoutineSymbolTable
  ?!@uint ioAddress
:
  [!?ioRoutineSymbolTable insertKey !mLabel !ioAddress] ;
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_ipic_pseudo_ORG.enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_ipic_actualInstruction.enterLabelAtAddress
  ?!@midrange_symbolTable unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint instructionLength ;
  [self instructionLength ?instructionLength] ;
  ioAddress := ioAddress  + instructionLength ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @midrange_ipic_instruction.generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
;

#----------------------------------------------------------------------------*

override method @midrange_ipic_NULL.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_ipic_pseudo_ORG.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
  setEmitAddress ! mOrigin + mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_FD.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if not m_W_isDestination then
    code := code | 0x80 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_F.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_FB.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  code := code | (mBitNumber << 7) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_BitTestSkip.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ; [self getBaseCode ?code] ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  code := code | (mBitNumber << 7) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

routine emit_midrange_GOTOinstruction_nocheck
  ??@uint inTargetAddress
:
  emitCode !0x2800 | (inTargetAddress & 0x7FF) ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_GOTOinstruction
  ??@location inIntructionLocation
  ??@uint inOriginAddress
  ??@uint inTargetAddress
:
  if ((inOriginAddress ^ inTargetAddress) & 0xF800) != 0 then
    error inIntructionLocation : "GOTO (from " . [inOriginAddress hexString] . " to " . [inTargetAddress hexString] . ") crosses page boundary" ;
  end if ;
  emit_midrange_GOTOinstruction_nocheck  !inTargetAddress ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_CALLinstruction_nocheck
  ??@uint inTargetAddress
:
  emitCode !0x2000 | (inTargetAddress & 0x7FF) ;
end routine ;

#----------------------------------------------------------------------------*

routine emit_midrange_CALLinstruction
  ??@location inIntructionLocation
  ??@uint inOriginAddress
  ??@uint inTargetAddress
:
  if ((inOriginAddress ^ inTargetAddress) & 0xF800) != 0 then
    error inIntructionLocation : "CALL (from " . [inOriginAddress hexString] . " to " . [inTargetAddress hexString] . ") crosses page boundary" ;
  end if ;
  emit_midrange_CALLinstruction_nocheck  !inTargetAddress ;
end routine ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_JUMP.generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#--- Get values for PCLATH register
  @registerExpression PCLATH_register [new ![@lstring new !"PCLATH" !here] ![@luint new !0 !here]] ;
  @midrange_ipic_registerExpression PCLATH_IPICregisterDescription ;
  [PCLATH_register resolveMidrangeAccess
    !inTotalBankCount
    ![@uint max] # Means unknown bank
    !inRegisterTable
    ?PCLATH_IPICregisterDescription
    ?*
  ] ;
#---
  switch mBit11 
  when set   : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when clear : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when clear : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when noChange :
  end switch ;
#---
  emit_midrange_GOTOinstruction_nocheck !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_GOTO.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#---
  emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_JSR.generateBinaryCodeAtAddress
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#--- Get values for PCLATH register
  @registerExpression PCLATH_register [new ![@lstring new !"PCLATH" !here] ![@luint new !0 !here]] ;
  @midrange_ipic_registerExpression PCLATH_IPICregisterDescription ;
  [PCLATH_register resolveMidrangeAccess
    !inTotalBankCount
    ![@uint max] # Means unknown bank
    !inRegisterTable
    ?PCLATH_IPICregisterDescription
    ?*
  ] ;
#---
  switch mBit11 
  when set   : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when clear : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when clear : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when noChange :
  end switch ;
  emit_midrange_CALLinstruction_nocheck !targetAddress ;
  switch mBit11 
  when set   : emitCode ! 0x1000 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 3
  when clear : emitCode ! 0x1400 | (3 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 3
  when noChange :
  end switch ;
  switch mBit12 
  when set   : emitCode ! 0x1000 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BCF PCLATH, 4
  when clear : emitCode ! 0x1400 | (4 << 7) | ([PCLATH_IPICregisterDescription mRegisterAddress] & 0x7F); # BSF PCLATH, 4
  when noChange :
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_CALL.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
#---
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
#---
  emit_midrange_CALLinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------*

override method @midrange_ipic_incDecRegisterInCondition.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint code ;
  if mIncrement then
    code := 0x0F00 ; # INCFSZ
  else
    code := 0x0B00 ; # DECFSZ
  end if ;
  if not m_W_isDestination then
    code := code | 0x0080 ;
  end if ;
  code := code | ([mRegisterDescription mRegisterAddress] & 127) ;
  emitCode !code ;
#---
  if mBranchIfZero then
    emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !ioAddress + 3 ;
  end if ;
#--- Generate GOTO instruction
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?targetAddress] ;
  emit_midrange_GOTOinstruction !mInstructionLocation !ioAddress !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_CLRWDT.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0064 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_CLRW.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0100 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_NOP.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0000 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_RETURN.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0008 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_RETFIE.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0009 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_SLEEP.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  emitCode !0x0063 ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_literalOperation.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | mLiteralValue ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_pseudo_LABEL.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable inRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mLabel ?targetAddress] ;
  if (targetAddress != ioAddress) then
    error mLabel: "Internal second pass error: the '" . mLabel
    . "' label gets " . [ioAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_ipic_instruction_MNOP.generateBinaryCodeAtAddress
  ??@registerTable unused inRegisterTable
  ??@uint unused inTotalBankCount
  ??@midrange_symbolTable unused inRoutineSymbolTable
  ?!@uint unused ioAddress
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    emitCode !0x0000 ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine build_midrange_ipic_binary_code
  ??@registerTable inRegisterTable
  ??@uint inTotalBankCount
  ??@midrange_ipic_instructionList inGeneratedInstructionList
  ??@uint inROMsize
  ??@actualConfigurationMap inActualConfigurationMap
  !@uint outUsedROMsize
:
#-------------------------------- First pass: build label map
  @midrange_symbolTable symbolTable [emptyMap] ;
  @uint currentAddress := 0 ;
  foreach inGeneratedInstructionList do
    [mInstruction enterLabelAtAddress !?symbolTable !?currentAddress] ;
  end foreach ;
  @uint lastAddressForFirstPass := currentAddress ;
  outUsedROMsize := currentAddress ;
#-------------------------------- Second pass: generate code
  currentAddress := 0 ;
  setEmitAddress !0 ;
  foreach inGeneratedInstructionList do
    [mInstruction generateBinaryCodeAtAddress
      !inRegisterTable
      !inTotalBankCount
      !symbolTable
      !?currentAddress
    ] ;
    @uint instructionLength ;
    [mInstruction instructionLength ?instructionLength] ;
    currentAddress := currentAddress  + instructionLength ;
    checkCurrentEmitAddress !currentAddress * 2 ;
  end foreach ;
  if lastAddressForFirstPass != currentAddress then
    error here: "Internal second pass error: the last address gets " . [currentAddress hexString]
    . " value in second pass, while it gets "
    . [lastAddressForFirstPass hexString] . " value in first pass" ;
  elsif lastAddressForFirstPass > inROMsize then
    error here: "Program too large: " . [lastAddressForFirstPass string]
    . " bytes (rom size is "
    . [inROMsize string] . " bytes)" ;
  end if ;
#-------------------------------- Add Configuration
  foreach inActualConfigurationMap do
    setEmitAddress ! mRegisterAddress + mRegisterAddress ;
    emitCode !mRegisterValue ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
