semantics midrange_ipic_build_assembly_code :
import "midrange_intermediate_classes.gSemantics" ;
import "piccolo_embedded_devices.gSemantics" ;

#----------------------------------------------------*
#                BUILD ASSEMBLY CODE                 *
#----------------------------------------------------*

abstract method @midrange_intermediate_instruction buildAssemblyCode
  ?!@string unused ioString 
  ?!@uint unused ioLocalLabelIndex
;

#----------------------------------------------------*

override method @midrange_intermediate_NULL buildAssemblyCode
  ?!@string unused ioString 
  ?!@uint unused ioLocalLabelIndex
:
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_pseudo_ORG buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  ORG " . [mOrigin hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_pseudo_LABEL buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= [mLabel string] . ":\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_FD buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  " . [mInstruction_FD_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioString .= ", W" ;
  else
    ioString .= ", F" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_FB buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  " . [mBitOrientedOp mnemonic] ;
  ioString .= "  " . [mRegisterDescription mAssemblyString] ;
  ioString .= ", " . [mBitNumber string] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_BitTestSkip buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  " ;
  if mSkipIfSet then
    ioString .= "BTFSS" ;
  else
    ioString .= "BTFSC" ;
  end if ;
  ioString .= "  " . [mRegisterDescription mAssemblyString] ;
  ioString .= ", " . [mBitNumber string] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_F buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  " . [mFinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_incDecRegisterInCondition buildAssemblyCode
  ?!@string ioString
  ?!@uint ioLocalLabelIndex
:
  if mIncrement then
    ioString .= "  " . "INCFSZ " ;
  else
    ioString .= "  " . "DECFSZ " ;
  end if ;
  ioString .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioString .= ", W" ;
  else
    ioString .= ", F" ;
  end if ;
  ioString .= "\n" ;
  if mBranchIfZero then
    @string localLabel := "_local_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    ioString .= "  GOTO " . localLabel . "\n" ;
    ioString .= "  GOTO " . mTargetLabel . "\n" ;
    ioString .= localLabel . ":\n" ;
  else
    ioString .= "  GOTO " . mTargetLabel . "\n" ;
  end if;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_JUMP buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  switch mBit11 
  when set   : ioString .= "  BSF PCLATH, 3\n" ;
  when clear : ioString .= "  BCF PCLATH, 3\n" ;
  when noChange :
  end switch ;
  switch mBit12 
  when set   : ioString .= "  BSF PCLATH, 4\n" ;
  when clear : ioString .= "  BCF PCLATH, 4\n" ;
  when noChange :
  end switch ;
  ioString .= "  GOTO   " . [mTargetLabel string] . "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_GOTO buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  GOTO   " . [mTargetLabel string] . "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_JSR buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  switch mBit11 
  when set   : ioString .= "  BSF PCLATH, 3\n" ;
  when clear : ioString .= "  BCF PCLATH, 3\n" ;
  when noChange :
  end switch ;
  switch mBit12 
  when set   : ioString .= "  BSF PCLATH, 4\n" ;
  when clear : ioString .= "  BCF PCLATH, 4\n" ;
  when noChange :
  end switch ;
  ioString .= "  CALL  " . [mTargetLabel string] . "\n" ;
  switch mBit11 
  when set   : ioString .= "  BCF PCLATH, 3\n" ;
  when clear : ioString .= "  BSF PCLATH, 3\n" ;
  when noChange :
  end switch ;
  switch mBit12 
  when set   : ioString .= "  BCF PCLATH, 4\n" ;
  when clear : ioString .= "  BSF PCLATH, 4\n" ;
  when noChange :
  end switch ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_CALL buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  CALL  " . [mTargetLabel string] . "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_CLRWDT buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  CLRWDT\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_CLRW buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  CLRW\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_NOP buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  NOP\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_RETURN buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  RETURN\n" ;
end method ;

#----------------------------------------------------*

 override method @midrange_intermediate_instruction_RETFIE buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  RETFIE\n" ;
end method ;

#----------------------------------------------------*

 override method @midrange_intermediate_instruction_SLEEP buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  SLEEP\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_literalOperation buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  ioString .= "  " . [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @midrange_intermediate_instruction_MNOP buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioLocalLabelIndex
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    ioString .= "  NOP\n" ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------*

#override method @midrange_intermediate_instruction_computed_retlw buildAssemblyCode
#  ?!@string ioString
#  ?!@uint unused ioLocalLabelIndex
#:
#  if mUsesRCALL then
#    ioString .= "  RCALL _computed_goto_2\n" ;
#  else
#    ioString .= "  CALL _computed_goto_2\n" ;
#  end if ;
#  foreach mLiteralValues do
#    ioString .= "  RETLW " . [mValue hexString] . "\n" ;
#  end foreach ;
#end method ;

#----------------------------------------------------*

#override method @midrange_intermediate_instruction_computed_bra buildAssemblyCode
#  ?!@string ioString
#  ?!@uint unused ioLocalLabelIndex
#:
#  if mUsesRCALL then
#    ioString .= "  RCALL _computed_goto_2\n" ;
#  else
#    ioString .= "  CALL _computed_goto_2\n" ;
#  end if ;
#  foreach mTargetLabels do
#    ioString .= "  BRA " . [mValue string] . "\n" ;
#  end foreach ;
#end method ;

#----------------------------------------------------*

#override method @midrange_intermediate_instruction_computed_goto buildAssemblyCode
#  ?!@string ioString
#  ?!@uint unused ioLocalLabelIndex
#:
#  if mUsesRCALL then
#    ioString .= "  RCALL _computed_goto_4\n" ;
#  else
#    ioString .= "  CALL _computed_goto_4\n" ;
#  end if ;
#  foreach mTargetLabels do
#    ioString .= "  GOTO " . [mValue string] . "\n" ;
#  end foreach ;
#end method ;

#----------------------------------------------------*

routine midrange_build_assembly_code
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@registerTable inAllRegisters
  ??@midrange_intermediate_instructionList inInstructionList
  ??@actualConfigurationMap inActualConfigurationMap
  !@string outAssemblyCode
:
  outAssemblyCode := "  errorlevel -302 ; No Warning on registers not in bank 0\n" ; 
  outAssemblyCode .= "  errorlevel -306 ; No Warning on crossing page boundary\n\n" ; 
  outAssemblyCode .= "  PROCESSOR " . inProcessorName . "\n\n" ;
#--- Code
  outAssemblyCode .= ";--- Code\n" ;
  outAssemblyCode .= "  ORG 0\n" ;
  @uint bccLabelIndex := 0 ;
  foreach inInstructionList do
    [mInstruction buildAssemblyCode !?outAssemblyCode !?bccLabelIndex] ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- Prefined registers
  outAssemblyCode .= ";--- Prefefined registers\n" ;
  foreach inPredefinedRegisters do
    @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
    outAssemblyCode .= [lkey string] . " EQU " . [firstRegister hexString] . "\n" ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- User defined registers in ram
  outAssemblyCode .= ";--- User defined registers (in RAM)\n" ;
  foreach inAllRegisters do
    if not [inPredefinedRegisters hasKey ![lkey string]] then
      @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
      outAssemblyCode .= [lkey string] . " EQU " . [firstRegister hexString] . "\n" ;
    end if ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- PICCOLO defined symbols
  outAssemblyCode .= ";--- Piccolo defined symbol\n" ;
  outAssemblyCode .= "W EQU 1\n\n" ;
#-------------------------------- Add Configuration
  if [inActualConfigurationMap count] > 0 then
    outAssemblyCode .= ";--- Configuration\n\n" ;
    foreach inActualConfigurationMap do
      outAssemblyCode .= "  __config " . [mRegisterAddress hexString] . ", " . [mRegisterValue & 255 hexString] . "\n" ;
    end foreach ;
  end if ;
#-------------------------------- End
  outAssemblyCode .= ";---\n\n" ;
  outAssemblyCode .= "  END\n\n" ;
end routine ;

#----------------------------------------------------*

end semantics ;
