semantics midrange_optimizations :
import "intermediate_generic.gSemantics" ;
import "midrange_display_intermediate_instruction.gSemantics" ;
import "midrange_intermediate_instruction_set_current_address.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#                   isLABELorORG                                             *
#                                                                            *
#----------------------------------------------------------------------------*

reader @midrange_intermediate_instruction isLABELorORG -> @bool outIsLABELorORG :
  outIsLABELorORG := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_pseudo_ORG isLABELorORG -> @bool outIsLABELorORG :
  outIsLABELorORG := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_pseudo_LABEL isLABELorORG -> @bool outIsLABELorORG :
  outIsLABELorORG := true ;
end reader ;

#----------------------------------------------------------------------------*
#                                                                            *
#                   isNULL                                                   *
#                                                                            *
#----------------------------------------------------------------------------*

reader @midrange_intermediate_instruction isNULL -> @bool outIsNULL :
  outIsNULL := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_NULL isNULL -> @bool outIsNULL :
  outIsNULL := true ;
end reader ;

#----------------------------------------------------------------------------*
#                                                                            *
#                   enterReferencedLabel                                     *
#                                                                            *
#----------------------------------------------------------------------------*

method @midrange_intermediate_instruction enterReferencedLabel ?!@stringset unused ioReferencedLabelSet :
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_JUMP enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_GOTO enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_CALL enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_JSR enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;

#----------------------------------------------------------------------------*

override method @midrange_intermediate_incDecRegisterInCondition enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !mTargetLabel ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#                   isSkippingInstruction                                    *
#                                                                            *
#----------------------------------------------------------------------------*

reader @midrange_intermediate_instruction isSkippingInstruction -> @bool outIsSkipping :
  outIsSkipping := false ;
end reader ;

#----------------------------------------------------------------------------*

override
reader @midrange_intermediate_instruction_BitTestSkip isSkippingInstruction -> @bool outIsSkipping :
  outIsSkipping := true ;
end reader ;


#----------------------------------------------------------------------------*
#                                                                            *
#                   nextInstructionIsReachable                               *
#                                                                            *
#----------------------------------------------------------------------------*

reader @midrange_intermediate_instruction nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_JUMP nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_GOTO nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_instruction_RETURN nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_instruction_RETFIE nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @midrange_intermediate_instruction_literalOperation nextInstructionIsReachable -> @bool outIsReachable :
  outIsReachable := mLiteralInstruction != [@midrange_literal_instruction_opcode RETLW] ;
end reader ;

#----------------------------------------------------------------------------*
#                                                                            *
#                          defineLabel                                       *
#                                                                            *
#----------------------------------------------------------------------------*

method @midrange_intermediate_instruction defineLabel
  ?!@symbolTableForOptimizations unused ioRoutineSymbolTable
  ??@uint unused inLineIndex
:
end method ;

#----------------------------------------------------------------------------*

override
method @midrange_intermediate_pseudo_LABEL defineLabel
  ?!@symbolTableForOptimizations ioRoutineSymbolTable
  ??@uint inLineIndex
:
  [!?ioRoutineSymbolTable insertKey !mLabel !inLineIndex] ;
end method ;

#----------------------------------------------------------------------------*

routine findMidRangeFirstInstructionFromAddress
  ??@uint inLineIndex
  ??@midrange_intermediate_instructionList inGeneratedInstructionList
  !@midrange_intermediate_instruction outFirstInstruction
:
#--- Line Index
  @uint currentAddress := inLineIndex ;
#--- Find first executable instruction
  outFirstInstruction := [@midrange_intermediate_NULL new] ; # By default, no instruction
  @bool found := false ;
  loop [inGeneratedInstructionList length] :
  while (currentAddress < [inGeneratedInstructionList length]) & not found
  do
    cast [inGeneratedInstructionList mInstructionAtIndex !currentAddress] :
    when >= @midrange_intermediate_actualInstruction instr do
      outFirstInstruction := instr ;
      found := true ;
    else
      currentAddress ++ ;
    end cast ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

routine findMidRangeFirstInstructionOrLabelFromAddress
  ??@uint inLineIndex
  ??@midrange_intermediate_instructionList inGeneratedInstructionList
  !@midrange_intermediate_instruction outFirstInstruction
  !@stringset outReachedLabelSet
:
  outReachedLabelSet := [@stringset emptySet] ;
#--- Line Index
  @uint currentAddress := inLineIndex ;
#--- Find first executable instruction
  outFirstInstruction := [@midrange_intermediate_NULL new] ; # By default, no instruction
  @bool found := false ;
  loop [inGeneratedInstructionList length] :
  while (currentAddress < [inGeneratedInstructionList length]) & not found
  do
    cast [inGeneratedInstructionList mInstructionAtIndex !currentAddress] :
    when >= @midrange_intermediate_actualInstruction instr do
      outFirstInstruction := instr ;
      found := true ;
    when >= @midrange_intermediate_pseudo_ORG instr do
      outFirstInstruction := instr ;
      found := true ;
    when == @midrange_intermediate_pseudo_LABEL instr do
      outFirstInstruction := instr ;
      outReachedLabelSet += ![[instr mLabel] string] ;
      currentAddress ++ ;
    else
      currentAddress ++ ;
    end cast ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#                           O P T I M I Z E                                  *
#                                                                            *
#----------------------------------------------------------------------------*

method @midrange_intermediate_JUMP optimizeJUMP
  ??@symbolTableForOptimizations inSymbolTable
  ??@uint inLineIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone
:
#--- The JUMP goes to the next instruction ?
  @stringset reachedLabelSet ;
  findMidRangeFirstInstructionOrLabelFromAddress !inLineIndex+1 !ioGeneratedInstructionList ?* ?reachedLabelSet ;
#  log reachedLabelSet ; log inLineIndex ;
  if [reachedLabelSet hasKey ![mTargetLabel string]] then
    [!?ioGeneratedInstructionList setMInstructionAtIndex ![@midrange_intermediate_NULL new] !inLineIndex] ;
    ioListFileContents .= "  line " . [inLineIndex string] . ": JUMP branching to next instruction deleted\n" ;
  else      
  #--- Find destination label definition line
    @uint line ; [inSymbolTable searchKey !mTargetLabel ?line] ;
  #--- Find first executable instruction
    @midrange_intermediate_instruction firstInstruction ;
    findMidRangeFirstInstructionFromAddress !line + 1 !ioGeneratedInstructionList ?firstInstruction ;
  #--- Optimization from found first instruction
    cast firstInstruction :
    when == @midrange_intermediate_instruction_RETURN do
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        ![@midrange_intermediate_instruction_RETURN new !mInstructionLocation]
        !inLineIndex
      ] ;
      ioOptimizationsDone := true ;
      ioListFileContents .= "  line " . [inLineIndex string] . ": JUMP branching to RETURN replaced by RETURN\n" ;
    when == @midrange_intermediate_instruction_literalOperation literalOp do
      if [literalOp mLiteralInstruction] == [@midrange_literal_instruction_opcode RETLW] then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          !literalOp
          !inLineIndex
        ] ;
        ioOptimizationsDone := true ;
        ioListFileContents .= "  line " . [inLineIndex string] . ": JUMP branching to RETLW replaced by RETLW\n" ;
      end if ;
    when == @midrange_intermediate_JUMP jump do
      if mTargetLabel != [jump mTargetLabel] then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          ![@midrange_intermediate_JUMP new !mInstructionLocation ![jump mTargetLabel] ![@midrange_call_goto_bit noChange] ![@midrange_call_goto_bit noChange]]
          !inLineIndex
        ] ;
        ioOptimizationsDone := true ;
        ioListFileContents .= "  line " . [inLineIndex string] . ": JUMP branching to JUMP replaced by JUMP\n" ;
      end if ;
    else # No Optimization
    end cast ;
  end if ;      
end method ;

#----------------------------------------------------------------------------*

method @midrange_intermediate_GOTO optimizeGOTO
  ??@symbolTableForOptimizations inSymbolTable
  ??@uint inLineIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone
:
#  message "GOTO (line " . [inLineIndex string] . ")\n" ;
#--- The GOTO goes to the next instruction ?
  @stringset reachedLabelSet ;
  findMidRangeFirstInstructionOrLabelFromAddress !inLineIndex+1 !ioGeneratedInstructionList ?* ?reachedLabelSet ;
#  log reachedLabelSet ; log inLineIndex ;
  if [reachedLabelSet hasKey ![mTargetLabel string]] then
    [!?ioGeneratedInstructionList setMInstructionAtIndex ![@midrange_intermediate_NULL new] !inLineIndex] ;
    ioListFileContents .= "  line " . [inLineIndex string] . ": GOTO branching to next instruction deleted\n" ;
  else      
  #--- Find destination label definition line
    @uint line ; [inSymbolTable searchKey !mTargetLabel ?line] ;
  #--- Find first executable instruction
    @midrange_intermediate_instruction firstInstruction ;
    findMidRangeFirstInstructionFromAddress !line + 1 !ioGeneratedInstructionList ?firstInstruction ;
  #--- Optimization from found first instruction
#    log firstInstruction ;
    cast firstInstruction :
    when == @midrange_intermediate_instruction_RETURN do
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        ![@midrange_intermediate_instruction_RETURN new !mInstructionLocation]
        !inLineIndex
      ] ;
      ioOptimizationsDone := true ;
      ioListFileContents .= "  line " . [inLineIndex string] . ": GOTO branching to RETURN replaced by RETURN\n" ;
    when == @midrange_intermediate_instruction_literalOperation literalOp do
      if [literalOp mLiteralInstruction] == [@midrange_literal_instruction_opcode RETLW] then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          !literalOp
          !inLineIndex
        ] ;
        ioOptimizationsDone := true ;
        ioListFileContents .= "  line " . [inLineIndex string] . ": GOTO branching to RETLW replaced by RETLW\n" ;
      end if ;
    when == @midrange_intermediate_JUMP jump do
      if mTargetLabel != [jump mTargetLabel] then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          ![@midrange_intermediate_JUMP new !mInstructionLocation ![jump mTargetLabel] ![@midrange_call_goto_bit noChange] ![@midrange_call_goto_bit noChange]]
          !inLineIndex
        ] ;
        ioOptimizationsDone := true ;
        ioListFileContents .= "  line " . [inLineIndex string] . ": GOTO branching to JUMP replaced by JUMP\n" ;
      end if ;
    when == @midrange_intermediate_GOTO goto do
      if mTargetLabel != [goto mTargetLabel] then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          ![@midrange_intermediate_GOTO new !mInstructionLocation ![goto mTargetLabel]]
          !inLineIndex
        ] ;
        ioOptimizationsDone := true ;
        ioListFileContents .= "  line " . [inLineIndex string] . ": GOTO branching to GOTO replaced by GOTO\n" ;
      end if ;
    else # No Optimization
    end cast ;
  end if ;      
end method ;

#----------------------------------------------------------------------------*

#method @midrange_intermediate_CALL.optimizeCALL
#  ??@uint inLineIndex
#  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
#  ?!@string ioListFileContents
#  ?!@bool ioOptimizationsDone
#:
##--- Find first executable instruction
#  @midrange_intermediate_instruction firstInstruction ;
#  findFirstInstructionFromAddress !inLineIndex + 1 !ioGeneratedInstructionList ?firstInstruction ;
##--- Optimization from found first instruction
#  cast firstInstruction :
#  when == @midrange_intermediate_instruction_RETURN do
#    [!?ioGeneratedInstructionList setMInstructionAtIndex
#      ![@midrange_intermediate_GOTO new !mInstructionLocation !mTargetLabel]
#      !inLineIndex
#    ] ;
#    ioOptimizationsDone := true ;
#    ioListFileContents .= "  line " . [inLineIndex string] . ": JSR followed by RETURN replaced by JUMP\n" ;
#  else
#  end cast ;
#end method ;

#----------------------------------------------------------------------------*

method @midrange_intermediate_instruction_literalOperation optimizeMOVLW
  ??@uint inLineIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone
:
  if mLiteralInstruction == [@midrange_literal_instruction_opcode MOVLW] then
  #--- Find first executable instruction
    @midrange_intermediate_instruction firstInstruction ;
    findMidRangeFirstInstructionFromAddress !inLineIndex + 1 !ioGeneratedInstructionList ?firstInstruction ;
  #--- Optimization from found first instruction
    cast firstInstruction :
    when == @midrange_intermediate_instruction_RETURN do
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        ![@midrange_intermediate_instruction_literalOperation new !mInstructionLocation ![@midrange_literal_instruction_opcode RETLW] !mLiteralValue]
        !inLineIndex
      ] ;
      ioOptimizationsDone := true ;
      ioListFileContents .= "  line " . [inLineIndex string] . ": MOVLW followed by RETURN replaced by RETLW\n" ;
    else
    end cast ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

method @midrange_intermediate_incDecRegisterInCondition optimizeTestDecInc
  ??@symbolTableForOptimizations inSymbolTable
  ??@uint inLineIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone
:
#  message "optimizeTestDecInc " . [inLineIndex string] . "\n" ;
#--- Find destination label definition line
  @uint line ; [inSymbolTable searchKey ![@lstring new !mTargetLabel !here] ?line] ;
#--- Find first executable instruction
  @midrange_intermediate_instruction firstInstruction ;
  findMidRangeFirstInstructionFromAddress !line + 1 !ioGeneratedInstructionList ?firstInstruction ;
#--- Optimization from found first instruction
#  log firstInstruction ;
  cast firstInstruction :
  when == @midrange_intermediate_JUMP jump do
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      ![@midrange_intermediate_incDecRegisterInCondition new
        !mInstructionLocation
        !mRegisterDescription
        ![[jump mTargetLabel] string]
        !mIncrement
        !m_W_isDestination
        !mBranchIfZero
      ]
      !inLineIndex
    ] ;
    ioOptimizationsDone := true ;
    ioListFileContents .= "  line " . [inLineIndex string] . ": label of " ;
    ioListFileContents .= "JUMP " ;
    if mIncrement then
      ioListFileContents .= "INCF " ;
    else
      ioListFileContents .= "DECF " ;
    end if ;
    ioListFileContents .= [mRegisterDescription mAssemblyString] ;
    if m_W_isDestination then
      ioListFileContents .= ", W " ;
    end if ;
    if mBranchIfZero then
      ioListFileContents .= "Z" ;
    else
      ioListFileContents .= "NZ" ;
    end if ;
    ioListFileContents .= ": branching to JUMP replaced by second JUMP label\n" ;
  when == @midrange_intermediate_GOTO goto do
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      ![@midrange_intermediate_incDecRegisterInCondition new
        !mInstructionLocation
        !mRegisterDescription
        ![[goto mTargetLabel] string]
        !mIncrement
        !m_W_isDestination
        !mBranchIfZero
      ]
      !inLineIndex
    ] ;
    ioOptimizationsDone := true ;
    ioListFileContents .= "  line " . [inLineIndex string] . ": label of " ;
    ioListFileContents .= "JUMP " ;
    if mIncrement then
      ioListFileContents .= "INCF " ;
    else
      ioListFileContents .= "DECF " ;
    end if ;
    ioListFileContents .= [mRegisterDescription mAssemblyString] ;
    if m_W_isDestination then
      ioListFileContents .= ", W" ;
    end if ;
    if mBranchIfZero then
      ioListFileContents .= " Z" ;
    else
      ioListFileContents .= " NZ" ;
    end if ;
    ioListFileContents .= ": branching to GOTO replaced by second JUMP label\n" ;
  else
  end cast ;
end method ;

#----------------------------------------------------------------------------*

method @midrange_intermediate_instruction_BitTestSkip optimizeBitTestSkip
  ??@uint inLineIndex
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone
:
#--- First following instruction is a JUMP ?
  @string jumpLabel := "" ; # No By default
  @bool ok := false ;
  cast [ioGeneratedInstructionList mInstructionAtIndex !inLineIndex + 1] :
  when == @midrange_intermediate_JUMP jump do
    jumpLabel := [[jump mTargetLabel] string] ;
    ok := true ;
  else
  end cast ;
#--- Get second following instruction
  if (ok) then
    cast [ioGeneratedInstructionList mInstructionAtIndex !inLineIndex + 2] :
    when >= @midrange_intermediate_actualInstruction instruction do
      ok := [instruction instructionLength] == 1 ;
    else
      ok := false ;
    end cast ;
  end if ;
#--- Get third following instruction
  if (ok) then
    @midrange_intermediate_instruction thirdInstruction := [@midrange_intermediate_NULL new] ;
    @stringset reachedLabelSet ;
    findMidRangeFirstInstructionOrLabelFromAddress !inLineIndex+3 !ioGeneratedInstructionList ?* ?reachedLabelSet ;
    ok := [reachedLabelSet hasKey !jumpLabel] ;
  end if ;
#--- If Ok, perform optimization
  if ok then
  #--- Complement Bit test instruction (at inLineIndex)
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      ![@midrange_intermediate_instruction_BitTestSkip new
        !mInstructionLocation
        !not mSkipIfSet
        !mRegisterDescription
        !mBitNumber
      ]
      !inLineIndex
    ] ;
  #--- Delete instruction at (inLineIndex + 1)
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      ![@midrange_intermediate_NULL new]
      !inLineIndex + 1
    ] ;
  #--- 
    ioOptimizationsDone := true ;
  #--- Log
    ioListFileContents .= "  lines " . [inLineIndex string] . " to " . [inLineIndex + 2 string] ;
    ioListFileContents .= " bit test skip, following by a JUMP skipping next instruction, is complemented\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine perform_midrange_optimizations
  ?!@midrange_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
#-------------------------------- List file
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["CODE OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
#-------------------------------- Build label map
  @symbolTableForOptimizations symbolTable [emptyMap] ;
  foreach ioGeneratedInstructionList index lineIndex do
    [mInstruction defineLabel !?symbolTable !lineIndex] ;
  end foreach ;
#-------------------------------- Iterative optimizations
  @bool optimizationsDone := true ;
  @uint iteration := 0 ;
  loop [ioGeneratedInstructionList length] :
  while optimizationsDone
  do
    optimizationsDone := false ;
    iteration ++ ;
    ioListFileContents .= "Pass " . [iteration string] . ":\n" ;
  #--- Optimization loop
    foreach ioGeneratedInstructionList index idx do
      cast mInstruction :
      when == @midrange_intermediate_GOTO ipic_GOTO do
        [ipic_GOTO optimizeGOTO !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
      when == @midrange_intermediate_JUMP ipic_JUMP do
        [ipic_JUMP optimizeJUMP !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
#      when == @midrange_intermediate_CALL ipic_CALL do
#        [ipic_CALL optimizeCALL !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
      when == @midrange_intermediate_instruction_literalOperation ipic_literal do
        [ipic_literal optimizeMOVLW !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
      when == @midrange_intermediate_incDecRegisterInCondition ipic_decInc do
        [ipic_decInc optimizeTestDecInc !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
      when == @midrange_intermediate_instruction_BitTestSkip ipic_bitTestSkip do
        [ipic_bitTestSkip optimizeBitTestSkip !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone] ;
      else
      end cast ;
    end foreach ;
  #--- Delete non referenced labels
    @stringset referencedLabels [emptySet] ;
    foreach ioGeneratedInstructionList do
      [mInstruction enterReferencedLabel !?referencedLabels] ;
    end foreach ;
    foreach symbolTable do
      if not [referencedLabels hasKey ![lkey string]] then
        @uint definitionLine ; [symbolTable searchKey !lkey ?definitionLine] ;
        ioListFileContents .= "  line " . [definitionLine  string] . ": unreferenced label '" . lkey . "' is deleted\n" ;
        [!?ioGeneratedInstructionList setMInstructionAtIndex ![@midrange_intermediate_NULL new] !definitionLine] ;
        [!?symbolTable removeKey !lkey ?*] ;
      end if ;
    end foreach ;
  #--- Dead code elimination
    @bool reachable := true ;
    @bool skippingInstruction := false ;
    @bool previousWasSkippingInstruction := false ;
    foreach ioGeneratedInstructionList index idx do
       if reachable | previousWasSkippingInstruction then
         reachable := [mInstruction nextInstructionIsReachable] ;
         previousWasSkippingInstruction := skippingInstruction ;
         skippingInstruction := [mInstruction isSkippingInstruction] ;
       else
         const @bool isLABELorORG := [mInstruction isLABELorORG] ;
         if (not isLABELorORG) & (not [mInstruction isNULL]) then
           ioListFileContents .= "  line " . [idx string] . ": unreachable instruction is deleted\n" ;
           [!?ioGeneratedInstructionList setMInstructionAtIndex ![@midrange_intermediate_NULL new] !idx] ;
         elsif isLABELorORG then
           reachable := true ;
           previousWasSkippingInstruction := false ;
           skippingInstruction := false ;
         end if ;
       end if ;
    end foreach ;
    if not optimizationsDone then
      ioListFileContents .= "  No optimization\n\n" ;
    #--- Compute code size
      @uint currentAddress := 0 ;
      foreach ioGeneratedInstructionList do
        [mInstruction setCurrentAddress !?currentAddress] ;
      end foreach ;
      ioListFileContents .= "Minimum code size: " . [currentAddress string] . " instructions\n\n" ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
