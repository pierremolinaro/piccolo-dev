semantics midrange_semantics :
import "midrange_checkingAndBuildIPIC.gSemantics" ;
import "midrange_ipic_build_assembly_code.gSemantics" ;
import "piccolo_embedded_devices.gSemantics" ;
import "midrange_metamodel.gSemantics" ;
import "piccolo_config.gSemantics" ;
import "ram_sections.gSemantics" ;
import "midrange_optimizations.gSemantics" ;
import "midrange_build_binary_code.gSemantics" ;
import "midrange_compute_JSR_JUMP.gSemantics" ;
import "midrange_used_routines.gSemantics" ;
import "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*

map @midrange_declaredRoutineMap {
  insert insertKey error message "the '%K' routine is already declared" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine midrange_analyze ??@midrange_model inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
  switch [piccoloDeviceModel mProcessorType]
    when midrange :
    when pic18_60, pic18_80 : error [inPiccoloModel mDeviceName]: "a pic18 device is not accepted here : only a mid-range device" ;
    when baseline : error [inPiccoloModel mDeviceName]: "a baseline device is not accepted here : only a mid-range device" ;
  end switch ;
#-------------------------------- Interrupts ?
  @bool hasInterrupt := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if hasInterrupt then
      error mInterruptLocation:"only one interrupt routine can be defined" ;
    end if ;
    hasInterrupt := true ;
  end foreach ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  buildConfig
    ![piccoloDeviceModel mConfigRegisterMap]
    ![inPiccoloModel mConfigDefinitionList]
    !?listFileContents
    ?actualConfigurationMap
  ;
#-------------------------------- Ram definition
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  analyze_ram_sections
    !"DECLARED VARIABLES"
    ![inPiccoloModel mRamDefinitionList]
    !?ramBank
    ![piccoloDeviceModel mRegisterTable]
    !?listFileContents
    !?registerTable
    ??@declaredByteMap declaredByteMap
  ;
#-------------------------------- Build IPIC Assembly Instruction List
  @stringset usedRegisters [emptySet] ;
  build_midrange_assembly_instruction_list
    !([[piccoloDeviceModel mRomSize] uint] + 2047) / 2048
    ![[piccoloDeviceModel mBankCount] uint]
    ![[[piccoloDeviceModel mRomSize] uint] sint]
    !piccoloDeviceModel->mSharedBankName
    !registerTable
    !inPiccoloModel
    !hasInterrupt
    ?@midrange_intermediate_instructionList generatedInstructionList
    !?listFileContents
    !?usedRegisters
  ;
#-------------------------------- Compute used routine set
  const @stringset usedRoutineSet := midrange_computeUsedRoutines [
    !inPiccoloModel->mInterruptDefinitionList
    !inPiccoloModel->mRoutineDefinitionList
  ] ;
  @midrange_declaredRoutineMap declaredRoutineMap [emptyMap] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    [!?declaredRoutineMap insertKey !mRoutineName] ;
  end foreach ;
#-------------------------------- Check used routines
  @stringset unusedRoutineDeclarationUnicity [emptySet] ;
  foreach inPiccoloModel->mUnusedRoutineList do
    if not [declaredRoutineMap hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' routine is not declared" ;
    elsif [unusedRoutineDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is already declared as unused" ;
    elsif [usedRoutineSet hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is declared as unused, but is used" ;
    end if ;
    unusedRoutineDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach declaredRoutineMap do
    if (not [usedRoutineSet hasKey !lkey->string]) & (not [unusedRoutineDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' routine is unused" ;
    end if ;
  end foreach ;
#----------------------------------------------------------- Check declared bytes are used
  @stringset unusedByteDeclarationUnicity [emptySet] ;
  foreach inPiccoloModel->mUnusedRegisterList do
    if not [registerTable hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' byte is not declared" ;
    elsif [unusedByteDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is already declared as unused" ;
    elsif [usedRegisters hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' byte is declared as unused, but is used" ;
    end if ;
    unusedByteDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach declaredByteMap do
    if (not [usedRegisters hasKey !lkey->string]) & (not [unusedByteDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' byte is unused" ;
    end if ;
  end foreach ;
#-------------------------------- Perform Code Optimization
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    perform_midrange_optimizations !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Compute inter-pages JUMP and JSR
  if [@uint errorCount] == 0 then
    midrange_compute_JSR_JUMP !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Code generation
#--- If no error, generate object file(s)
  if [@uint errorCount] == 0 then
  #--- Generate hex file
    @uint usedROMsize ;
    build_midrange_ipic_binary_code
      !registerTable
      ![[piccoloDeviceModel mBankCount] uint]
      !generatedInstructionList
      ![[piccoloDeviceModel mRomSize] uint]
      !actualConfigurationMap
      !?listFileContents
      ?usedROMsize
    ;
    @string contents ;
    getGeneratedContents ?contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    if [option piccolo_options.output_C_Array value] then
      const @string baseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
      get_C_ArrayImplementation !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".c" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
      get_C_ArrayHeader !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".h" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    end if ;
  #--- Write infos (if verbose mode)
    if [option.verbose_output value] then
      @string verboseMessage := "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " words;" ;
      verboseMessage .= " used: " . [usedROMsize string] . " words (" ;
      verboseMessage .= [(usedROMsize * 100) / [[piccoloDeviceModel mRomSize] uint] string] . "%).\n" ;
      foreach ramBank do
        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
        verboseMessage .= "  RAM bank '" . lkey . "': " ;
        verboseMessage .= [bankSize string] . " bytes, used " ;
        verboseMessage .= [usedSize string] . " bytes (" ;
        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
      end foreach ;
      message verboseMessage ;
    end if ;
  #--- Generate asm file, if corresponding option enabled
    if [option piccolo_options.generateAssembly value] then
      @string assemblyCode ;
      midrange_build_assembly_code
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        !actualConfigurationMap
        ?assemblyCode
      ;
      @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !asmDestinationFile ?*] ;
    end if ;
  else # There are errors : delete hex and asm files
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    if [hexDestinationFile fileExists] then
      [@string deleteFile !hexDestinationFile] ;
    end if ;
    @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
    if [asmDestinationFile fileExists] then
      [@string deleteFile !asmDestinationFile] ;
    end if ;
  end if ;
#-------------------------------- Listing file
  if [option piccolo_options.ouputListingFile value] then
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile ?*] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
