syntax pic18_bootloader_syntax :
import lexique piccolo_lexique in "piccolo_lexique.gLexique" ;
import semantics pic18_metamodel in "pic18_metamodel.gSemantics" ;
import semantics pic18_bootloader_specification_semantics in "pic18_bootloader_specification_semantics.gSemantics" ;
import option piccolo_options in "piccolo_options.gOption" ;

#----------------------------------------------------*

nonterminal <ram_definition> ?!@ramDefinitionList ioRamDefinitionList ;

nonterminal <start_symbol> ;

nonterminal <routine_declaration> ?!@routineDeclarationList ioRoutineDefinitionList ;

#----------------------------------------------------*

rule <start_symbol> :
  $pic18$ ;
  $bootloader$ ;
  $identifier$ ? @lstring bootloaderName ;
  $literal_string$ ? @lstring deviceName ;
#--- First part
  ${$ ;
  @routineDeclarationList bootloaderRoutineDeclarationList [emptyList] ;
  @bootloaderReservedRAMmap bootloaderReservedRAMmap [emptyMap] ;
  @luint reservedRomSize [new !0 !here] ;
  repeat
  while
    <routine_declaration> !?bootloaderRoutineDeclarationList ;
  while
    $rom$ ;
    $=$ ;
    $integer$ ? @luint rs ;
    if [reservedRomSize uint] != 0 then
      error rs : "ROM size already defined" ;
    elsif [rs uint] == 0 then
      error rs: "ROM size should be > 0" ;
    elsif ([rs uint] mod 8) != 0 then
      error rs: "ROM size should be a multiple of 8" ;
    else
      reservedRomSize := rs ;
    end if ;
  while
    $ram$ ;
    $identifier$ ? @lstring bankName ;
    $=$ ;
    $integer$ ? @luint rs ;
    if [bootloaderReservedRAMmap hasKey ![bankName string]] then
      error rs : "RAM size already defined for '" . bankName . "' bank" ;
    elsif [rs uint] == 0 then
      error rs: "RAM size should be > 0" ;
    else
      [!?bootloaderReservedRAMmap  insertKey !bankName !rs] ;
    end if ;
  end repeat ;
  $}$ ;
#--- Second part
  ${$ ;
  @routineDeclarationList userRoutineDeclarationList [emptyList] ;
  repeat
  while
    <routine_declaration> !? userRoutineDeclarationList ;
  end repeat ;
  $}$ ;
#--- Third part
  @ramDefinitionList sharedRamDefinitionList [emptyList] ;
  ${$ ;
  repeat
  while
    <ram_definition> !?sharedRamDefinitionList ;
  end repeat ;
  $}$ ;
#--- Semantic analysis
  @string listingFile := [[@string stringWithSourceFilePath] stringByDeletingPathExtension] . ".list" ;
  if [@uint errorCount] == 0 then
    @string listFileContents ;
    pic18BootloaderSpecificationAnalysis
      ![@string stringWithSourceFilePath]
      !bootloaderName
      !deviceName
      !bootloaderRoutineDeclarationList
      !bootloaderReservedRAMmap
      !reservedRomSize
      !userRoutineDeclarationList
      !sharedRamDefinitionList
      ?listFileContents
    ;
    if ([@uint errorCount] == 0) & [option piccolo_options.ouputListingFile] then
      [listFileContents writeToFileWhenDifferentContents !listingFile ?*] ;
    end if ;
  end if ;
  if [@uint errorCount] > 0 then
    [@string deleteFileIfExists !listingFile] ;
  end if ;
end rule ;

#----------------------------------------------------*

rule <routine_declaration>
  ?!@routineDeclarationList ioRoutineDefinitionList
:
  @bool noreturn ;
  select
    noreturn := false ;
  or
    $noreturn$ ;
    noreturn := true ;
  end select ;
  $routine$ ;
  $identifier$ ? @lstring routineName ;
  @luint requiredBank ;
  @luint returnedBank ;
  @bool preservesBank ;
  select
    requiredBank := [@luint new ![@uint max] !here] ;
    returnedBank := [@luint new ![@uint max] !here] ;
    preservesBank := false ;
  or
    $bank$ ;
    $:$ ;
    select
      $preserved$ ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:preserved\" setting" ;
      end if ;
      preservesBank := true ;
      requiredBank := [@luint new ![@uint max] !here] ;
      returnedBank := [@luint new ![@uint max] !here] ;
    or
      $requires$ ;
      $integer$ ? requiredBank ;
      preservesBank := false ;
      select
        returnedBank := [@luint new ![@uint max] !here] ;
      or
        $ensures$ ;
        $integer$ ? returnedBank ;
        if noreturn then
          error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
        end if ;
      end select ;
    or
      $ensures$ ;
      $integer$ ? returnedBank ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
      end if ;
      preservesBank := false ;
      requiredBank := [@luint new ![@uint max] !here] ;
    end select ;
  end select ;
#---
  ioRoutineDefinitionList += !routineName !requiredBank !returnedBank !preservesBank !noreturn ;
end rule ;

#----------------------------------------------------*

end syntax ;
