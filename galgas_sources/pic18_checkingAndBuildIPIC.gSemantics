semantics pic18_checkingAndBuildIPIC :
import "piccolo_options.gOption" ;
import "pic18_metamodel.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;
import "pic18_intermediate_classes_set_current_address.gSemantics" ;

#----------------------------------------------------------------------------*

map @dataMap {
  @uint mDataSize ;
  insert insertKey error message "the '%K' data is already declared" ;
  search searchKey error message "the '%K' data is not declared" ;
}

#----------------------------------------------------*
#           DECOMPOSE STRUCTURED INSTRUCTIONS        *
#----------------------------------------------------*

abstract method @piccolo_instruction buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
;

#----------------------------------------------------------------------------*

routine handleInstructionList
  ??@instructionList inInstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  !@bool outContinuesInSequence
  ??@routineKind inRoutineKind
:
  outContinuesInSequence := true ;
  foreach inInstructionList do
    if not outContinuesInSequence then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      outContinuesInSequence := true ;
    end if ;
    [mInstruction buildIPICinstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?ioCurrentBank
      !inShouldPreserveBSR
      !?outContinuesInSequence
      !inRoutineKind
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------*

override method @instruction_nobanksel buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList unused ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"nobank\" here: BSR should be preserved (use it in a \"banksave\" construct)" ;
  end if ;
  ioCurrentBank := [@uint max] ;
#--- Generates no code
end method ;

#----------------------------------------------------*

override method @instruction_savebank buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Get values for BSR register
  @registerExpression BSRregister [new ![@lstring new !"BSR" !here] ![@luint new !0 !here]] ;
  @pic18_intermediate_registerExpressionWithoutBSRIndication BSR_IPICregisterDescription ;
  [BSRregister resolveAccessWithoutCheckingBank
    !inRegisterTable
    ?BSR_IPICregisterDescription
  ] ;
#--- Get values for register used for saving
  @pic18_intermediate_registerExpressionWithoutBSRIndication save_IPICregisterDescription ;
  [mRegister resolveAccessWithoutCheckingBank
    !inRegisterTable
    ?save_IPICregisterDescription
  ] ;
#--- Generate "MOVFF BSR, save_register" instruction
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !BSR_IPICregisterDescription
    !save_IPICregisterDescription
  ] ;
#--- Generate instruction list
  @uint finalBank := ioCurrentBank ;
  handleInstructionList
    !mInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?finalBank
    !false # Do not preserve bank now
    ?ioContinuesInSequence
    !inRoutineKind
  ;
  if not ioContinuesInSequence then
    error mEndOfSaveBankInstruction:"useless saving: execution does reach the end of \"savebank\" instruction list" ;
  end if ;
#--- Generate "MOVFF save_register, BSR" instruction
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !save_IPICregisterDescription
    !BSR_IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_banksel buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  if [mBankIndex uint] > 15 then
    error mBankIndex:"selected bank idx should be lower or equal to 15" ;
    ioCurrentBank := [@uint max] ; # No selected bank
  elsif [mBankIndex uint] != ioCurrentBank then
    ioCurrentBank := [mBankIndex uint] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVLB new !mInstructionLocation !mBankIndex] ;
  elsif mWarningOnUselessBanksel then
    warning mBankIndex:"useless instruction: the bank " . [ioCurrentBank string] . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_banksel_register buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: bank selection should be preserved (use \"banksave\" instruction)" ;
  end if ;
  const @uint registerAddress := [mRegisterExpression registerAddress !inRegisterTable] ;
  const @uint newBank := registerAddress >> 8 ;
  if ioCurrentBank != newBank then
    ioCurrentBank := newBank ;
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVLB new
      !mInstructionLocation
      ![@luint new !newBank ![mRegisterExpression mRegisterName]->location]
    ] ;
  elsif mWarningOnUselessBanksel then
    warning [mRegisterExpression mRegisterName]:"useless instruction: the bank " . newBank . " is already selected" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_FDA buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@pic18_intermediate_registerExpression IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
    !mInstructionLocation
    !mInstruction_FDA_base_code
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FA buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
    !mInstructionLocation
    !mFAinstruction
    !IPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_MOVFF buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @pic18_intermediate_registerExpressionWithoutBSRIndication sourceIPICregisterDescription ;
  [mSourceRegisterName resolveAccessWithoutCheckingBank
    !inRegisterTable
    ?sourceIPICregisterDescription
  ] ;
  @pic18_intermediate_registerExpressionWithoutBSRIndication destinationIPICregisterDescription ;
  [mDestinationRegisterName resolveAccessWithoutCheckingBank
    !inRegisterTable
    ?destinationIPICregisterDescription
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVFF new
    !mInstructionLocation
    !sourceIPICregisterDescription
    !destinationIPICregisterDescription
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FBA buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @bitSliceTable bitSliceTable ;
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FBA new
    !mInstructionLocation
    !mBitOrientedOp
    !IPICregisterDescription
    !bitNumber
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JSR buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#--- Check instruction
  @bool isNoReturn ;
  @uint requiredBank ;
  @uint returnedBank ;
  @bool preservesBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a BRA, GOTO, Bcc or JUMP instruction" ;
  end if ;
  if not preservesBank then
    ioCurrentBank := returnedBank ;
    if inShouldPreserveBSR then
      error mTargetLabel:"the routine call should preserve bank selection" ;
    end if ;
  end if ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_JSR new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JUMP buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#--- Check instruction
  @bool isNoReturn ;
  @uint requiredBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
  ioContinuesInSequence := false ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new
    !mInstructionLocation
    !mTargetLabel
    !mKind
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_JUMPCC buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  @bool isNoReturn ;
  @uint requiredBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
#---
  @condionalBranchMode mode ;
  if mIsBcc then
    mode := [@condionalBranchMode native] ;
  else
    mode := [@condionalBranchMode native] ;
  end if ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_conditionalBranch new
    !mInstructionLocation
    !mode
    !mConditionalBranch
    !mTargetLabel
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_CLRWDT buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_CLRWDT new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_DAW buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_DAW new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_NOP buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_NOP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_POP buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_POP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_PUSH buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_PUSH new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_RESET buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_RESET new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_SLEEP buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_SLEEP new
    !mInstructionLocation
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_literalOperation buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @sint result ; [mImmediatExpression eval !inRegisterTable !inConstantMap ?result] ;
#---
   if (result > 255S) | (result < -128S) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be betwween -128 and 255)" ;
   end if ;
#---  
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_literalOperation new
    !mInstructionLocation
    !mLiteralInstruction
    ![result & 0x000000FFS uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_LFSR buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if [mFSRindex uint] > 2 then
    error mFSRindex:"the LFSR register idx (" . [[mFSRindex uint] string] . ") should be lower or equal to 2" ;
  end if ;
#---
  @sint result ; [mImmediatExpression eval !inRegisterTable !inConstantMap ?result] ;
#---
   if (result > 0xFFFS) | (result < 0S) then
     error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 4095)" ;
   end if ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_LFSR new
    !mInstructionLocation
    !mFSRindex
    ![result uint]
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_LTBLPTR buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mImmediatExpression eval !inRegisterTable !inConstantMap ?@sint result] ;
#---
  if (result > 0xFF_FFFF_S) | (result < 0S) then
    error mInstructionLocation:"immediate value is evaluated as " . [result string] . " (should be between 0 and 0xFF_FFFF)" ;
  end if ;
  const @uint address := [result uint] ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@pic18_intermediate_registerExpression outIPICregisterDescription
    ?*
  ] ;
  const @uint upper := address >> 16 ;
  if upper == 0 then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif upper == 0xFF then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !upper
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  const @uint high := (address >> 8) & 0xFF ;
  if high == 0 then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif high == 0xFF then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !high
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  const @uint low := address & 0xFF ;
  if low == 0 then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code CLRF]
      !outIPICregisterDescription
    ] ;  
  elsif low == 0xFF then
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code SETF]
      !outIPICregisterDescription
    ] ;  
  else
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_literalOperation new
      !mInstructionLocation
      ![@literal_instruction_opcode MOVLW]
      !low
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
      !mInstructionLocation
      ![@FA_instruction_base_code MOVWF]
      !outIPICregisterDescription
    ] ;  
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_LDATAPTR buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [inDataMap searchKey !mDataName ?@uint dataSize] ;
  const @lstring labelName [new !"_data_" . mDataName !mDataName->location] ;
#--- Check index
  if [mDataIndex uint] >= dataSize then
    error mDataIndex: "index should be < " . dataSize ;
  end if ;
#--- Upper byte
  const @registerExpression TBLPTRU [new ![@lstring new !"TBLPTRU" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRU resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?@pic18_intermediate_registerExpression outIPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !labelName
    ![mDataIndex uint] * 2
    !16
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- High byte
  const @registerExpression TBLPTRH [new ![@lstring new !"TBLPTRH" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRH resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !labelName
    ![mDataIndex uint] * 2
    !8
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
#--- Low byte
  const @registerExpression TBLPTRL [new ![@lstring new !"TBLPTRL" !mInstructionLocation] ![@luint new !0 !mInstructionLocation]] ;
  [TBLPTRL resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?outIPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_MOV_LABEL_W new
    !mInstructionLocation
    !labelName
    ![mDataIndex uint] * 2
    !0
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
    !mInstructionLocation
    ![@FA_instruction_base_code MOVWF]
    !outIPICregisterDescription
  ] ;  
end method ;

#----------------------------------------------------*

override method @instruction_TBLRD buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_TBLRD new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLWT buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_TBLWT new
    !mInstructionLocation
    !mOption
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_retlw buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine : # ok
  when noReturnRoutine :
    error mInstructionLocation:"a \"noreturn\" routine does not accept computed retlw instruction" ;
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed retlw instruction" ;
  end switch ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mImmediateExpressionList length] then
    error mInstructionLocation:"the constant list length (" . [[mImmediateExpressionList length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#--- 
  @uintlist literalValues [emptyList] ;
  foreach mImmediateExpressionList index idx do
    @sint v ; [mExpression eval !inRegisterTable !inConstantMap ?v] ;
    if (v > 255S) | (v < -128S) then
      error mInstructionLocation:"immediate value with idx " . [idx string] . " is evaluated as " . [v string] . " (should be <= 255)" ;
    end if ;
    literalValues += ![v & 0x000000FFS uint] ;
  end foreach ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_computed_retlw new
    !mInstructionLocation
    !literalValues
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_MNOP buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap unused inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor:"occurrence argument is zero: no generated code" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_MNOP new
    !mInstructionLocation
    !mOccurrenceFactor
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_bra buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  @bool allPreserveBankSetting := true ;
  @bool allReturnBank := true ;
  @uint returnedBankValue [max] ;
  foreach mTargetLabels do
    @bool isNoReturn ;
    @uint requiredBank ;
    @uint returnedBank ;
    @bool preservesBank ;
    [inRoutineMap searchKey !mValue ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
  #--- Check bank "requires"
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;    
  #--- Check bank "preserved", "ensures"
    if preservesBank then
      allReturnBank := false ;
    elsif (returnedBankValue != [@uint max]) & (returnedBankValue != returnedBank) then
      error mValue:"this routine ensures setting of bank '" . [returnedBank string] . "', but "
      . "previous routine(s) ensure setting of bank '" . [returnedBankValue string] . "'." ;
    else
      allPreserveBankSetting := false ;
      returnedBankValue := returnedBank ;
    end if ;
    if ([@routineKind regularRoutine ] != inRoutineKind) & not isNoReturn then
      error mValue:"for being named in a computed bra from a regular routine, the '" . mValue . "' routine should be declared without any \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
#---
  if allReturnBank & not allPreserveBankSetting then
    ioCurrentBank := returnedBankValue ;
  elsif (not allReturnBank) & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine should either all preserve bank, eihter return the same selected bank" ;
  end if ;
  if inShouldPreserveBSR & not allPreserveBankSetting then
    error mInstructionLocation:"invoked routine(s) do(es) not preserve bank selection" ;
  end if ;
#---
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
#    error mInstructionLocation:"a regular routine does not accept computed bra instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed bra instruction" ;
  end switch ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 128S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 128" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_computed_bra new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_goto buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint unused ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  foreach mTargetLabels do
    @bool isNoReturn ;
    @uint requiredBank ;
    [inRoutineMap searchKey !mValue ?isNoReturn ?requiredBank ?* ?*] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if not isNoReturn then
      error mValue:"for being named in a computed goto, the '" . mValue . "' routine should be declared with the \"noreturn\" qualifier" ;
  end if ;
  end foreach ;
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept computed goto instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed goto instruction" ;
  end switch ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_computed_goto new
    !mInstructionLocation
    !mTargetLabels
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_rcall buildIPICinstructionList
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap unused inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
#---
  @bool allPreserveBank := true ;
  @bool someReturnsBank := false ;
  @uint returnedBankSelection := ioCurrentBank ;
  foreach mTargetLabels do
    @bool isNoReturn ;
    @uint requiredBank ;
    @uint returnedBank ;
    @bool preservesBank ;
    [inRoutineMap searchKey !mValue ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if isNoReturn then
      error mValue:"for being named in a computed rcall, the '" . mValue . "' routine should be declared without the \"noreturn\" qualifier" ;
  end if ;
     if inShouldPreserveBSR & not preservesBank then
       error mValue:"the '" . mValue . "' routine should preserved bank selection" ;
     elsif (not inShouldPreserveBSR) & not preservesBank then
       if not someReturnsBank then
         returnedBankSelection := returnedBank ;
         someReturnsBank := true ;
       elsif returnedBankSelection != returnedBank then 
         @string errorMessage := "the '" . mValue . "' routine returns " ;
         if returnedBank == [@uint max] then
           errorMessage .= "no bank selection" ;
         else
           errorMessage .= "bank selection set to  ". [returnedBank string] ;
         end if ;
         errorMessage .= ", but previous routine(s) return(s) " ;
         if returnedBankSelection == [@uint max] then
           errorMessage .= "no bank selection" ;
         else
           errorMessage .= "bank selection set to  ". [returnedBankSelection string] ;
         end if ;
         error mValue: errorMessage ;
       end if ;
     elsif (not inShouldPreserveBSR) & preservesBank then
     end if ;
  end foreach ;
#---
  ioContinuesInSequence := true ;
  ioCurrentBank := returnedBankSelection ;
#---
  @sint size ; [mSizeExpression eval !inRegisterTable !inConstantMap ?size] ;
  if size < 2S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be greater or equal to 2" ;
  elsif size > 64S then
    error mInstructionLocation:"the computed range (" . [size string] . ") should be lower or equal to 64" ;
  elsif [size uint] != [mTargetLabels length] then
    error mInstructionLocation:"the routine name list length (" . [[mTargetLabels length] string] . ") should be equal to the computed range (" . [size string] . ")" ;
  end if ;
#---
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_computed_rcall new
    !mInstructionLocation
    !mTargetLabels
    !label0
    !mUsesRelativeCall
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_FOREVER buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
#--- Check instruction list does not change bank
  @uint finalBank := ioCurrentBank ;
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation] !true] ;
  handleInstructionList
    !mInstructionList 
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?finalBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind
  ;
  if ioCurrentBank != finalBank then
    error mEndOfInstructionList:"instruction list does not leave BSR value unchanged";
  end if ;
#--- Generate JUMP to loop start
  ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new !mInstructionLocation ![@lstring new !label0 !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
#---
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  @FA_instruction_base_code baseCode ;
  switch mOpCode
    when CPFSEQ : baseCode := [@FA_instruction_base_code CPFSEQ] ;
    when CPFSGT : baseCode := [@FA_instruction_base_code CPFSGT] ;
    when CPFSLT : baseCode := [@FA_instruction_base_code CPFSLT] ;
    when TSTFSZ : baseCode := [@FA_instruction_base_code TSTFSZ] ;
  end switch ;
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FA new
    !mInstructionLocation
    !baseCode
    !IPICregisterDescription
  ] ;
#--- Append Instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction buildIPICinstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_BitTest buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  @bitSliceTable bitSliceTable ;
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_BitTestSkip new
    !mInstructionLocation
    !mSkipIfSet
    !IPICregisterDescription
    !bitNumber
  ] ;
#--- Append Instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction buildIPICinstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------*

abstract method @conditionExpression buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
;

#----------------------------------------------------*

abstract method @conditionExpression computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition buildIPICinstructionForCondition
  ??@uint unused inAccessBankSplitOffset
  ??@uint unused inCurrentBank
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @conditional_branch condition ;
  if inComplementaryBranch then
    getComplementaryBcc !mCondition ?condition ;
  else
    condition := mCondition ;
  end if ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_conditionalBranch new
    !inInstructionLocation
    ![@condionalBranchMode native]
    !condition
    ![@lstring new !inTargetLabel !inInstructionLocation]
  ] ;
end method ;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

routine getRegisterComparisonComplementary
  ??@registerComparison inComparison
  !@registerComparison outComparison
:
  switch inComparison
    when notEqual : outComparison := [@registerComparison equal] ;
    when equal : outComparison := [@registerComparison notEqual] ;
    when greaterOrEqual : outComparison := [@registerComparison lower] ;
    when greater : outComparison := [@registerComparison lowerOrEqual] ;
    when lowerOrEqual : outComparison := [@registerComparison greater] ;
    when lower : outComparison := [@registerComparison greaterOrEqual] ;
  end switch ;
end routine ;

#----------------------------------------------------*

override method @registerComparisonCondition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @registerComparison comparison ;
  if inComplementaryBranch then
    getRegisterComparisonComplementary !mComparison ?comparison ;
  else
    comparison := mComparison ;
  end if ;
#---
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_registerComparisonCondition new
    !inInstructionLocation
    !IPICregisterDescription
    ![@lstring new !inTargetLabel !here]
    !comparison
    !true # By Default, uses BRA
  ] ;
end method ;

#----------------------------------------------------*

routine getRegisterComparisonInstructionCount
  ??@registerComparison inComparison
  !@uint outInstructionCount
:
  switch inComparison
    when notEqual       : outInstructionCount := 2 ;
    when equal          : outInstructionCount := 3 ;
    when greaterOrEqual : outInstructionCount := 2 ;
    when greater        : outInstructionCount := 3 ;
    when lowerOrEqual   : outInstructionCount := 2 ;
    when lower          : outInstructionCount := 3 ;
  end switch ;
end routine ;

#----------------------------------------------------*

override method @registerComparisonCondition computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  @registerComparison comparison ;
  if inComplementaryBranch then
    getRegisterComparisonComplementary !mComparison ?comparison ;
  else
    comparison := mComparison ;
  end if ;
  getRegisterComparisonInstructionCount !comparison ?outInstructionCount ;
end method ;

#----------------------------------------------------*

override method @incDecRegisterInCondition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_incDecRegisterInCondition new
    !inInstructionLocation
    !IPICregisterDescription
    ![@lstring new !inTargetLabel !here]
    !mIncrement
    !m_W_isDestination
    !mBranchIfZero ^ inComplementaryBranch
    !true # By Default, uses BRA
  ] ;
end method ;

#----------------------------------------------------*

override method @incDecRegisterInCondition computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

override method @registerTestCondition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_jump_test_register new
    !inInstructionLocation
    !IPICregisterDescription
  ] ;
#---
  const @lstring targetLabel [new !inTargetLabel !inInstructionLocation] ;
  if inComplementaryBranch ^ mBranchIfZero then
    const @lstring aLabel [new !"_bcc_label_" . [ioLocalLabelIndex string] !inInstructionLocation] ; ioLocalLabelIndex ++ ;
    ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new
      !inInstructionLocation
      !aLabel
      ![@jumpInstructionKind ipicRelative]
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new
      !inInstructionLocation
      !targetLabel
      ![@jumpInstructionKind ipicRelative]
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new
      !aLabel
      !true
    ] ;
  else
    ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new
      !inInstructionLocation
      !targetLabel
      ![@jumpInstructionKind ipicRelative]
    ] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @registerTestCondition computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  if mBranchIfZero ^ inComplementaryBranch then
    outInstructionCount := 3 ;
  else
    outInstructionCount := 2 ;
  end if ;
end method ;

#----------------------------------------------------*

override method @negateCondition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  [mCondition buildIPICinstructionForCondition
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    !?ioLocalLabelIndex
    !not inComplementaryBranch
    !inInstructionLocation
    !inTargetLabel
    !?ioGeneratedInstructionList
    !?ioListFileContents
  ] ;
end method ;

#----------------------------------------------------*

override method @negateCondition computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  [mCondition computeInstructionCountForCondition
    !not inComplementaryBranch
    ?outInstructionCount
  ] ;
end method ;

#----------------------------------------------------*

override method @andCondition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
:
  if inComplementaryBranch then
    [mLeftExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  else
    @string label0 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    [mLeftExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !inInstructionLocation
      !label0
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    [mRightExpression buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !inCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !inInstructionLocation
      !inTargetLabel
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
    ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label0 !inInstructionLocation] !true] ;
  end if ;
end method ;

#----------------------------------------------------*

override method @andCondition computeInstructionCountForCondition
  ??@bool inComplementaryBranch
  !@uint outInstructionCount
:
  @uint countLeft ;
  [mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?countLeft
  ] ;
  @uint countRight ;
  [mLeftExpression computeInstructionCountForCondition
    !inComplementaryBranch
    ?countRight
  ] ;
  outInstructionCount := countLeft + countRight ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition buildIPICinstructionForCondition
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  ?!@uint unused ioLocalLabelIndex
  ??@bool inComplementaryBranch
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string unused ioListFileContents
:
  @bitSliceTable bitSliceTable ;
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !inCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?bitSliceTable
  ] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber
    !bitSliceTable
    ?bitNumber
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_BitTestSkip new
    !inInstructionLocation
    !mBTFSSinstruction ^ inComplementaryBranch
    !IPICregisterDescription
    !bitNumber
  ] ;
  ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new !inInstructionLocation ![@lstring new !inTargetLabel !inInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition computeInstructionCountForCondition
  ??@bool unused inComplementaryBranch
  !@uint outInstructionCount
:
  outInstructionCount := 2 ;
end method ;

#----------------------------------------------------*

override method @instruction_structured_if buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  @bool generateComplementaryCondition := false ;
#--- Direct Test Instruction Count
  if [option piccolo_options.performOptimizations value] then
    @uint directCount ; [mIfCondition computeInstructionCountForCondition !true ?directCount] ;
    if [mElseInstructionList length] > 0 then
      directCount ++ ;
    end if ;
    @uint complementaryCount ; [mIfCondition computeInstructionCountForCondition !false ?complementaryCount] ;
    if [mThenInstructionList length] > 0 then
      complementaryCount ++ ;
    end if ;
    if (complementaryCount < directCount) then
      generateComplementaryCondition := true ;
      ioListFileContents .= "  line " . [[ioGeneratedInstructionList length] string] . ": generates complementary test (saves "
      . [directCount - complementaryCount string] . " instruction" ;
      if (directCount - complementaryCount) > 1 then
        ioListFileContents .= "s" ;
      end if ;
      ioListFileContents .= ")\n" ;
    end if ;
  end if ;
  @uint elseBranchFinalBank := ioCurrentBank ;
  @uint thenBranchFinalBank := ioCurrentBank ;
  @bool elseContinuesInSequence ;
  @bool thenContinuesInSequence ;
  if generateComplementaryCondition then
  #---
    @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  #--- Translate condition
    [mIfCondition buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !ioCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !false
      !mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  #--- 'else' instructions
    handleInstructionList
      !mElseInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?elseBranchFinalBank
      !inShouldPreserveBSR
      ?elseContinuesInSequence
      !inRoutineKind
    ;
  #--- 'then' instructions
    if [mThenInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new !mInstructionLocation ![@lstring new !label_endOfIfinstruction !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
    end if ;
    ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation] !true] ;
    handleInstructionList 
      !mThenInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?thenBranchFinalBank
      !inShouldPreserveBSR
      ?thenContinuesInSequence
      !inRoutineKind
     ;
    if [mThenInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation] !true] ;
    end if ;
  else
  #---
    @string label_nextCondition := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
    @string label_endOfIfinstruction := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  #--- Translate condition
    [mIfCondition buildIPICinstructionForCondition
      !inAccessBankSplitOffset
      !ioCurrentBank
      !inRegisterTable
      !?ioLocalLabelIndex
      !true
      !mInstructionLocation
      !label_nextCondition
      !?ioGeneratedInstructionList
      !?ioListFileContents
    ] ;
  #--- 'then' instructions
    handleInstructionList
      !mThenInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?thenBranchFinalBank
      !inShouldPreserveBSR
      ?thenContinuesInSequence
      !inRoutineKind
    ;
  #--- 'else' instructions
    if [mElseInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new !mInstructionLocation ![@lstring new !label_endOfIfinstruction !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
    end if ;
    ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label_nextCondition !mInstructionLocation] !true] ;
    handleInstructionList
      !mElseInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !inDataMap
      !inConstantMap
      !?ioLocalLabelIndex
      !?ioGeneratedInstructionList
      !?ioListFileContents
      !?elseBranchFinalBank
      !inShouldPreserveBSR
      ?elseContinuesInSequence
      !inRoutineKind
    ;
    if [mElseInstructionList length] > 0 then
      ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !label_endOfIfinstruction !mInstructionLocation] !true] ;
    end if ;
  end if ;
  if elseBranchFinalBank == thenBranchFinalBank then
    ioCurrentBank := elseBranchFinalBank ;
  else
    error mEndOfElsePartLocation:"This branch does not leave BSR value as the first one does";
    elseBranchFinalBank := [@uint max] ; # No available value for BSR
  end if ;
#---
  ioContinuesInSequence := thenContinuesInSequence | elseContinuesInSequence ;
end method ;

#----------------------------------------------------*

override method @instruction_do_while buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Generate label
  @string labelInstructionBegin := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Define label
  ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !labelInstructionBegin !mInstructionLocation] !true] ;
#--- Repeated instructions
  @uint finalBank := ioCurrentBank ;
  handleInstructionList
    !mRepeatedInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?finalBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind
  ;
  if ioCurrentBank != finalBank then
    error mEndOfRepeatedInstructionList:"This branch does not leave BSR value unchanged";
  end if ;
#--- while parts
  foreach mWhilePartList do
    if [mInstructionList length] == 0 then
      [mCondition buildIPICinstructionForCondition
        !inAccessBankSplitOffset
        !ioCurrentBank
        !inRegisterTable
        !?ioLocalLabelIndex
        !false
        !mInstructionLocation
        !labelInstructionBegin
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
    else
      @string nextBranchLabel := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
      [mCondition buildIPICinstructionForCondition
        !inAccessBankSplitOffset
        !ioCurrentBank
        !inRegisterTable
        !?ioLocalLabelIndex
        !true
        !mInstructionLocation
        !nextBranchLabel
        !?ioGeneratedInstructionList
        !?ioListFileContents
      ] ;
      @uint bank := ioCurrentBank ;
      handleInstructionList
        !mInstructionList
        !inAccessBankSplitOffset
        !inRoutineMap
        !inRegisterTable
        !inDataMap
        !inConstantMap
        !?ioLocalLabelIndex
        !?ioGeneratedInstructionList
        !?ioListFileContents
        !?bank
        !inShouldPreserveBSR
        ?ioContinuesInSequence
        !inRoutineKind
      ;
      if ioCurrentBank != bank then
        error mEndOfPartLocation:"This branch does not leave BSR value unchanged";
      end if ;
      ioGeneratedInstructionList += ![@pic18_intermediate_JUMP new !mInstructionLocation ![@lstring new !labelInstructionBegin !mInstructionLocation] ![@jumpInstructionKind ipicRelative]] ;
      ioGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !nextBranchLabel !mInstructionLocation] !true] ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_IncDec buildIPICinstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@constantMap inConstantMap
  ?!@uint ioLocalLabelIndex
  ?!@pic18_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#---
  @instruction_FDA_base_code baseCode ;
  if mIncrement & mSkipIfZero then
    baseCode := [@instruction_FDA_base_code INCFSZ] ;
  elsif mIncrement & not mSkipIfZero then
    baseCode := [@instruction_FDA_base_code INFSNZ] ;
  elsif (not mIncrement) & mSkipIfZero then
    baseCode := [@instruction_FDA_base_code DECFSZ] ;
  else
    baseCode := [@instruction_FDA_base_code DCFSNZ] ;
  end if ;
#---
  @pic18_intermediate_registerExpression IPICregisterDescription ;
  [mRegisterExpression resolveAccess
    !inAccessBankSplitOffset
    !ioCurrentBank
    !inRegisterTable
    ?IPICregisterDescription
    ?*
  ] ;
#---
  ioGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
    !mInstructionLocation
    !baseCode
    !IPICregisterDescription
    !m_W_isDestination
  ] ;
#--- Embedded instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction buildIPICinstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !inDataMap
    !inConstantMap
    !?ioLocalLabelIndex
    !?ioGeneratedInstructionList
    !?ioListFileContents
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------*

routine build_pic18_intermediate_assembly_instruction_list
  ??@programKind inProgramKind
  ??@sint inROMSize
  ??@sint inRAMSize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForBootloaderImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ??@luint inBootloaderReservedROMsize
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ??@routineDeclarationList inUserRoutineDeclarationListForUserProgramImplementation
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ??@dataMap inDataMap
  ??@piccoloModel inPiccoloModel
  ??@bool inHasHighInterrupt
  ??@bool inHasLowInterrupt
  ??@pic18_intermediate_instructionList inDataGeneratedInstructionList
  ??@constantMap inDataLengthConstantMap
  !@pic18_intermediate_instructionList outGeneratedInstructionList
  ?!@string ioListFileContents
:
  @string generationOptimizationMessages := "" ;
#-------------------------------- Build routine map
  @routineMap routineMap [emptyMap] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    if ([mRequiredBank uint] != [@uint max]) & ([mRequiredBank uint] > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15" ;
    end if ;
    if ([mReturnedBank uint] != [@uint max]) & ([mReturnedBank uint] > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15" ;
    end if ;
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
#-------------------------------- Check bootloader routine definition
# For a bootloader implementation, check all bootloader routines are declared
  foreach inBootloaderRoutineDeclarationListForBootloaderImplementation do
    if [routineMap hasKey ![mRoutineName string]] then
      @bool isNoReturn ;
      @uint requiredBank ;
      @uint returnedBank ;
      @bool preservesBank ;
      [routineMap searchKey !mRoutineName ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
      if (isNoReturn != mIsNoReturn) | (requiredBank != [mRequiredBank uint]) | (returnedBank != [mReturnedBank uint])  | (preservesBank != mPreservesBank) then
        error [routineMap locationForKey ![mRoutineName string]] : "the '" . mRoutineName . "' routine header does not conform to its declaration in bootloader specification" ;
      end if ;
    else
      error here:"The bootloader specification requires the implementation to define the '" . mRoutineName . "' routine" ;
    end if ;
  end foreach ;
#-------------------------------- Check user program routine definition
# For an user program implementation, check all user routines are declared
  foreach inUserRoutineDeclarationListForUserProgramImplementation do
    if [routineMap hasKey ![mRoutineName string]] then
      @bool isNoReturn ;
      @uint requiredBank ;
      @uint returnedBank ;
      @bool preservesBank ;
      [routineMap searchKey !mRoutineName ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
      if (isNoReturn != mIsNoReturn) | (requiredBank != [mRequiredBank uint]) | (returnedBank != [mReturnedBank uint])  | (preservesBank != mPreservesBank) then
        error [routineMap locationForKey ![mRoutineName string]] : "the '" . mRoutineName . "' routine header does not conform to its declaration in bootloader specification" ;
      end if ;
    else
      error here:"The bootloader specification requires the implementation to define the '" . mRoutineName . "' routine" ;
    end if ;
  end foreach ;
#-------------------------------- Build constant map
  @constantMap constantMap := inDataLengthConstantMap ;
#--- Add "ROM_SIZE" and "RAM_SIZE" constants
  [!?constantMap insertKey ![@lstring new !"ROM_SIZE" !here] !inROMSize] ;
  [!?constantMap insertKey ![@lstring new !"RAM_SIZE" !here] !inRAMSize] ;
#--- Add "BOOTLOADER_RESERVED_SIZE" constant
  if inProgramKind != [@programKind regularProgram] then
    @lstring bootloaderSizeString [new !"BOOTLOADER_RESERVED_SIZE" !here] ;
    [!?constantMap insertKey !bootloaderSizeString ![[inBootloaderReservedROMsize uint] sint]] ;
  end if ;
#--- Add declared constants
  foreach [inPiccoloModel mConstantDefinitionList] do
    @sint result ; [mExpression eval !inRegisterTable !constantMap ?result] ;
    if [inRegisterTable hasKey ![mConstantName string]] then
      error mConstantName: "'" . mConstantName . "' is already declared as ram register or special register" ;
    else
      [!?constantMap insertKey !mConstantName !result] ;
    end if ;
  end foreach ;
#-------------------------------- Print constant map
  if [option piccolo_options.ouputListingFile value] then
    print_constant_definition
      !constantMap
      !?ioListFileContents
    ;
  end if ;
#-------------------------------- Check the "main" routine is declared
  if inProgramKind != [@programKind userProgram] then
    if [routineMap hasKey !"main"] then
      @bool isNoReturn ;
      @uint requiredBank ;
      [routineMap searchKey ![@lstring new !"main" !here] ?isNoReturn ?requiredBank ?* ?*] ;
      if not isNoReturn then
        error here :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
      if requiredBank != 0 then
        error here :"the \"main\" should be declared with \"requiresbank 0\" qualifier: \"noreturn main requiresbank 0\"" ;
      end if ;
    else
      error [inPiccoloModel mEndOfProgram]: "the program should declare the \"main\" routine" ;
    end if ;
  end if ;
#-------------------------------- Generate bootstrap entry points for user program
  outGeneratedInstructionList := [@pic18_intermediate_instructionList emptyList] ;
  @uint entryPoint := 0x04 ;
  foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !entryPoint] ;
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new !mRoutineName !true] ;
    entryPoint := entryPoint + 4 ;
    if entryPoint == 0x08 then
      entryPoint := 0x0C ;
    elsif entryPoint == 0x18 then
      entryPoint := 0x1C ;
    end if ;
  end foreach ;
#-------------------------------- Generate user program entry points for user program
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForUserProgramImplementation do
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !entryPoint] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here !mRoutineName ![@jumpInstructionKind ipicRelative]] ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#-------------------------------- At zero, generate 'jump main' instruction
  if inProgramKind != [@programKind userProgram] then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !0] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here ![@lstring new !"main" !here] ![@jumpInstructionKind ipicRelative]] ;
  end if ;
#-------------------------------- At 0x04, generate the first bootloader entry point (if any)
  @routineDeclarationList tempBootloaderRoutineDeclarationList := inBootloaderRoutineDeclarationListForBootloaderImplementation ;
  if [tempBootloaderRoutineDeclarationList length] > 0 then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !0x04] ;
    @lstring routineName ;
    [!?tempBootloaderRoutineDeclarationList popFirst ?routineName ?* ?* ?* ?*] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here !routineName ![@jumpInstructionKind ipicRelative]] ;
  end if ;
#-------------------------------- At 0x08, generate 'bra _high_interrupt' instruction, if fast interrupt is defined
  if inHasHighInterrupt then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !0x8] ;
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_high_interrupt_routine" !here] !false] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here ![@lstring new !"_high_interrupt" !here] ![@jumpInstructionKind ipicRelative]] ;
  end if ;
#-------------------------------- At 0x0C, 0x10, 0x14, generate the bootloader entry points (if they exists)
  entryPoint := 0x0C ;
  loop [tempBootloaderRoutineDeclarationList length] :
  while ([tempBootloaderRoutineDeclarationList length] > 0) & (entryPoint < 0x18) 
  do
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !entryPoint] ;
    @lstring routineName ;
    [!?tempBootloaderRoutineDeclarationList popFirst ?routineName ?* ?* ?* ?*] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here !routineName ![@jumpInstructionKind ipicRelative]] ;
    entryPoint := entryPoint + 0x4 ;
  end loop ;
#-------------------------------- Generate JUMP to low interrupt (if any)
  if inHasLowInterrupt then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !0x18] ;
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_low_interrupt_routine" !here] !false] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here ![@lstring new !"_low_interrupt" !here] ![@jumpInstructionKind ipicRelative]] ;
  end if ;
#-------------------------------- Generate entry points for remaining bootloader routines
  entryPoint := 0x1C ;
  foreach tempBootloaderRoutineDeclarationList do
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !entryPoint] ;
    outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here !mRoutineName ![@jumpInstructionKind ipicRelative]] ;
    entryPoint := entryPoint + 0x4 ;
  end foreach ;
#-------------------------------- Generate low interrupt routine (if any)
  @uint localLabelIndex := 0 ;
  if inHasLowInterrupt then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_low_interrupt" !here] !true] ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        @bool continuesInSequence ;
        @uint currentBank [max] ; # No bank
        handleInstructionList
          !mInstructionList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !inDataMap
          !constantMap
          !?localLabelIndex
          !?outGeneratedInstructionList
          !?generationOptimizationMessages
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ?continuesInSequence
          ![@routineKind interruptRoutine]
        ;
        if not continuesInSequence then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
        end if ;
      #--- Ajouter l'instruction REFFIE
        outGeneratedInstructionList += ![@pic18_intermediate_instruction_RETFIE new !here !mFastReturn] ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Generate high interrupt routine (if any)
  if inHasHighInterrupt then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_high_interrupt" !here] !true] ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        @bool continuesInSequence ;
        @uint currentBank [max] ; # No bank
        handleInstructionList
          !mInstructionList
          !inAccessBankSplitOffset
          !routineMap
          !inRegisterTable
          !inDataMap
          !constantMap
          !?localLabelIndex
          !?outGeneratedInstructionList
          !?generationOptimizationMessages
          !?currentBank
          !not mFastReturn # Preserve BSR if not "fast"
          ?continuesInSequence
          ![@routineKind interruptRoutine]
        ;
        if not continuesInSequence then
          error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
         end if ;
      #--- Add a REFFIE instruction
        outGeneratedInstructionList += ![@pic18_intermediate_instruction_RETFIE new !here !true] ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Check and translate routines
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @bool continuesInSequence ;
    @uint currentBank := [mRequiredBank uint] ;
    @routineKind routineKind ;
    if mIsNoReturn then
      routineKind := [@routineKind noReturnRoutine] ;
    else
      routineKind := [@routineKind regularRoutine] ;
    end if ;
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new !mRoutineName  !true] ;
    handleInstructionList
      !mInstructionList
      !inAccessBankSplitOffset
      !routineMap
      !inRegisterTable
      !inDataMap
      !constantMap
      !?localLabelIndex
      !?outGeneratedInstructionList
      !?generationOptimizationMessages
      !?currentBank
      !mPreservesBank
      ?continuesInSequence
      !routineKind
    ;
    if (not mIsNoReturn) & ([mReturnedBank uint] != [@uint max]) & (currentBank != [mReturnedBank uint]) then
      error mRoutineName:"execution will not set BSR to " . [[mReturnedBank uint] string] ;
    end if ;
    if mIsNoReturn & continuesInSequence then
      error mRoutineName:"execution should not reach the end of a \"noreturn\" routine" ;
    end if ;
  #--- Add a RETURN instruction (if it is a regular routine)
    if not mIsNoReturn then
      outGeneratedInstructionList += ![@pic18_intermediate_instruction_RETURN new ![mRoutineName location]] ;
    end if ;
  end foreach ;
#-------------------------------- Generate _computed_goto_4 and _computed_goto_2 (if needed)
#--- Description of register WREG
  @registerExpression WREGregister [new ![@lstring new !"WREG" !here] ![@luint new !0 !here]] ;
  @pic18_intermediate_registerExpression WREG_IPICregisterDescription ;
  [WREGregister resolveAccess
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ?WREG_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSL
  @registerExpression TOSLregister [new ![@lstring new !"TOSL" !here] ![@luint new !0 !here]] ;
  @pic18_intermediate_registerExpression TOSL_IPICregisterDescription ;
  [TOSLregister resolveAccess
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ?TOSL_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSH
  @registerExpression TOSHregister [new ![@lstring new !"TOSH" !here] ![@luint new !0 !here]] ;
  @pic18_intermediate_registerExpression TOSH_IPICregisterDescription ;
  [TOSHregister resolveAccess
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ?TOSH_IPICregisterDescription
    ?*
  ] ;
#--- Description of register TOSU
  @registerExpression TOSUregister [new ![@lstring new !"TOSU" !here] ![@luint new !0 !here]] ;
  @pic18_intermediate_registerExpression TOSU_IPICregisterDescription ;
  [TOSUregister resolveAccess
    !inAccessBankSplitOffset
    !0 # Current bank
    !inRegisterTable
    ?TOSU_IPICregisterDescription
    ?*
  ] ;
#--- computed_goto2 routine needed ?
  if [inPiccoloModel mNeedsComputedGoto4] then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_computed_goto_4" !here] !true] ;
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      !WREG_IPICregisterDescription
      !true
    ] ; # ADDWF WREG, W
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"_computed_goto_2" !here] !true] ;
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] | [inPiccoloModel mNeedsComputedGoto4] then
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      !WREG_IPICregisterDescription
      !true
    ] ; # ADDWF WREG, W
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      !TOSL_IPICregisterDescription
      !false
    ] ; # ADDWF TOSL, F
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_literalOperation new
      !here
      ![@literal_instruction_opcode MOVLW]
      !0
    ] ; # MOVLW 0
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      !TOSH_IPICregisterDescription
      !false
    ] ; # ADDWFC TOSH, F
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      !TOSU_IPICregisterDescription
      !false
    ] ; # ADDWFC TOSU, F
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_RETURN new
      !here
    ] ; # RETURN 0
  end if ;
#-------------------------------- Add Data definition
  foreach inDataGeneratedInstructionList do
    outGeneratedInstructionList += !mInstruction ;
  end foreach ;
#-------------------------------- Generate 'BOOTLOADER_ACTUAL_SIZE' label
  if inProgramKind == [@programKind bootloaderProgram] then
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"BOOTLOADER_ACTUAL_SIZE" !here] !false] ;
  end if ;
#-------------------------------- Generate default user routines
  entryPoint := [inBootloaderReservedROMsize uint] ;
  foreach inUserRoutineDeclarationListForBootloaderImplementation do
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_ORG new !entryPoint] ;
    outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new !mRoutineName !true] ;
    if mIsNoReturn then
      outGeneratedInstructionList += ![@pic18_intermediate_JUMP new !here !mRoutineName ![@jumpInstructionKind ipicRelative]] ;
    elsif [mReturnedBank uint] != [@uint max] then
      outGeneratedInstructionList += ![@pic18_intermediate_instruction_MOVLB new !here !mReturnedBank] ;
    end if ;
    outGeneratedInstructionList += ![@pic18_intermediate_instruction_RETURN_NOT_OPTIMIZABLE new !here] ;
    entryPoint := entryPoint + 4 ;
  end foreach ;
#-------------------------------- Generate 'PRGM_SIZE' label
  outGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new ![@lstring new !"PRGM_SIZE" !here] !false] ;
#--- Output a listing ?
  if [option piccolo_options.ouputListingFile value] then
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . ["IPIC INSTRUCTION LIST" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    if [generationOptimizationMessages length] > 0 then
      ioListFileContents .= "Optimizations during generation:\n" ;
      ioListFileContents .= generationOptimizationMessages ;
      ioListFileContents .= "\n" ;
    end if ;
    ioListFileContents .= "Generated intermediate code:\n" ;
    @uint idx := 0 ;
    @uint currentAddress := 0 ;
    foreach outGeneratedInstructionList do
      [mInstruction setCurrentAddress !?currentAddress] ;
      ioListFileContents .= [[idx string] stringByLeftPadding !5 !' '] . ": " ;
      [mInstruction display !? ioListFileContents] ;
      ioListFileContents .= "\n" ;
      idx ++ ;
    end foreach ;
    ioListFileContents .= "\n" ;
    ioListFileContents .= "Minimum code size without optimization: " . [currentAddress string] . " bytes.\n\n" ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
