semantics pic18_intermediate_classes :
import "pic18_mnemonics.gSemantics" ;
import "intermediate_generic.gSemantics" ;

#----------------------------------------------------------------------------*

struct @pic18_intermediate_registerExpressionWithoutBSRIndication {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
}

#----------------------------------------------------------------------------*

struct @pic18_intermediate_registerExpression {
  @string mAssemblyString ;
  @uint mRegisterAddress ; # 12 bit full address
  @bool mNeedsBSR ;
}

#----------------------------------------------------------------------------*

method @registerExpression resolveAccess
  ??@uint inAccessBankSplitOffset
  ??@uint inCurrentBank
  ??@registerTable inRegisterTable
  !@pic18_intermediate_registerExpression outIPICregisterDescription
  !@bitSliceTable outBitSliceTable
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  @uint registerAddress := 0 ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable ?*] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
    registerAddress := mValue ;
  end foreach ;
  @bool needsBSRaccess := false ;
  if not found then
    needsBSRaccess := true ;
    [registerAddressList first ?registerAddress] ;
    @uint neededBank := registerAddress >> 8 ;
    if (neededBank != inCurrentBank) then
      @string errorMessage := "Accessing the '" . mRegisterName . "' needs the bank selection set to " . [neededBank string] ;
      if inCurrentBank == [@uint max] then
        errorMessage .= ", but current bank selection cannot be known" ;
      else
        errorMessage .= ", but current bank selection is set to " . [inCurrentBank string] ;
      end if ;
      error mRegisterName: errorMessage ;
    end if ;
  end if ;
#---
  outIPICregisterDescription := [@pic18_intermediate_registerExpression new
    !assemblyString
    !registerAddress + [mOffset uint]
    !needsBSRaccess
  ] ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression resolveAccessWithoutCheckingBank
  ??@registerTable inRegisterTable
  !@pic18_intermediate_registerExpressionWithoutBSRIndication outIPICregisterDescription
:
#--- Build assembly string
  @string assemblyString := [mRegisterName string] ;
  if [mOffset uint] > 0 then
    assemblyString .= " + " . [[mOffset uint] hexString] ;
  end if ;
#--- 
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?@uint registerAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
#---
  outIPICregisterDescription := [@pic18_intermediate_registerExpressionWithoutBSRIndication new
    !assemblyString
    !registerAddress + [mOffset uint]
  ] ;
end method ;

#----------------------------------------------------------------------------*

reader @registerExpression registerAddress
  ??@registerTable inRegisterTable
  -> @uint outRegisterAddress
:
  [inRegisterTable searchKey !mRegisterName ?@uintlist registerAddressList ?@uint size ?* ?*] ;
  [registerAddressList first ?outRegisterAddress] ;
#---
  if [mOffset uint] > size then
    error mOffset: "this offset is too large: should be lower than " . [size string] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

abstract class @pic18_intermediate_instruction {
}

abstract method @pic18_intermediate_instruction display ?!@string ioListFileContents ;

method @pic18_intermediate_instruction isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := false ;
end method ;

method @pic18_intermediate_instruction isNULL !@bool outIsNULL :
  outIsNULL := false ;
end method ;

reader @pic18_intermediate_instruction isSkippingInstruction -> @bool outIsSkipping :
  outIsSkipping := false ;
end reader ;

method @pic18_intermediate_instruction enterReferencedLabel
  ?!@stringset unused ioReferencedLabelSet
:
end method ;

override method @pic18_intermediate_MOV_LABEL_W enterReferencedLabel
  ?!@stringset ioReferencedLabelSet
:
  ioReferencedLabelSet += !mLabel->string ;
end method ;

#----------------------------------------------------------------------------*

list @pic18_intermediate_instructionList {
  @pic18_intermediate_instruction mInstruction feature setter ;
}

#----------------------------------------------------------------------------*

class @pic18_intermediate_NULL extends @pic18_intermediate_instruction {
}
override
method @pic18_intermediate_NULL display ?!@string ioListFileContents :
  ioListFileContents .= "-" ;
end method ;

override method @pic18_intermediate_NULL isNULL !@bool outIsNULL :
  outIsNULL := true ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_pseudo_ORG extends @pic18_intermediate_instruction {
  @uint mOrigin ;
}

override
method @pic18_intermediate_pseudo_ORG display ?!@string ioListFileContents :
  ioListFileContents .= "ORG " . [mOrigin hexString] ;
end method ;

override method @pic18_intermediate_pseudo_ORG isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := true ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_pseudo_LABEL extends @pic18_intermediate_instruction {
  @lstring mLabel ;
  @bool mIsDeletable ;
}

override method @pic18_intermediate_pseudo_LABEL display ?!@string ioListFileContents :
  ioListFileContents .= "LABEL " . mLabel ;
end method ;

override method @pic18_intermediate_pseudo_LABEL isLABELorORG !@bool outIsLABELorORG :
  outIsLABELorORG := true ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_word extends @pic18_intermediate_instruction {
  @uint mValue ;
}

override
method @pic18_intermediate_word display ?!@string ioListFileContents :
  ioListFileContents .= "WORD " . [mValue hexString] ;
end method ;

#----------------------------------------------------------------------------*

abstract class @pic18_intermediate_actualInstruction extends @pic18_intermediate_instruction {
  @location mInstructionLocation ;
}

#----------------------------------------------------------------------------*

class @pic18_intermediate_MOV_LABEL_W extends @pic18_intermediate_actualInstruction {
  @lstring mLabel ;
  @uint mOffset ;
  @uint mRightShift ;
}

override
method @pic18_intermediate_MOV_LABEL_W display ?!@string ioListFileContents :
  ioListFileContents .= "MOVLW ((" . mLabel . " + " . mOffset . ") >> " . mRightShift . ") & 0xFF"  ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_FDA extends @pic18_intermediate_actualInstruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @pic18_intermediate_registerExpression mRegisterDescription ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------------------------------*

method @pic18_intermediate_instruction_FDA getBaseCode !@uint outBaseCode :
  switch mInstruction_FDA_base_code
  when ADDWF : outBaseCode := 0x2400 ;
  when ADDWFC : outBaseCode := 0x2000 ;
  when ANDWF : outBaseCode := 0x1400 ;
  when COMF : outBaseCode := 0x1C00 ;
  when DECF : outBaseCode := 0x0400 ;
  when DECFSZ : outBaseCode := 0x2C00 ;
  when DCFSNZ : outBaseCode := 0x4C00 ;
  when INCF : outBaseCode := 0x2800 ;
  when INCFSZ : outBaseCode := 0x3C00 ;
  when INFSNZ : outBaseCode := 0x4800 ;
  when IORWF : outBaseCode := 0x1000 ;
  when MOVF : outBaseCode := 0x5000 ;
  when RLCF : outBaseCode := 0x3400 ;
  when RLNCF : outBaseCode := 0x4400 ;
  when RRCF : outBaseCode := 0x3000 ;
  when RRNCF : outBaseCode := 0x4000 ;
  when SUBFWB : outBaseCode := 0x5400 ;
  when SUBWF : outBaseCode := 0x5C00 ;
  when SUBWFB :  outBaseCode := 0x5800 ;
  when SWAPF : outBaseCode := 0x3800 ;
  when XORWF : outBaseCode := 0x1800 ;
  end switch ;
end method ;

override
method @pic18_intermediate_instruction_FDA display ?!@string ioListFileContents :
  ioListFileContents .= [mInstruction_FDA_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioListFileContents .= ", W" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_FA extends @pic18_intermediate_actualInstruction {
  @FA_instruction_base_code mFAinstruction ;
  @pic18_intermediate_registerExpression mRegisterDescription ;
}

override
method @pic18_intermediate_instruction_FA display ?!@string ioListFileContents :
  ioListFileContents .= [mFAinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
end method ;

method @pic18_intermediate_instruction_FA getBaseCode !@uint outBaseCode :
  switch mFAinstruction
  when CLRF   : outBaseCode := 0x6A00 ;
  when CPFSEQ : outBaseCode := 0x6200 ;
  when CPFSGT : outBaseCode := 0x6400 ;
  when CPFSLT : outBaseCode := 0x6000 ;
  when MOVWF  : outBaseCode := 0x6E00 ;
  when MULWF  : outBaseCode := 0x0200 ;
  when NEGF   : outBaseCode := 0x6C00 ;
  when SETF   : outBaseCode := 0x6800 ;
  when TSTFSZ : outBaseCode := 0x6600 ;
  end switch ;
end method ;

override
reader @pic18_intermediate_instruction_FA isSkippingInstruction -> @bool outIsSkipping :
  switch mFAinstruction
  when CLRF   : outIsSkipping := false ;
  when CPFSEQ : outIsSkipping := true ;
  when CPFSGT : outIsSkipping := true ;
  when CPFSLT : outIsSkipping := true ;
  when MOVWF  : outIsSkipping := false ;
  when MULWF  : outIsSkipping := false ;
  when NEGF   : outIsSkipping := false ;
  when SETF   : outIsSkipping := false ;
  when TSTFSZ : outIsSkipping := true ;
  end switch ;
end reader ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_MOVFF extends @pic18_intermediate_actualInstruction {
  @pic18_intermediate_registerExpressionWithoutBSRIndication mSourceRegisterDescription ;
  @pic18_intermediate_registerExpressionWithoutBSRIndication mDestinationRegisterDescription ;
}
  
override
method @pic18_intermediate_instruction_MOVFF display ?!@string ioListFileContents :
  ioListFileContents .= "MOVFF " . [mSourceRegisterDescription mAssemblyString]  . ", " . [mDestinationRegisterDescription mAssemblyString] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_FBA extends @pic18_intermediate_actualInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @pic18_intermediate_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
}

method @pic18_intermediate_instruction_FBA getBaseCode !@uint outBaseCode :
  switch mBitOrientedOp
  when BCF : outBaseCode := 0x9000 ;
  when BSF : outBaseCode := 0x8000 ;
  when BTG : outBaseCode := 0x7000 ;
  end switch ;
end method ;

override
method @pic18_intermediate_instruction_FBA display ?!@string ioListFileContents :
  ioListFileContents .= [mBitOrientedOp mnemonic] . " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
end method ;



#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_BitTestSkip extends @pic18_intermediate_actualInstruction {
  @bool mSkipIfSet ;
  @pic18_intermediate_registerExpression mRegisterDescription ;
  @uint mBitNumber ;
}

method @pic18_intermediate_instruction_BitTestSkip getBaseCode !@uint outBaseCode :
  if mSkipIfSet then
    outBaseCode := 0xA000 ; # BTFSS
  else
    outBaseCode := 0xB000 ; # BTFSC
  end if ;
end method ;

override
method @pic18_intermediate_instruction_BitTestSkip display ?!@string ioListFileContents :
  if mSkipIfSet then
    ioListFileContents .= "BTFSS" ;
  else
    ioListFileContents .= "BTFSC" ;
  end if ;
  ioListFileContents .= " " . [mRegisterDescription mAssemblyString] . ", " . [mBitNumber string] ;
end method ;

override
reader @pic18_intermediate_instruction_BitTestSkip isSkippingInstruction -> @bool outIsSkipping :
  outIsSkipping := true ;
end reader ;

#----------------------------------------------------------------------------*

enum @condionalBranchMode {
  native, ipicNative, ipicBRA, ipicGOTO
}{
}

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_conditionalBranch extends @pic18_intermediate_actualInstruction {
  @condionalBranchMode mBranchMode ;
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabel ;
}



override
method @pic18_intermediate_instruction_conditionalBranch display ?!@string ioListFileContents :
  ioListFileContents .= "JUMP " . [mConditionalBranch condition] . " " . mTargetLabel ;
end method ;

override method @pic18_intermediate_instruction_conditionalBranch enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_JUMP extends @pic18_intermediate_actualInstruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;
}

  override
  method @pic18_intermediate_JUMP display ?!@string ioListFileContents :
    switch mKind
      when ipicRelative : ioListFileContents .= "JUMP " . mTargetLabel ;
      when relative     : ioListFileContents .= "BRA " . mTargetLabel ;
      when absolute     : ioListFileContents .= "GOTO " . mTargetLabel ;
    end switch ;
  end method ;

  override method @pic18_intermediate_JUMP enterReferencedLabel ?!@stringset ioReferencedLabelSet :
    ioReferencedLabelSet += ![mTargetLabel string] ;
  end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_JSR extends @pic18_intermediate_actualInstruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;
}

override
method @pic18_intermediate_JSR display ?!@string ioListFileContents :
  switch mKind
    when ipicRelative : ioListFileContents .= "JSR " . mTargetLabel ;
    when relative     : ioListFileContents .= "RCALL " . mTargetLabel ;
    when absolute     : ioListFileContents .= "CALL " . mTargetLabel ;
  end switch ;
end method ;

override method @pic18_intermediate_JSR enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += ![mTargetLabel string] ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_withNoOperand extends @pic18_intermediate_actualInstruction {
  @pic18InstructionWithNoOperandKind mKind ;
}

override method @pic18_intermediate_instruction_withNoOperand display ?!@string ioListFileContents :
  ioListFileContents .= [mKind assemblyCode] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_RETURN extends @pic18_intermediate_actualInstruction {
}

override
method @pic18_intermediate_instruction_RETURN display ?!@string ioListFileContents :
  ioListFileContents .= "RETURN" ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_RETURN_NOT_OPTIMIZABLE extends @pic18_intermediate_actualInstruction {
}

override
method @pic18_intermediate_instruction_RETURN_NOT_OPTIMIZABLE display ?!@string ioListFileContents :
  ioListFileContents .= "RETURN NOT OPTIMIZABLE" ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_RETFIE extends @pic18_intermediate_actualInstruction {
  @bool mFastReturn ;
}

override
method @pic18_intermediate_instruction_RETFIE display ?!@string ioListFileContents :
  ioListFileContents .= "RETFIE" ;
  if mFastReturn then
    ioListFileContents .= " FAST" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_literalOperation extends @pic18_intermediate_actualInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @uint mLiteralValue ;
}

method @pic18_intermediate_instruction_literalOperation getBaseCode !@uint outBaseCode :
  switch mLiteralInstruction
  when ADDLW : outBaseCode := 0x0F00 ;
  when ANDLW : outBaseCode := 0x0B00 ;
  when IORLW : outBaseCode := 0x0900 ;
  when MOVLW : outBaseCode := 0x0E00 ;
  when MULLW : outBaseCode := 0x0D00 ;
  when SUBLW : outBaseCode := 0x0800 ;
  when XORLW : outBaseCode := 0x0A00 ;
  end switch ;
end method ;

override
method @pic18_intermediate_instruction_literalOperation display ?!@string ioListFileContents :
  ioListFileContents .= [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_RETLW extends @pic18_intermediate_actualInstruction {
  @uint mLiteralValue ;
}

override
method @pic18_intermediate_instruction_RETLW display ?!@string ioListFileContents :
  ioListFileContents .= "RETLW " . [mLiteralValue hexString] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_LFSR extends @pic18_intermediate_actualInstruction {
  @luint mFSRindex ;
  @uint mValue ;
}  

override
method @pic18_intermediate_instruction_LFSR display ?!@string ioListFileContents :
  ioListFileContents .= "LFSR " . [[mFSRindex uint] string] . ", " . [mValue hexString] ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_MOVLB extends @pic18_intermediate_actualInstruction {
  @luint mBankIndex ;
}

override
method @pic18_intermediate_instruction_MOVLB display ?!@string ioListFileContents :
  ioListFileContents .= "MOVLB " . [[mBankIndex uint] string] ;
end method ;


#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_TBLRD extends @pic18_intermediate_actualInstruction {
  @tableAccessOption mOption ;
}

override
method @pic18_intermediate_instruction_TBLRD display ?!@string ioListFileContents :
  ioListFileContents .= "TBLRD " . [mOption mnemonic] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_TBLWT extends @pic18_intermediate_actualInstruction {
  @tableAccessOption mOption ;
}

override
method @pic18_intermediate_instruction_TBLWT display ?!@string ioListFileContents :
  ioListFileContents .= "TBLWT " . [mOption mnemonic] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_MNOP extends @pic18_intermediate_actualInstruction {
  @luint mOccurrenceFactor ;
}

override
method @pic18_intermediate_instruction_MNOP display ?!@string ioListFileContents :
  ioListFileContents .= "MNOP " . [[mOccurrenceFactor uint] string] ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_computed_retlw extends @pic18_intermediate_actualInstruction {
  @uintlist mLiteralValues ;
  @bool mUsesRCALL ;
}

override
method @pic18_intermediate_instruction_computed_retlw display ?!@string ioListFileContents :
  ioListFileContents .= "COMPUTED RETLW " ;
  if mUsesRCALL then
    ioListFileContents .= " (uses RCALL)" ;
  else
    ioListFileContents .= " (uses CALL)" ;
  end if ;
  foreach mLiteralValues do
    ioListFileContents .= ", " . [mValue hexString] ;
  end foreach ;
end method ;

override method @pic18_intermediate_instruction_computed_retlw enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !"_computed_goto_2" ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_computed_bra extends @pic18_intermediate_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;
}

override
method @pic18_intermediate_instruction_computed_bra display ?!@string ioListFileContents :
  ioListFileContents .= "COMPUTED BRA " ;
  if mUsesRCALL then
    ioListFileContents .= " (uses RCALL)" ;
  else
    ioListFileContents .= " (uses CALL)" ;
  end if ;
  foreach mTargetLabels do
    ioListFileContents .= ", " . mValue ;
  end foreach ;
end method ;

override method @pic18_intermediate_instruction_computed_bra enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !"_computed_goto_2" ;
  foreach mTargetLabels do
    ioReferencedLabelSet += ![mValue string] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_computed_goto extends @pic18_intermediate_actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRCALL ;
}

override
method @pic18_intermediate_instruction_computed_goto display ?!@string ioListFileContents :
  ioListFileContents .= "COMPUTED GOTO " ;
  if mUsesRCALL then
    ioListFileContents .= " (uses RCALL)" ;
  else
    ioListFileContents .= " (uses CALL)" ;
  end if ;
  foreach mTargetLabels do
    ioListFileContents .= ", " . mValue ;
  end foreach ;
end method ;

override method @pic18_intermediate_instruction_computed_goto enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !"_computed_goto_4" ;
  foreach mTargetLabels do
    ioReferencedLabelSet += ![mValue string] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_instruction_computed_rcall extends @pic18_intermediate_actualInstruction {
  @lstringlist mTargetLabels ;
  @string mEndOfInstructionLabel ;
  @bool mUsesRCALL ;
}

override
method @pic18_intermediate_instruction_computed_rcall display ?!@string ioListFileContents :
  ioListFileContents .= "COMPUTED RCALL " ;
  if mUsesRCALL then
    ioListFileContents .= "(uses RCALL)" ;
  else
    ioListFileContents .= "(uses CALL)" ;
  end if ;
  foreach mTargetLabels do
    ioListFileContents .= ", " . mValue ;
  end foreach ;
end method ;

override method @pic18_intermediate_instruction_computed_rcall enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !"_computed_goto_4" ;
  foreach mTargetLabels do
    ioReferencedLabelSet += ![mValue string] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_jump_test_register extends @pic18_intermediate_actualInstruction {
  @pic18_intermediate_registerExpression mRegisterDescription ;
}

override
method @pic18_intermediate_jump_test_register display ?!@string ioListFileContents :
  ioListFileContents .= "TSTFSZ " . [mRegisterDescription mAssemblyString] ;
end method ;

override
reader @pic18_intermediate_jump_test_register isSkippingInstruction -> @bool outIsSkipping :
  outIsSkipping := true ;
end reader ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_incDecRegisterInCondition extends @pic18_intermediate_actualInstruction {
  @pic18_intermediate_registerExpression mRegisterDescription ;
  @lstring mTargetLabel ;
  @bool mIncrement ;
  @bool m_W_isDestination ;
  @bool mBranchIfZero ;
  @bool mUsesBra ;
}

override
method @pic18_intermediate_incDecRegisterInCondition display ?!@string ioListFileContents :
  ioListFileContents .= "JUMP " ;
  if mIncrement then
    ioListFileContents .= "INCF " ;
  else
    ioListFileContents .= "DECF " ;
  end if ;
  ioListFileContents .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination then
    ioListFileContents .= ", W " ;
  end if ;
  if mBranchIfZero then
    ioListFileContents .= "Z" ;
  else
    ioListFileContents .= "NZ" ;
  end if ;
  ioListFileContents .= " " . mTargetLabel ;
end method ;

override method @pic18_intermediate_incDecRegisterInCondition enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !mTargetLabel->string ;
end method ;

#----------------------------------------------------------------------------*

class @pic18_intermediate_registerComparisonCondition extends @pic18_intermediate_actualInstruction {
  @pic18_intermediate_registerExpression mRegisterDescription ;
  @lstring mTargetLabel ;
  @pic18RegisterComparison mComparison ;
  @bool mUsesBra ;
}

method @pic18_intermediate_registerComparisonCondition usesIntermediateBRA !@bool outUses :
  switch mComparison
    when notEqual       : outUses := false ; # CPFSEQ 
    when equal          : outUses := true  ; # CPFSEQ + BRA
    when greaterOrEqual : outUses := false ; # CPFLT
    when greater        : outUses := true  ; # CPFGT + BRA
    when lowerOrEqual   : outUses := false ; # CPFGT
    when lower          : outUses := true  ; # CPFLT + BRA
  end switch ;
end method ;


override
method @pic18_intermediate_registerComparisonCondition display ?!@string ioListFileContents :
  ioListFileContents .= "JUMP " ;
  ioListFileContents .= [mRegisterDescription mAssemblyString] ;
  ioListFileContents .= " " . [mComparison mnemonic] ;
  ioListFileContents .= " " . mTargetLabel ;
end method ;

override method @pic18_intermediate_registerComparisonCondition enterReferencedLabel ?!@stringset ioReferencedLabelSet :
  ioReferencedLabelSet += !mTargetLabel->string ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
