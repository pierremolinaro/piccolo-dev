semantics pic18_metamodel :
import "generic_metamodel.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    B O O T L O A D E R   R E S E R V E D   R A M    M A P                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @bootloaderReservedRAMmap {
  @luint mReservedSize ;
  insert insertKey error message "the reserved size for the '%K' bank is already declared" ;
  search searchKey error message "the reserved size for the '%K' bank is not declared" ;
}

#----------------------------------------------------*

abstract class @piccolo_instruction {
  @location mInstructionLocation ;
}

#----------------------------------------------------*

list @instructionList {
  @piccolo_instruction mInstruction ;
}

#----------------------------------------------------*

class @instruction_nobanksel extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_banksel extends @piccolo_instruction {
  @luint mBankIndex ;
}

#----------------------------------------------------*

class @instruction_savebank extends @piccolo_instruction {
  @registerExpression mRegister ;
  @instructionList mInstructionList ;
  @location mEndOfSaveBankInstruction ;
}

#----------------------------------------------------*

enum @instruction_FDA_base_code {
  ADDWF, ADDWFC, ANDWF, COMF, DECF, DECFSZ, DCFSNZ, INCF, INCFSZ, INFSNZ,
  IORWF, MOVF, RLCF, RLNCF, RRCF, RRNCF, SUBFWB, SUBWF, SUBWFB, SWAPF, XORWF
}{
}

reader @instruction_FDA_base_code mnemonic -> @string outResult :
  switch selfcopy
    when ADDWF : outResult := "ADDWF" ;
    when ADDWFC : outResult := "ADDWFC" ;
    when ANDWF : outResult := "ANDWF" ;
    when COMF : outResult := "COMF" ;
    when DECF : outResult := "DECF" ;
    when DECFSZ : outResult := "DECFSZ" ;
    when DCFSNZ : outResult := "DCFSNZ" ;
    when INCF : outResult := "INCF" ;
    when INCFSZ : outResult := "INCFSZ" ;
    when INFSNZ : outResult := "INFSNZ" ;
    when IORWF : outResult := "IORWF" ;
    when MOVF : outResult := "MOVF" ;
    when RLCF : outResult := "RLCF" ;
    when RLNCF : outResult := "RLNCF" ;
    when RRCF : outResult := "RRCF" ;
    when RRNCF : outResult := "RRNCF" ;
    when SUBFWB : outResult := "SUBFWB" ;
    when SUBWF : outResult := "SUBWF" ;
    when SUBWFB : outResult := "SUBWFB" ;
    when SWAPF : outResult := "SWAPF" ;
    when XORWF : outResult := "XORWF" ;
  end switch ;
end reader ;

#----------------------------------------------------*

routine getFDAinstructionBaseCode
  ??@instruction_FDA_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when ADDWF : outBaseCode := 0x2400 ;
  when ADDWFC : outBaseCode := 0x2000 ;
  when ANDWF : outBaseCode := 0x1400 ;
  when COMF : outBaseCode := 0x1C00 ;
  when DECF : outBaseCode := 0x0400 ;
  when DECFSZ : outBaseCode := 0x2C00 ;
  when DCFSNZ : outBaseCode := 0x4C00 ;
  when INCF : outBaseCode := 0x2800 ;
  when INCFSZ : outBaseCode := 0x3C00 ;
  when INFSNZ : outBaseCode := 0x4800 ;
  when IORWF : outBaseCode := 0x1000 ;
  when MOVF : outBaseCode := 0x5000 ;
  when RLCF : outBaseCode := 0x3400 ;
  when RLNCF : outBaseCode := 0x4400 ;
  when RRCF : outBaseCode := 0x3000 ;
  when RRNCF : outBaseCode := 0x4000 ;
  when SUBFWB : outBaseCode := 0x5400 ;
  when SUBWF : outBaseCode := 0x5C00 ;
  when SUBWFB :  outBaseCode := 0x5800 ;
  when SWAPF : outBaseCode := 0x3800 ;
  when XORWF : outBaseCode := 0x1800 ;
  end switch ;
end routine ;

#----------------------------------------------------*

class @instruction_FDA extends @piccolo_instruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------*

enum @FA_instruction_base_code {
  CLRF, CPFSEQ, CPFSGT, CPFSLT, MOVWF, MULWF, NEGF, SETF, TSTFSZ
}{
}

reader @FA_instruction_base_code mnemonic -> @string outResult :
  switch selfcopy
    when CLRF    : outResult := "CLRF" ;
    when CPFSEQ : outResult := "CPFSEQ" ;
    when CPFSGT : outResult := "CPFSGT" ;
    when CPFSLT : outResult := "CPFSLT" ;
    when MOVWF  : outResult := "MOVWF" ;
    when MULWF  : outResult := "MULWF" ;
    when NEGF   : outResult := "NEGF";
    when SETF   : outResult := "SETF"  ;
    when TSTFSZ : outResult := "TSTFSZ" ;
  end switch ;
end reader ;

#----------------------------------------------------*

class @instruction_FA extends @piccolo_instruction {
  @FA_instruction_base_code mFAinstruction ;
  @registerExpression mRegisterExpression ;
}

#----------------------------------------------------*

class @instruction_MOVFF extends @piccolo_instruction {
  @registerExpression mSourceRegisterName ;
  @registerExpression mDestinationRegisterName ;
}

#----------------------------------------------------*

enum @bit_oriented_op {
  BCF, BSF, BTG
}{
}

reader @bit_oriented_op mnemonic  -> @string outResult :
  switch selfcopy
    when BCF : outResult := "BCF" ;
    when BSF : outResult := "BSF" ;
    when BTG : outResult := "BTG" ;
  end switch ;
end reader ;

#----------------------------------------------------*

class @instruction_FBA extends @piccolo_instruction {
  @bit_oriented_op mBitOrientedOp ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
}

#----------------------------------------------------*

enum @conditional_branch {
  bz, bnz, bn, bnn, bc, bnc, bov, bnov
}{
}

reader @conditional_branch mnemonic  -> @string outResult :
  switch selfcopy
    when bz   : outResult := "BZ" ;
    when bnz  : outResult := "BNZ" ;
    when bn   : outResult := "BN" ;
    when bnn  : outResult := "BNN" ;
    when bc   : outResult := "BC" ;
    when bnc  : outResult := "BNC" ;
    when bov  : outResult := "BOV" ;
    when bnov : outResult := "BNOV" ;
  end switch ;
end reader ;

reader @conditional_branch condition -> @string outResult :
  switch selfcopy
    when bz   : outResult := "Z" ;
    when bnz  : outResult := "NZ" ;
    when bn   : outResult := "N" ;
    when bnn  : outResult := "NN" ;
    when bc   : outResult := "C" ;
    when bnc  : outResult := "NC" ;
    when bov  : outResult := "OV" ;
    when bnov : outResult := "NOV" ;
  end switch ;
end reader ;

#----------------------------------------------------*

routine getComplementaryBcc ??@conditional_branch inConditionalBranch !@conditional_branch outComplementary :
  switch inConditionalBranch
  when bz   : outComplementary := [@conditional_branch bnz] ;
  when bnz  : outComplementary := [@conditional_branch bz] ;
  when bn   : outComplementary := [@conditional_branch bnn] ;
  when bnn  : outComplementary := [@conditional_branch bn] ;
  when bc   : outComplementary := [@conditional_branch bnc] ;
  when bnc  : outComplementary := [@conditional_branch bc] ;
  when bov  : outComplementary := [@conditional_branch bnov] ;
  when bnov : outComplementary := [@conditional_branch bov] ;
  end switch ;
end routine ;

#----------------------------------------------------*

enum @jumpInstructionKind {
  ipicRelative, ipicAbsolute, relative, absolute
}{
}

#----------------------------------------------------*

class @instruction_JSR extends @piccolo_instruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;
}

#----------------------------------------------------*

class @instruction_JUMP extends @piccolo_instruction {
  @lstring mTargetLabel ;
  @jumpInstructionKind mKind ;
}

#----------------------------------------------------*

class @instruction_JUMPCC extends @piccolo_instruction {
  @lstring mTargetLabel ;
  @conditional_branch mConditionalBranch ;
  @bool mIsBcc ;
}

#----------------------------------------------------*

class @instruction_CLRWDT extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_DAW extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_NOP extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_POP extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_PUSH extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_RESET extends @piccolo_instruction {
}

#----------------------------------------------------*

class @instruction_SLEEP extends @piccolo_instruction {
}

#----------------------------------------------------*

enum @literal_instruction_opcode {
  ADDLW, ANDLW, IORLW, MOVLW, MULLW, SUBLW, XORLW
}{
}

reader @literal_instruction_opcode mnemonic -> @string outResult :
  switch selfcopy
    when ADDLW : outResult := "ADDLW" ;
    when ANDLW : outResult := "ANDLW" ;
    when IORLW : outResult := "IORLW" ;
    when MOVLW : outResult := "MOVLW" ;
    when MULLW : outResult := "MULLW" ;
    when SUBLW : outResult := "SUBLW" ;
    when XORLW : outResult := "XORLW" ;
  end switch ;
end reader ;

#----------------------------------------------------*

class @instruction_literalOperation extends @piccolo_instruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @immediatExpression mImmediatExpression ;
}

#----------------------------------------------------*

class @instruction_LFSR extends @piccolo_instruction {
  @luint mFSRindex ;
  @immediatExpression mImmediatExpression ;
}

#----------------------------------------------------*

enum @tableAccessOption {
  simpleAccess, postIncrement, postDecrement, preIncrement
}{
}
reader @tableAccessOption mnemonic  -> @string outResult :
  switch selfcopy
    when simpleAccess : outResult := "*" ;
    when postIncrement : outResult := "*+" ;
    when postDecrement : outResult := "*-" ;
    when preIncrement : outResult := "+*" ;
  end switch ;
end reader ;

#----------------------------------------------------*

class @instruction_TBLRD extends @piccolo_instruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @instruction_TBLWT extends @piccolo_instruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @instruction_MNOP extends @piccolo_instruction {
  @luint mOccurrenceFactor ;
}

#----------------------------------------------------*

class @instruction_FOREVER extends @piccolo_instruction {
  @instructionList mInstructionList ;
  @location mEndOfInstructionList ;
}

#----------------------------------------------------*

enum @if_semi_colon_op {
  CPFSEQ, CPFSGT, CPFSLT, TSTFSZ
}{
}

reader @if_semi_colon_op mnemonic -> @string outResult :
  switch selfcopy
    when CPFSEQ : outResult := "CPFSEQ" ;
    when CPFSGT : outResult := "CPFSGT" ;
    when CPFSLT : outResult := "CPFSLT" ;
    when TSTFSZ : outResult := "TSTFSZ" ;
  end switch ;
end reader ;

#----------------------------------------------------*

abstract class @instruction_IF_SEMI_COLON extends @piccolo_instruction {
  @piccolo_instruction mInstruction ;
}

#----------------------------------------------------*

class @instruction_IF_FA_SEMI_COLON extends @instruction_IF_SEMI_COLON {
  @if_semi_colon_op mOpCode ;
  @registerExpression mRegisterExpression ;
}

#----------------------------------------------------*

class @instruction_IF_BitTest extends @instruction_IF_SEMI_COLON {
  @bool mSkipIfSet ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
}

method @instruction_IF_BitTest getBaseCode !@uint outBaseCode :
  if mSkipIfSet then
    outBaseCode := 0xA000 ; # BTFSS
  else
    outBaseCode := 0xB000 ; # BTFSC
  end if ;
end method ; 

method @instruction_IF_BitTest getMnemonic !@string outMnemonic :
  if mSkipIfSet then
    outMnemonic := "BTFSS" ;
  else
    outMnemonic := "BTFSC" ;
  end if ;
end method ; 


#----------------------------------------------------*

class @instruction_IF_IncDec extends @instruction_IF_SEMI_COLON {
  @bool mIncrement ;
  @bool mSkipIfZero ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;
}

#----------------------------------------------------*

class @instruction_computed_retlw extends @piccolo_instruction {
  @immediatExpression mSizeExpression ;
  @immediatExpressionList mImmediateExpressionList ;
  @bool mUsesRelativeCall ;
}

#----------------------------------------------------*

class @instruction_computed_bra extends @piccolo_instruction {
  @immediatExpression mSizeExpression ;
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;
}

#----------------------------------------------------*

class @instruction_computed_goto extends @piccolo_instruction {
  @immediatExpression mSizeExpression ;
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;
}

#----------------------------------------------------*

class @instruction_computed_rcall extends @piccolo_instruction {
  @immediatExpression mSizeExpression ;
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;
}

#----------------------------------------------------*

abstract class @conditionExpression {
}

#----------------------------------------------------*

class @registerTestCondition extends @conditionExpression {
  @registerExpression mRegisterExpression ;
  @bool mBranchIfZero ;
}

#----------------------------------------------------*

enum @registerComparison {
  notEqual, equal, greaterOrEqual, greater, lowerOrEqual, lower
}{
}

reader @registerComparison mnemonic -> @string outResult :
  switch selfcopy
    when notEqual : outResult := "!=" ;
    when equal    : outResult := "==" ;
    when greaterOrEqual : outResult := ">=" ;
    when greater : outResult := ">"  ;
    when lowerOrEqual : outResult := "<="  ;
    when lower : outResult := "<" ;
  end switch ;
end reader ;

#----------------------------------------------------*

routine getRegisterComparisonComplementary
  ??@registerComparison inComparison
  !@registerComparison outComparison
:
  switch inComparison
    when notEqual : outComparison := [@registerComparison equal] ;
    when equal : outComparison := [@registerComparison notEqual] ;
    when greaterOrEqual : outComparison := [@registerComparison lower] ;
    when greater : outComparison := [@registerComparison lowerOrEqual] ;
    when lowerOrEqual : outComparison := [@registerComparison greater] ;
    when lower : outComparison := [@registerComparison greaterOrEqual] ;
  end switch ;
end routine ;

#----------------------------------------------------*

routine getRegisterComparisonInstructionCount
  ??@registerComparison inComparison
  !@uint outInstructionCount
:
  switch inComparison
    when notEqual       : outInstructionCount := 2 ;
    when equal          : outInstructionCount := 3 ;
    when greaterOrEqual : outInstructionCount := 2 ;
    when greater        : outInstructionCount := 3 ;
    when lowerOrEqual   : outInstructionCount := 2 ;
    when lower          : outInstructionCount := 3 ;
  end switch ;
end routine ;

#----------------------------------------------------*

class @registerComparisonCondition extends @conditionExpression {
  @registerExpression mRegisterExpression ;
  @registerComparison mComparison ;
}

#----------------------------------------------------*

class @incDecRegisterInCondition extends @conditionExpression {
  @registerExpression mRegisterExpression ;
  @bool mIncrement ;
  @bool m_W_isDestination ;
  @bool mBranchIfZero ;
}

#----------------------------------------------------*

class @bcc_in_structured_if_condition extends @conditionExpression {
  @conditional_branch mCondition ;
}

#----------------------------------------------------*

class @negateCondition extends @conditionExpression {
  @conditionExpression mCondition ;
}

#----------------------------------------------------*

class @andCondition extends @conditionExpression {
  @conditionExpression mLeftExpression ;
  @conditionExpression mRightExpression ;
}

#----------------------------------------------------*

class @bitTest_in_structured_if_condition extends @conditionExpression {
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
  @bool mBTFSSinstruction ;
}

#----------------------------------------------------*

class @instruction_structured_if extends @piccolo_instruction {
  @conditionExpression mIfCondition ;
  @instructionList mThenInstructionList ;
  @instructionList mElseInstructionList ;
  @location mEndOfElsePartLocation ;
}

#----------------------------------------------------*

list @partList {
  @conditionExpression mCondition ;
  @instructionList mInstructionList ;
  @location mEndOfPartLocation ;
}

#----------------------------------------------------*

class @instruction_do_while extends @piccolo_instruction {
  @instructionList mRepeatedInstructionList ;
  @location mEndOfRepeatedInstructionList ;
  @partList mWhilePartList ;
}

#----------------------------------------------------*

list @interruptDefinitionList {
  @lstring mInterruptName ;
  @bool mFastReturn ;
  @instructionList mInstructionList ;
  @location mEndOfInterruptLocation ;
}

#----------------------------------------------------*

list @routineDefinitionList {
  @lstring mRoutineName ;
  @luint mRequiredBank ;
  @luint mReturnedBank ;
  @bool mPreservesBank ;
  @bool mIsNoReturn ;
  @instructionList mInstructionList ;
  @location mEndOfRoutineLocation ;
}

#----------------------------------------------------*

list @routineDeclarationList {
  @lstring mRoutineName ;
  @luint mRequiredBank ;
  @luint mReturnedBank ;
  @bool mPreservesBank ;
  @bool mIsNoReturn ;
}

#----------------------------------------------------*

enum @programKind {
  regularProgram, bootloaderProgram, userProgram
}{
}

#----------------------------------------------------*

struct @piccoloModel {
  @lstring mProgramName ;
  @programKind mProgramKind ;
  @lstring mDeviceNameOrBootLoaderReference ;
  @configDefinitionList mConfigDefinitionList ;
  @bool mAcceptDefaultConfiguration ;
  @ramDefinitionList mRamDefinitionList ;
  @interruptDefinitionList mInterruptDefinitionList ;
  @constantDefinitionList mConstantDefinitionList ;
  @routineDefinitionList mRoutineDefinitionList ;
  @bool mNeedsComputedGoto2 ;
  @bool mNeedsComputedGoto4 ;
  @location mEndOfProgram ;
}

#----------------------------------------------------*

end semantics ;
