semantics pic18_metrics_analysis :
import "pic18_metamodel.gSemantics" ;
import "piccolo_options.gOption" ;
import "pic18_intermediate_next_intruction_is_reachable.gSemantics" ;
import "pic18_optimizations.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#               R O U T I N E    C A L L    G R A P H                        *
#                                                                            *
#----------------------------------------------------------------------------*

graph @routineCallGraph (@stringlist) {
  insert addNode error message "the '%K' routine is already declared at %L" ;
}

#---------------------------------------------------------------------------*

method @pic18PiccoloInstruction enterCallInGraph
  ?@lstring unused inRoutineName
  ?!@routineCallGraph unused ioRoutineCallGraph
:
end method ;

#---------------------------------------------------------------------------*

override method @instruction_JSR enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  [!?ioRoutineCallGraph addEdge !inRoutineName !mTargetLabel] ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_computed_rcall enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach mTargetLabels do
    [!?ioRoutineCallGraph addEdge !inRoutineName !mValue] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_computed_goto enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach mTargetLabels do
    [!?ioRoutineCallGraph addEdge !inRoutineName !mValue] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_FOREVER enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mInstructionList !inRoutineName !?ioRoutineCallGraph ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_structured_if enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mThenInstructionList !inRoutineName !?ioRoutineCallGraph ;
  exploreInstructionList !mElseInstructionList !inRoutineName !?ioRoutineCallGraph ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_do_while enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mRepeatedInstructionList !inRoutineName !?ioRoutineCallGraph ;
  foreach mWhilePartList do
    exploreInstructionList !mInstructionList !inRoutineName !?ioRoutineCallGraph ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_IF_SEMI_COLON enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  [mEmbeddedInstruction enterCallInGraph !inRoutineName !?ioRoutineCallGraph] ;
end method ;

#---------------------------------------------------------------------------*

local routine exploreInstructionList
  ?@instructionList inInstructionList
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach inInstructionList do
    [mInstruction enterCallInGraph !inRoutineName !?ioRoutineCallGraph] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    S T A C K    N E E D S                      *
#                                                                            *
#----------------------------------------------------------------------------*

map @symbolTableForStackLevels {
  @uint mStackLevel ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*

method @pic18_intermediate_instruction exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels unused inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset unused ioExploredLineSet
  ?!@string unused ioListFileContents
:
  [!?ioStackNeedsArray setMValueAtIndex !0 !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JSR exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset unused ioExploredLineSet
  ?!@string unused ioListFileContents
:
  [inSymbolTableForStackLevels searchKey !mTargetLabel ?@uint stackNeeds] ;
  [!?ioStackNeedsArray setMValueAtIndex !stackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_retlw exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels unused inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset unused ioExploredLineSet
  ?!@string unused ioListFileContents
:
  [!?ioStackNeedsArray setMValueAtIndex !1 !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JUMP exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    ?@uint instructionStackNeeds
    !?ioExploredLineSet
    !?ioListFileContents
  ;
  [!?ioStackNeedsArray setMValueAtIndex !instructionStackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_bra exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  @uint stackNeeds := 1 ;
  foreach mTargetLabels do
    computeStackLevelsFromLabel
      !inGeneratedInstructionList
      !mValue
      !inSymbolTable
      !inSymbolTableForStackLevels
      !?ioStackNeedsArray
      ?@uint instStackNeeds
      !?ioExploredLineSet
      !?ioListFileContents
    ;
    if stackNeeds > instStackNeeds then
      stackNeeds := instStackNeeds ;
    end if ;
  end foreach ;
  [!?ioStackNeedsArray setMValueAtIndex !stackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_incDecRegisterInCondition exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    ?@uint instructionStackNeeds
    !?ioExploredLineSet
    !?ioListFileContents
  ;
  [!?ioStackNeedsArray setMValueAtIndex !instructionStackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_jump_test_register exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
#--- No stack needs for this instruction
  [!?ioStackNeedsArray setMValueAtIndex !0 !inCurrentLine] ;
#--- This instruction can skip next one
  computeStackLevelsFromLine
    !inGeneratedInstructionList
    !inCurrentLine + 2
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    !?ioExploredLineSet
    !?ioListFileContents
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_registerComparisonCondition exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    ?@uint instructionStackNeeds
    !?ioExploredLineSet
    !?ioListFileContents
  ;
  [!?ioStackNeedsArray setMValueAtIndex !instructionStackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_BitTestSkip exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  computeStackLevelsFromLine
    !inGeneratedInstructionList
    !inCurrentLine + 2
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    !?ioExploredLineSet
    !?ioListFileContents
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_goto exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  @uint stackNeeds := 1 ;
  foreach mTargetLabels do
    computeStackLevelsFromLabel
      !inGeneratedInstructionList
      !mValue
      !inSymbolTable
      !inSymbolTableForStackLevels
      !?ioStackNeedsArray
      ?@uint instructionStackNeeds
      !?ioExploredLineSet
      !?ioListFileContents
    ;
    if stackNeeds < instructionStackNeeds then
      stackNeeds := instructionStackNeeds ;
    end if ;
  end foreach ;
  [!?ioStackNeedsArray setMValueAtIndex !stackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_rcall exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset unused ioExploredLineSet
  ?!@string unused ioListFileContents
:
  @uint maxStackNeeds := 1 ;
  foreach mTargetLabels do
    [inSymbolTableForStackLevels searchKey !mValue ?@uint stackNeeds] ;
    if maxStackNeeds < stackNeeds then
      maxStackNeeds := stackNeeds ;
    end if ;
  end foreach ;
  [!?ioStackNeedsArray setMValueAtIndex !maxStackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_conditionalBranch exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    ?@uint instructionStackNeeds
    !?ioExploredLineSet
    !?ioListFileContents
  ;
  [!?ioStackNeedsArray setMValueAtIndex !instructionStackNeeds !inCurrentLine] ;
end method ;

#----------------------------------------------------------------------------*

local routine computeStackLevelsFromLine
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@uint inStartLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ?!@uintlist ioStackNeedsArray
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  @uint currentLine := inStartLine ;
  @bool explores := true ;
  loop [inGeneratedInstructionList length] : while explores do
    const @string currentLineString := [currentLine string] ;
    if [ioExploredLineSet hasKey !currentLineString] then
      explores := false ;
    else
      ioExploredLineSet += ![currentLine string] ;
      const @pic18_intermediate_instruction instruction := [inGeneratedInstructionList mInstructionAtIndex !currentLine] ;
      [instruction exploreStackNeeds
        !inGeneratedInstructionList
        !inSymbolTable
        !inSymbolTableForStackLevels
        !currentLine
        !?ioStackNeedsArray
        !?ioExploredLineSet
        !?ioListFileContents
      ] ;
      explores := [instruction nextInstructionIsReachable] ;
      currentLine := currentLine + 1 ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeStackLevelsFromLabel
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@lstring inStartLabel
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ?!@uintlist ioStackNeedsArray
  !@uint outInstructionStackNeeds
  ?!@stringset ioExploredLineSet
  ?!@string ioListFileContents
:
  [inSymbolTable searchKey !inStartLabel ?@uint currentLine ?*] ;
  computeStackLevelsFromLine
    !inGeneratedInstructionList
    !currentLine
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeedsArray
    !?ioExploredLineSet
    !?ioListFileContents
  ;
  outInstructionStackNeeds := [ioStackNeedsArray mValueAtIndex !currentLine] ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@lstringlist inSortedRoutineNames
  ?!@string ioListFileContents
:
#-------------------------------- Build label map
  @symbolTableForOptimizations symbolTable [emptyMap] ;
  foreach inGeneratedInstructionList index lineIndex do
    [mInstruction defineLabel !?symbolTable !lineIndex] ;
  end foreach ;
#-------------------------------- Build Stack needs
  ioListFileContents .= "\nStack needs:\n" ;
  ioListFileContents .= ["Routine" stringByLeftPadding !70 !' '] . " Levels\n" ;
  @symbolTableForStackLevels stackLevelMap [emptyMap] ;
  foreach inSortedRoutineNames do
    if not [symbolTable hasKey !mValue->string] then
      ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " inlined\n" ;
    else
      @stringset exploredLineSet [emptySet] ;
      @uintlist stackRequirementArray [emptyList] ;
      foreach inGeneratedInstructionList do
        stackRequirementArray += ![@uint max] ;
      end foreach ;
      computeStackLevelsFromLabel
        !inGeneratedInstructionList
        !mValue
        !symbolTable
        !stackLevelMap
        !?stackRequirementArray
        ?*
        !?exploredLineSet
        !?ioListFileContents
      ;
      @uint maxStackNeeds := 0 ;
      foreach stackRequirementArray do
        if (mValue < [@uint max]) & (mValue > maxStackNeeds) then
          maxStackNeeds := mValue ;
        end if ;
      end foreach ;
      if [option piccolo_options.detailledComputing value] then
        ioListFileContents .= "------------------ " . mValue . "\n" ;
        ioListFileContents .= " Line:level:\n" ;
        foreach inGeneratedInstructionList index lineIndex do
          @uint stack := [stackRequirementArray mValueAtIndex !lineIndex] ;
          if stack < [@uint max] then
            ioListFileContents .= [[lineIndex string] stringByLeftPadding !5 !' '] . ":" ;
            ioListFileContents .= [[stack string] stringByLeftPadding !5 !' '] . ":" ;
            [mInstruction display !?ioListFileContents] ;
            ioListFileContents .= "\n" ;
          end if ;
        end foreach ;
        ioListFileContents .= mValue->string . " --> " . maxStackNeeds . "\n" ;
      else
        ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " " . maxStackNeeds . "\n" ;
      end if ;
      [!?stackLevelMap insertKey !mValue !maxStackNeeds + 1] ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    R O U T I N E    L O O P                    *
#                                                                            *
#----------------------------------------------------------------------------*

map @routineHasLoopMap {
  @bool mHasLoop ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*

map @routineMinMaxMap {
  @uint mMin ;
  @uint mMax ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*

method @pic18PiccoloInstruction searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := false ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_do_while searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := true ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_FOREVER searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := true ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_JUMP searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  [inRoutineHasLoopMap searchKey !mTargetLabel ?outHasLoopInstruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_JSR searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  [inRoutineHasLoopMap searchKey !mTargetLabel ?outHasLoopInstruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_structured_if searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  searchForLoopInInstructionList !mThenInstructionList !inRoutineHasLoopMap ?outHasLoopInstruction ;
  if not outHasLoopInstruction then
    searchForLoopInInstructionList !mElseInstructionList !inRoutineHasLoopMap ?outHasLoopInstruction ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_bra searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := false ;
  foreach mTargetLabels while not outHasLoopInstruction do
    [inRoutineHasLoopMap searchKey !mValue ?outHasLoopInstruction] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_goto searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := false ;
  foreach mTargetLabels while not outHasLoopInstruction do
    [inRoutineHasLoopMap searchKey !mValue ?outHasLoopInstruction] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_rcall searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := false ;
  foreach mTargetLabels while not outHasLoopInstruction do
    [inRoutineHasLoopMap searchKey !mValue ?outHasLoopInstruction] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

local routine searchForLoopInInstructionList
  ?@instructionList inInstructionList
  ??@routineHasLoopMap inRoutineHasLoopMap
  !@bool outHasLoopInstruction
:
  outHasLoopInstruction := false ;
  foreach inInstructionList while not outHasLoopInstruction do
    [mInstruction searchForLoopInstruction !inRoutineHasLoopMap ?outHasLoopInstruction] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    R O U T I N E    D U R A T I O N S          *
#                                                                            *
#----------------------------------------------------------------------------*

method @pic18_intermediate_instruction duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint unused ioCurrentMin
  ?!@uint unused ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_actualInstruction duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_MOVFF duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JSR duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  [inRoutineMinMaxMap searchKey !mTargetLabel ?@uint min ?@uint max] ;
  ioCurrentMin := ioCurrentMin + 2 + min ;
  ioCurrentMax := ioCurrentMax + 2 + max ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_LFSR duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_MNOP duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + mOccurrenceFactor->uint ;
  ioCurrentMax := ioCurrentMax + mOccurrenceFactor->uint ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETURN duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETURN_NOT_OPTIMIZABLE duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETFIE duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETLW duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_retlw duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- Duration of calling _computed_goto_2:
# (r)call _computed_goto_2; ADDWF WREG, W; ADDWFC TOSL; MOVLW 0;ADDWFC TOSH; ADDWFC TOSU;RETURN --> 9
#  retlw xx --> 2
  ioCurrentMin := ioCurrentMin + 11 ;
  ioCurrentMax := ioCurrentMax + 11 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JUMP duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_conditionalBranch duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + 1
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + 1
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_jump_test_register duration
  ??@uint inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- When Skip next instruction
  @pic18_intermediate_instruction nextInstruction := [inGeneratedInstructionList mInstructionAtIndex !inCurrentLine + 1] ;
  const @uint durationWhenSkip := 1 + [nextInstruction instructionLength] / 2 ;
  computeMinMaxFromLine
    !inCurrentLine + 2
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + durationWhenSkip
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + durationWhenSkip
    !?ioExecutionMax
  ;
#--- When execute next instruction
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_BitTestSkip duration
  ??@uint inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- When skip next instruction
  @pic18_intermediate_instruction nextInstruction := [inGeneratedInstructionList mInstructionAtIndex !inCurrentLine + 1] ;
  const @uint durationWhenSkip := 1 + [nextInstruction instructionLength] / 2 ;
  computeMinMaxFromLine
    !inCurrentLine + 2
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + durationWhenSkip
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + durationWhenSkip
    !?ioExecutionMax
  ;
#--- When execute next instruction
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_incDecRegisterInCondition duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- When execute next instruction (a branch or a goto)
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + 3
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + 3
    !?ioExecutionMax
  ;
#--- When skip next instruction
  const @uint durationWhenSkip := 1 + if mUsesBra then 1 else 2 end ;
  ioCurrentMin := ioCurrentMin + durationWhenSkip ;
  ioCurrentMax := ioCurrentMax + durationWhenSkip ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_bra duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- Duration of calling _computed_goto_2:
# (r)call _computed_goto_2; ADDWF WREG, W; ADDWFC TOSL; MOVLW 0;ADDWFC TOSH; ADDWFC TOSU;RETURN --> 9
#  bra label --> 2
  const @uint duration := 11 ; 
  foreach mTargetLabels do
    computeMinMaxFromLabel
      !mValue
      !inSymbolTable
      !inRoutineMinMaxMap
      !inGeneratedInstructionList
      !?ioMinArray
      !ioCurrentMin + duration
      !?ioExecutionMin
      !?ioMaxArray
      !ioCurrentMax + duration
      !?ioExecutionMax
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_goto duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- Duration of calling _computed_goto_4:
# (r)call _computed_goto_4; ADDWF WREG, W; ADDWF WREG, W; ADDWFC TOSL; MOVLW 0;ADDWFC TOSH; ADDWFC TOSU;RETURN --> 10
#  bra label --> 2
  const @uint duration := 12 ; 
  foreach mTargetLabels do
    computeMinMaxFromLabel
      !mValue
      !inSymbolTable
      !inRoutineMinMaxMap
      !inGeneratedInstructionList
      !?ioMinArray
      !ioCurrentMin + duration
      !?ioExecutionMin
      !?ioMaxArray
      !ioCurrentMax + duration
      !?ioExecutionMax
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_rcall duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- Duration of calling _computed_goto_4:
# (r)call _computed_goto_4; ADDWF WREG, W; ADDWF WREG, W; ADDWFC TOSL; MOVLW 0;ADDWFC TOSH; ADDWFC TOSU;RETURN --> 10
#  rcall label; BRA next --> 4
# but last test has no BRA next
  foreach mTargetLabels index idx do
  const @uint duration := 12 + if idx < ([mTargetLabels length] - 1) then 2 else 0 end ; 
    computeMinMaxFromLabel
      !mValue
      !inSymbolTable
      !inRoutineMinMaxMap
      !inGeneratedInstructionList
      !?ioMinArray
      !ioCurrentMin + duration
      !?ioExecutionMin
      !?ioMaxArray
      !ioCurrentMax + duration
      !?ioExecutionMax
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_registerComparisonCondition duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
#--- When execute next instruction (a branch or a goto)
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + 3
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + 3
    !?ioExecutionMax
  ;
#--- When skip next instruction
  const @uint durationWhenSkip := 1 + if mUsesBra then 1 else 2 end ;
  ioCurrentMin := ioCurrentMin + durationWhenSkip ;
  ioCurrentMax := ioCurrentMax + durationWhenSkip ;
end method ;

#----------------------------------------------------------------------------*

local routine computeMinMaxFromLine
  ??@uint inStartLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ??@uint inCurrentMin
  ?!@uint ioExecutionMin
  ?!@uintlist ioMaxArray
  ??@uint inCurrentMax
  ?!@uint ioExecutionMax
:
  @uint currentLine := inStartLine ;
  @bool explores := true ;
  @uint min := inCurrentMin ;
  @uint max := inCurrentMax ;
  loop [inGeneratedInstructionList length] : while explores do
    if (min < [ioMinArray mValueAtIndex !currentLine]) | (max > [ioMaxArray mValueAtIndex !currentLine]) then
      const @pic18_intermediate_instruction instruction := [inGeneratedInstructionList mInstructionAtIndex !currentLine] ;
      [instruction duration !currentLine !inSymbolTable !inRoutineMinMaxMap !inGeneratedInstructionList !?ioMinArray !?ioMaxArray !?min !?max !?ioExecutionMin !?ioExecutionMax] ;
      if min < [ioMinArray mValueAtIndex !currentLine] then
        [!?ioMinArray setMValueAtIndex !min !currentLine] ;
      end if ;
      if max > [ioMaxArray mValueAtIndex !currentLine] then
        [!?ioMaxArray setMValueAtIndex !max !currentLine] ;
      end if ;
      explores := [instruction nextInstructionIsReachable] ;
      currentLine := currentLine + 1 ;
    else
      explores := false ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeMinMaxFromLabel
  ??@lstring inLabel
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ??@uint inCurrentMin
  ?!@uint ioExecutionMin
  ?!@uintlist ioMaxArray
  ??@uint inCurrentMax
  ?!@uint ioExecutionMax
:
  [inSymbolTable searchKey !inLabel ?@uint line ?*] ;
  computeMinMaxFromLine
    !line
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !inCurrentMin
    !?ioExecutionMin
    !?ioMaxArray
    !inCurrentMax
    !?ioExecutionMax
  ;  
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    M E T R I C S                               *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_compute_metrics
  ??@piccoloModel inPiccoloModel
  ??@routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ??@pic18_intermediate_instructionList inGeneratedInstructionList 
  ?!@string ioListFileContents
  ??@string inSourceFileName
:
  @lstringlist sortedRoutineNameList ;
  @stringset routinesInvolvedInRecursion ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*           S T A C K    R E Q U I R E M E N T S                              *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  if [option piccolo_options.doNotComputeStackRequirements value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeStackRequirements string] . "': stack requirements are not computed.\n" ;
    routinesInvolvedInRecursion := [@stringset emptySet] ;
    sortedRoutineNameList := [@lstringlist emptyList] ;
  else
    @routineCallGraph routineCallGraph [emptyGraph] ;
  #--- Enter routine names
    foreach inPiccoloModel->mRoutineDefinitionList do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter applicative routine names (for bootloader)
    foreach inUserRoutineDeclarationListForBootloaderImplementation do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter bootloader routine names (for applicative)
    foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter interrupts routine name, and populate graph
    foreach inPiccoloModel->mInterruptDefinitionList do
      const @lstring interruptRoutineName [new !"_" . mInterruptName->string . "_interrupt_routine" !mInterruptName->location] ;
      [!?routineCallGraph addNode !interruptRoutineName !interruptRoutineName->string] ;
      exploreInstructionList !mInstructionList !interruptRoutineName !?routineCallGraph ;
    end foreach ;
  #--- Populate graph from routines
    foreach inPiccoloModel->mRoutineDefinitionList do
      exploreInstructionList !mInstructionList !mRoutineName !?routineCallGraph ;
    end foreach ;
  #--- Sort routine call graph
    [routineCallGraph topologicalSort
      ?*
      ?sortedRoutineNameList
      ?*
      ?@lstringlist unsortedNodeKeyList
    ] ;
    routinesInvolvedInRecursion := [@stringset setWithLStringList !unsortedNodeKeyList] ;
    if [unsortedNodeKeyList length] > 0 then
      @string s := "stack needs cannot be computed, the following routines are involved in a recursion:" ;
      foreach unsortedNodeKeyList do
        s .= "\n-  " . mValue ;
      end foreach ;
      warning inPiccoloModel->mEndOfProgram : s ;
      ioListFileContents .= s ;
    else
      ioListFileContents .= "No recursive routines.\n" ;
    end if ;
  #--- Output a graphviz file
    if [option piccolo_options.generateGraphvizFiles value] then
      const @string graphvizText := [routineCallGraph graphviz] ;
      const @string graphvizFile := [inSourceFileName stringByDeletingPathExtension] . ".dot" ;
      [graphvizText writeToFileWhenDifferentContents !graphvizFile ?*] ;
    end if ;
  #--- Compute stack needs
    if [unsortedNodeKeyList length] == 0 then
      computeStackNeeds 
        !inGeneratedInstructionList
        !sortedRoutineNameList
        !?ioListFileContents
      ;
    end if ;
  end if ;
  ioListFileContents .= "\n" ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*           R O U T I N E    D U R A T I O N S                                *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  if [option piccolo_options.doNotComputeRoutineDuration value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeRoutineDuration string] . "': routine durations are not computed.\n" ;
  elsif [option piccolo_options.doNotComputeStackRequirements value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeStackRequirements string] . "': cannot compute interrupt routine durations.\n" ;
  else
    @routineHasLoopMap routineHasLoopMap [emptyMap] ;
  #--- Enter applicative routine names (for bootloader)
    foreach inUserRoutineDeclarationListForBootloaderImplementation do
      [!?routineHasLoopMap insertKey !mRoutineName !mIsNoReturn] ; # Routine loops if no return
    end foreach ;
  #--- Enter bootloader routine names (for applicative)
    foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
      [!?routineHasLoopMap insertKey !mRoutineName !mIsNoReturn] ; # Routine loops if no return
    end foreach ;
  #--- Foreach non recursive routine, establish if it contains loops
    foreach sortedRoutineNameList do
      @bool found := false ;
      foreach inPiccoloModel->mRoutineDefinitionList while not found do
        found := mValue->string == mRoutineName->string ;
        if found & not [routinesInvolvedInRecursion hasKey !mRoutineName->string] then
          searchForLoopInInstructionList !mInstructionList !routineHasLoopMap ?@bool hasLoopInstruction ;
          [!?routineHasLoopMap insertKey !mRoutineName !hasLoopInstruction] ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Foreach interrupt routine, establish if it contains loops
    foreach inPiccoloModel->mInterruptDefinitionList do
      const @lstring routineName [new !"_" . mInterruptName->string . "_interrupt_routine" !mInterruptName->location] ;
      if [routinesInvolvedInRecursion hasKey !routineName->string] then
        ioListFileContents .= "Cannot compute '" . mInterruptName . "' interrupt routine duration : it is involved in recursive routine calls.\n" ;
      else
        searchForLoopInInstructionList !mInstructionList !routineHasLoopMap ?@bool hasLoopInstruction ;
        [!?routineHasLoopMap insertKey !routineName !hasLoopInstruction] ;
        if hasLoopInstruction then
          ioListFileContents .= "Cannot compute '" . mInterruptName . "' interrupt routine duration : it contains 'do ... while' instruction(s).\n" ;
          warning mInterruptName : "cannot compute '" . mInterruptName . "' interrupt routine duration : it contains 'do ... while' instruction's).\n" ;
        end if ;
      end if ;
    end foreach ;
  #-------------------------------- Build label map
    @symbolTableForOptimizations symbolTable [emptyMap] ;
    foreach inGeneratedInstructionList index lineIndex do
      [mInstruction defineLabel !?symbolTable !lineIndex] ;
    end foreach ;
    ioListFileContents .= "\nDurations are expressed in instruction clock cycles.\n\n" ;
    ioListFileContents .= ["Routine" stringByLeftPadding !70 !' '] . " Min-Max\n" ;
    @routineMinMaxMap routineMinMaxMap [emptyMap] ;
    foreach sortedRoutineNameList do
      if [symbolTable hasKey !mValue->string] & [routineHasLoopMap hasKey !mValue->string] then
        [routineHasLoopMap searchKey !mValue ?@bool hasLoopInstruction] ;
        if hasLoopInstruction then
          ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " loops\n" ;
        else
          @uintlist minArray [emptyList] ;
          @uintlist maxArray [emptyList] ;
          foreach inGeneratedInstructionList do
            minArray += ![@uint max] ;
            maxArray += !0 ;
          end foreach ;
          @uint executionMin := [@uint max] ;
          @uint executionMax := 0 ;
          if [option piccolo_options.detailledComputing value] then
            ioListFileContents .= [" " . mValue stringByLeftPadding !76 !'-'] . "\n" ;
            ioListFileContents .= " Line:  min-  max:\n" ;
          end if ;
          computeMinMaxFromLabel
            !mValue
            !symbolTable
            !routineMinMaxMap
            !inGeneratedInstructionList
            !?minArray !0 !?executionMin
            !?maxArray !0 !?executionMax
          ;
          [!?routineMinMaxMap insertKey !mValue !executionMin !executionMax] ;
          foreach inGeneratedInstructionList index lineIndex do
            const @uint imin := [minArray mValueAtIndex !lineIndex] ;
            const @uint imax := [maxArray mValueAtIndex !lineIndex] ;
            if (imin <= imax) & [option piccolo_options.detailledComputing value] then
              ioListFileContents .= [[lineIndex string] stringByLeftPadding !5 !' '] . ":" ;
              ioListFileContents .= [[imin string] stringByLeftPadding !5 !' '] . "-" ;
              ioListFileContents .= [[imax string] stringByLeftPadding !5 !' '] . ":" ;
              [mInstruction display !?ioListFileContents] ;
              ioListFileContents .= "\n" ;
            end if ;
          end foreach ;
          if [option piccolo_options.detailledComputing value] then
            ioListFileContents .= mValue->string . " --> " . executionMin . " ... " . executionMax . "\n" ;
          else
            ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " " . executionMin . "-" . executionMax . "\n" ;
          end if ;        
        end if ;
      else
        ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " recursive\n" ;
      end if ;
    end foreach ;
  end if ;
  ioListFileContents .= "\n" ;
end routine ;

#----------------------------------------------------*

end semantics ;
