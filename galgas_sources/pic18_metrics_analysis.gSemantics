semantics pic18_metrics_analysis :
import "pic18_metamodel.gSemantics" ;
import "piccolo_options.gOption" ;
import "pic18_intermediate_next_intruction_is_reachable.gSemantics" ;
import "pic18_optimizations.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#               R O U T I N E    C A L L    G R A P H                        *
#                                                                            *
#----------------------------------------------------------------------------*

graph @routineCallGraph (@stringlist) {
  insert addNode error message "the '%K' routine is already declared at %L" ;
}

#---------------------------------------------------------------------------*

method @piccolo_instruction enterCallInGraph
  ?@lstring unused inRoutineName
  ?!@routineCallGraph unused ioRoutineCallGraph
:
end method ;

#---------------------------------------------------------------------------*

override method @instruction_JSR enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  [!?ioRoutineCallGraph addArc !inRoutineName !mTargetLabel] ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_computed_rcall enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach mTargetLabels do
    [!?ioRoutineCallGraph addArc !inRoutineName !mValue] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_computed_goto enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach mTargetLabels do
    [!?ioRoutineCallGraph addArc !inRoutineName !mValue] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_FOREVER enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mInstructionList !inRoutineName !?ioRoutineCallGraph ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_structured_if enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mThenInstructionList !inRoutineName !?ioRoutineCallGraph ;
  exploreInstructionList !mElseInstructionList !inRoutineName !?ioRoutineCallGraph ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_do_while enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  exploreInstructionList !mRepeatedInstructionList !inRoutineName !?ioRoutineCallGraph ;
  foreach mWhilePartList do
    exploreInstructionList !mInstructionList !inRoutineName !?ioRoutineCallGraph ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_IF_SEMI_COLON enterCallInGraph
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  [mInstruction enterCallInGraph !inRoutineName !?ioRoutineCallGraph] ;
end method ;

#---------------------------------------------------------------------------*

local routine exploreInstructionList
  ?@instructionList inInstructionList
  ?@lstring inRoutineName
  ?!@routineCallGraph ioRoutineCallGraph
:
  foreach inInstructionList do
    [mInstruction enterCallInGraph !inRoutineName !?ioRoutineCallGraph] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    S T A C K    N E E D S                      *
#                                                                            *
#----------------------------------------------------------------------------*

map @symbolTableForStackLevels {
  @uint mStackLevel ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*

method @pic18_intermediate_instruction exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels unused inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint unused ioStackNeeds
  ?!@stringset unused ioExploredLineSet
:
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JSR exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset unused ioExploredLineSet
:
  [inSymbolTableForStackLevels searchKey !mTargetLabel ?@uint routineNeeds] ;
  if ioStackNeeds < routineNeeds then
    ioStackNeeds := routineNeeds ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_retlw exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels unused inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset unused ioExploredLineSet
:
  if ioStackNeeds == 0 then
    ioStackNeeds := 1 ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JUMP exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_bra exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  if ioStackNeeds == 0 then
    ioStackNeeds := 1 ;
  end if ;
  foreach mTargetLabels do
    computeStackLevelsFromLabel
      !inGeneratedInstructionList
      !mValue
      !inSymbolTable
      !inSymbolTableForStackLevels
      !?ioStackNeeds
      !?ioExploredLineSet
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_incDecRegisterInCondition exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_jump_test_register exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_registerComparisonCondition exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_BitTestSkip exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLine
    !inGeneratedInstructionList
    !inCurrentLine + 2
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_goto exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  if ioStackNeeds == 0 then
    ioStackNeeds := 1 ;
  end if ;
  foreach mTargetLabels do
    computeStackLevelsFromLabel
      !inGeneratedInstructionList
      !mValue
      !inSymbolTable
      !inSymbolTableForStackLevels
      !?ioStackNeeds
      !?ioExploredLineSet
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_rcall exploreStackNeeds
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset unused ioExploredLineSet
:
  if ioStackNeeds == 0 then
    ioStackNeeds := 1 ;
  end if ;
  foreach mTargetLabels do
    [inSymbolTableForStackLevels searchKey !mValue ?@uint stackNeeds] ;
    if ioStackNeeds < stackNeeds then
      ioStackNeeds := stackNeeds ;
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_conditionalBranch exploreStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ??@uint unused inCurrentLine
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  computeStackLevelsFromLabel
    !inGeneratedInstructionList
    !mTargetLabel
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end method ;

#----------------------------------------------------------------------------*

local routine computeStackLevelsFromLine
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@uint inStartLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  @uint currentLine := inStartLine ;
  @bool explores := true ;
  loop [inGeneratedInstructionList length] : while explores do
    const @string currentLineString := [currentLine string] ;
    if [ioExploredLineSet hasKey !currentLineString] then
      explores := false ;
    else
      ioExploredLineSet += ![currentLine string] ;
      const @pic18_intermediate_instruction instruction := [inGeneratedInstructionList mInstructionAtIndex !currentLine] ;
#      @string s := currentLineString . ":" ;
#      [instruction displayIPICinstruction !?s] ;
#      message s  . "\n" ;
      [instruction exploreStackNeeds
        !inGeneratedInstructionList
        !inSymbolTable
        !inSymbolTableForStackLevels
        !currentLine
        !?ioStackNeeds
        !?ioExploredLineSet
      ] ;
      explores := [instruction nextInstructionIsReachable] ;
      currentLine := currentLine + 1 ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeStackLevelsFromLabel
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@lstring inStartLabel
  ??@symbolTableForOptimizations inSymbolTable
  ??@symbolTableForStackLevels inSymbolTableForStackLevels
  ?!@uint ioStackNeeds
  ?!@stringset ioExploredLineSet
:
  [inSymbolTable searchKey !inStartLabel ?@uint currentLine ?*] ;
  computeStackLevelsFromLine
    !inGeneratedInstructionList
    !currentLine
    !inSymbolTable
    !inSymbolTableForStackLevels
    !?ioStackNeeds
    !?ioExploredLineSet
  ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeStackNeeds
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ??@lstringlist inSortedRoutineNames
  ?!@string ioListFileContents
:
#-------------------------------- Build label map
  @symbolTableForOptimizations symbolTable [emptyMap] ;
  foreach inGeneratedInstructionList index lineIndex do
    [mInstruction defineLabel !?symbolTable !lineIndex] ;
  end foreach ;
#-------------------------------- Build Stack needs
  ioListFileContents .= "\nStack needs:\n" ;
  ioListFileContents .= ["Routine" stringByLeftPadding !70 !' '] . " Levels\n" ;
  @symbolTableForStackLevels stackLevelMap [emptyMap] ;
  foreach inSortedRoutineNames do
    if not [symbolTable hasKey !mValue->string] then
      ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " inlined\n" ;
    else
      @stringset exploredLineSet [emptySet] ;
      @uint stackNeeds := 0 ;
      # message "------------ " . mValue . "\n" ;
      computeStackLevelsFromLabel
        !inGeneratedInstructionList
        !mValue
        !symbolTable
        !stackLevelMap
        !?stackNeeds
        !?exploredLineSet
       ;
      ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " " . stackNeeds . "\n" ;
      [!?stackLevelMap insertKey !mValue !stackNeeds + 1] ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    R O U T I N E    L O O P                    *
#                                                                            *
#----------------------------------------------------------------------------*

map @routineHasLoopMap {
  @bool mHasLoop ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*

map @routineMinMaxMap {
  @uint mMin ;
  @uint mMax ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*

method @piccolo_instruction searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  ?!@bool unused ioHasLoopInstruction
:
end method ;

#---------------------------------------------------------------------------*

override method @instruction_do_while searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  ?!@bool ioHasLoopInstruction
:
  ioHasLoopInstruction := true ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_FOREVER searchForLoopInstruction
  ??@routineHasLoopMap unused inRoutineHasLoopMap
  ?!@bool ioHasLoopInstruction
:
  ioHasLoopInstruction := true ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_JSR searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  ?!@bool ioHasLoopInstruction
:
  [inRoutineHasLoopMap searchKey !mTargetLabel ?@bool hasLoop] ;
  if hasLoop then
    ioHasLoopInstruction := true ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @instruction_structured_if searchForLoopInstruction
  ??@routineHasLoopMap inRoutineHasLoopMap
  ?!@bool ioHasLoopInstruction
:
  searchForLoopInInstructionList !mThenInstructionList !inRoutineHasLoopMap !?ioHasLoopInstruction ;
  searchForLoopInInstructionList !mElseInstructionList !inRoutineHasLoopMap !?ioHasLoopInstruction ;
end method ;

#----------------------------------------------------------------------------*

local routine searchForLoopInInstructionList
  ?@instructionList inInstructionList
  ??@routineHasLoopMap inRoutineHasLoopMap
  ?!@bool ioHasLoopInstruction
:
  foreach inInstructionList do
    [mInstruction searchForLoopInstruction !inRoutineHasLoopMap !?ioHasLoopInstruction] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    R O U T I N E    D U R A T I O N S          *
#                                                                            *
#----------------------------------------------------------------------------*

method @pic18_intermediate_instruction duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint unused ioCurrentMin
  ?!@uint unused ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_actualInstruction duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_MOVFF duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JSR duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  [inRoutineMinMaxMap searchKey !mTargetLabel ?@uint min ?@uint max] ;
  ioCurrentMin := ioCurrentMin + 2 + min ;
  ioCurrentMax := ioCurrentMax + 2 + max ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_LFSR duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_MNOP duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + mOccurrenceFactor->uint ;
  ioCurrentMax := ioCurrentMax + mOccurrenceFactor->uint ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETURN duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETURN_NOT_OPTIMIZABLE duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETFIE duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_RETLW duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_retlw duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
  if ioExecutionMin > ioCurrentMin then
    ioExecutionMin := ioCurrentMin ;
  end if ;
  if ioExecutionMax < ioCurrentMax then
    ioExecutionMax := ioCurrentMax ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_JUMP duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_conditionalBranch duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin + 1
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax + 1
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_jump_test_register duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 1 ;
  ioCurrentMax := ioCurrentMax + 1 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin - 1
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax - 1
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_BitTestSkip duration
  ??@uint inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
#---
  computeMinMaxFromLine
    !inCurrentLine + 2
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin - 1
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax - 1
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_incDecRegisterInCondition duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ?!@uintlist ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint ioExecutionMin
  ?!@uint ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
#---
  computeMinMaxFromLabel
    !mTargetLabel
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !ioCurrentMin - 1
    !?ioExecutionMin
    !?ioMaxArray
    !ioCurrentMax - 1
    !?ioExecutionMax
  ;
end method ;

#----------------------------------------------------------------------------*
#----------------------------------------------------------------------------*
#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_bra duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_goto duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_instruction_computed_rcall duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18_intermediate_registerComparisonCondition duration
  ??@uint unused inCurrentLine
  ??@symbolTableForOptimizations unused inSymbolTable
  ??@routineMinMaxMap unused inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList unused inGeneratedInstructionList
  ?!@uintlist unused ioMinArray
  ?!@uintlist unused ioMaxArray
  ?!@uint ioCurrentMin
  ?!@uint ioCurrentMax
  ?!@uint unused ioExecutionMin
  ?!@uint unused ioExecutionMax
:
  ioCurrentMin := ioCurrentMin + 2 ;
  ioCurrentMax := ioCurrentMax + 2 ;
end method ;

#----------------------------------------------------------------------------*

local routine computeMinMaxFromLine
  ??@uint inStartLine
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ??@uint inCurrentMin
  ?!@uint ioExecutionMin
  ?!@uintlist ioMaxArray
  ??@uint inCurrentMax
  ?!@uint ioExecutionMax
:
  @uint currentLine := inStartLine ;
  @bool explores := true ;
  @uint min := inCurrentMin ;
  @uint max := inCurrentMax ;
  loop [inGeneratedInstructionList length] : while explores do
    if (min < [ioMinArray mValueAtIndex !currentLine]) | (max > [ioMaxArray mValueAtIndex !currentLine]) then
      const @pic18_intermediate_instruction instruction := [inGeneratedInstructionList mInstructionAtIndex !currentLine] ;
      [instruction duration !currentLine !inSymbolTable !inRoutineMinMaxMap !inGeneratedInstructionList !?ioMinArray !?ioMaxArray !?min !?max !?ioExecutionMin !?ioExecutionMax] ;
      if min < [ioMinArray mValueAtIndex !currentLine] then
        [!?ioMinArray setMValueAtIndex !min !currentLine] ;
      end if ;
      if max > [ioMaxArray mValueAtIndex !currentLine] then
        [!?ioMaxArray setMValueAtIndex !max !currentLine] ;
      end if ;
      explores := [instruction nextInstructionIsReachable] ;
      currentLine := currentLine + 1 ;
    else
      explores := false ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

local routine computeMinMaxFromLabel
  ??@lstring inLabel
  ??@symbolTableForOptimizations inSymbolTable
  ??@routineMinMaxMap inRoutineMinMaxMap
  ??@pic18_intermediate_instructionList inGeneratedInstructionList
  ?!@uintlist ioMinArray
  ??@uint inCurrentMin
  ?!@uint ioExecutionMin
  ?!@uintlist ioMaxArray
  ??@uint inCurrentMax
  ?!@uint ioExecutionMax
:
  [inSymbolTable searchKey !inLabel ?@uint line ?*] ;
  computeMinMaxFromLine
    !line
    !inSymbolTable
    !inRoutineMinMaxMap
    !inGeneratedInstructionList
    !?ioMinArray
    !inCurrentMin
    !?ioExecutionMin
    !?ioMaxArray
    !inCurrentMax
    !?ioExecutionMax
  ;  
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               C O M P U T E    M E T R I C S                               *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_compute_metrics
  ??@piccoloModel inPiccoloModel
  ??@routineDeclarationList inUserRoutineDeclarationListForBootloaderImplementation
  ??@routineDeclarationList inBootloaderRoutineDeclarationListForUserProgramImplementation
  ??@pic18_intermediate_instructionList inGeneratedInstructionList 
  ?!@string ioListFileContents
  ??@string inSourceFileName
:
  @lstringlist sortedRoutineNameList ;
  @stringset routinesInvolvedInRecursion ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*           S T A C K    R E Q U I R E M E N T S                              *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  if [option piccolo_options.doNotComputeStackRequirements value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeStackRequirements string] . "': stack requirements are not computed.\n" ;
    routinesInvolvedInRecursion := [@stringset emptySet] ;
    sortedRoutineNameList := [@lstringlist emptyList] ;
  else
    @routineCallGraph routineCallGraph [emptyGraph] ;
  #--- Enter routine names
    foreach inPiccoloModel->mRoutineDefinitionList do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter applicative routine names (for bootloader)
    foreach inUserRoutineDeclarationListForBootloaderImplementation do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter bootloader routine names (for applicative)
    foreach inBootloaderRoutineDeclarationListForUserProgramImplementation do
      [!?routineCallGraph addNode !mRoutineName !mRoutineName->string] ;
    end foreach ;
  #--- Enter interrupts routine name, and populate graph
    foreach inPiccoloModel->mInterruptDefinitionList do
      const @lstring interruptRoutineName [new !"_" . mInterruptName->string . "_interrupt_routine" !mInterruptName->location] ;
      [!?routineCallGraph addNode !interruptRoutineName !interruptRoutineName->string] ;
      exploreInstructionList !mInstructionList !interruptRoutineName !?routineCallGraph ;
    end foreach ;
  #--- Populate graph from routines
    foreach inPiccoloModel->mRoutineDefinitionList do
      exploreInstructionList !mInstructionList !mRoutineName !?routineCallGraph ;
    end foreach ;
  #--- Sort routine call graph
    [routineCallGraph topologicalSort
      ?*
      ?sortedRoutineNameList
      ?*
      ?@lstringlist unsortedNodeKeyList
    ] ;
    routinesInvolvedInRecursion := [@stringset setWithLStringList !unsortedNodeKeyList] ;
    if [unsortedNodeKeyList length] > 0 then
      @string s := "stack needs cannot be computed, the following routines are involved in a recursion:" ;
      foreach unsortedNodeKeyList do
        s .= "\n-  " . mValue ;
      end foreach ;
      warning inPiccoloModel->mEndOfProgram : s ;
      ioListFileContents .= s ;
    else
      ioListFileContents .= "No recursive routines.\n" ;
    end if ;
  #--- Output a graphviz file
    if [option piccolo_options.generateCallGraph value] then
      const @string graphvizText := [routineCallGraph graphviz] ;
      const @string graphvizFile := [inSourceFileName stringByDeletingPathExtension] . ".dot" ;
      [graphvizText writeToFileWhenDifferentContents !graphvizFile ?*] ;
    end if ;
  #--- Compute stack needs
    if [unsortedNodeKeyList length] == 0 then
      computeStackNeeds 
        !inGeneratedInstructionList
        !sortedRoutineNameList
        !?ioListFileContents
      ;
    end if ;
  end if ;
  ioListFileContents .= "\n" ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*           I N T E R R U P T    R O U T I N E    D U R A T I O N S           *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  if [option piccolo_options.doNotComputeInterruptRoutineDuration value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeInterruptRoutineDuration string] . "': interrupt routine durations are not computed.\n" ;
  elsif [option piccolo_options.doNotComputeStackRequirements value] then
    ioListFileContents .= "option '" . [option piccolo_options.doNotComputeStackRequirements string] . "': cannot compute interrupt routine durations.\n" ;
  else
    @routineHasLoopMap routineHasLoopMap [emptyMap] ;
  #--- Foreach non recursive routine, establish if it contains loops
    foreach sortedRoutineNameList do
      @bool found := false ;
      foreach inPiccoloModel->mRoutineDefinitionList while not found do
        found := mValue->string == mRoutineName->string ;
        if found & not [routinesInvolvedInRecursion hasKey !mRoutineName->string] then
          @bool hasLoopInstruction := false ;
          searchForLoopInInstructionList !mInstructionList !routineHasLoopMap !?hasLoopInstruction ;
          [!?routineHasLoopMap insertKey !mRoutineName !hasLoopInstruction] ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Foreach interrupt routine, establish if it contains loops
    foreach inPiccoloModel->mInterruptDefinitionList do
      const @lstring routineName [new !"_" . mInterruptName->string . "_interrupt_routine" !mInterruptName->location] ;
      if [routinesInvolvedInRecursion hasKey !routineName->string] then
        ioListFileContents .= "Cannot compute '" . mInterruptName . "' interrupt routine duration : it is involved in recursive routine calls.\n" ;
      else
        @bool hasLoopInstruction := false ;
        searchForLoopInInstructionList !mInstructionList !routineHasLoopMap !?hasLoopInstruction ;
        [!?routineHasLoopMap insertKey !routineName !hasLoopInstruction] ;
        if hasLoopInstruction then
          ioListFileContents .= "Cannot compute '" . mInterruptName . "' interrupt routine duration : it contains 'do ... while' instruction(s).\n" ;
          warning mInterruptName : "cannot compute '" . mInterruptName . "' interrupt routine duration : it contains 'do ... while' instruction's).\n" ;
        end if ;
      end if ;
    end foreach ;
  #-------------------------------- Build label map
    @symbolTableForOptimizations symbolTable [emptyMap] ;
    foreach inGeneratedInstructionList index lineIndex do
      [mInstruction defineLabel !?symbolTable !lineIndex] ;
    end foreach ;
    ioListFileContents .= "\nDurations are expressed in instruction clock cycles.\n\n" ;
    ioListFileContents .= ["Routine" stringByLeftPadding !70 !' '] . " Min-Max\n" ;
    @routineMinMaxMap routineMinMaxMap [emptyMap] ;
    foreach sortedRoutineNameList do
      if [routineHasLoopMap hasKey !mValue->string] then
        [routineHasLoopMap searchKey !mValue ?@bool hasLoopInstruction] ;
        if hasLoopInstruction then
          ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " loops\n" ;
        else
          @uintlist minArray [emptyList] ;
          @uintlist maxArray [emptyList] ;
          foreach inGeneratedInstructionList do
            minArray += ![@uint max] ;
            maxArray += !0 ;
          end foreach ;
          @uint executionMin := [@uint max] ;
          @uint executionMax := 0 ;
#          @uint currentMin := 0 ;
#          @uint currentMax := 0 ;
          message "---- " . mValue . "\n" ;
          computeMinMaxFromLabel !mValue !symbolTable !routineMinMaxMap !inGeneratedInstructionList !?minArray !0 !?executionMin !?maxArray !0 !?executionMax ;
          [!?routineMinMaxMap insertKey !mValue !executionMin !executionMax] ;
          foreach inGeneratedInstructionList index lineIndex do
            const @uint imin := [minArray mValueAtIndex !lineIndex] ;
            const @uint imax := [maxArray mValueAtIndex !lineIndex] ;
            if imin <= imax then
              @string s := [lineIndex string] . ":" . imin . "..." . imax . ":" ;
              [mInstruction displayIPICinstruction !?s] ;
              message s  . "\n" ;
            end if ;
          end foreach ;
          message "--> " . executionMin . ".." . executionMax . "\n" ;
          ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " " . executionMin . "-" . executionMax . "\n" ;        
        end if ;
      else
        ioListFileContents .= [mValue stringByLeftPadding !70 !' '] . " recursive\n" ;
      end if ;
    end foreach ;
  end if ;
  ioListFileContents .= "\n" ;
end routine ;

#----------------------------------------------------*

end semantics ;
