semantics pic18_optimize_block_ordering :
import "ipic18_block_representation.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Block invocation graph

#----------------------------------------------------------------------------*

graph @blockInvocationGraph (@stringlist) {
  insert addNode error message "the '%K' label is already declared at %L" ;
}

#----------------------------------------------------------------------------*

#!--- Build ordered blocks

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  if not [ioVisitedBlockSet hasKey !mLabel->string] then
    [!?ioGraph addArc !inLabelBlock !mLabel] ;
    ioVisitedBlockSet += !mLabel->string ;
    [inSymbolTable searchKey !mLabel ??@uint targetBlockIndex] ;
    const @ipic18Block targetBlock := [inBlockList mBlockAtIndex !targetBlockIndex] ;
    [!?ioGraph addNode !targetBlock->mLabel !targetBlock->mLabel->string] ;
    [targetBlock->mTerminator buildOrderedBlocks
      !?ioGraph
      !?ioVisitedBlockSet
      !inBlockList
      !inSymbolTable
      !targetBlock->mLabel
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
  [mInstructionIfConditionFalse buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- buildInvocationGraph

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mLabel . "\"" ;
  if inDottedArrow then
    ioGraphVizString .= " [style=dotted]" ;
  end if ;
  ioGraphVizString .= " ;\n" ;
end method ;

#----------------------------------------------------------------------------*

#!--- Block build ordering constraint

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
  if not [ioVisitedBlockSet hasKey !mLabel->string] then
    [!?ioGraph addArc !inBlockLabel !mLabel] ;
    if inDominatorLabel->string != "" then
      [!?ioGraph addArc !inDominatorLabel !mLabel] ;
    end if ;
  #--- Explore next block
    [!?ioGraph addNode !mLabel !mLabel->string] ;
    ioVisitedBlockSet += !mLabel->string ;
    [inSymbolTable searchKey !mLabel ??@uint blockIndex] ;
    const @ipic18Block nextBlock := [inBlockList mBlockAtIndex !blockIndex] ;
    [nextBlock->mTerminator buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !mLabel
      !inDominatorLabel
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
  [mInstructionIfConditionFalse buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
#--- Only true jump can be ommitted
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
#--- Weak precedence
  if (mInstructionIfConditionTrue is @ipic18JumpTerminator) then
    const @ipic18JumpTerminator jp := (cast mInstructionIfConditionTrue : @ipic18JumpTerminator) ;
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      ![jp mLabel]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  else
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      !["" nowhere]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
#--- Only true jump can be ommitted
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
#--- Weak precedence
  if (mInstructionIfConditionTrue is @ipic18JumpTerminator) then
    const @ipic18JumpTerminator jp := (cast mInstructionIfConditionTrue : @ipic18JumpTerminator) ;
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      ![jp mLabel]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  else
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      !["" nowhere]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator display

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
;

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult := mLabel->string == inNextBlockLabel ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator canJumpDirectlyToNextBlock
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := true ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18BraCCTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18IncDecRegisterTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18BitTestTerminator canJumpDirectlyToNextBlock
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue canJumpDirectlyToNextBlock !inNextBlockLabel]
    |
    [mInstructionIfConditionFalse canJumpDirectlyToNextBlock !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Routines

#----------------------------------------------------------------------------*

local routine buildInvocationGraph
  ??@ipic18BlockList inBlockList
  !@string outGraphVizString
:
  outGraphVizString := "digraph G{\n" ;
  foreach inBlockList do
    if mBlock->mStartAddress == [@uint max] then # Only relocatable block
      [mBlock->mTerminator buildInvocationGraph !mBlock->mLabel !?outGraphVizString !false] ;
    end if ;
  end foreach ;
  outGraphVizString .= "}\n" ;
end routine ;

#----------------------------------------------------------------------------*

local routine buildDirectInvocationGraph
  ??@ipic18BlockList inBlockList
  !@blockInvocationGraph outGraph
:
#-------------------------------- Build label map
  @symbolTableForBlockOptimization symbolTable [emptyMap] ;
  foreach inBlockList index blockIndex do
    [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
  end foreach ;
#---
  outGraph := [@blockInvocationGraph emptyGraph] ;
  @stringset visitedBlockSet [emptySet] ;
  foreach inBlockList do
    if (mBlock->mStartAddress == [@uint max]) # Only relocatable block
     & not [visitedBlockSet hasKey !mBlock->mLabel->string] then
      visitedBlockSet += !mBlock->mLabel->string ;
      [!?outGraph addNode !mBlock->mLabel !mBlock->mLabel->string] ;
      [mBlock->mTerminator buildOrderingConstraintGraph
        !inBlockList
        !symbolTable
        !mBlock->mLabel
        !["" nowhere]
        !?outGraph
        !?visitedBlockSet
      ] ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine performBlockOrdering
  ?!@ipic18BlockList ioBlockList
:
#-------------------------------- Build label map
  @symbolTableForBlockOptimization symbolTable [emptyMap] ;
  foreach ioBlockList index blockIndex do
    [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
  end foreach ;
#---
  @stringset visitedBlockSet [emptySet] ;
  @ipic18BlockList orderedBlockList [emptyList] ;
  foreach ioBlockList do
    if (mBlock->mStartAddress != [@uint max]) then # Absolute block
      orderedBlockList += !mBlock ;    
    elsif not [visitedBlockSet hasKey !mBlock->mLabel->string] then 
      visitedBlockSet += !mBlock->mLabel->string ;
      message "------ VISIT '" . mBlock->mLabel . "'\n" ;
      @blockInvocationGraph g [emptyGraph] ;
      [!?g addNode !mBlock->mLabel !mBlock->mLabel->string] ;
      [mBlock->mTerminator buildOrderingConstraintGraph
        !ioBlockList
        !symbolTable
        !mBlock->mLabel
        !["" nowhere]
        !?g
        !?visitedBlockSet
      ] ;
      [g topologicalSort
        ??@stringlist orderedBlockList
        ?3*
      ] ;
      log g ;
      log "" : mBlock->mLabel ;
      const @stringlist undefinedLabelList := [g undefinedNodeKeyList] ;
      log undefinedLabelList ;
      log orderedBlockList ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local function blockDiscontinuityCount
  ?@ipic18BlockList inBlockList
  ->@uint outResult
:
  outResult := 0 ;
  foreach inBlockList index blockIndex do
    if mBlock->mStartAddress == [@uint max] then # Only relocatable block
      @string nextBlockLabel ;
      if (blockIndex+1) < [inBlockList length] then
        nextBlockLabel := [inBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
      else
        nextBlockLabel := "" ;
      end if ;
      if not [mBlock->mTerminator canJumpDirectlyToNextBlock !nextBlockLabel] then
        outResult := outResult + 1 ;
      end if ;
    end if ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

routine ipic18OptimizeBlockOrdering
  ??@string inSourceFileName
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
  message "Block ordering optimization:\n" ;
#---
  buildInvocationGraph !ioGeneratedBlockList ??@string invocationGraph ;
  [invocationGraph writeToFileWhenDifferentContents !inSourceFileName. ".blockInvocation.dot" ?*] ;
#---
  buildDirectInvocationGraph !ioGeneratedBlockList ??@blockInvocationGraph directInvocationGraph ;
  [[directInvocationGraph graphviz] writeToFile !inSourceFileName. ".orderedBlocks.dot"] ;
#---
  performBlockOrdering !?ioGeneratedBlockList ;
#---
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["BLOCK REPRESENTATION ORDERING OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  @bool optimizationDone := true ;
  @uint optimizationPass := 0 ;
  loop [ioGeneratedBlockList length] + 1
  while optimizationDone & ([@uint errorCount] == 0) do
    optimizationDone := false ;
    optimizationPass := optimizationPass + 1 ;
    ioListFileContents .= "\n--- Pass " . optimizationPass . " (" . blockDiscontinuityCount [!ioGeneratedBlockList] . " discontinuities)\n" ;
    message "  Pass " . optimizationPass . " (" . blockDiscontinuityCount [!ioGeneratedBlockList] . " discontinuities)\n" ;


  end loop ;
  message "\n" ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
