semantics pic18_optimize_block_ordering :
import "ipic18_block_representation.gSemantics" ;
import "pic18_mnemonics.gSemantics" ;

#----------------------------------------------------------------------------*

#!--- Block invocation graph

#----------------------------------------------------------------------------*

graph @blockInvocationGraph (@stringlist) {
  insert addNode error message "the '%K' label is already declared at %L" ;
}

#----------------------------------------------------------------------------*

#!--- Build ordered blocks

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator buildOrderedBlocks
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inLabelBlock
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  if not [ioVisitedBlockSet hasKey !mLabel->string] then
    [!?ioGraph addArc !inLabelBlock !mLabel] ;
    ioVisitedBlockSet += !mLabel->string ;
    [inSymbolTable searchKey !mLabel ??@uint targetBlockIndex] ;
    const @ipic18Block targetBlock := [inBlockList mBlockAtIndex !targetBlockIndex] ;
    [!?ioGraph addNode !targetBlock->mLabel !targetBlock->mLabel->string] ;
    [targetBlock->mTerminator buildOrderedBlocks
      !?ioGraph
      !?ioVisitedBlockSet
      !inBlockList
      !inSymbolTable
      !targetBlock->mLabel
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
  [mInstructionIfConditionFalse buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildOrderedBlocks
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inLabelBlock
:
  [mInstructionIfConditionTrue buildOrderedBlocks
    !?ioGraph
    !?ioVisitedBlockSet
    !inBlockList
    !inSymbolTable
    !inLabelBlock
  ] ;
end method ;

#----------------------------------------------------------------------------*

#!--- buildInvocationGraph

#----------------------------------------------------------------------------*

abstract method @ipic18AbstractBlockTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
;

#----------------------------------------------------------------------------*

override method @ipic18ReturnTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetlwTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18RetfieTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedRETLWTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedBraTerminator buildInvocationGraph
  ??@lstring unused inBlockLabel
  ?!@string unused ioGraphVizString
  ??@bool unused inDottedArrow
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool unused inDottedArrow
:
  [mInstructionIfConditionTrue buildInvocationGraph !inBlockLabel !?ioGraphVizString !false] ;
  [mInstructionIfConditionFalse buildInvocationGraph !inBlockLabel !?ioGraphVizString !true] ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildInvocationGraph
  ??@lstring inBlockLabel
  ?!@string ioGraphVizString
  ??@bool inDottedArrow
:
  ioGraphVizString .= "  \"" . inBlockLabel . "\" -> \"" . mLabel . "\"" ;
  if inDottedArrow then
    ioGraphVizString .= " [style=dotted]" ;
  end if ;
  ioGraphVizString .= " ;\n" ;
end method ;

#----------------------------------------------------------------------------*

#!--- Block build ordering constraint

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList unused inBlockList
  ??@symbolTableForBlockOptimization unused inSymbolTable
  ??@lstring unused inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph unused ioGraph
  ?!@stringset unused ioVisitedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18JumpTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
  if not [ioVisitedBlockSet hasKey !mLabel->string] then
    [!?ioGraph addArc !inBlockLabel !mLabel] ;
    if inDominatorLabel->string != "" then
      [!?ioGraph addArc !inDominatorLabel !mLabel] ;
    end if ;
  #--- Explore next block
    [!?ioGraph addNode !mLabel !mLabel->string] ;
    ioVisitedBlockSet += !mLabel->string ;
    [inSymbolTable searchKey !mLabel ??@uint blockIndex] ;
    const @ipic18Block nextBlock := [inBlockList mBlockAtIndex !blockIndex] ;
    [nextBlock->mTerminator buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !mLabel
      !inDominatorLabel
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18AbstractConditionTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
  [mInstructionIfConditionFalse buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18RegisterComparisonTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
#--- Only true jump can be ommitted
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
#--- Weak precedence
  if (mInstructionIfConditionTrue is @ipic18JumpTerminator) then
    const @ipic18JumpTerminator jp := (cast mInstructionIfConditionTrue : @ipic18JumpTerminator) ;
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      ![jp mLabel]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  else
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      !["" nowhere]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pic18TestRegisterTerminator buildOrderingConstraintGraph
  ??@ipic18BlockList inBlockList
  ??@symbolTableForBlockOptimization inSymbolTable
  ??@lstring inBlockLabel
  ??@lstring unused inDominatorLabel
  ?!@blockInvocationGraph ioGraph
  ?!@stringset ioVisitedBlockSet
:
#--- Only true jump can be ommitted
  [mInstructionIfConditionTrue buildOrderingConstraintGraph
    !inBlockList
    !inSymbolTable
    !inBlockLabel
    !["" nowhere]
    !?ioGraph
    !?ioVisitedBlockSet
  ] ;
#--- Weak precedence
  if (mInstructionIfConditionTrue is @ipic18JumpTerminator) then
    const @ipic18JumpTerminator jp := (cast mInstructionIfConditionTrue : @ipic18JumpTerminator) ;
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      ![jp mLabel]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  else
    [mInstructionIfConditionFalse buildOrderingConstraintGraph
      !inBlockList
      !inSymbolTable
      !inBlockLabel
      !["" nowhere]
      !?ioGraph
      !?ioVisitedBlockSet
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#!--- Terminator noNeedToInsertJumpInstruction

#----------------------------------------------------------------------------*

abstract reader @ipic18AbstractBlockTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
;

#----------------------------------------------------------------------------*

override reader @ipic18ReturnTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetlwTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18RetfieTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18JumpTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult := mLabel->string != inNextBlockLabel ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedGotoTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedRETLWTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ConditionalJumpTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
    &
    [mInstructionIfConditionFalse needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18ComputedBraTerminator needToInsertJumpInstruction
  ??@string unused inNextBlockLabel
  ->@bool outResult
:
  outResult := false ;
end reader ;

#----------------------------------------------------------------------------*

override reader @ipic18AbstractConditionTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
    &
    [mInstructionIfConditionFalse needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18RegisterComparisonTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

override reader @pic18TestRegisterTerminator needToInsertJumpInstruction
  ??@string inNextBlockLabel
  ->@bool outResult
:
  outResult :=
    [mInstructionIfConditionTrue needToInsertJumpInstruction !inNextBlockLabel]
  ;
end reader ;

#----------------------------------------------------------------------------*

#!--- Terminator buildTerminatorCalledRoutineSet

#----------------------------------------------------------------------------*

method @ipic18AbstractBlockTerminator buildTerminatorCalledRoutineSet
  ?!@stringset unused ioReferencedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18ComputedGotoTerminator buildTerminatorCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  foreach mTargetLabels do
    ioReferencedBlockSet += !mValue->string ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

#!--- Instruction buildInstructionCalledRoutineSet

#----------------------------------------------------------------------------*

method @ipic18SequentialInstruction buildInstructionCalledRoutineSet
  ?!@stringset unused ioReferencedBlockSet
:
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_JSR buildInstructionCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  ioReferencedBlockSet += !mTargetLabel->string ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_intermediate_instruction_computed_rcall buildInstructionCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  foreach mTargetLabels do
    ioReferencedBlockSet += !mValue->string ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @ipic18_skip_instruction buildInstructionCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  [mEmbeddedInstruction buildInstructionCalledRoutineSet !?ioReferencedBlockSet] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Block optimization

#----------------------------------------------------------------------------*

method @ipic18SequentialInstructionList buildInstructionCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  foreach selfcopy do
    [mInstruction buildInstructionCalledRoutineSet !?ioReferencedBlockSet] ;  
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

method @ipic18Block buildCalledRoutineSet
  ?!@stringset ioReferencedBlockSet
:
  [mInstructionList buildInstructionCalledRoutineSet !?ioReferencedBlockSet] ;
  [mTerminator buildTerminatorCalledRoutineSet !?ioReferencedBlockSet] ;
end method ;

#----------------------------------------------------------------------------*

#!--- Routines

#----------------------------------------------------------------------------*

local routine buildInvocationGraph
  ??@ipic18BlockList inBlockList
  !@string outGraphVizString
:
  outGraphVizString := "digraph G{\n" ;
  foreach inBlockList do
    if mBlock->mStartAddress == [@uint max] then # Only relocatable block
      [mBlock->mTerminator buildInvocationGraph !mBlock->mLabel !?outGraphVizString !false] ;
    end if ;
  end foreach ;
  outGraphVizString .= "}\n" ;
end routine ;

##----------------------------------------------------------------------------*
#
#local routine buildDirectInvocationGraph
#  ??@ipic18BlockList inBlockList
#  !@blockInvocationGraph outGraph
#:
##-------------------------------- Build label map
#  @symbolTableForBlockOptimization symbolTable [emptyMap] ;
#  foreach inBlockList index blockIndex do
#    [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
#  end foreach ;
##---
#  outGraph := [@blockInvocationGraph emptyGraph] ;
#  @stringset visitedBlockSet [emptySet] ;
#  foreach inBlockList do
#    if (mBlock->mStartAddress == [@uint max]) # Only relocatable block
#     & not [visitedBlockSet hasKey !mBlock->mLabel->string] then
#      visitedBlockSet += !mBlock->mLabel->string ;
#      [!?outGraph addNode !mBlock->mLabel !mBlock->mLabel->string] ;
#      [mBlock->mTerminator buildOrderingConstraintGraph
#        !inBlockList
#        !symbolTable
#        !mBlock->mLabel
#        !["" nowhere]
#        !?outGraph
#        !?visitedBlockSet
#      ] ;
#    end if ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

local routine performBlockOrdering
  ??@string unused inSourceFileName
  ?!@ipic18BlockList ioBlockList
:
#-------------------------------- Build actual routine set
  @stringset actualRoutineSet [emptySet] ;
  actualRoutineSet += !"main" ;
  actualRoutineSet += !"_high_interrupt" ;
  actualRoutineSet += !"_low_interrupt" ;
  foreach ioBlockList do
    [mBlock buildCalledRoutineSet !?actualRoutineSet] ;
  end foreach ;
#-------------------------------- Build label map
  @symbolTableForBlockOptimization symbolTable [emptyMap] ;
  foreach ioBlockList index blockIndex do
    [!?symbolTable insertKey !mBlock->mLabel !blockIndex] ;
  end foreach ;
#---
  @ipic18BlockList orderedBlockList [emptyList] ;
  @stringset generatedBlockSet [emptySet] ;
  foreach ioBlockList do
    if (mBlock->mStartAddress != [@uint max]) then # Absolute block
      orderedBlockList += !mBlock ;    
    elsif [actualRoutineSet hasKey !mBlock->mLabel->string] then
      @stringset visitedBlockSet [setWithString !mBlock->mLabel->string] ;
      @blockInvocationGraph g [emptyGraph] ;
      [!?g addNode !mBlock->mLabel !mBlock->mLabel->string] ;
      [mBlock->mTerminator buildOrderingConstraintGraph
        !ioBlockList
        !symbolTable
        !mBlock->mLabel
        !["" nowhere]
        !?g
        !?visitedBlockSet
      ] ;
      [g topologicalSort
        ??@stringlist orderedLabelList
        ?3*
      ] ;
      foreach \down orderedLabelList do
        if not [generatedBlockSet hasKey !mValue] then
          generatedBlockSet += !mValue ;
          [symbolTable searchKey ![mValue nowhere] ??@uint blockIndex] ;
          const @ipic18Block b := [ioBlockList mBlockAtIndex !blockIndex] ;
          orderedBlockList += !b ;
        end if ;
      end foreach ;
    end if ;
  end foreach ;
  ioBlockList := orderedBlockList ;
#  message "  " . [orderedBlockList length] . " blocks\n" ;
end routine ;

#----------------------------------------------------------------------------*

local function blockDiscontinuityCount
  ?@ipic18BlockList inBlockList
  ->@uint outResult
:
  outResult := 0 ;
  foreach inBlockList index blockIndex do
    if mBlock->mStartAddress == [@uint max] then # Only relocatable block
      @string nextBlockLabel ;
      if (blockIndex+1) < [inBlockList length] then
        nextBlockLabel := [inBlockList mBlockAtIndex !blockIndex+1]->mLabel->string ;
      else
        nextBlockLabel := "" ;
      end if ;
      if [mBlock->mTerminator needToInsertJumpInstruction !nextBlockLabel] then
        outResult := outResult + 1 ;
      end if ;
    end if ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

routine ipic18OptimizeBlockOrdering
  ??@string inSourceFileName
  ?!@string ioListFileContents
  ?!@ipic18BlockList ioGeneratedBlockList
:
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
  ioListFileContents .= "*" . ["BLOCK REPRESENTATION ORDERING OPTIMIZATION" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
  ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
#---
  message "Block ordering optimization:\n" ;
  message "  discontinuity count before optimization: " . blockDiscontinuityCount [!ioGeneratedBlockList] . "\n" ;
#---
  buildInvocationGraph !ioGeneratedBlockList ??@string invocationGraph ;
  [invocationGraph writeToFileWhenDifferentContents !inSourceFileName. ".blockInvocation.dot" ?*] ;
##---
#  buildDirectInvocationGraph !ioGeneratedBlockList ??@blockInvocationGraph directInvocationGraph ;
#  [[directInvocationGraph graphviz] writeToFile !inSourceFileName. ".orderedBlocks.dot"] ;
#---
  performBlockOrdering !inSourceFileName !?ioGeneratedBlockList ;
  message "  discontinuity count after optimization: " . blockDiscontinuityCount [!ioGeneratedBlockList] . "\n\n" ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
