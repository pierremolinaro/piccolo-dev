semantics pic18_routine_inlining :
import "pic18_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*

map @declaredRoutineMap {
  @luint mRequiredBank ;
  @luint mReturnedBank ;
  @bool mPreservesBank ;
  @bool mIsNoReturn ;
  @pic18InstructionList mInstructionList ;
  insert insertKey error message "the '%K' routine is already declared" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#---------------------------------------------------------------------------*

method @pic18PiccoloInstruction performInlining
  ??@stringset unused inInlinedRoutineSet
  ??@declaredRoutineMap unused inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  ioInstructionList += !selfcopy ;
end method ;

#---------------------------------------------------------------------------*

override method @pic18Instruction_FOREVER performInlining
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  performInlineFromInstructionList
    !mInstructionList
    !inInlinedRoutineSet
    !inDeclaredRoutineMap
    ??@pic18InstructionList instructionList
  ;
  ioInstructionList += ![@pic18Instruction_FOREVER new
    !mInstructionLocation
    !instructionList
    !mEndOfInstructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @pic18Instruction_do_while performInlining
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  performInlineFromInstructionList
    !mRepeatedInstructionList
    !inInlinedRoutineSet
    !inDeclaredRoutineMap
    ??@pic18InstructionList repeatedInstructionList
  ;
  @pic18DoWhilePartList whilePartList [emptyList] ;
  foreach mWhilePartList do
    performInlineFromInstructionList
      !mInstructionList
      !inInlinedRoutineSet
      !inDeclaredRoutineMap
      ??@pic18InstructionList instructionList
    ;
    whilePartList += !mCondition !instructionList !mEndOfPartLocation ;
  end foreach ;
  ioInstructionList += ![@pic18Instruction_do_while new
    !mInstructionLocation
    !repeatedInstructionList
    !mEndOfRepeatedInstructionList
    !whilePartList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @pic18Instruction_savebank performInlining
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  performInlineFromInstructionList
    !mInstructionList
    !inInlinedRoutineSet
    !inDeclaredRoutineMap
    ??@pic18InstructionList instructionList
  ;
  ioInstructionList += ![@pic18Instruction_savebank new
    !mInstructionLocation
    !mRegister
    !instructionList
    !mEndOfSaveBankInstruction
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @pic18Instruction_structured_if performInlining
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  performInlineFromInstructionList
    !mThenInstructionList
    !inInlinedRoutineSet
    !inDeclaredRoutineMap
    ??@pic18InstructionList thenInstructionList
  ;
  performInlineFromInstructionList
    !mElseInstructionList
    !inInlinedRoutineSet
    !inDeclaredRoutineMap
    ??@pic18InstructionList elseInstructionList
  ;
  ioInstructionList += ![@pic18Instruction_structured_if new
    !mInstructionLocation
    !mIfCondition
    !thenInstructionList
    !elseInstructionList
    !mEndOfElsePartLocation
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @pic18Instruction_JSR performInlining
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InstructionList ioInstructionList
:
  @bool inlineDone ;
  if [inDeclaredRoutineMap hasKey !mTargetLabel->string] & [inInlinedRoutineSet hasKey !mTargetLabel->string] then
    [inDeclaredRoutineMap searchKey
      !mTargetLabel
      ??@luint requiredBank
      ??@luint returnedBank
      ??@bool preservesBank
      ??@bool isNoReturn
      ??@pic18InstructionList instructionList
    ] ;
    if isNoReturn then
      error mTargetLabel: "a \"noreturn\" routine cannot be inlined" : inlineDone ;
    else
      if requiredBank->uint != [@uint max] then
        ioInstructionList += ![@pic18Instruction_checkbank new !mInstructionLocation !requiredBank->uint] ;
      end if ;
      ioInstructionList .= instructionList ;
      if returnedBank->uint != [@uint max] then
        ioInstructionList += ![@pic18Instruction_checkbank new !mInstructionLocation !returnedBank->uint] ;
      end if ;
      inlineDone := true ;
    end if ;
  else 
    inlineDone := false ;
  end if ;
  if not inlineDone then
    ioInstructionList += !selfcopy ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

local routine performInlineFromInstructionList
  ??@pic18InstructionList inInstructionList
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  !@pic18InstructionList outInstructionList
:
  outInstructionList := [@pic18InstructionList emptyList] ;
  foreach inInstructionList do
    [mInstruction performInlining
      !inInlinedRoutineSet
      !inDeclaredRoutineMap
      !?outInstructionList
   ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine pic18PerformRoutineInline
  ??@stringset inInlinedRoutineSet
  ??@declaredRoutineMap inDeclaredRoutineMap
  ?!@pic18InterruptDefinitionList ioInterruptDefinitionList
  ?!@pic18RoutineDefinitionList ioRoutineDefinitionList
:
#--- Interrupt routines
  @pic18InterruptDefinitionList interruptDefinitionList [emptyList] ;
  foreach ioInterruptDefinitionList do
    performInlineFromInstructionList
      !mInstructionList
      !inInlinedRoutineSet
      !inDeclaredRoutineMap
      ??@pic18InstructionList instructionList
    ;
    interruptDefinitionList +=
      !mInterruptName
      !mFastReturn
      !instructionList
      !mEndOfInterruptLocation
    ;
  end foreach ;
  ioInterruptDefinitionList := interruptDefinitionList ;
#--- Regular routines
  @pic18RoutineDefinitionList routineDefinitionList [emptyList] ;
  foreach ioRoutineDefinitionList do
    performInlineFromInstructionList
      !mInstructionList
      !inInlinedRoutineSet
      !inDeclaredRoutineMap
      ??@pic18InstructionList instructionList
    ;
    routineDefinitionList +=
      !mRoutineName
      !mRequiredBank
      !mReturnedBank
      !mPreservesBank
      !mIsNoReturn
      !instructionList
      !mEndOfRoutineLocation
    ;
  end foreach ;
  ioRoutineDefinitionList := routineDefinitionList ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
