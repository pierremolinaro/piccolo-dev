semantics pic18_semantics :
import "pic18_build_binary_code.gSemantics" ;
import "pic18_checkingAndBuildIPIC.gSemantics" ;
import "pic18_convert_relatives.gSemantics" ;
import "pic18_optimizations.gSemantics" ;
import "piccolo_config.gSemantics" ;
import "ram_sections.gSemantics" ;
import "pic18_grammar.gGrammar" ;
import "pic18_metrics_analysis.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#       L I S T I N G   O F    G E N E R A T E D   C O D E                   *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_build_listing_of_generated_code
  ??@pic18_intermediate_instructionList inInstructionList
  ?!@string ioListFileContents
:
#--- Build symbol table
  @pic18_intermediate_symbolTable symbolTable [emptyMap] ;
  @uint currentAddress := 0 ;
  foreach inInstructionList do
    [mInstruction enterLabelAtAddress !?symbolTable !?currentAddress] ;
  end foreach ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*                              GENERATED CODE                                 *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  ioListFileContents .= " Line  Address  Code      Assembly\n" ;
  @uint bccLabelIndex := 0 ;
  currentAddress := 0 ;
  foreach inInstructionList index idx do
    @stringlist lineList [emptyList] ;
    [mInstruction buildAssemblyCode !?lineList !?bccLabelIndex] ;
    @emittedCodeList code [emptyList] ;
    [mInstruction generateBinaryCodeAtAddress !symbolTable !?currentAddress !?code] ;
    loop [lineList length] :
    while [lineList length] > [code length] do
      code += ![@uintlist emptyList] ;
    end loop ;
    if [lineList length] != [code length] then
      error here : "internal error for listing line " . [idx string]
             . " : " . [[lineList length] string] . " != " . [[code length] string] ;
    end if ;
    foreach lineList, code do
      @string codeString := "" ;
      foreach mCode prefixedby code_ do
        codeString .= [[code_mValue xString] stringByLeftPadding !4 !'0'] . " " ;
      end foreach ;
      ioListFileContents .= [[idx string] stringByLeftPadding !5 !' '] . "  "
                         . [[currentAddress xString] stringByLeftPadding !6 !'0'] . " : "
                         . [codeString stringByRightPadding !10 !' ']
                         . mValue . "\n" ;
      currentAddress := currentAddress + [mCode length] * 2 ;
    end foreach ;
  end foreach ;
  ioListFileContents .= "\n" ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               A N A L Y Z E    D A T A    S E C T I O N                    *
#                                                                            *
#----------------------------------------------------------------------------*

local routine analyze_data_sections
  ??@dataList inDataDefinitionList
  ?!@string ioListFileContents
  !@pic18_intermediate_instructionList outDataGeneratedInstructionList
  !@dataMap outDataMap
  !@constantMap outConstantMap
:
  outConstantMap := [@constantMap emptyMap] ;
  outDataGeneratedInstructionList := [@pic18_intermediate_instructionList emptyList] ;
  outDataMap := [@dataMap emptyMap] ;
  foreach inDataDefinitionList
  before
    ioListFileContents .= "*******************************************************************************\n" ;
    ioListFileContents .= "*                    D A T A    D E C L A R A T I O N                         *\n" ;
    ioListFileContents .= "*******************************************************************************\n\n" ;
  do
    ioListFileContents .= "Data '" . mDataName . "', " . [mValueList length] . " words (" . [mValueList length] * 2 . " bytes).\n" ; 
    [!?outDataMap insertKey !mDataName ![mValueList length]] ;
    [!?outConstantMap insertKey ![@lstring new !mDataName->string . "_BYTE_COUNT" !mDataName->location] ![[mValueList length] * 2 sint]] ;
    const @lstring dataName [new !"_data_" . mDataName !mDataName->location] ;
    outDataGeneratedInstructionList += ![@pic18_intermediate_pseudo_LABEL new !dataName] ;
    foreach mValueList do
      if mValue->uint > 65535 then
        error mValue: "data value is " . [mValue->uint hexString] . " (greater than 0xFFFF)" ;
      else
        outDataGeneratedInstructionList += ![@pic18_intermediate_word new !mValue->uint] ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
#-------------------------------- Check source file name
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  @uint accessBankSplitOffset ;
  @ramBankTable ramBank ;
  @bootloaderReservedRAMmap bootloaderReservedRAMmap ; # Used only for bootloader implementation
  @routineDeclarationList bootloaderRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList userRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList bootloaderRoutineDeclarationListForUserProgramImplementation ;
  @routineDeclarationList userRoutineDeclarationListForUserProgramImplementation ;
  @luint bootloaderReservedROMsize ; # Used only for bootloader implementation or user program implementation, zero for regular program
  @registerTable registerTable ;
  switch [inPiccoloModel mProgramKind]
  when regularProgram : 
    parseDeviceDefinition ![inPiccoloModel mDeviceNameOrBootLoaderReference] ?piccoloDeviceModel ;
    switch [piccoloDeviceModel mProcessorType]
      when pic18_60 : accessBankSplitOffset := 0x60 ;
      when pic18_80 : accessBankSplitOffset := 0x80 ;
      when midrange : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a midrange device is not accepted here" : accessBankSplitOffset ;
      when baseline : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a baseline device is not accepted here" : accessBankSplitOffset ;
    end switch ;
    ramBank := [piccoloDeviceModel mRamBankTable] ;
    bootloaderReservedRAMmap := [@bootloaderReservedRAMmap emptyMap] ;
    registerTable := [piccoloDeviceModel mRegisterTable] ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    bootloaderReservedROMsize := [@luint new !0 !here] ;
  when bootloaderProgram :
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    grammar pic18_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForBootloaderImplementation
      ?userRoutineDeclarationListForBootloaderImplementation
      ?bootloaderReservedROMsize
    ;
    foreach ramBank do #--- Reset first free addresses for all banks
      [!?ramBank setMFirstFreeAddressForKey !mFirstAddress ![lkey string]] ;
    end foreach ;
  when userProgram :
    grammar pic18_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForUserProgramImplementation
      ?userRoutineDeclarationListForUserProgramImplementation
      ?bootloaderReservedROMsize
    ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
  end switch ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool highInterruptIsFast := false ;
  @bool hasLowInterrupt := false ;
  @bool lowInterruptIsFast := false ;
  foreach inPiccoloModel->mInterruptDefinitionList do
    if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
      error mInterruptName: "interrupt routine is not allowed for a bootloader user program" ;
    end if ;
    if [mInterruptName string] == "high" then
      highInterruptIsFast := mFastReturn ;
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      lowInterruptIsFast := mFastReturn ;
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
    if highInterruptIsFast & lowInterruptIsFast then
      error mInterruptName:"either low interrupt or high interrupt can be \"fast\", not both" ;
    end if ;
  end foreach ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
    foreach [inPiccoloModel mConfigDefinitionList] do
      error mDefinitionLocation: "configuration is not allowed for a bootloader user program" ;
    end foreach ;
    actualConfigurationMap := [@actualConfigurationMap emptyMap] ;
  else
    buildConfig
      ![piccoloDeviceModel mConfigRegisterMap]
      ![inPiccoloModel mConfigDefinitionList]
      !?listFileContents
      ?actualConfigurationMap
    ;
  end if ;
#-------------------------------- Ram definition
  analyze_ram_sections
    !"DECLARED VARIABLES"
    ![inPiccoloModel mRamDefinitionList]
    !?ramBank
    ![piccoloDeviceModel mRegisterTable]
    !?listFileContents
    !?registerTable
  ;
#-------------------------------- Data definition
  analyze_data_sections
    !inPiccoloModel->mDataList
    !?listFileContents
    ?@pic18_intermediate_instructionList dataGeneratedInstructionList
    ?@dataMap dataMap
    ?@constantMap dataLengthConstantMap
  ;
#--- For bootloader implementation, check declared var footprint does not span beyond values declared in specification
  if [inPiccoloModel mProgramKind] == [@programKind bootloaderProgram] then
    foreach ramBank do
      if [bootloaderReservedRAMmap hasKey ![lkey string]] then
        @luint bootloaderReservedSize ;
        [bootloaderReservedRAMmap searchKey !lkey ?bootloaderReservedSize] ;
        if (mFirstFreeAddress - mFirstAddress) > [bootloaderReservedSize uint] then
          error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
          . [mFirstFreeAddress - mFirstAddress string]
          . " byte(s), althought the bootloader specification reserves "
          . [[bootloaderReservedSize uint] string]
          . " byte(s)" ;
        end if ;
      elsif mFirstFreeAddress > mFirstAddress then
        error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
        . [mFirstFreeAddress - mFirstAddress string]
        . " byte(s), althought the bootloader specification reserves no space" ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Compute RAM size
  @uint RAMsize := 0 ;
  foreach ramBank do
    if mLastAddressPlusOne > RAMsize then
      RAMsize := mLastAddressPlusOne ;
    end if ;
  end foreach ;
#-------------------------------- Build IPIC Assembly Instruction List
  @pic18_intermediate_instructionList generatedInstructionList ;
  build_pic18_intermediate_assembly_instruction_list
    ![inPiccoloModel mProgramKind]
    ![[[piccoloDeviceModel mRomSize] uint] sint]
    ![RAMsize sint]
    !bootloaderRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !userRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !bootloaderReservedROMsize
    !bootloaderRoutineDeclarationListForUserProgramImplementation
    !userRoutineDeclarationListForUserProgramImplementation
    !accessBankSplitOffset
    !registerTable
    !dataMap
    !inPiccoloModel
    !hasHighInterrupt
    !hasLowInterrupt
    !dataGeneratedInstructionList
    !dataLengthConstantMap
    ?generatedInstructionList
    !?listFileContents
  ;
#-------------------------------- Perform Code Optimization
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    performOptimizations !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Convert relative branchs to absolute, when needed
  if [@uint errorCount] == 0 then
    pic18_intermediate_convertRelativeBranchsToAbsoluteWhenNeeded !?generatedInstructionList !?listFileContents ;
  end if ;
#--- If no error, generate object file(s)
  if [@uint errorCount] == 0 then
  #--- Generate hex file
    @uint usedROMsize ;
    build_pic18_intermediate_binary_code
      !generatedInstructionList
      ![[piccoloDeviceModel mRomSize] uint]
      !actualConfigurationMap
      ?usedROMsize
    ;
    @string contents ;
    getGeneratedContents ?contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    if [option piccolo_options.output_C_Array value] then
      const @string baseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
      get_C_ArrayImplementation !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".c" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
      get_C_ArrayHeader !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".h" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    end if ;
  #--- Write infos (if verbose mode)
    if [option.verbose_output value] then
      @string verboseMessage := "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " bytes;" ;
      verboseMessage .= " used: " . [usedROMsize string] . " bytes (" ;
      verboseMessage .= [(usedROMsize * 100) / [[piccoloDeviceModel mRomSize] uint] string] . "%).\n" ;
      foreach ramBank do
        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
        verboseMessage .= "  RAM bank '" . lkey . "': " ;
        verboseMessage .= [bankSize string] . " bytes, used " ;
        verboseMessage .= [usedSize string] . " bytes (" ;
        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
      end foreach ;
      message verboseMessage ;
    end if ;
  #--- Generate asm file, if corresponding option enabled
    if [option piccolo_options.generateAssembly value] then
      pic18_build_assembly_code
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        !actualConfigurationMap
        ?@string assemblyCode
      ;
      const @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !asmDestinationFile ?*] ;
    end if ;
  else # There are errors : delete hex and asm files
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [@string deleteFileIfExists !hexDestinationFile] ;
    @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
    [@string deleteFileIfExists !asmDestinationFile] ;
  end if ;
#-------------------------------- Write generated code
  if [@uint errorCount] == 0 then
    pic18_build_listing_of_generated_code
      !generatedInstructionList
      !?listFileContents
    ;
  end if ;
#-------------------------------- Compute stack requirements
  if [@uint errorCount] == 0 then
    pic18_stack_requirements
      !inPiccoloModel
      !userRoutineDeclarationListForBootloaderImplementation # Empty for regular program
      !bootloaderRoutineDeclarationListForUserProgramImplementation
      !generatedInstructionList
      !?listFileContents
      !inSourceFileName
    ;
  end if ;
#-------------------------------- Write listing file
  if [option piccolo_options.ouputListingFile value] then
    listFileContents .= "*******************************************************************************\n" ;
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile ?*] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
