semantics pic18_semantics :
import "ipic18_build_binary_code.gSemantics" ;
import "pic18_checkingAndBuildIPIC.gSemantics" ;
import "ipc18_convert_relatives.gSemantics" ;
import "ipic18_optimizations.gSemantics" ;
import "piccolo_config.gSemantics" ;
import "ram_sections.gSemantics" ;
import "piccolo_grammar.gGrammar" ;

import semantics ipic18_build_binary_code in "ipic18_build_binary_code.gSemantics" ;
import semantics pic18_checkingAndBuildIPIC in "pic18_checkingAndBuildIPIC.gSemantics" ;
import semantics ipc18_convert_relatives in "ipc18_convert_relatives.gSemantics" ;
import semantics ipic18_optimizations in "ipic18_optimizations.gSemantics" ;
import semantics piccolo_config in "piccolo_config.gSemantics" ;
import semantics ram_sections in "ram_sections.gSemantics" ;

import grammar piccolo_grammar in "piccolo_grammar.gGrammar" ;

#----------------------------------------------------------------------------*
#                                                                            *
#       L I S T I N G   O F    G E N E R A T E D   C O D E                   *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_build_listing_of_generated_code
  ??@ipic18_instructionList inInstructionList
  ?!@string ioListFileContents
:
#--- Build symbol table
  @ipic18_symbolTable symbolTable [emptyMap] ;
  @uint currentAddress := 0 ;
  foreach inInstructionList do
    [mInstruction enterLabelAtAddress !?symbolTable !?currentAddress] ;
  end foreach ;
  ioListFileContents .= "*******************************************************************************\n" ;
  ioListFileContents .= "*                              GENERATED CODE                                 *\n" ;
  ioListFileContents .= "*******************************************************************************\n\n" ;
  ioListFileContents .= " Line  Address  Code      Assembly\n" ;
  @uint bccLabelIndex := 0 ;
  currentAddress := 0 ;
  foreach inInstructionList index idx do
    @stringlist lineList [emptyList] ;
    [mInstruction buildAssemblyCode !?lineList !?bccLabelIndex] ;
    @emittedCodeList code [emptyList] ;
    [mInstruction generateBinaryCodeAtAddress !symbolTable !?currentAddress !?code] ;
    loop [lineList length] :
    while [lineList length] > [code length] do
      code += ![@uintlist emptyList] ;
    end loop ;
    if [lineList length] != [code length] then
      error here : "internal error for listing line " . [idx string]
             . " : " . [[lineList length] string] . " != " . [[code length] string] ;
    end if ;
    foreach lineList, code do
      @string codeString := "" ;
      foreach mCode prefixedby code_ do
        codeString .= [[code_mValue xString] stringByLeftPadding !4 !'0'] . " " ;
      end foreach ;
      ioListFileContents .= [[idx string] stringByLeftPadding !5 !' '] . "  "
                         . [[currentAddress xString] stringByLeftPadding !6 !'0'] . " : "
                         . [codeString stringByRightPadding !10 !' ']
                         . mValue . "\n" ;
      currentAddress := currentAddress + [mCode length] * 2 ;
    end foreach ;
  end foreach ;
  ioListFileContents .= "\n*******************************************************************************\n" ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
#-------------------------------- Check source file name
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  @uint accessBankSplitOffset ;
  @ramBankTable ramBank ;
  @bootloaderReservedRAMmap bootloaderReservedRAMmap ; # Used only for bootloader implementation
  @routineDeclarationList bootloaderRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList userRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList bootloaderRoutineDeclarationListForUserProgramImplementation ;
  @routineDeclarationList userRoutineDeclarationListForUserProgramImplementation ;
  @luint bootloaderReservedROMsize ; # Used only for bootloader implementation or user program implementation, zero for regular program
  @registerTable registerTable ;
  switch [inPiccoloModel mProgramKind]
  when regularProgram : 
    parseDeviceDefinition ![inPiccoloModel mDeviceNameOrBootLoaderReference] ?piccoloDeviceModel ;
    switch [piccoloDeviceModel mProcessorType]
      when pic18_60 : accessBankSplitOffset := 0x60 ;
      when pic18_80 : accessBankSplitOffset := 0x80 ;
      when midrange : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a midrange device is not accepted here" : accessBankSplitOffset ;
      when baseline : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a baseline device is not accepted here" : accessBankSplitOffset ;
    end switch ;
    ramBank := [piccoloDeviceModel mRamBankTable] ;
    bootloaderReservedRAMmap := [@bootloaderReservedRAMmap emptyMap] ;
    registerTable := [piccoloDeviceModel mRegisterTable] ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    bootloaderReservedROMsize := [@luint new !0 !here] ;
  when bootloaderProgram :
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    grammar piccolo_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForBootloaderImplementation
      ?userRoutineDeclarationListForBootloaderImplementation
      ?bootloaderReservedROMsize
    ;
    foreach ramBank do #--- Reset first free addresses for all banks
      [!?ramBank setMFirstFreeAddressForKey !mFirstAddress ![lkey string]] ;
    end foreach ;
  when userProgram :
    grammar piccolo_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForUserProgramImplementation
      ?userRoutineDeclarationListForUserProgramImplementation
      ?bootloaderReservedROMsize
    ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
  end switch ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool highInterruptIsFast := false ;
  @bool hasLowInterrupt := false ;
  @bool lowInterruptIsFast := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
      error mInterruptName: "interrupt routine is not allowed for a bootloader user program" ;
    end if ;
    if [mInterruptName string] == "high" then
      highInterruptIsFast := mFastReturn ;
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      lowInterruptIsFast := mFastReturn ;
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
    if highInterruptIsFast & lowInterruptIsFast then
      error mInterruptName:"either low interrupt or high interrupt can be \"fast\", not both" ;
    end if ;
  end foreach ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
    foreach [inPiccoloModel mConfigDefinitionList] do
      error mDefinitionLocation: "configuration is not allowed for a bootloader user program" ;
    end foreach ;
    actualConfigurationMap := [@actualConfigurationMap emptyMap] ;
  else
    buildConfig
      ![piccoloDeviceModel mConfigRegisterMap]
      ![inPiccoloModel mConfigDefinitionList]
      ![inPiccoloModel mAcceptDefaultConfiguration]
      !?listFileContents
      ?actualConfigurationMap
    ;
  end if ;
#-------------------------------- Ram definition
  analyze_ram_sections
    !"DECLARED VARIABLES"
    ![inPiccoloModel mRamDefinitionList]
    !?ramBank
    ![piccoloDeviceModel mRegisterTable]
    !?listFileContents
    !?registerTable
  ;
#--- For bootloader implementation, check declared var footprint does not span beyond values declared in specification
  if [inPiccoloModel mProgramKind] == [@programKind bootloaderProgram] then
    foreach ramBank do
      if [bootloaderReservedRAMmap hasKey ![lkey string]] then
        @luint bootloaderReservedSize ;
        [bootloaderReservedRAMmap searchKey !lkey ?bootloaderReservedSize] ;
        if (mFirstFreeAddress - mFirstAddress) > [bootloaderReservedSize uint] then
          error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
          . [mFirstFreeAddress - mFirstAddress string]
          . " byte(s), althought the bootloader specification reserves "
          . [[bootloaderReservedSize uint] string]
          . " byte(s)" ;
        end if ;
      elsif mFirstFreeAddress > mFirstAddress then
        error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
        . [mFirstFreeAddress - mFirstAddress string]
        . " byte(s), althought the bootloader specification reserves no space" ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Build IPIC Assembly Instruction List
  @ipic18_instructionList generatedInstructionList ;
  build_ipic18_assembly_instruction_list
    ![inPiccoloModel mProgramKind]
    ![[[piccoloDeviceModel mRomSize] uint] sint]
    !bootloaderRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !userRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !bootloaderReservedROMsize
    !bootloaderRoutineDeclarationListForUserProgramImplementation
    !userRoutineDeclarationListForUserProgramImplementation
    !accessBankSplitOffset
    !registerTable
    !inPiccoloModel
    !hasHighInterrupt
    !hasLowInterrupt
    ?generatedInstructionList
    !?listFileContents
  ;
#-------------------------------- Perform Code Optimization
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations value] then
    performOptimizations !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Convert relative branchs to absolute, when needed
  if [@uint errorCount] == 0 then
    ipic18_convertRelativeBranchsToAbsoluteWhenNeeded !?generatedInstructionList !?listFileContents ;
  end if ;
#--- If no error, generate object file(s)
  if [@uint errorCount] == 0 then
  #--- Generate hex file
    @uint usedROMsize ;
    build_ipic18_binary_code
      !generatedInstructionList
      ![[piccoloDeviceModel mRomSize] uint]
      !actualConfigurationMap
      ?usedROMsize
    ;
    @string contents ;
    getGeneratedContents ?contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    if [option piccolo_options.output_C_Array value] then
      const @string baseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
      get_C_ArrayImplementation !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".c" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
      get_C_ArrayHeader !baseName ?contents ;
      destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".h" ;
      [contents writeToFileWhenDifferentContents !destinationFile ?*] ;
    end if ;
  #--- Write infos (if verbose mode)
    if [option.verbose_output value] then
      @string verboseMessage := "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " bytes;" ;
      verboseMessage .= " used: " . [usedROMsize string] . " bytes (" ;
      verboseMessage .= [(usedROMsize * 100) / [[piccoloDeviceModel mRomSize] uint] string] . "%).\n" ;
      foreach ramBank do
        @uint bankSize := mLastAddressPlusOne - mFirstAddress ;
        @uint usedSize := mFirstFreeAddress - mFirstAddress ;
        verboseMessage .= "  RAM bank '" . lkey . "': " ;
        verboseMessage .= [bankSize string] . " bytes, used " ;
        verboseMessage .= [usedSize string] . " bytes (" ;
        verboseMessage .= [(usedSize * 100) / bankSize string] . "%).\n" ;
      end foreach ;
      message verboseMessage ;
    end if ;
  #--- Generate asm file, if corresponding option enabled
    if [option piccolo_options.generateAssembly value] then
      @string assemblyCode ;
      pic18_build_assembly_code
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        !actualConfigurationMap
        ?assemblyCode
      ;
      @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !asmDestinationFile ?*] ;
    end if ;
  else # There are errors : delete hex and asm files
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [@string deleteFileIfExists !hexDestinationFile] ;
    @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
    [@string deleteFileIfExists !asmDestinationFile] ;
  end if ;
#-------------------------------- Write listing fule
  if [option piccolo_options.ouputListingFile value] then
    if [@uint errorCount] == 0 then
      pic18_build_listing_of_generated_code
        !generatedInstructionList
        !?listFileContents
      ;
    end if ;
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile ?*] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
