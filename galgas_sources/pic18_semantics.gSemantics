semantics pic18_semantics :
import "piccolo_config.gSemantics" ;
import "ram_sections.gSemantics" ;
import "pic18_grammar.gGrammar" ;
import "ipic18_build_block_representation.gSemantics" ;
import "pic18_used_routines.gSemantics" ;
import "piccolo_embedded_devices.gSemantics" ;
import "pic18_routine_inlining.gSemantics" ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine pic18_analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
#-------------------------------- Check source file name
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  @uint accessBankSplitOffset ;
  @ramBankTable ramBank ;
  @bootloaderReservedRAMmap bootloaderReservedRAMmap ; # Used only for bootloader implementation
  @routineDeclarationList bootloaderRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList userRoutineDeclarationListForBootloaderImplementation ;
  @routineDeclarationList bootloaderRoutineDeclarationListForUserProgramImplementation ;
  @routineDeclarationList userRoutineDeclarationListForUserProgramImplementation ;
  @luint bootloaderReservedROMsize ; # Used only for bootloader implementation or user program implementation, zero for regular program
  @registerTable registerTable ;
  @string piccoloDeviceName ;
  switch inPiccoloModel->mProgramKind
  when regularProgram :
    piccoloDeviceName := inPiccoloModel->mDeviceNameOrBootLoaderReference->string ;
    parseDeviceDefinition ![inPiccoloModel mDeviceNameOrBootLoaderReference] ?piccoloDeviceModel ;
    switch [piccoloDeviceModel mProcessorType]
      when pic18_60 : accessBankSplitOffset := 0x60 ;
      when pic18_80 : accessBankSplitOffset := 0x80 ;
      when midrange : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a midrange device is not accepted here" : accessBankSplitOffset ;
      when baseline : error [inPiccoloModel mDeviceNameOrBootLoaderReference]: "a baseline device is not accepted here" : accessBankSplitOffset ;
    end switch ;
    ramBank := [piccoloDeviceModel mRamBankTable] ;
    bootloaderReservedRAMmap := [@bootloaderReservedRAMmap emptyMap] ;
    registerTable := [piccoloDeviceModel mRegisterTable] ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    bootloaderReservedROMsize := [@luint new !0 !here] ;
  when bootloaderProgram :
    bootloaderRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForUserProgramImplementation := [@routineDeclarationList emptyList] ;
    grammar pic18_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?piccoloDeviceName
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForBootloaderImplementation
      ?userRoutineDeclarationListForBootloaderImplementation
      ?bootloaderReservedROMsize
    ;
    foreach ramBank do #--- Reset first free addresses for all banks
      [!?ramBank setMFirstFreeAddressForKey !mFirstAddress ![lkey string]] ;
    end foreach ;
  when userProgram :
    grammar pic18_grammar label importBootloaderSpecification in [inPiccoloModel mDeviceNameOrBootLoaderReference]
      ?piccoloDeviceModel
      ?piccoloDeviceName
      ?accessBankSplitOffset
      ?ramBank
      ?registerTable
      ?bootloaderReservedRAMmap
      ?bootloaderRoutineDeclarationListForUserProgramImplementation
      ?userRoutineDeclarationListForUserProgramImplementation
      ?bootloaderReservedROMsize
    ;
    bootloaderRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
    userRoutineDeclarationListForBootloaderImplementation := [@routineDeclarationList emptyList] ;
  end switch ;
#-------------------------------- Compute used routine set
  const @stringset usedRoutineSet := pic18_computeUsedRoutines [
    !inPiccoloModel->mInterruptDefinitionList
    !inPiccoloModel->mRoutineDefinitionList
    !bootloaderRoutineDeclarationListForBootloaderImplementation
    !userRoutineDeclarationListForUserProgramImplementation
  ] ;
  @declaredRoutineMap declaredRoutineMap [emptyMap] ;
  foreach inPiccoloModel->mRoutineDefinitionList do
    [!?declaredRoutineMap insertKey
      !mRoutineName
      !mRequiredBank
      !mReturnedBank
      !mPreservesBank
      !mIsNoReturn
      !mInstructionList
    ] ;
  end foreach ;
#-------------------------------- Check used routines
  @stringset unusedDeclarationUnicity [emptySet] ;
  foreach inPiccoloModel->mUnusedRoutineList do
    if not [declaredRoutineMap hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' routine is not declared" ;
    elsif [unusedDeclarationUnicity hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is already declared as unused" ;
    elsif [usedRoutineSet hasKey !mValue->string] then
      warning mValue : "the '" . mValue . "' routine is declared as unused, but is used" ;
    end if ;
    unusedDeclarationUnicity += !mValue->string ;
  end foreach ;
  foreach declaredRoutineMap do
    if (not [usedRoutineSet hasKey !lkey->string]) & (not [unusedDeclarationUnicity hasKey !lkey->string]) then
      warning lkey : "the '" . lkey . "' routine is unused" ;
    end if ;
  end foreach ;
#-------------------------------- inline routines
  @stringset inlinedRoutineSet [emptySet] ;
  foreach inPiccoloModel->mInlinedRoutineList do
    if not [declaredRoutineMap hasKey !mValue->string] then
      error mValue : "the '" . mValue . "' routine is not declared" ;
    elsif not [usedRoutineSet hasKey !mValue->string] then
      warning mValue : "useless declaration, the '" . mValue . "' routine is unused" ;
    else
      inlinedRoutineSet += !mValue->string ;
    end if ;
  end foreach ;
  @pic18InterruptDefinitionList interruptDefinitionList := inPiccoloModel->mInterruptDefinitionList ;
  @pic18RoutineDefinitionList routineDefinitionList := inPiccoloModel->mRoutineDefinitionList ;
  pic18PerformRoutineInline
    !inlinedRoutineSet
    !declaredRoutineMap
    !?interruptDefinitionList
    !?routineDefinitionList
  ;
#-------------------------------- Check 'checkpic' instructions
  foreach inPiccoloModel->mCheckpicList do
    @bool found := false ;
    foreach mValueList while not found do
      found := mValue->string == piccoloDeviceName ;
    end foreach ;
    if not found then
      error mErrorLocation: "this code is not available for '" . piccoloDeviceName . "'" ;
    end if ;
  end foreach ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool highInterruptIsFast := false ;
  @bool hasLowInterrupt := false ;
  @bool lowInterruptIsFast := false ;
  foreach interruptDefinitionList do
    if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
      error mInterruptName: "interrupt routine is not allowed for a bootloader user program" ;
    end if ;
    if [mInterruptName string] == "high" then
      highInterruptIsFast := mFastReturn ;
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      lowInterruptIsFast := mFastReturn ;
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
    if highInterruptIsFast & lowInterruptIsFast then
      error mInterruptName:"either low interrupt or high interrupt can be \"fast\", not both" ;
    end if ;
  end foreach ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  if [inPiccoloModel mProgramKind] == [@programKind userProgram] then
    foreach [inPiccoloModel mConfigDefinitionList] do
      error mDefinitionLocation: "configuration is not allowed for a bootloader user program" ;
    end foreach ;
    actualConfigurationMap := [@actualConfigurationMap emptyMap] ;
  else
    buildConfig
      ![piccoloDeviceModel mConfigRegisterMap]
      ![inPiccoloModel mConfigDefinitionList]
      !?listFileContents
      ?actualConfigurationMap
    ;
  end if ;
#-------------------------------- Ram definition
  analyze_ram_sections
    !"DECLARED VARIABLES"
    ![inPiccoloModel mRamDefinitionList]
    !?ramBank
    ![piccoloDeviceModel mRegisterTable]
    !?listFileContents
    !?registerTable
    ??@declaredByteMap declaredByteMap
  ;
#--- For bootloader implementation, check declared var footprint does not span beyond values declared in specification
  if [inPiccoloModel mProgramKind] == [@programKind bootloaderProgram] then
    foreach ramBank do
      if [bootloaderReservedRAMmap hasKey ![lkey string]] then
        @luint bootloaderReservedSize ;
        [bootloaderReservedRAMmap searchKey !lkey ?bootloaderReservedSize] ;
        if (mFirstFreeAddress - mFirstAddress) > [bootloaderReservedSize uint] then
          error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
          . [mFirstFreeAddress - mFirstAddress string]
          . " byte(s), althought the bootloader specification reserves "
          . [[bootloaderReservedSize uint] string]
          . " byte(s)" ;
        end if ;
      elsif mFirstFreeAddress > mFirstAddress then
        error here: "for '" . lkey . "' RAM bank, the bootloader implementation declares "
        . [mFirstFreeAddress - mFirstAddress string]
        . " byte(s), althought the bootloader specification reserves no space" ;
      end if ;
    end foreach ;
  end if ;
#-------------------------------- Compute RAM size
  @uint RAMsize := 0 ;
  foreach ramBank do
    if mLastAddressPlusOne > RAMsize then
      RAMsize := mLastAddressPlusOne ;
    end if ;
  end foreach ;
#-------------------------------- Build block representation
  build_ipic18_block_representation_list
    !inSourceFileName
    ![piccoloDeviceModel->mRomSize->uint sint64]
    ![RAMsize sint64]
    !bootloaderRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !userRoutineDeclarationListForBootloaderImplementation # Empty for regular program
    !bootloaderReservedROMsize
    !bootloaderRoutineDeclarationListForUserProgramImplementation
    !userRoutineDeclarationListForUserProgramImplementation
    !accessBankSplitOffset
    !registerTable
    !declaredByteMap
    !routineDefinitionList
    !inPiccoloModel->mProgramKind
    !inPiccoloModel->mConstantDefinitionList
    !inPiccoloModel->mDataList
    !interruptDefinitionList
    !inPiccoloModel->mUnusedRegisterList
    !ramBank
    !hasHighInterrupt
    !hasLowInterrupt
    !piccoloDeviceModel->mDeviceName->string
    !piccoloDeviceModel->mRegisterTable
    !actualConfigurationMap
    !inPiccoloModel->mEndOfProgram
    !?listFileContents
  ;
#-------------------------------- Write listing file
  if [option piccolo_options.ouputListingFile value] then
    listFileContents .= "*******************************************************************************\n" ;
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile ?*] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
