syntax pic18_syntax ("piccolo_lexique.gLexique") :
import "pic18_metamodel.gSemantics" ;
import "pic18_semantics.gSemantics" ;
import "pic18_include_grammar.gGrammar" ;

#----------------------------------------------------*

nonterminal <configuration_definition>
  ?!@configDefinitionList ioConfigDefinitionList
;

nonterminal <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
;

nonterminal <constant_definition>
  ?!@constantDefinitionList ioConstantDefinitionList
;

nonterminal <immediate_expression>
  !@immediatExpression outExpression
;

nonterminal <register_parsing>
  !@registerExpression outRegisterExpression
;

nonterminal <optional_w_as_dest>
  !@bool out_W_isDestination
;

nonterminal <bit_number_parsing>
  !@bitNumberExpression outBitNumber
;

#----------------------------------------------------*

rule <body>
  ?!@pic18InterruptDefinitionList interruptDefinitionList
  ?!@pic18RoutineDefinitionList routineDefinitionList
  ?!@lstringlist unusedRoutineList
  ?!@lstringlist inlinedRoutineList
  ?!@ramDefinitionList ramDefinitionList
  ?!@lstringlist unusedRegisterList
  ?!@configDefinitionList configDefinitionList
  ?!@constantDefinitionList constantDefinitionList
  ?!@checkpicList ioCheckpicList
  ?!@dataList dataList
  ?!@bool needsComputedGoto2
  ?!@bool needsComputedGoto4
:
  repeat
  while
    $mark$ ;
    $literal_string$ ?@lstring s ;
    warning s : "obsolete construct: use a comment beginning by #!" ;
  while
    $unused$ ;
    $byte$ ;
    repeat
      $identifier$ ?@lstring unusedRegister ;
      unusedRegisterList += !unusedRegister ;
    while 
      $,$ ;
    end repeat ;
  while
    $unused$ ;
    $routine$ ;
    repeat
      $identifier$ ?@lstring unusedRoutine ;
      unusedRoutineList += !unusedRoutine ;
    while 
      $,$ ;
    end repeat ;
  while
    $inline$ ;
    repeat
      $identifier$ ?@lstring inlinedRoutine ;
      inlinedRoutineList += !inlinedRoutine ;
    while 
      $,$ ;
    end repeat ;
  while
    <configuration_definition> !?configDefinitionList ;
  while
    <ram_definition> !?ramDefinitionList ;
  while
    <constant_definition> !?constantDefinitionList ;
  while
    <interrupt_definition>
      !?interruptDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  while
    <routine_definition>
      !?routineDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  while
    <data_definition> !?dataList ;
  while
    <checkpic_definition> !?ioCheckpicList ;
  while
    $include$ ;
    $literal_string$ ?@lstring includedFilePath ;
    grammar pic18_include_grammar in includedFilePath
      !?interruptDefinitionList
      !?routineDefinitionList
      !?unusedRoutineList
      !?inlinedRoutineList
      !?ramDefinitionList
      !?unusedRegisterList
      !?configDefinitionList
      !?constantDefinitionList
      !?ioCheckpicList
      !?dataList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
    end repeat ;
end rule ;

#----------------------------------------------------*

rule <checkpic_definition>
  ?!@checkpicList ioList
:
  $checkpic$ ;
  const @location loc := here ;
  @lstringlist valueList [emptyList] ;
  repeat
    $literal_string$ ?@lstring s ;
    valueList += !s ;
  while
    $,$ ;
  end repeat ;
  ioList += !loc !valueList ;
end rule ;
    
#----------------------------------------------------*

rule <data_definition>
  ?!@dataList ioDataList
:
  $data$ ;
  $identifier$ ? @lstring dataName ;
  ${$ ;
  @immediatExpressionList valueList [emptyList] ;
  repeat
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    valueList += !expression !here ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ioDataList += !dataName !valueList ;
end rule ;
    
#----------------------------------------------------*

rule <instruction_list>
  !@pic18InstructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  outInstructionList := [@pic18InstructionList emptyList] ;
  repeat
  while
    <simple_instruction> ??@pic18PiccoloSimpleInstruction instruction ;
    outInstructionList += !instruction ;
  while
    @pic18PiccoloInstruction instruction ;
    <structured_instruction>
      ?instruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    outInstructionList += !instruction ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <interrupt_definition>
  ?!@pic18InterruptDefinitionList ioInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $interrupt$ ;
  $identifier$ ? @lstring interruptName ;
  @bool isFast ;
  select
    isFast := false ;
  or
    $fast$ ;
    isFast := true ;
  end select ;
  ${$ ;
  @pic18InstructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioInterruptDefinitionList += !interruptName !isFast !instructionList !here ;
end rule ;

#----------------------------------------------------*

rule <routine_definition>
  ?!@pic18RoutineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  @bool noreturn ;
  select
    noreturn := false ;
  or
    $noreturn$ ;
    noreturn := true ;
  end select ;
  $routine$ ;
  $identifier$ ? @lstring routineName ;
  @luint requiredBank ;
  @luint returnedBank ;
  @bool preservesBank ;
  select
    requiredBank := [@luint new ![@uint max] !here] ;
    returnedBank := [@luint new ![@uint max] !here] ;
    preservesBank := false ;
  or
    $bank$ ;
    $:$ ;
    select
      $preserved$ ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:preserved\" setting" ;
      end if ;
      preservesBank := true ;
      requiredBank := [@luint new ![@uint max] !here] ;
      returnedBank := [@luint new ![@uint max] !here] ;
    or
      $requires$ ;
      $integer$ ? requiredBank ;
      preservesBank := false ;
      select
        returnedBank := [@luint new ![@uint max] !here] ;
      or
        $ensures$ ;
        $integer$ ? returnedBank ;
        if noreturn then
          error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
        end if ;
      end select ;
    or
      $ensures$ ;
      $integer$ ? returnedBank ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
      end if ;
      preservesBank := false ;
      requiredBank := [@luint new ![@uint max] !here] ;
    end select ;
  end select ;
  ${$ ;
  @pic18InstructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioRoutineDefinitionList += !routineName !requiredBank !returnedBank !preservesBank !noreturn !instructionList !here ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition
:
  $!$ ;
  @pic18ConditionExpression condition ;
  <condition_factor> ? condition ;
  outCondition := [@pic18NegateCondition new !condition] ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition
:
  <condition_expression> ? outCondition ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@pic18ConditionExpression outCondition
:
  select
    @bool isIncrement ;
    select
      $incf$ ; isIncrement := true ;
    or
      $decf$ ; isIncrement := false ;
    end select ;
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @bool W_isDestination ;
    select
      W_isDestination := false ;
    or
      $,$ ; $w$ ; W_isDestination := true ;
    end select ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      : branchIfZero
      ;
    end if ;
    outCondition := [@pic18IncDecRegisterInCondition new
      !registerExpression
      !isIncrement
      !W_isDestination
      !branchIfZero
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @pic18RegisterComparison comparison ;
    select
      $!=$ ; $w$ ; comparison := [@pic18RegisterComparison notEqual] ;
    or
      $==$ ; $w$ ; comparison := [@pic18RegisterComparison equal] ;
    or
      $<=$ ; $w$ ; comparison := [@pic18RegisterComparison lowerOrEqual] ;
    or
      $>=$ ; $w$ ; comparison := [@pic18RegisterComparison greaterOrEqual] ;
    or
      $<$  ; $w$ ; comparison := [@pic18RegisterComparison lower] ;
    or
      $>$  ; $w$ ; comparison := [@pic18RegisterComparison greater] ;
    end select ;
    outCondition := [@pic18RegisterComparisonCondition new
      !registerExpression
      !comparison
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    $.$ ;
    @bitNumberExpression bitNumberExpression ;
    <bit_number_parsing> ?bitNumberExpression ;
    @bool BTFSSinstruction ;
    select
      BTFSSinstruction := false ;
    or
      $identifier$ ? @lstring conditionString ;
      @string condition := [[conditionString string] uppercaseString] ;
      if condition == "Z" then
        BTFSSinstruction := true ;
        @string s := "! " . [[registerExpression mRegisterName] string] ;
        if [[registerExpression mOffset] uint] > 0 then
          s .= " [" . [[[registerExpression mOffset] uint] string] . "]" ;
        end if ;
        s .= "." ; [bitNumberExpression display !?s] ;
        warning conditionString: "In Piccolo 1.2.0 and later, this construction is deprecated; use '" . s . "' instead" ; 
      elsif condition == "NZ" then
        BTFSSinstruction := false ;
        @string s := [[registerExpression mRegisterName] string] ;
        if [[registerExpression mOffset] uint] > 0 then
          s .= " [" . [[[registerExpression mOffset] uint] string] . "]" ;
        end if ;
        s .= "." ; [bitNumberExpression display !?s] ;
        warning conditionString: "In Piccolo 1.2.0 and later, this construction is deprecated; use '" . s . "' instead" ; 
      else
        error conditionString: "invalid '" . conditionString
        . "' condition; valid ones are: 'z' and 'nz'"
        : BTFSSinstruction
        ;
      end if ;
    end select ;
    outCondition := [@pic18BitTestInStructuredCondition new
      !registerExpression
      !bitNumberExpression
      !BTFSSinstruction
    ] ;
  or
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      : branchIfZero
      ;
    end if ;
    outCondition := [@pic18RegisterTestCondition new !registerName !branchIfZero] ;
  or
    @conditional_branch conditional_branch ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      conditional_branch := [@conditional_branch bz] ;
    elsif condition == "NZ" then
      conditional_branch := [@conditional_branch bnz] ;
    elsif condition == "NN" then
      conditional_branch := [@conditional_branch bnn] ;
    elsif condition == "N" then
      conditional_branch := [@conditional_branch bn] ;
    elsif condition == "C" then
      conditional_branch := [@conditional_branch bc] ;
    elsif condition == "NC" then
      conditional_branch := [@conditional_branch bnc] ;
    elsif condition == "OV" then
      conditional_branch := [@conditional_branch bov] ;
    elsif condition == "NOV" then
      conditional_branch := [@conditional_branch bnov] ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      : conditional_branch
      ;
    end if ;
    outCondition := [@pic18BccInStructuredCondition new !conditionString->location !conditional_branch] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <condition_expression>
  !@pic18ConditionExpression outCondition
:
  $($ ;
  <condition_term> ? outCondition ;
  repeat
  while
    $|$ ;
    @pic18ConditionExpression c ;
    <condition_term> ? c ;
    @pic18ConditionExpression rc := [@pic18NegateCondition new !c] ;
    @pic18ConditionExpression lc := [@pic18NegateCondition new !outCondition] ;
    outCondition := [@pic18NegateCondition new ![@pic18AndCondition new !lc !rc]] ;
  end repeat ;
  $)$ ;
end rule ;

#----------------------------------------------------*

rule <condition_term>
  !@pic18ConditionExpression outCondition
:
  <condition_factor> ? outCondition ;
  repeat
  while
    $&$ ;
    @pic18ConditionExpression c ;
    <condition_factor> ? c ;
    outCondition := [@pic18AndCondition new !outCondition !c] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <structured_instruction>
  !@pic18PiccoloInstruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  select
    $ldataptr$ ;
    @location instructionLocation := here ;
    $identifier$ ?@lstring dataName ;
    $[$ ;
    $integer$ ? @luint dataIndex ;
    $]$ ;
    outInstruction := [@pic18Instruction_LDATAPTR new !instructionLocation !dataName !dataIndex] ;
  or
    $ltblptr$ ;
    @location instructionLocation := here ;
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    outInstruction := [@pic18Instruction_LTBLPTR new !instructionLocation !expression] ;
  or
    $banksel$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint bank ;
    @bool warningOnUselessBanksel ;
    select
      warningOnUselessBanksel := true ;
    or
      $,$ ;
      $*$ ;
      warningOnUselessBanksel := false ;
    end select ;
    outInstruction := [@pic18Instruction_banksel new ! instructionLocation !bank !warningOnUselessBanksel] ;
  or
    $banksel$ ;
    @location instructionLocation := here ;
    <register_parsing> ?@registerExpression register ;
    @bool warningOnUselessBanksel ;
    select
      warningOnUselessBanksel := true ;
    or
      $,$ ;
      $*$ ;
      warningOnUselessBanksel := false ;
    end select ;
    outInstruction := [@pic18Instruction_banksel_register new !instructionLocation !register !warningOnUselessBanksel] ;
  or
    $nobank$ ;
    outInstruction := [@pic18Instruction_nobanksel new !here] ;
  or
    $banksave$ ;
    @location instructionLocation := here ;
    <register_parsing> ?@registerExpression register ;
    @pic18InstructionList instructionList ;
    <instruction_list> ?instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@pic18Instruction_savebank new
      !instructionLocation
      !register
      !instructionList
      !here
    ] ;
  or
    $computed$ ;
    @location instructionLocation := here ;
    $[$ ;
    @immediatExpression sizeExpression ;
    <immediate_expression> ?sizeExpression ;
    $]$ ;
    select
      $retlw$ ;
      @immediatExpressionList argumentList [emptyList] ;
      repeat
        @immediatExpression expression ;
        <immediate_expression> ?expression ;
        argumentList += !expression !here ;
      while
        $,$ ;
      end repeat ;
      outInstruction := [@pic18Instruction_computed_retlw new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto2 := true ;
    or
      $bra$ ;
      @lstringlist argumentList [emptyList] ;
      repeat
        $identifier$ ? @lstring targetRoutine ;
        argumentList += ! targetRoutine ;
      while
        $,$ ;
     end repeat ;
       outInstruction := [@pic18Instruction_computed_bra new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto2 := true ;
    or
      $goto$ ;
      @lstringlist argumentList [emptyList] ;
      repeat
        $identifier$ ? @lstring targetRoutine ;
        argumentList += ! targetRoutine ;
      while
        $,$ ;
      end repeat ;
      outInstruction := [@pic18Instruction_computed_goto new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto4 := true ;
    or
      $rcall$ ;
      @lstringlist argumentList [emptyList] ;
      repeat
        $identifier$ ? @lstring targetRoutine ;
        argumentList += ! targetRoutine ;
      while
        $,$ ;
      end repeat ;
      outInstruction := [@pic18Instruction_computed_rcall new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto4 := true ;
    end select ;
  or
    $forever$ ;
    @location instructionLocation := here ;
    @pic18InstructionList instructionList ;
    <instruction_list> ?instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@pic18Instruction_FOREVER new
      !instructionLocation
      !instructionList
      !here
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @if_semi_colon_op opCode ;
    select
      $!=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSEQ] ;
    or
      $<=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSGT] ;
    or
      $>=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSLT] ;
    or
      $identifier$ ? @lstring conditionString ;
      @string condition := [[conditionString string] uppercaseString] ;
      if condition != "NZ" then
        error conditionString:"invalid '" . condition . "' condition; it should be 'nz'" ;
      end if ;
      opCode := [@if_semi_colon_op TSTFSZ] ;
    end select ;
    $:$ ;
    <simple_instruction> ??@pic18PiccoloSimpleInstruction instruction ;
    outInstruction := [@pic18Instruction_IF_FA_SEMI_COLON new
      !instructionLocation
      !instruction
      !opCode
      !registerName
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    @bitNumberExpression bitNumber ;
    @bool skipIfSet ;
    select
      $!$ ;
      <register_parsing> ?registerName ;
      $.$ ;
      <bit_number_parsing> ?bitNumber ;
       skipIfSet := true ;
    or
      <register_parsing> ?registerName ;
      $.$ ;
      <bit_number_parsing> ?bitNumber ;
      select
        skipIfSet := false ;
      or
        $identifier$ ? @lstring conditionString ;
        @string condition := [[conditionString string] uppercaseString] ;
        if condition == "Z" then
          skipIfSet := true ;
          @string s := "if ! " . [registerName mRegisterName] ;
          if [[registerName mOffset] uint] > 0 then
            s .= " [" . [[[registerName mOffset] uint] string] . "]" ;
          end if ;
          s .= "." ; [bitNumber display !?s] ;
          s .= " :" ;
          warning conditionString: "In Piccolo 1.2.0 and later, this construction is deprecated; use '" . s . "' instead" ; 
        elsif condition == "NZ" then
          skipIfSet := false ;
          @string s := "if " . [registerName mRegisterName] ;
          if [[registerName mOffset] uint] > 0 then
            s .= " [" . [[[registerName mOffset] uint] string] . "]" ;
          end if ;
          s .= "." ; [bitNumber display !?s] ;
          s .= " :" ;
          warning conditionString: "In Piccolo 1.2.0 and later, this construction is deprecated; use '" . s . "' instead" ; 
        else
          error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" : skipIfSet ;
        end if ;
      end select ;
    end select ;
    $:$ ;
    <simple_instruction> ??@pic18PiccoloSimpleInstruction instruction ;
    outInstruction := [@pic18Instruction_IF_BitTest new
      !instructionLocation
      !instruction
      !skipIfSet
      !registerName
      !bitNumber
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @bool increment ;
    select
      $decf$ ; increment := false ;
    or
      $incf$ ; increment := true ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool w_isTarget ;
    select
      w_isTarget := false ;
    or
      $,$ ; $w$ ; w_isTarget := true ;
    end select ;
    @bool skipIfZero ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      skipIfZero := false ;
    elsif condition == "NZ" then
      skipIfZero := true ;
    else
      error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" : skipIfZero ;
    end if ;
    $:$ ;
    <simple_instruction> ??@pic18PiccoloSimpleInstruction instruction ;
    outInstruction := [@pic18Instruction_IF_IncDec new
      !instructionLocation
      !instruction
      !increment
      !skipIfZero
      !registerName
      !w_isTarget
    ] ;
  or
    $if$ ;
    <structured_if_instruction>
      ?outInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    $end$ ;
  or
    $do$ ;
    @location instructionLocation := here ;
    @pic18InstructionList repeatedInstructionList ;
    <instruction_list>
      ?repeatedInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    @location endOfRepeatedInstructionList := here ;
    @pic18DoWhilePartList whilePartList [emptyList] ;
    repeat
      $while$ ;
      @pic18ConditionExpression whileCondition ;
      <condition_expression> ?whileCondition ;
      @pic18InstructionList instructionList ;
      <instruction_list>
        ?instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
      whilePartList += !whileCondition !instructionList !here ;
    while
    end repeat ;
    $end$ ;
    outInstruction := [@pic18Instruction_do_while new
      !instructionLocation
      !repeatedInstructionList
      !endOfRepeatedInstructionList
      !whilePartList
    ] ;
  or
    $mnop$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint occurrenceFactor ;
    outInstruction := [@pic18Instruction_MNOP new !instructionLocation !occurrenceFactor] ;
  or
    @conditional_branch condition ;
    select
      $bc$ ; condition := [@conditional_branch bc] ;
    or
      $bnc$ ; condition := [@conditional_branch bnc] ;
    or
      $bn$ ; condition := [@conditional_branch bn] ;
    or
      $bnn$ ; condition := [@conditional_branch bnn] ;
    or
      $bov$ ; condition := [@conditional_branch bov] ;
    or
      $bnov$ ; condition := [@conditional_branch bnov] ;
    or
      $bz$ ; condition := [@conditional_branch bz] ;
    or
      $bnz$ ; condition := [@conditional_branch bnz] ;
    end select ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JUMPCC new
      !instructionLocation
      !targetLabelName
      !condition
      !true
    ] ;
  or
    $jump$ ;
    @location instructionLocation := here ;
    @conditional_branch conditional_branch ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      conditional_branch := [@conditional_branch bz] ;
    elsif condition == "NZ" then
      conditional_branch := [@conditional_branch bnz] ;
    elsif condition == "NN" then
      conditional_branch := [@conditional_branch bnn] ;
    elsif condition == "N" then
      conditional_branch := [@conditional_branch bn] ;
    elsif condition == "C" then
      conditional_branch := [@conditional_branch bc] ;
    elsif condition == "NC" then
      conditional_branch := [@conditional_branch bnc] ;
    elsif condition == "OV" then
      conditional_branch := [@conditional_branch bov] ;
    elsif condition == "NOV" then
      conditional_branch := [@conditional_branch bnov] ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      : conditional_branch
      ;
    end if ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JUMPCC new
      !instructionLocation
      !targetLabelName
      !conditional_branch
      !false
    ] ;
  or
    $jump$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind ipicRelative]
    ] ;
  or
    $goto$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind absolute]
    ] ;
  or
    $bra$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind relative]
    ] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <structured_if_instruction>
  !@pic18PiccoloInstruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  @location instructionLocation := here ;
  @pic18ConditionExpression structured_if_condition ;
  <condition_expression> ?structured_if_condition ;
  @pic18InstructionList thenInstructionList ;
  <instruction_list>
    ?thenInstructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  @pic18InstructionList elseInstructionList ;
  select
    elseInstructionList := [@pic18InstructionList emptyList] ;
  or
    $elsif$ ;
    @pic18PiccoloInstruction elsifPartInstruction ;
    <structured_if_instruction>
      ?elsifPartInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    elseInstructionList := [@pic18InstructionList emptyList] ;
    elseInstructionList += !elsifPartInstruction ;
  or
    $else$ ;
    <instruction_list>
      ?elseInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
  end select ;
  @location endOfElsePartLocation := here ;
  outInstruction := [@pic18Instruction_structured_if new
    !instructionLocation
    !structured_if_condition
    !thenInstructionList
    !elseInstructionList
    !endOfElsePartLocation
  ] ;
end rule ;

#----------------------------------------------------*

rule <simple_instruction> !@pic18PiccoloSimpleInstruction outInstruction :
  select
    @pic18Instruction_FDA_base_code_AST baseCode ;
    select
      $addwf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST ADDWF] ;
    or
      $addwfc$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST ADDWFC] ;
    or
      $andwf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST ANDWF] ;
    or
      $comf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST COMF] ;
    or
      $decf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST DECF] ;
    or
      $incf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST INCF] ;
    or
      $iorwf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST IORWF] ;
    or
      $movf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST MOVF] ;
    or
      $rlcf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST RLCF] ;
    or
      $rlncf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST RLNCF] ;
    or
      $rrcf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST RRCF] ;
    or
      $rrncf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST RRNCF] ;
    or
      $subfwb$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST SUBFWB] ;
    or
      $subwf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST SUBWF] ;
    or
      $subwfb$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST SUBWFB] ;
    or
      $swapf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST SWAPF] ;
    or
      $xorwf$ ;
      baseCode := [@pic18Instruction_FDA_base_code_AST XORWF] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool W_isDestination ;
    <optional_w_as_dest> ?W_isDestination ;
    outInstruction := [@pic18Instruction_FDA new
      !instructionLocation
      !baseCode
      !registerName
      !W_isDestination
    ] ;
  or
    @FA_instruction_base_code FAinstruction ;
    select
      $clrf$ ;
      FAinstruction := [@FA_instruction_base_code CLRF] ;
    or
      $movwf$ ;
      FAinstruction := [@FA_instruction_base_code MOVWF] ;
    or
      $mulwf$ ;
      FAinstruction := [@FA_instruction_base_code MULWF] ;
    or
      $negf$ ;
      FAinstruction := [@FA_instruction_base_code NEGF] ;
    or
      $setf$ ;
      FAinstruction := [@FA_instruction_base_code SETF] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@pic18Instruction_FA new
      !instructionLocation
      !FAinstruction
      !registerName
    ] ;
  or
    $movff$ ;
    @location instructionLocation := here ;
    @registerExpression sourceRegisterName ;
    <register_parsing> ?sourceRegisterName ;
    $,$ ;
    @registerExpression destinationRegisterName ;
    <register_parsing> ? destinationRegisterName ;
    outInstruction := [@pic18Instruction_MOVFF new
      !instructionLocation
      !sourceRegisterName
      !destinationRegisterName
    ] ;
  or
    @bit_oriented_op bitOrientedOp ;
    select
      $bcf$ ; bitOrientedOp := [@bit_oriented_op BCF] ;
    or
      $bsf$ ; bitOrientedOp := [@bit_oriented_op BSF] ;
    or
      $btg$ ; bitOrientedOp := [@bit_oriented_op BTG] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@pic18Instruction_FBA new
      !instructionLocation
      !bitOrientedOp
      !registerName
      !bitNumber
    ] ;
  or
    $jsr$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind ipicRelative]
    ] ;
  or
    $call$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind absolute]
    ] ;
  or
    $rcall$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pic18Instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind relative]
    ] ;
  or
    $clrwdt$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind CLRWDT]] ;
  or
    $daw$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind DAW]] ;
  or
    $nop$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind NOP]] ;
  or
    $pop$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind POP]] ;
  or
    $push$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind PUSH]] ;
  or
    $reset$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind RESET]] ;
  or
    $sleep$ ;
    outInstruction := [@pic18Instruction_withNoOperand new !here ![@pic18InstructionWithNoOperandKind SLEEP]] ;
  or
    @literal_instruction_opcode literalInstruction ;
    select
      $addlw$ ; literalInstruction := [@literal_instruction_opcode ADDLW] ;
    or
      $andlw$ ; literalInstruction := [@literal_instruction_opcode ANDLW] ;
    or
      $iorlw$ ; literalInstruction := [@literal_instruction_opcode IORLW] ;
    or
      $movlw$ ; literalInstruction := [@literal_instruction_opcode MOVLW] ;
    or
      $mullw$ ; literalInstruction := [@literal_instruction_opcode MULLW] ;
    or
      $sublw$ ; literalInstruction := [@literal_instruction_opcode SUBLW] ;
    or
      $xorlw$ ; literalInstruction := [@literal_instruction_opcode XORLW] ;
    end select ;
    @location instructionLocation := here ;
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    outInstruction := [@pic18Instruction_literalOperation new
      !instructionLocation
      !literalInstruction
      !expression
    ] ;
  or
    $lfsr$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint FSRindex ;
    $,$ ;
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    outInstruction := [@pic18Instruction_LFSR new !instructionLocation !FSRindex !expression] ;
  or
    $tblrd$ ;
    @location instructionLocation := here ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@pic18Instruction_TBLRD new !instructionLocation !accessOption] ;
  or
    $tblwt$ ;
    @location instructionLocation := here ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@pic18Instruction_TBLWT new !instructionLocation !accessOption] ;
  end select ;
end rule ;

#----------------------------------------------------*

end syntax ;
