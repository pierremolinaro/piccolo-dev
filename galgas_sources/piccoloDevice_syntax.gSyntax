syntax piccoloDevice_syntax ("piccoloDevice_lexique.gLexique") :
import "piccoloDevice_semantics.gSemantics" ;

#----------------------------------------------------*

nonterminal <start_symbol>
  !@piccoloDeviceModel outPiccoloModel
;

#----------------------------------------------------*

rule <start_symbol>
  !@piccoloDeviceModel outPiccoloDeviceModel
:
  $controller$ ;
  $identifier$ ? @lstring deviceName ;
  ${$ ;
  $processor$ ;
  @processorType processorType ;
  $string$ ? @lstring processorName ;
  if [processorName string] == "pic18_60" then
    processorType := [@processorType pic18_60] ;
  elsif [processorName string] == "pic18_80" then
    processorType := [@processorType pic18_80] ;
  elsif [processorName string] == "mid-range" then
    processorType := [@processorType midrange] ;
  elsif [processorName string] == "baseline" then
    processorType := [@processorType baseline] ;
  else
    error here : "The '" . processorName . "' processor is not handled" : processorType ;
  end if ;
  $;$ ;
  $romsize$ ;
  $integer$ ? @luint romSize ;
  $;$ ;
  @uint eepromSize ;
  @uint eepromAddress ;
  select
    eepromSize := 0 ;
    eepromAddress := 0 ;
  or
    $eepromsize$ ;
    $integer$ ? @luint l_eepromSize ;
    eepromSize := [l_eepromSize uint] ;
    $at$ ;
    $integer$ ? @luint l_eepromAddress ;
    eepromAddress := [l_eepromAddress uint] ;
    $;$ ;
  end select ;
  $bank$ ;
  $integer$ ? @luint bankCount ;
  $;$ ;
  repeat
  while
    $unusedregister$ ;
    $integer$ ? @luint unusedRegisterStart ;
    select
    or
     $to$ ;
     $integer$ ? @luint unusedRegisterEnd ;
    end select ;
    $;$ ;
  end repeat ;
  @ramBankTable ramBankTable [emptyMap] ;
  repeat
  while
    $ram$ ;
    $identifier$ ? @lstring ramName ;
    $:$ ;
    $integer$ ? @luint ramStart ;
    $to$ ;
    $integer$ ? @luint ramEnd ;
    @uintlist mirrorOffsetList [emptyList] ;
    select
    or
      $mirrorat$ ;
      repeat
        $integer$ ? @luint mirrorStartAddress ;
        mirrorOffsetList += ![mirrorStartAddress uint] - [ramStart uint] ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
    [!?ramBankTable insertKey
      !ramName
      ![ramStart uint] # Start
      ![ramStart uint] # First free address (mutable)
      ![ramEnd uint] + 1
      !mirrorOffsetList
    ] ;
  end repeat ;
  @registerTable registerTable [emptyMap] ;
  repeat
  while
    $register$ ;
    $identifier$ ? @lstring registerName ;
    $at$ ;
    @uintlist registerAddressList [emptyList] ;
    repeat
      $integer$ ? @luint registerAddress ;
      registerAddressList += ![registerAddress uint] ;
    while
      $,$ ;
    end repeat ;
    $<$ ;
    @uint sliceIndex := 8 ;
    @bitSliceTable bitSliceTable [emptyMap] ;
    @string bitDefinitionString := " <" ;
    repeat
      select
        @uint sliceWidth := 0 ; # Means undefined
        repeat
          @uint sliceBase := sliceIndex ;
          $identifier$ ? @lstring sliceName ;
          select
            if (sliceWidth != 0) & (sliceWidth != 1) then
              error sliceName:"a slice of 1 bit is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := 1 ;
            bitDefinitionString .= [sliceName string] ; 
          or
            $[$ ;
            $integer$ ? @luint sliceSize ;
            if (sliceWidth != 0) & (sliceWidth != [sliceSize uint]) then
              error sliceName:"a slice of " . [sliceWidth string] . " bits is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := [sliceSize uint] ;
            sliceBase := sliceBase + 1 - [sliceSize uint] ;
            $]$ ;
            bitDefinitionString .= [sliceName string] . "[" . [[sliceSize uint] string] . "]" ; 
          end select ;
          [!?bitSliceTable insertKey !sliceName !sliceIndex-sliceWidth !sliceWidth] ;
        while
          $/$ ;
          bitDefinitionString .= "/" ;
        end repeat ;
        sliceIndex := sliceIndex - sliceWidth ;
      or
        $-$ ;
        bitDefinitionString .= "-" ;
        sliceIndex -- ;
      end select ;
    while
      $,$ ;
      bitDefinitionString .= ", " ; 
    end repeat ;
    if sliceIndex != 0 then
      error registerName:"Incorrect bit definition for register '" . registerName . "'" ;
    end if ;
    bitDefinitionString .= ">" ;
    $>$ ;
    [!?registerTable insertKey !registerName !registerAddressList !1 !bitSliceTable !bitDefinitionString] ;
    $;$ ;
  end repeat ;
  @configRegisterMap configRegisterMap [emptyMap] ;
  repeat
  while
    $configuration$ ;
    $identifier$ ? @lstring configRegisterName ;
    $at$ ;
    $integer$ ? @luint configRegisterAddress ;
    $width$ ;
    $integer$ ? @luint configRegisterWidth ;
    @illegalMaskList illegalMaskList [emptyList] ;
    repeat
    while
      $illegal$ ;
      $integer$ ? @luint illegalValue ;
      $mask$ ;
      $integer$ ? @luint illegalMask ;
      $message$ ;
      $string$ ? @lstring illegalDescriptionString ;
      illegalMaskList += !illegalValue !illegalMask !illegalDescriptionString ;
    end repeat ;
    ${$ ;
    @configRegisterMaskMap configRegisterMaskMap [emptyMap] ;
    @stringset settingNameSet [emptySet] ;
    repeat
    while
      $identifier$ ? @lstring maskName ;
      if [settingNameSet hasKey ![maskName string]] then
        error maskName:"The '" . maskName . "' setting is already defined" ;
      end if ;
      settingNameSet += ![maskName string] ;
      $mask$ ;
      $integer$ ? @luint maskValue ;
      $description$ ;
      $string$ ? @lstring maskDescriptionString ;
      @fieldSettingMap fieldSettingMap [emptyMap] ;
      repeat
        $setting$ ;
        $integer$ ? @luint value ;
        $mask$ ;
        $integer$ ? @luint mask ;
        $description$ ;
        $string$ ? @lstring descriptionString ;
        [!?fieldSettingMap insertKey !descriptionString ![value uint] ![mask uint]] ;
      while
      end repeat ;
      [!?configRegisterMaskMap insertKey !maskName !maskValue !maskDescriptionString !fieldSettingMap] ;
    end repeat ;
    $}$ ;
    [!?configRegisterMap insertKey
      !configRegisterName
      !configRegisterAddress
      !configRegisterWidth
      !configRegisterMaskMap
      !illegalMaskList
    ] ;
  end repeat ;
  $}$ ;
#--- Check some registers are actual defined
  if ([processorName string] == "pic18_60") | ([processorName string] == "pic18_80") then
    [registerTable searchKey ![@lstring new !"BSR" !here] ?4*] ;
    [registerTable searchKey ![@lstring new !"TOSL" !here] ?4*] ;
    [registerTable searchKey ![@lstring new !"TOSH" !here] ?4*] ;
    [registerTable searchKey ![@lstring new !"TOSU" !here] ?4*] ;
  end if ;
#--- Check if controller has a shared bank
  @string sharedBankName := "" ; # No shared bank by default
  if [processorName string] == "mid-range" then
    foreach ramBankTable while sharedBankName  == "" do
      @uint bankAccessibility := 1 << (mFirstFreeAddress >> 7) ;
      foreach mMirrorOffsetList do
        bankAccessibility := bankAccessibility  | (1 << ((mFirstFreeAddress + mValue) >> 7)) ;
      end foreach ;
      if (1 << [bankCount uint]) == (bankAccessibility + 1) then
        sharedBankName := [lkey string] ;
      end if ;
    end foreach ;
  end if ;
#---
  outPiccoloDeviceModel := [@piccoloDeviceModel new
    !deviceName
    !processorType
    !romSize
    !bankCount
    !registerTable
    !ramBankTable
    !eepromSize
    !eepromAddress
    !configRegisterMap
    !sharedBankName
  ] ;
end rule ;

#----------------------------------------------------*

end syntax ;
