syntax piccoloDevice_syntax :
import lexique piccoloDevice_lexique in "piccoloDevice_lexique.gLexique" ;
import semantics piccoloDevice_semantics in "piccoloDevice_semantics.gSemantics" ;

#----------------------------------------------------*

nonterminal <start_symbol>
  !@piccoloDeviceModel outPiccoloModel
;

#----------------------------------------------------*

rule <start_symbol>
  !@piccoloDeviceModel outPiccoloDeviceModel
:
  $controller$ ;
  $identifier$ ? @lstring deviceName ;
  ${$ ;
  $processor$ ;
  @processorType processorType ;
  $string$ ? @lstring processorName ;
  if [processorName string] == "pic18_60" then
    processorType := [@processorType pic18_60] ;
  elsif [processorName string] == "pic18_80" then
    processorType := [@processorType pic18_80] ;
  else
    error here : "The '" . processorName . "' is not handled" -> processorType ;
  end if ;
  $;$ ;
  $romsize$ ;
  $integer$ ? @luint romSize ;
  $;$ ;
  @uint eepromSize ;
  @uint eepromAddress ;
  select
    eepromSize := 0 ;
    eepromAddress := 0 ;
  or
    $eepromsize$ ;
    $integer$ ? @luint l_eepromSize ;
    eepromSize := [l_eepromSize uint] ;
    $at$ ;
    $integer$ ? @luint l_eepromAddress ;
    eepromAddress := [l_eepromAddress uint] ;
    $;$ ;
  end select ;
  $bank$ ;
  $integer$ ? @luint bankCount ;
  $;$ ;
  repeat
  while
    $unusedregister$ ;
    $integer$ ? @luint unusedRegisterStart ;
    select
    or
     $to$ ;
     $integer$ ? @luint unusedRegisterEnd ;
    end select ;
    $;$ ;
  end repeat ;
  @ramBankTable ramBankTable [emptyMap] ;
  repeat
  while
    $ram$ ;
    $identifier$ ? @lstring ramName ;
    $:$ ;
    $integer$ ? @luint ramStart ;
    $to$ ;
    $integer$ ? @luint ramEnd ;
    $;$ ;
    [!?ramBankTable insertKey
      !ramName
      ![ramStart uint]
      ![ramEnd uint] + 1
    ] ;
  end repeat ;
  @registerTable registerTable [emptyMap] ;
  repeat
  while
    $register$ ;
    $identifier$ ? @lstring registerName ;
    $at$ ;
    @uintlist registerAddressList [emptyList] ;
    repeat
      $integer$ ? @luint registerAddress ;
      registerAddressList += ![registerAddress uint] ;
    while
      $,$ ;
    end repeat ;
    $<$ ;
    @uint sliceIndex := 8 ;
    @bitSliceTable bitSliceTable [emptyMap] ;
    repeat
      select
        @uint sliceWidth := 0 ; # Means undefined
        repeat
          @uint sliceBase := sliceIndex ;
          $identifier$ ? @lstring sliceName ;
          select
            if (sliceWidth != 0) & (sliceWidth != 1) then
              error sliceName:"a slice of 1 bit is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := 1 ;
          or
            $[$ ;
            $integer$ ? @luint sliceSize ;
            if (sliceWidth != 0) & (sliceWidth != [sliceSize uint]) then
              error sliceName:"a slice of " . [sliceWidth string] . " bits is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := [sliceSize uint] ;
            sliceBase := sliceBase + 1 - [sliceSize uint] ;
            $]$ ;
          end select ;
          [!?bitSliceTable insertKey !sliceName !sliceIndex-sliceWidth !sliceWidth] ;
        while
          $/$ ;
        end repeat ;
        sliceIndex := sliceIndex - sliceWidth ;
      or
        $-$ ;
        sliceIndex -- ;
      end select ;
    while
      $,$ ;
    end repeat ;
    if sliceIndex != 0 then
      error registerName:"Incorrect bit definition for register '" . registerName . "'" ;
    end if ;
    $>$ ;
    [!?registerTable insertKey !registerName !registerAddressList !1 !bitSliceTable] ;
    $;$ ;
  end repeat ;
  @configRegisterMap configRegisterMap [emptyMap] ;
  repeat
  while
    $config$ ;
    $identifier$ ? @lstring configRegisterName ;
    $at$ ;
    $integer$ ? @luint configRegisterAddress ;
    $width$ ;
    $integer$ ? @luint configRegisterWidth ;
    @illegalMaskList illegalMaskList [emptyList] ;
    repeat
    while
      $illegal$ ;
      $integer$ ? @luint illegalValue ;
      $mask$ ;
      $integer$ ? @luint illegalMask ;
      $message$ ;
      $string$ ? @lstring illegalDescriptionString ;
      illegalMaskList += !illegalValue !illegalMask !illegalDescriptionString ;
    end repeat ;
    ${$ ;
    @configRegisterMaskMap configRegisterMaskMap [emptyMap] ;
    repeat
    while
      $identifier$ ? @lstring maskName ;
      $mask$ ;
      $integer$ ? @luint maskValue ;
      $description$ ;
      $string$ ? @lstring maskDescriptionString ;
      @fieldSettingList fieldSettingList [emptyList] ;
      repeat
        $setting$ ;
        $integer$ ? @luint value ;
        $mask$ ;
        $integer$ ? @luint mask ;
        $description$ ;
        $string$ ? @lstring descriptionString ;
        fieldSettingList += ![value uint] ![mask uint] ![descriptionString string] ;
      while
      end repeat ;
      [!?configRegisterMaskMap insertKey !maskName !maskValue !maskDescriptionString !fieldSettingList] ;
    end repeat ;
    $}$ ;
    [!?configRegisterMap insertKey
      !configRegisterName
      !configRegisterAddress
      !configRegisterWidth
      !configRegisterMaskMap
      !illegalMaskList
    ] ;
  end repeat ;
  $}$ ;
  outPiccoloDeviceModel := [@piccoloDeviceModel new
    !deviceName
    !processorType
    !romSize
    !bankCount
    !registerTable
    !ramBankTable
    !eepromSize
    !eepromAddress
    !configRegisterMap
  ] ;
end rule ;

#----------------------------------------------------*

end syntax ;
