semantics piccolo_build_assembly_code :
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.gSemantics" ;
import semantics ipic_metamodel in "ipic_metamodel.gSemantics" ;
import "ipic_metamodel.gSemantics" ;
import "piccolo_embedded_devices.gSemantics" ;

#----------------------------------------------------*
#                BUILD ASSEMBLY CODE                 *
#----------------------------------------------------*

abstract method @ipic_instruction.buildAssemblyCode
  ?!@string unused ioString 
  ?!@uint unused ioBccLabelIndex
;

#----------------------------------------------------*

override method @ipic_pseudo_ORG.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  ORG " . [mOrigin hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_pseudo_LABEL.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= [mLabel string] . ":\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_FDA.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  " . [mInstruction_FDA_base_code mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination & [mRegisterDescription mNeedsBSR] then
    ioString .= ", W, BSR_ACCESS" ;
  elsif [mRegisterDescription mNeedsBSR] then
    ioString .= ", F, BSR_ACCESS" ;
  elsif m_W_isDestination then
    ioString .= ", W" ;
  else
    ioString .= ", F" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_MOVFF.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  MOVFF ";
  ioString .= [mSourceRegisterDescription mAssemblyString] ;
  ioString .= ", " ;
  ioString .= [mDestinationRegisterDescription mAssemblyString] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_FBA.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  @bool useBSRaccess ;
  ioString .= "  " . [mBitOrientedOp mnemonic] ;
  ioString .= "  " . [mRegisterDescription mAssemblyString] ;
  ioString .= ", " . [mBitNumber string] ;
  if [mRegisterDescription mNeedsBSR] then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_BitTestSkip.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  @bool useBSRaccess ;
  ioString .= "  " ;
  if mSkipIfSet then
    ioString .= "BTFSS" ;
  else
    ioString .= "BTFSC" ;
  end if ;
  ioString .= "  " . [mRegisterDescription mAssemblyString] ;
  ioString .= ", " . [mBitNumber string] ;
  if [mRegisterDescription mNeedsBSR] then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_FA.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  " . [mFAinstruction mnemonic] . " " . [mRegisterDescription mAssemblyString] ;
  if [mRegisterDescription mNeedsBSR] then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_conditionalBranch.buildAssemblyCode
  ?!@string ioString
  ?!@uint ioBccLabelIndex
:
  switch mBranchMode
  when native, ipicNative :
    ioString .= "  " . [mConditionalBranch mnemonic] . " " . [mTargetLabel string] . "\n" ;
  when ipicBRA :
    @conditional_branch complementary ;
    getComplementaryBcc !mConditionalBranch ?complementary ;
    @string aLabel := "_bcc_label_" . [ioBccLabelIndex string] ; ioBccLabelIndex ++ ;
    ioString .= "  " . [complementary mnemonic] . " " . aLabel . "\n" ;
    ioString .= "  BRA " . [mTargetLabel string] . "\n" ;
    ioString .= aLabel . ":\n" ;
  when ipicGOTO :
    @conditional_branch complementary ;
    getComplementaryBcc !mConditionalBranch ?complementary ;
    @string aLabel := "_bcc_label_" . [ioBccLabelIndex string] ; ioBccLabelIndex ++ ;
    ioString .= "  " . [complementary mnemonic] . " " . aLabel . "\n" ;
    ioString .= "  GOTO " . [mTargetLabel string] . "\n" ;
    ioString .= aLabel . ":\n" ;
  end switch ;
end method ;

#----------------------------------------------------*

override method @ipic_jump_test_register.buildAssemblyCode
  ?!@string ioString
  ?!@uint ioBccLabelIndex
:
  ioString .= "  " . "TSTFSZ " . [mRegisterDescription mAssemblyString] ;
  if [mRegisterDescription mNeedsBSR] then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
  if mBranchIfZero then
    @string aLabel := "_bcc_label_" . [ioBccLabelIndex string] ; ioBccLabelIndex ++ ;
    ioString .= "  BRA " . aLabel . "\n" ;
    if mUsesBra then
      ioString .= "  BRA " . mTargetLabel . "\n" ;
    else
      ioString .= "  GOTO " . mTargetLabel . "\n" ;
    end if ;
    ioString .= aLabel . ":\n" ;
  else
    if mUsesBra then
      ioString .= "  BRA " . mTargetLabel . "\n" ;
    else
      ioString .= "  GOTO " . mTargetLabel . "\n" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------*

override method @ipic_incDecRegisterInCondition.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  if mBranchIfZero & mIncrement then
    ioString .= "  " . "INFSNZ " ;
  elsif mBranchIfZero & not mIncrement then
    ioString .= "  " . "DCFSNZ " ;
  elsif (not mBranchIfZero) & mIncrement then
    ioString .= "  " . "INCFSZ " ;
  else
    ioString .= "  " . "DECFSZ " ;
  end if ;
  ioString .= [mRegisterDescription mAssemblyString] ;
  if m_W_isDestination & [mRegisterDescription mNeedsBSR] then
    ioString .= ", W, BSR_ACCESS" ;
  elsif [mRegisterDescription mNeedsBSR] then
    ioString .= ", F, BSR_ACCESS" ;
  elsif m_W_isDestination then
    ioString .= ", W" ;
  else
    ioString .= ", F" ;
  end if ;
  ioString .= "\n" ;
  if mUsesBra then
    ioString .= "  BRA " . mTargetLabel . "\n" ;
  else
    ioString .= "  GOTO " . mTargetLabel . "\n" ;
  end if ;
end method ;

#----------------------------------------------------*

override method @ipic_registerComparisonCondition.buildAssemblyCode
  ?!@string ioString
  ?!@uint ioBccLabelIndex
:
  switch mComparison
    when notEqual : ioString .= " CPFSEQ " ;
    when equal : ioString .= " CPFSEQ " ;
    when greaterOrEqual : ioString .= " CPFSLT " ;
    when greater : ioString .= " CPFSGT " ;
    when lowerOrEqual : ioString .= " CPFSGT " ;
    when lower : ioString .= " CPFSLT " ;
  end switch ;
  ioString .= [mRegisterDescription mAssemblyString] ;
  if [mRegisterDescription mNeedsBSR] then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
  @bool usesIntermediateBRA ; [self usesIntermediateBRA ?usesIntermediateBRA] ;
  if usesIntermediateBRA then
    @string aLabel := "_bcc_label_" . [ioBccLabelIndex string] ; ioBccLabelIndex ++ ;
    ioString .= "  BRA " . aLabel . "\n" ;
    if mUsesBra then
      ioString .= "  BRA " . mTargetLabel . "\n" ;
    else
      ioString .= "  GOTO " . mTargetLabel . "\n" ;
    end if ;
    ioString .= aLabel . ":\n" ;
  else
    if mUsesBra then
      ioString .= "  BRA " . mTargetLabel . "\n" ;
    else
      ioString .= "  GOTO " . mTargetLabel . "\n" ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------*

override method @ipic_JUMP.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  switch mKind
    when ipicRelative : ioString .= "  BRA   " . [mTargetLabel string] . "\n" ;
    when ipicAbsolute : ioString .= "  GOTO  " . [mTargetLabel string] . "\n" ;
    when relative     : ioString .= "  BRA   " . [mTargetLabel string] . "\n" ;
    when absolute     : ioString .= "  GOTO  " . [mTargetLabel string] . "\n" ;
  end switch ;
end method ;

#----------------------------------------------------*

override method @ipic_JSR.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  switch mKind
    when ipicRelative : ioString .= "  RCALL " . [mTargetLabel string] . "\n" ;
    when ipicAbsolute : ioString .= "  CALL  " . [mTargetLabel string] . "\n" ;
    when relative     : ioString .= "  RCALL " . [mTargetLabel string] . "\n" ;
    when absolute     : ioString .= "  CALL  " . [mTargetLabel string] . "\n" ;
  end switch ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_MOVLB.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  MOVLB " . [[mBankIndex uint] hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_CLRWDT.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  CLRWDT\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_DAW.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  DAW\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_NOP.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  NOP\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_POP.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  POP\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_PUSH.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  PUSH\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_RESET.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  RESET\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_RETURN.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  RETURN\n" ;
end method ;

#----------------------------------------------------*

 override method @ipic_instruction_RETFIE.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  RETFIE" ;
  if mFastReturn then
    ioString .= " 1" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

 override method @ipic_instruction_SLEEP.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  SLEEP\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_literalOperation.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  " . [mLiteralInstruction mnemonic] . " " . [mLiteralValue hexString] . "\n" ;
end method ;

#----------------------------------------------------*

 override method @ipic_instruction_LFSR.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  LFSR " . [[mFSRindex uint] string] . ", " ;
  ioString .= [mValue hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_MNOP.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    ioString .= "  NOP\n" ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_TBLRD.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  TBLRD " . [mOption mnemonic] . "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_TBLWT.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  ioString .= "  TBLWT " . [mOption mnemonic] . "\n" ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_computed_retlw.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  if mUsesRCALL then
    ioString .= "  RCALL _computed_goto_2\n" ;
  else
    ioString .= "  CALL _computed_goto_2\n" ;
  end if ;
  foreach mLiteralValues do
    ioString .= "  RETLW " . [mValue hexString] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_computed_bra.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  if mUsesRCALL then
    ioString .= "  RCALL _computed_goto_2\n" ;
  else
    ioString .= "  CALL _computed_goto_2\n" ;
  end if ;
  foreach mTargetLabels do
    ioString .= "  BRA " . [mValue string] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @ipic_instruction_computed_goto.buildAssemblyCode
  ?!@string ioString
  ?!@uint unused ioBccLabelIndex
:
  if mUsesRCALL then
    ioString .= "  RCALL _computed_goto_4\n" ;
  else
    ioString .= "  CALL _computed_goto_4\n" ;
  end if ;
  foreach mTargetLabels do
    ioString .= "  GOTO " . [mValue string] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

routine buildAssemblyCode
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@registerTable inAllRegisters
  ??@ipic_instructionList inInstructionList
  ??@actualConfigurationMap inActualConfigurationMap
  !@string outAssemblyCode
:
  outAssemblyCode := "  PROCESSOR " . inProcessorName . "\n" ;
#--- Code
  outAssemblyCode .= ";--- Code\n" ;
  outAssemblyCode .= "  ORG 0\n" ;
  @uint bccLabelIndex := 0 ;
  foreach inInstructionList do
    [mInstruction buildAssemblyCode !?outAssemblyCode !?bccLabelIndex] ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- Prefined registers
  outAssemblyCode .= ";--- Prefefined registers\n" ;
  foreach inPredefinedRegisters do
    @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
    outAssemblyCode .= [key string] . " EQU " . [firstRegister hexString] . "\n" ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- User defined registers in ram
  outAssemblyCode .= ";--- User defined registers (in RAM)\n" ;
  foreach inAllRegisters do
    if not [inPredefinedRegisters hasKey ![key string]] then
      @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
      outAssemblyCode .= [key string] . " EQU " . [firstRegister hexString] . "\n" ;
    end if ;
  end foreach ;
  outAssemblyCode .= "\n" ;
#--- PICCOLO defined symbols
  outAssemblyCode .= ";--- Piccolo defined symbols\n" ;
  outAssemblyCode .= "F EQU 0\n" ;
  outAssemblyCode .= "W EQU 1\n" ;
  outAssemblyCode .= "BSR_ACCESS EQU 1\n\n" ;
#-------------------------------- Add Configuration
  if [inActualConfigurationMap count] > 0 then
    outAssemblyCode .= ";--- Configuration\n\n" ;
    foreach inActualConfigurationMap do
      outAssemblyCode .= "  __config " . [mRegisterAddress hexString] . ", " . [mRegisterValue & 255 hexString] . "\n" ;
    end foreach ;
  end if ;
#-------------------------------- End
  outAssemblyCode .= ";---\n\n" ;
  outAssemblyCode .= "  END\n\n" ;
end routine ;

#----------------------------------------------------*

end semantics ;
