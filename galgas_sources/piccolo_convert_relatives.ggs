semantics piccolo_convert_relatives :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;

#----------------------------------------------------------------------------*

map @symbolTableForConvertingRelatives {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' label is already declared in %L" ;
  search searchKey error message "the '%K' label is not declared" ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#                          defineLabelAtAddress                              *
#                                                                            *
#----------------------------------------------------------------------------*

method @instruction.defineLabelAtAddress
  ?!@symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint unused ioAddress
:
end method ;

#----------------------------------------------------------------------------*

override
method @pseudo_LABEL.defineLabelAtAddress
  ?!@symbolTableForConvertingRelatives ioRoutineSymbolTable
  ?!@uint ioAddress
:
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !ioAddress] ;
end method ;

#----------------------------------------------------------------------------*

override
method @pseudo_ORG.defineLabelAtAddress
  ?!@symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override
method @actualInstruction.defineLabelAtAddress
  ?!@symbolTableForConvertingRelatives unused ioRoutineSymbolTable
  ?!@uint ioAddress
:
  @uint instructionLength ;
  [self instructionLength ?instructionLength] ;
  ioAddress := ioAddress  + instructionLength ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               R E L A T I V E    B R A N C H    C H E C K I N G            *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @instruction.checkRelativeBranch
  ??@symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint unused ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
;

#----------------------------------------------------------------------------*

override
method @pseudo_ORG.checkRelativeBranch
  ??@symbolTableForConvertingRelatives unused inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
:
  ioAddress := mOrigin ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  switch mBranchMode
  when native :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 127S) | (displacement < - 128S) then
      ioRelativeBranchOverflow := true ;
##      message "  native Bcc overflow, converted to Bcc with BRA\n" ;
      @actualInstruction instruction := [@instruction_conditionalBranch new
        !mInstructionLocation
        ![@condionalBranchMode usesBRA]
        !mConditionalBranch
        !mTargetLabel
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when usesBRA :
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
##      message "  Bcc with BRA overflow, converted to Bcc with GOTO\n" ;
      @actualInstruction instruction := [@instruction_conditionalBranch new
        !mInstructionLocation
        ![@condionalBranchMode usesGOTO]
        !mConditionalBranch
        !mTargetLabel
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  when usesGOTO : # No overflow, do nothing
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_BRA.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
  @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    ioRelativeBranchOverflow := true ;
##    message "  BRA overflow, converted to GOTO\n" ;
    @actualInstruction instruction := [@instruction_GOTO new
      !mInstructionLocation
      !mTargetLabel
    ] ;
    [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_RCALL.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
  @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
##    message "  RCALL overflow, converted to CALL\n" ;
    ioRelativeBranchOverflow := true ;
    @actualInstruction instruction := [@instruction_CALL new
      !mInstructionLocation
      !mTargetLabel
    ] ;
    [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @pseudo_LABEL.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool unused ioRelativeBranchOverflow
  ?!@instructionList unused ioGeneratedInstructionList
  ??@uint unused inIndex
:
  @uint targetAddress ;
  [inRoutineSymbolTable searchKey !mTargetLabel ?targetAddress] ;
  if (targetAddress != ioAddress) then
    error mTargetLabel: "Internal second pass error: the '" . mTargetLabel
    . "' label gets " . [ioAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_retlw.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  if mUsesRelativeCall then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_2" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
##      message "  rcomputed retlw overflow, converted to computed retlw\n" ;
      @actualInstruction instruction := [@instruction_computed_retlw new
        !mInstructionLocation
        !mLiteralValues
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_bra.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  if mUsesRelativeCall then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_2" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
##      message "  rcomputed bra overflow, converted to computed bra\n" ;
      @actualInstruction instruction := [@instruction_computed_bra new
        !mInstructionLocation
        !mTargetLabels
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
  @uint address := ioAddress + 4 ;
  foreach mTargetLabels do
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;

    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_goto.checkRelativeBranch
  ??@symbolTableForConvertingRelatives inRoutineSymbolTable
  ?!@uint ioAddress
  ?!@bool ioRelativeBranchOverflow
  ?!@instructionList ioGeneratedInstructionList
  ??@uint inIndex
:
  if mUsesRelativeCall then
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey ![@lstring new !"_computed_goto_4" !here] ?targetAddress] ;
    @sint displacement := ([targetAddress sint] - 2S - [ioAddress sint]) >> 1 ;
    if (displacement > 1023S) | (displacement < - 1024S) then
      ioRelativeBranchOverflow := true ;
##      message "  rcomputed goto overflow, converted to computed goto\n" ;
      @actualInstruction instruction := [@instruction_computed_goto new
        !mInstructionLocation
        !mTargetLabels
        !false
      ] ;
      [!?ioGeneratedInstructionList setMInstructionAtIndex !instruction !inIndex] ;
    end if ;
  end if ;
  foreach mTargetLabels do
    @uint targetAddress ;
    [inRoutineSymbolTable searchKey !mValue ?targetAddress] ;

  end foreach ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine convertRelativeBranchsToAbsoluteWhenNeeded
  ?!@instructionList ioGeneratedInstructionList
:
  @bool relativeBranchOverflow := true ;
  @uint iteration := 0 ;
  loop [ioGeneratedInstructionList length] :
  while relativeBranchOverflow
  do
    relativeBranchOverflow := false ;
    iteration ++ ;
##    message "convert relatives, pass " . [iteration string] . "\n" ;
  #-------------------------------- First pass: build label map
    @symbolTableForConvertingRelatives symbolTable [emptyMap] ;
    @uint currentAddress := 0 ;
    foreach ioGeneratedInstructionList do
      [mInstruction defineLabelAtAddress !?symbolTable !?currentAddress] ;
    end foreach ;
    @uint lastAddressForFirstPass := currentAddress ;
  #-------------------------------- Second pass: generate code
    currentAddress := 0 ;
    foreach ioGeneratedInstructionList:idx do
      @uint instructionLength ;
      [mInstruction instructionLength ?instructionLength] ;
      [mInstruction checkRelativeBranch !symbolTable !?currentAddress !?relativeBranchOverflow !?ioGeneratedInstructionList !idx] ;
      currentAddress := currentAddress  + instructionLength ;
    end foreach ;
    if lastAddressForFirstPass != currentAddress then
      error here: "Internal second pass error: the last address gets " . [currentAddress hexString]
      . " value in second pass, while it gets "
      . [lastAddressForFirstPass hexString] . " value in first pass" ;
    end if ;
  end loop ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
