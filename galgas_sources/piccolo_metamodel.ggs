semantics piccolo_metamodel :
  import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

abstract class @instruction {

  abstract method instructionLength !@uint outLength ;
}

#----------------------------------------------------*

abstract class @pseudoInstruction extends @instruction {

  override method instructionLength !@uint outLength :
    outLength := 0 ;
  end method ;
}

#----------------------------------------------------*

class @pseudo_NULL extends @pseudoInstruction {
}

#----------------------------------------------------*

class @pseudo_ORG extends @pseudoInstruction {
  @uint mOrigin ;
}

#----------------------------------------------------*

class @pseudo_LABEL extends @pseudoInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

abstract class @actualInstruction extends @instruction {
  @location mInstructionLocation ;

  override method instructionLength !@uint outLength :
    outLength := 2 ;
  end method ;
}

#----------------------------------------------------*

list @instructionList {
  @instruction mInstruction ;
}

#----------------------------------------------------*

class @registerExpression {
  @lstring mRegisterName ;
  @luint mOffset ;
}

#----------------------------------------------------*

enum @instruction_FDA_base_code {
  constructor ADDWF ;
  constructor ADDWFC ;
  constructor ANDWF ;
  constructor COMF ;
  constructor DECF ;
  constructor DECFSZ ;
  constructor DCFSNZ ;
  constructor INCF ;
  constructor INCFSZ ;
  constructor INFSNZ ;
  constructor IORWF ;
  constructor MOVF ;
  constructor RLCF ;
  constructor RLNCF ;
  constructor RRCF ;
  constructor RRNCF ;
  constructor SUBFWB ;
  constructor SUBWF ;
  constructor SUBWFB ;
  constructor SWAPF ;
  constructor XORWF ;
}{
  reader mnemonic :
    ADDWF -> "ADDWF" ;
    ADDWFC -> "ADDWFC" ;
    ANDWF -> "ANDWF" ;
    COMF -> "COMF" ;
    DECF -> "DECF" ;
    DECFSZ -> "DECFSZ" ;
    DCFSNZ -> "DCFSNZ" ;
    INCF -> "INCF" ;
    INCFSZ -> "INCFSZ" ;
    INFSNZ -> "INFSNZ" ;
    IORWF -> "IORWF" ;
    MOVF -> "MOVF" ;
    RLCF -> "RLCF" ;
    RLNCF -> "RLNCF" ;
    RRCF -> "RRCF" ;
    RRNCF -> "RRNCF" ;
    SUBFWB -> "SUBFWB" ;
    SUBWF -> "SUBWF" ;
    SUBWFB -> "SUBWFB" ;
    SWAPF -> "SWAPF" ;
    XORWF -> "XORWF" ;
  end reader ;
}

#----------------------------------------------------*

routine getFDAinstructionBaseCode
  ??@instruction_FDA_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when ADDWF : outBaseCode := 0x2400 ;
  when ADDWFC : outBaseCode := 0x2000 ;
  when ANDWF : outBaseCode := 0x1400 ;
  when COMF : outBaseCode := 0x1C00 ;
  when DECF : outBaseCode := 0x0400 ;
  when DECFSZ : outBaseCode := 0x2C00 ;
  when DCFSNZ : outBaseCode := 0x4C00 ;
  when INCF : outBaseCode := 0x2800 ;
  when INCFSZ : outBaseCode := 0x3C00 ;
  when INFSNZ : outBaseCode := 0x4800 ;
  when IORWF : outBaseCode := 0x1000 ;
  when MOVF : outBaseCode := 0x5000 ;
  when RLCF : outBaseCode := 0x3400 ;
  when RLNCF : outBaseCode := 0x4400 ;
  when RRCF : outBaseCode := 0x3000 ;
  when RRNCF : outBaseCode := 0x4000 ;
  when SUBFWB : outBaseCode := 0x5400 ;
  when SUBWF : outBaseCode := 0x5C00 ;
  when SUBWFB :  outBaseCode := 0x5800 ;
  when SWAPF : outBaseCode := 0x3800 ;
  when XORWF : outBaseCode := 0x1800 ;
  end switch ;
end routine ;

#----------------------------------------------------*

class @instruction_FDA extends @actualInstruction {
  @instruction_FDA_base_code mInstruction_FDA_base_code ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    getFDAinstructionBaseCode !mInstruction_FDA_base_code ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

enum @FA_instruction_base_code {
  constructor CLRF ;
  constructor CPFSEQ ;
  constructor CPFSGT ;
  constructor CPFSLT ;
  constructor MOVWF  ;
  constructor MULWF  ;
  constructor NEGF  ;
  constructor SETF  ;
  constructor TSTFSZ ;
}{
  reader mnemonic :
    CLRF   -> "CLRF" ;
    CPFSEQ -> "CPFSEQ" ;
    CPFSGT -> "CPFSGT" ;
    CPFSLT -> "CPFSLT" ;
    MOVWF  -> "MOVWF" ;
    MULWF  -> "MULWF" ;
    NEGF   -> "NEGF";
    SETF   -> "SETF"  ;
    TSTFSZ -> "TSTFSZ" ;
  end reader ;
}

#----------------------------------------------------*

routine getFAinstructionBaseCode
  ??@FA_instruction_base_code inInstruction
  !@uint outBaseCode
:
  switch inInstruction
  when CLRF   : outBaseCode := 0x6A00 ;
  when CPFSEQ : outBaseCode := 0x6200 ;
  when CPFSGT : outBaseCode := 0x6400 ;
  when CPFSLT : outBaseCode := 0x6000 ;
  when MOVWF  : outBaseCode := 0x6E00 ;
  when MULWF  : outBaseCode := 0x0200 ;
  when NEGF   : outBaseCode := 0x6C00 ;
  when SETF   : outBaseCode := 0x6800 ;
  when TSTFSZ : outBaseCode := 0x6600 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @instruction_FA extends @actualInstruction {
  @FA_instruction_base_code mFAinstruction ;
  @registerExpression mRegisterExpression ;

  method getBaseCode !@uint outBaseCode :
   getFAinstructionBaseCode !mFAinstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @instruction_MOVFF extends @actualInstruction {
  @registerExpression mSourceRegisterName ;
  @registerExpression mDestinationRegisterName ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

abstract class @bitNumberExpression {
}

#----------------------------------------------------*

class @bitNumberLiteralValue extends @bitNumberExpression {
  @luint mBitNumberLiteralValue ;
}

#----------------------------------------------------*

class @bitNumberLabelValue extends @bitNumberExpression {
  @lstring mBitNumberLabelValue ;
  @luint mBitNumberIndexValue ;
}

#----------------------------------------------------*

enum @bit_oriented_op {
  constructor BCF ;
  constructor BSF ;
  constructor BTFSC ;
  constructor BTFSS ;
  constructor BTG ;
}{
  reader mnemonic :
    BCF -> "BCF" ;
    BSF -> "BSF" ;
    BTFSC -> "BTFSC" ;
    BTFSS -> "BTFSS" ;
    BTG -> "BTG" ;
  end reader ;
}

#----------------------------------------------------*

routine getBitOrientedOpBaseCode ??@bit_oriented_op inInstruction !@uint outBaseCode :
  switch inInstruction
  when BCF : outBaseCode := 0x9000 ;
  when BSF : outBaseCode := 0x8000 ;
  when BTFSC : outBaseCode := 0xB000 ;
  when BTFSS : outBaseCode := 0xA000 ;
  when BTG : outBaseCode := 0x7000 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @instruction_FBA extends @actualInstruction {
  @bit_oriented_op mBitOrientedOp ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
  method getBaseCode !@uint outBaseCode :
    getBitOrientedOpBaseCode !mBitOrientedOp ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

enum @conditional_branch {
  constructor bz ;
  constructor bnz ;
  constructor bn ;
  constructor bnn ;
  constructor bc ;
  constructor bnc ;
  constructor bov ;
  constructor bnov ;
}{
  reader mnemonic :
    bz   -> "BZ" ;
    bnz  -> "BNZ" ;
    bn   -> "BN" ;
    bnn  -> "BNN" ;
    bc   -> "BC" ;
    bnc  -> "BNC" ;
    bov  -> "BOV" ;
    bnov -> "BNOV" ;
  end reader ;
}

#----------------------------------------------------*

routine getBccBaseCode ??@conditional_branch inConditionalBranch !@uint outBaseCode :
  switch inConditionalBranch
  when bz   : outBaseCode := 0xE000 ;
  when bnz  : outBaseCode := 0xE100 ;
  when bn   : outBaseCode := 0xE600 ;
  when bnn  : outBaseCode := 0xE700 ;
  when bc   : outBaseCode := 0xE200 ;
  when bnc  : outBaseCode := 0xE300 ;
  when bov  : outBaseCode := 0xE400 ;
  when bnov : outBaseCode := 0xE500 ;
  end switch ;
end routine ;

#----------------------------------------------------*

routine getComplementaryBcc ??@conditional_branch inConditionalBranch !@conditional_branch outComplementary :
  switch inConditionalBranch
  when bz   : outComplementary := [@conditional_branch bnz] ;
  when bnz  : outComplementary := [@conditional_branch bz] ;
  when bn   : outComplementary := [@conditional_branch bnn] ;
  when bnn  : outComplementary := [@conditional_branch bn] ;
  when bc   : outComplementary := [@conditional_branch bnc] ;
  when bnc  : outComplementary := [@conditional_branch bc] ;
  when bov  : outComplementary := [@conditional_branch bnov] ;
  when bnov : outComplementary := [@conditional_branch bov] ;
  end switch ;
end routine ;

#----------------------------------------------------*

enum @condionalBranchMode {
  constructor native ;
  constructor usesBRA ;
  constructor usesGOTO ;
}{
}

#----------------------------------------------------*

class @instruction_conditionalBranch extends @actualInstruction {
  @condionalBranchMode mBranchMode ;
  @conditional_branch mConditionalBranch ;
  @lstring mTargetLabel ;

  override
  method instructionLength !@uint outLength :
    switch mBranchMode
      when native   : outLength := 2 ;
      when usesBRA  : outLength := 4 ;
      when usesGOTO : outLength := 6 ;
    end switch ;
  end method ;
}

#----------------------------------------------------*

class @instruction_BRA extends @actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @instruction_CALL extends @actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @instruction_GOTO extends @actualInstruction {
  @lstring mTargetLabel ;
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @instruction_RCALL extends @actualInstruction {
  @lstring mTargetLabel ;
}

#----------------------------------------------------*

class @instruction_CLRWDT extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_DAW extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_NOP extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_POP extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_PUSH extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_RESET extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_RETURN extends @actualInstruction {
}

#----------------------------------------------------*

class @instruction_RETFIE extends @actualInstruction {
  @bool mFastReturn ;
}

#----------------------------------------------------*

class @instruction_SLEEP extends @actualInstruction {
}

#----------------------------------------------------*

enum @literal_instruction_opcode {
  constructor ADDLW ;
  constructor ANDLW ;
  constructor IORLW ;
  constructor MOVLW ;
  constructor MULLW ;
  constructor RETLW ;
  constructor SUBLW ;
  constructor XORLW ;
}{
  reader mnemonic :
    ADDLW -> "ADDLW" ;
    ANDLW -> "ANDLW" ;
    IORLW -> "IORLW" ;
    MOVLW -> "MOVLW" ;
    MULLW -> "MULLW" ;
    RETLW -> "RETLW" ;
    SUBLW -> "SUBLW" ;
    XORLW -> "XORLW" ;
  end reader ;
}

#----------------------------------------------------*

routine getLiteralInstructionBaseCode ??@literal_instruction_opcode inInstruction !@uint outBaseCode :
  switch inInstruction
  when ADDLW : outBaseCode := 0x0F00 ;
  when ANDLW : outBaseCode := 0x0B00 ;
  when IORLW : outBaseCode := 0x0900 ;
  when MOVLW : outBaseCode := 0x0E00 ;
  when MULLW : outBaseCode := 0x0D00 ;
  when RETLW : outBaseCode := 0x0C00 ;
  when SUBLW : outBaseCode := 0x0800 ;
  when XORLW : outBaseCode := 0x0A00 ;
  end switch ;
end routine ;


#----------------------------------------------------*

class @instruction_literalOperation extends @actualInstruction {
  @literal_instruction_opcode mLiteralInstruction ;
  @luint mLiteralValue ;
  method getBaseCode !@uint outBaseCode :
    getLiteralInstructionBaseCode !mLiteralInstruction ?outBaseCode ;
  end method ;
}

#----------------------------------------------------*

class @instruction_LFSR extends @actualInstruction {
  @luint mFSRindex ;
  @registerExpression mRegisterExpression ;
  
  override
  method instructionLength !@uint outLength :
    outLength := 4 ;
  end method ;
}

#----------------------------------------------------*

class @instruction_MOVLB extends @actualInstruction {
  @luint mPageIndex ;
}

#----------------------------------------------------*

class @instruction_MOVAW extends @actualInstruction {
  @registerExpression mRegisterExpression ;
}

#----------------------------------------------------*

enum @tableAccessOption {
  constructor simpleAccess ;
  constructor postIncrement ;
  constructor postDecrement ;
  constructor preIncrement ;
}{
  reader mnemonic :
    simpleAccess -> "*" ;
    postIncrement -> "*+" ;
    postDecrement -> "*-" ;
    preIncrement -> "+*" ;
  end reader ;
}

#----------------------------------------------------*

class @instruction_TBLRD extends @actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @instruction_TBLWT extends @actualInstruction {
  @tableAccessOption mOption ;
}

#----------------------------------------------------*

class @instruction_MNOP extends @actualInstruction {
  @luint mOccurrenceFactor ;
  override
  method instructionLength !@uint outLength :
    outLength := [mOccurrenceFactor uint] * 2 ;
  end method ;
}

#----------------------------------------------------*

class @instruction_FOREVER extends @actualInstruction {
  @instructionList mInstructionList ;
  override
  method instructionLength !@uint outLength :
    outLength := 2 ; # BRA at the end of instruction list
    foreach mInstructionList do
      @uint lg ; [mInstruction instructionLength ?lg] ;
      outLength := outLength + lg ;
    end foreach ;
  end method ;
}

#----------------------------------------------------*

enum @if_semi_colon_op {
  constructor CPFSEQ ;
  constructor CPFSGT ;
  constructor CPFSLT ;
  constructor TSTFSZ ;
}{
  reader mnemonic :
    CPFSEQ -> "CPFSEQ" ;
    CPFSGT -> "CPFSGT" ;
    CPFSLT -> "CPFSLT" ;
    TSTFSZ -> "TSTFSZ" ;
  end reader ;
}

#----------------------------------------------------*

routine getBaseCodeForIfSemiColonOp ??@if_semi_colon_op inInstruction !@uint outBaseCode :
  switch inInstruction
    when CPFSEQ : outBaseCode := 0x6200 ;
    when CPFSGT : outBaseCode := 0x6400 ;
    when CPFSLT : outBaseCode := 0x6000 ;
    when TSTFSZ : outBaseCode := 0x6600 ;
  end switch ; 
end routine ;

#----------------------------------------------------*

abstract class @instruction_IF_SEMI_COLON extends @actualInstruction {
  @instruction mInstruction ;

  override
  method instructionLength !@uint outLength :
    [mInstruction instructionLength ?outLength] ;
    outLength := outLength + 2 ;
  end method ;
}

#----------------------------------------------------*

class @instruction_IF_FA_SEMI_COLON extends @instruction_IF_SEMI_COLON {
  @if_semi_colon_op mOpCode ;
  @registerExpression mRegisterExpression ;

  method getBaseCode !@uint outBaseCode :
    getBaseCodeForIfSemiColonOp !mOpCode ?outBaseCode ;
  end method ;

}

#----------------------------------------------------*

class @instruction_IF_BitTest extends @instruction_IF_SEMI_COLON {
  @bool mSkipIfSet ;
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;

  method getBaseCode !@uint outBaseCode :
    if mSkipIfSet then
      outBaseCode := 0xA000 ; # BTFSS
    else
      outBaseCode := 0xB000 ; # BTFSC
    end if ;
  end method ; 

  method getMnemonic !@string outMnemonic :
    if mSkipIfSet then
      outMnemonic := "BTFSS" ;
    else
      outMnemonic := "BTFSC" ;
    end if ;
  end method ; 
}

#----------------------------------------------------*

class @instruction_IF_IncDec extends @instruction_IF_SEMI_COLON {
  @bool mIncrement ;
  @bool mSkipIfZero ;
  @registerExpression mRegisterExpression ;
  @bool m_W_isDestination ;

  method getBaseCode !@uint outBaseCode :
    if mIncrement & mSkipIfZero then
      outBaseCode := 0x3C00 ; # INCFSZ
    elsif mIncrement & not mSkipIfZero then
      outBaseCode := 0x4800 ; # INFSNZ
    elsif (not mIncrement) & mSkipIfZero then
      outBaseCode := 0x2C00 ; # DECFSZ
    else
      outBaseCode := 0x4C00 ; # DCFSNZ
    end if ;
  end method ; 

  method getMnemonic !@string outMnemonic :
    if mIncrement & mSkipIfZero then
      outMnemonic := "INCFSZ" ;
    elsif mIncrement & not mSkipIfZero then
      outMnemonic := "INFSNZ" ;
    elsif (not mIncrement) & mSkipIfZero then
      outMnemonic := "DECFSZ" ;
    else
      outMnemonic := "DCFSNZ" ;
    end if ;
  end method ; 
}

#----------------------------------------------------*

class @instruction_computed_retlw extends @actualInstruction {
  @luintlist mLiteralValues ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mLiteralValues length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @instruction_computed_bra extends @actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 2 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

class @instruction_computed_goto extends @actualInstruction {
  @lstringlist mTargetLabels ;
  @bool mUsesRelativeCall ;

  override
  method instructionLength !@uint outLength :
    outLength := [mTargetLabels length] * 4 + 2 ;
    if not mUsesRelativeCall then
      outLength := outLength + 2 ;
    end if ;
  end method ;
}

#----------------------------------------------------*

abstract class @structured_if_condition {
  abstract method conditionLength !@uint outLength ;
}

#----------------------------------------------------*

class @bcc_in_structured_if_condition extends @structured_if_condition {
  @conditional_branch mCondition ;
  override method conditionLength !@uint outLength :
    outLength := 2 ;
  end method ;
}

#----------------------------------------------------*

class @bitTest_in_structured_if_condition extends @structured_if_condition {
  @registerExpression mRegisterExpression ;
  @bitNumberExpression mBitNumber ;
  @bool mBTFSSinstruction ;
  override method conditionLength !@uint outLength :
    outLength := 4 ; # BTFSx, BRA instructions
  end method ;
  method baseCode !@uint outBaseCode :
    if mBTFSSinstruction then
      outBaseCode := 0xA000 ;  # BTFSS
    else
      outBaseCode := 0xB000 ;  # BTFSC
    end if ;
  end method ;
}

#----------------------------------------------------*

class @instruction_structured_if extends @actualInstruction {
  @structured_if_condition mIfCondition ;
  @instructionList mThenInstructionList ;
  @instructionList mElseInstructionList ;

  override
  method instructionLength !@uint outLength :
    [mIfCondition conditionLength ?outLength] ;
    foreach mThenInstructionList do
      @uint lg ; [mInstruction instructionLength ?lg] ;
      outLength := outLength + lg ;
    end foreach ;
    if [mElseInstructionList length] > 0 then
      outLength := outLength + 2 ; # Bra for skking else part
    end if ;
    foreach mElseInstructionList do
      @uint lg ; [mInstruction instructionLength ?lg] ;
      outLength := outLength + lg ;
    end foreach ;
  end method ;
}
#----------------------------------------------------*

class @instruction_do_while extends @actualInstruction {
  @structured_if_condition mWhileCondition ;
  @instructionList mRepeatedInstructionList ;

  override
  method instructionLength !@uint outLength :
    [mWhileCondition conditionLength ?outLength] ;
    foreach mRepeatedInstructionList do
      @uint lg ; [mInstruction instructionLength ?lg] ;
      outLength := outLength + lg ;
    end foreach ;
  end method ;
}

#----------------------------------------------------*

list @interruptDefinitionList {
  @lstring mInterruptName ;
  @instructionList mInstructionList ;
}

#----------------------------------------------------*

list @routineDefinitionList {
  @lstring mRoutineName ;
  @luint mBanksel ;
  @bool mHasNoReturn ;
  @instructionList mInstructionList ;
}

#----------------------------------------------------*

list @declarationInRamList {
  @lstring mName ;
  @luint mSize ;
}

#----------------------------------------------------*

list @ramDefinitionList {
  @lstring mBankName ;
  @declarationInRamList mDeclaration ;
}

#----------------------------------------------------*

struct @piccoloModel {
  @lstring mProgramName ;
  @lstring mDeviceName ;
  @ramDefinitionList mRamDefinitionList ;
  @interruptDefinitionList mInterruptDefinitionList ;
  @routineDefinitionList mRoutineDefinitionList ;
  @bool mNeedsComputedGoto2 ;
  @bool mNeedsComputedGoto4 ;
}

#----------------------------------------------------*

end semantics ;
