program piccolo_program "version 1.0.0":

#--- Import clauses
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;
import semantics piccolo_semantics in "piccolo_semantics.gSemantics" ;
import grammar piccolo_grammar in "piccolo_grammar.gGrammar" ;

#--- Prologue routine
before {
#--- Print supported device list
  if [option piccolo_options.ouputDeviceList] then
    @stringlist allDevices := [[filewrapper embeddedDevices] allFilePathes] ;
    message "List of the " . [[allDevices  length] string] . " supported devices:\n" ;
    @uint index := 0 ;
    @bool ok := true ;
    foreach allDevices while ok do
      @piccoloDeviceModel piccoloDeviceModel ;
      @string name := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      parseDeviceDefinition ![@lstring new !name !here] ?piccoloDeviceModel ;
      message [name stringByRightPadding !15 !' '] ;
      ok := [@uint errorCount] == 0 ;
      index ++ ;
      if index == 5 then
        index := 0 ;
        message "\n" ;
      end if ;
    end foreach ;
    if index != 0 then
      message "\n" ;
    end if ;
  end if ;
#--- Print RAM description
  @string deviceForMemoryDescription := [option piccolo_options.memoryDescription] ;
  if [deviceForMemoryDescription length] > 0 then
    @string devicePath := "/" . deviceForMemoryDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForMemoryDescription !here] ?piccoloDeviceModel ;
      @uint totalRam := 0 ;
      foreach [piccoloDeviceModel mRamBankTable] do
        totalRam  := totalRam  + mLastAddressPlusOne - mFirstFreeAddress ;
      end foreach ;
      message deviceForMemoryDescription . " device:\n" ;
      message "  " . [[[piccoloDeviceModel mRamBankTable] count] string] . " RAM banks (total " . [totalRam string] . " bytes):\n" ;
      foreach [piccoloDeviceModel mRamBankTable] do
        message "    bank \"" . key . "\" from " . [mFirstFreeAddress hexString]
        . " to " . [mLastAddressPlusOne-1 hexString]
        . " (" . [mLastAddressPlusOne-mFirstFreeAddress string] . " bytes)\n" ;
      end foreach ;
      message "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " bytes\n" ;
      if [piccoloDeviceModel mEepromSize] == 0 then
        message "  No EEPROM\n" ;
      else
        message "  EEPROM size: " . [[piccoloDeviceModel mEepromSize] string] . " bytes (at "
        . [[piccoloDeviceModel mEepromAddress] hexString] . ")\n" ;
      end if ;
    else
      error here:"The " . deviceForMemoryDescription . " device is not supported" ;
    end if ;
  end if ;
}

#--- 'when' clauses
when . "piccolo"
message "a source text file with the .piccolo extension"
??@lstring inSourceFile {
  @piccoloModel piccoloModel ;
  grammar piccolo_grammar in inSourceFile ?piccoloModel ;
  analyze !piccoloModel ![inSourceFile string] ;
}

#--- Epilogue routine
after {
}

#---

end program ;
