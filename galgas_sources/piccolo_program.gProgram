program piccolo_program "version 1.0.0":

#--- Import clauses
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;
import semantics piccolo_semantics in "piccolo_semantics.gSemantics" ;
import grammar piccolo_grammar in "piccolo_grammar.gGrammar" ;

#--- Prologue routine
before {
#------------------------------------------------ Print supported device list
  if [option piccolo_options.ouputDeviceList] then
  #--- Enumerate devices, and parse them
    @stringlist allDevices := [[filewrapper embeddedDevices] allFilePathes] ;
    @stringlist pic_60_devices [emptyList] ;
    @stringlist pic_80_devices [emptyList] ;
    message [[allDevices  length] string] . " supported devices.\n" ;
    @uint index := 0 ;
    @bool ok := true ;
    foreach allDevices while ok do
      @piccoloDeviceModel piccoloDeviceModel ;
      @string name := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      parseDeviceDefinition ![@lstring new !name !here] ?piccoloDeviceModel ;
      switch [piccoloDeviceModel mProcessorType]
        when pic18_60 : pic_60_devices += !name ;
        when pic18_80 : pic_80_devices += !name ;
      end switch ;
    end foreach ;
  #--- List 'pic 60' devices
    message [[pic_60_devices length] string] . " devices with access bank split offset 0x60:\n" ;
    foreach pic_60_devices do
      message [mValue stringByRightPadding !15 !' '] ;
      index ++ ;
      if index == 5 then
        index := 0 ;
        message "\n" ;
      end if ;
    end foreach ;
    if index != 0 then
      message "\n" ;
    end if ;
  #--- List 'pic 80' devices
    index := 0 ;
    message [[pic_80_devices  length] string] . " devices with access bank split offset 0x80:\n" ;
    foreach pic_80_devices do
      message [mValue stringByRightPadding !15 !' '] ;
      index ++ ;
      if index == 5 then
        index := 0 ;
        message "\n" ;
      end if ;
    end foreach ;
    if index != 0 then
      message "\n" ;
    end if ;
#  #--- Enumerate devices, and parse them
#    @stringlist allDevices := [[filewrapper embeddedDevices] allFilePathes] ;
#    @stringlist pic_60_standard_cpu_devices [emptyList] ;
#    @stringlist pic_80_standard_cpu_devices [emptyList] ;
#    @stringlist pic_60_extended_cpu_devices [emptyList] ;
#    @stringlist pic_80_extended_cpu_devices [emptyList] ;
#    message [[allDevices  length] string] . " supported devices.\n" ;
#    @uint index := 0 ;
#    @bool ok := true ;
#    foreach allDevices while ok do
#      @piccoloDeviceModel piccoloDeviceModel ;
#      @string name := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
#      parseDeviceDefinition ![@lstring new !name !here] ?piccoloDeviceModel ;
#    #--- Find if has extended instruction set
#      @bool hasExtendedInstructionSet := true ;
#      if not [[piccoloDeviceModel mConfigRegisterMap] hasKey !"CONFIG4L"] then
#        message "No CONFIG4L configuration register for '" . name . "' device.\n" ;
#      else
#        @configRegisterMaskMap CONFIG4L_maskMap ;
#        [[piccoloDeviceModel mConfigRegisterMap] searchKey ![@lstring new !"CONFIG4L" !here] ?* ?* ?CONFIG4L_maskMap] ;
#        hasExtendedInstructionSet := [CONFIG4L_maskMap hasKey !"ENHCPU"] ;
#      end if ;
#      if hasExtendedInstructionSet then
#        switch [piccoloDeviceModel mProcessorType]
#          when pic18_60 : pic_60_extended_cpu_devices += !name ;
#          when pic18_80 : pic_80_extended_cpu_devices += !name ;
#        end switch ;
#      else
#        switch [piccoloDeviceModel mProcessorType]
#          when pic18_60 : pic_60_standard_cpu_devices += !name ;
#          when pic18_80 : pic_80_standard_cpu_devices += !name ;
#        end switch ;
#      end if ;
#    end foreach ;
#  #--- List 'pic 60' devices with standard cpu
#    message [[pic_60_standard_cpu_devices  length] string] . " devices with standard instruction set and access bank split offset 0x60:\n" ;
#    foreach pic_60_standard_cpu_devices do
#      message [mValue stringByRightPadding !15 !' '] ;
#      index ++ ;
#      if index == 5 then
#        index := 0 ;
#        message "\n" ;
#      end if ;
#    end foreach ;
#    if index != 0 then
#      message "\n" ;
#    end if ;
#  #--- List 'pic 80' devices with standard cpu
#    index := 0 ;
#    message [[pic_80_standard_cpu_devices  length] string] . " devices with standard instruction set and access bank split offset 0x80:\n" ;
#    foreach pic_80_standard_cpu_devices do
#      message [mValue stringByRightPadding !15 !' '] ;
#      index ++ ;
#      if index == 5 then
#        index := 0 ;
#        message "\n" ;
#      end if ;
#    end foreach ;
#    if index != 0 then
#      message "\n" ;
#    end if ;
#  #--- List 'pic 60' devices with extended cpu
#    index := 0 ;
#    message [[pic_60_extended_cpu_devices  length] string] . " devices with extended instruction set and access bank split offset 0x60:\n" ;
#    foreach pic_60_extended_cpu_devices do
#      message [mValue stringByRightPadding !15 !' '] ;
#      index ++ ;
#      if index == 5 then
#        index := 0 ;
#        message "\n" ;
#      end if ;
#    end foreach ;
#    if index != 0 then
#      message "\n" ;
#    end if ;
#  #--- List 'pic 80' devices with extended cpu
#    index := 0 ;
#    message [[pic_80_extended_cpu_devices  length] string] . " devices with extended instruction set and access bank split offset 0x80:\n" ;
#    foreach pic_80_extended_cpu_devices do
#      message [mValue stringByRightPadding !15 !' '] ;
#      index ++ ;
#      if index == 5 then
#        index := 0 ;
#        message "\n" ;
#      end if ;
#    end foreach ;
#    if index != 0 then
#      message "\n" ;
#    end if ;
  end if ;
#------------------------------------------------ Print RAM description
  @string deviceForMemoryDescription := [option piccolo_options.memoryDescription] ;
  if [deviceForMemoryDescription length] > 0 then
    @string devicePath := "/" . deviceForMemoryDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForMemoryDescription !here] ?piccoloDeviceModel ;
      @uint totalRam := 0 ;
      foreach [piccoloDeviceModel mRamBankTable] do
        totalRam  := totalRam  + mLastAddressPlusOne - mFirstFreeAddress ;
      end foreach ;
      message deviceForMemoryDescription . " device:\n" ;
      message "  " . [[[piccoloDeviceModel mRamBankTable] count] string] . " RAM banks (total " . [totalRam string] . " bytes):\n" ;
      foreach [piccoloDeviceModel mRamBankTable] do
        message "    bank \"" . key . "\" from " . [mFirstFreeAddress hexString]
        . " to " . [mLastAddressPlusOne-1 hexString]
        . " (" . [mLastAddressPlusOne-mFirstFreeAddress string] . " bytes)\n" ;
      end foreach ;
      message "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " bytes\n" ;
      if [piccoloDeviceModel mEepromSize] == 0 then
        message "  No EEPROM\n" ;
      else
        message "  EEPROM size: " . [[piccoloDeviceModel mEepromSize] string] . " bytes (at "
        . [[piccoloDeviceModel mEepromAddress] hexString] . ")\n" ;
      end if ;
    else
      error here:"The " . deviceForMemoryDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
#------------------------------------------------ Print REGISTERS description
  @string deviceForRegistersDescription := [option piccolo_options.registerDescription] ;
  if [deviceForRegistersDescription length] > 0 then
    @string devicePath := "/" . deviceForRegistersDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForRegistersDescription !here] ?piccoloDeviceModel ;
      message deviceForRegistersDescription . " has " . [[[piccoloDeviceModel mRegisterTable] count] string] . " special registers:\n" ;
      foreach [piccoloDeviceModel mRegisterTable] do
        @string s := "  '" . key . "' at " ;
        foreach mRegisterAddressList
        do s .= [mValue hexString] ;
        between s .= ", " ;
        end foreach ;
        s .= "\n" ;
        message s ;
      end foreach ;
    else
      error here:"The " . deviceForRegistersDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
#------------------------------------------------ Print CONFIGURATION description
  @string deviceForConfigDescription := [option piccolo_options.configDescription] ;
  if [deviceForConfigDescription length] > 0 then
    @string devicePath := "/" . deviceForConfigDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForConfigDescription !here] ?piccoloDeviceModel ;
      message deviceForConfigDescription . " has " . [[[piccoloDeviceModel mConfigRegisterMap] count] string] . " configuration registers:\n" ;
      foreach [piccoloDeviceModel mConfigRegisterMap] do
        @string s := "  '" . key . "' at " . [[mRegisterAddress uint] hexString] . ", width " . [[mRegisterWidth uint] string] . "\n" ;
        foreach mIllegalMaskList do
          s .= "    illegal " . [[key uint] hexString] . "' mask " . [[mIllegalMask uint] hexString] . " description \"" . mDescription . "\"\n" ;
        end foreach ;
        foreach mConfigRegisterMaskMap do
          s .= "    '" . key . "': mask " . [[mMaskValue uint] hexString] . " description \"" . mDescription . "\"\n" ;
          foreach mFieldSettingList do
            s .= "      setting " . [mValue hexString] . " description \"" . mDescription . "\"\n" ;
          end foreach ;
        end foreach ;
        message s ;
      end foreach ;
    else
      error here:"The " . deviceForConfigDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*

when . "piccolo"
message "a source text file with the .piccolo extension"
??@lstring inSourceFile {
  @piccoloModel piccoloModel ;
  grammar piccolo_grammar in inSourceFile ?piccoloModel ;
  if [@uint errorCount] == 0 then
    analyze !piccoloModel ![inSourceFile string] ;
  end if ;
}

#----------------------------------------------------------------------------*

#--- Epilogue routine
after {
}

#----------------------------------------------------------------------------*

end program ;
