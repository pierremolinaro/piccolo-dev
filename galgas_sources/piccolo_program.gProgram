program piccolo_program "version PICCOLO_BETA_VERSION":
import "pic18_metamodel.gSemantics" ;
import "pic18_semantics.gSemantics" ;
import "piccolo_grammar.gGrammar" ;

#--- Prologue routine
before {
#------------------------------------------------ Print supported device list
  if [option piccolo_options.outputDeviceList value]
   | [option piccolo_options.outputPic18DeviceList value]
   | [option piccolo_options.outputBaselineDeviceList value]
   | [option piccolo_options.outputMidrangeDeviceList value] then
  #--- Enumerate devices
    @stringlist allDevices := [[filewrapper embeddedDevices] allFilePathes] ;
    @stringlist pic18_devices [emptyList] ;
    @stringlist midrange_devices [emptyList] ;
    @stringlist baseline_devices [emptyList] ;
  #--- Parse them
    @bool ok := true ;
    foreach allDevices while ok do
      @piccoloDeviceModel piccoloDeviceModel ;
      @string name := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      parseDeviceDefinition ![@lstring new !name !here] ?piccoloDeviceModel ;
      switch [piccoloDeviceModel mProcessorType]
      when pic18_60, pic18_80 : pic18_devices += !name ;
      when midrange : midrange_devices += !name ;
      if [[piccoloDeviceModel mBankCount] uint] > 4 then
        message name . " has " . [[[piccoloDeviceModel mBankCount] uint] string] . " banks\n" ;
      end if ;
      when baseline : baseline_devices += !name ;
      end switch ;
##      @uint bankCount := [[piccoloDeviceModel mBankCount] uint] ;
##      if (bankCount == 1) then
##        message name . " has 1 bank\n" ;
##      elsif (bankCount == 2)
##       | (bankCount == 4)
##       | (bankCount == 8)
##       | (bankCount == 16) then
##      else
##        message name . " has " . [bankCount string] . " banks\n" ;
##      end if ;
    end foreach ;
  #--- Print baseline device list
    if [option piccolo_options.outputDeviceList value] | [option piccolo_options.outputBaselineDeviceList value] then
      message [[baseline_devices length] string] . " baseline devices (not yet supported by Piccolo " . [@string stringWithVersionString] . "):\n" ;
      @uint idx := 0 ;
      foreach baseline_devices do
        message [mValue stringByRightPadding !15 !' '] ;
        idx ++ ;
        if idx == 5 then
          idx := 0 ;
          message "\n" ;
        end if ;
      end foreach ;
      if idx != 0 then
        message "\n" ;
      end if ;
    end if ;
  #--- Print mid-range device list
    if [option piccolo_options.outputDeviceList value] | [option piccolo_options.outputMidrangeDeviceList value] then
      message [[midrange_devices length] string] . " mid-range devices supported by Piccolo " . [@string stringWithVersionString] . ":\n" ;
      @uint idx := 0 ;
      foreach midrange_devices do
        message [mValue stringByRightPadding !15 !' '] ;
        idx ++ ;
        if idx == 5 then
          idx := 0 ;
          message "\n" ;
        end if ;
      end foreach ;
      if idx != 0 then
        message "\n" ;
      end if ;
    end if ;
  #--- Print pic18 device list
    if [option piccolo_options.outputDeviceList value] | [option piccolo_options.outputPic18DeviceList value] then
      message [[pic18_devices length] string] . " pic18 devices supported by Piccolo " . [@string stringWithVersionString] . ":\n" ;
      @uint idx := 0 ;
      foreach pic18_devices do
        message [mValue stringByRightPadding !15 !' '] ;
        idx ++ ;
        if idx == 5 then
          idx := 0 ;
          message "\n" ;
        end if ;
      end foreach ;
      if idx != 0 then
        message "\n" ;
      end if ;
    end if ;
  #---
  end if ;
#------------------------------------------------ Export Device definition files
  if [[option piccolo_options.exportDeviceFiles value] length] > 0 then
    @string dir := [option piccolo_options.exportDeviceFiles value] ;
    if not [dir directoryExists] then
      [dir makeDirectory] ;
    end if ;
    @filewrapper fw := [filewrapper embeddedDevices] ;
    @stringlist allDevices := [[filewrapper embeddedDevices] allFilePathes] ;
    foreach allDevices do
      @string definitionString := [fw fileContentsAtPath !mValue] ;
      [definitionString writeToFile !dir . mValue] ;
    end foreach ;
    message [[allDevices length] string] . " devices copied in '" . dir . "' directory\n" ;
  end if ;
#------------------------------------------------ Print RAM description
  @string deviceForMemoryDescription := [option piccolo_options.memoryDescription value] ;
  if [deviceForMemoryDescription length] > 0 then
    @string devicePath := "/" . deviceForMemoryDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new !deviceForMemoryDescription !here] ?piccoloDeviceModel ;
      @uint totalRam := 0 ;
      foreach [piccoloDeviceModel mRamBankTable] do
        totalRam  := totalRam  + mLastAddressPlusOne - mFirstFreeAddress ;
      end foreach ;
      message deviceForMemoryDescription . " device:\n" ;
      message "  " . [[[piccoloDeviceModel mRamBankTable] count] string] . " RAM banks (total " . [totalRam string] . " bytes):\n" ;
      foreach [piccoloDeviceModel mRamBankTable] do
        message "    bank \"" . lkey . "\" from " . [mFirstFreeAddress hexString]
        . " to " . [mLastAddressPlusOne-1 hexString]
        . " (" . [mLastAddressPlusOne-mFirstFreeAddress string] . " bytes)" ;
        foreach mMirrorOffsetList
        before  message ", mirror at " ;
        do message [mFirstFreeAddress  + mValue hexString] ;
        between message ", " ;
        end foreach ;
        message "\n" ;
      end foreach ;
      switch [piccoloDeviceModel mProcessorType]
      when pic18_60, pic18_80 :
        message "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " bytes\n" ;
      when midrange :
        @uint pageCount := ([[piccoloDeviceModel mRomSize] uint] + 2047) / 2048 ;
        @string s := "" ; 
        if pageCount > 1 then
          s := "s" ;
        end if ;
        message "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " instructions ("
        . [pageCount string] . " page" . s . ")\n" ;
      when baseline : 
        message "  ROM size: " . [[[piccoloDeviceModel mRomSize] uint] string] . " instructions\n" ;
      end switch ;
      if [piccoloDeviceModel mEepromSize] == 0 then
        message "  No EEPROM\n" ;
      else
        message "  EEPROM size: " . [[piccoloDeviceModel mEepromSize] string] . " bytes (at "
        . [[piccoloDeviceModel mEepromAddress] hexString] . ")\n" ;
      end if ;
    else
      error here:"The " . deviceForMemoryDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
#------------------------------------------------ Print REGISTERS description
  @string deviceForRegistersDescription := [option piccolo_options.registerDescription value] ;
  if [deviceForRegistersDescription length] > 0 then
    @string devicePath := "/" . deviceForRegistersDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForRegistersDescription !here] ?piccoloDeviceModel ;
      message deviceForRegistersDescription . " has " . [[[piccoloDeviceModel mRegisterTable] count] string] . " special registers:\n" ;
      foreach [piccoloDeviceModel mRegisterTable] do
        @string s := "  '" . lkey . "' at " ;
        foreach mRegisterAddressList
        do s .= [mValue hexString] ;
        between s .= ", " ;
        end foreach ;
        s .= mBitDefinitionString . "\n" ;
        message s ;
      end foreach ;
    else
      error here:"The " . deviceForRegistersDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
#------------------------------------------------ Print CONFIGURATION description
  @string deviceForConfigDescription := [option piccolo_options.configDescription value] ;
  if [deviceForConfigDescription length] > 0 then
    @string devicePath := "/" . deviceForConfigDescription . ".piccoloDevice" ;
    if [[filewrapper embeddedDevices] fileExistsAtPath !devicePath] then
      @piccoloDeviceModel piccoloDeviceModel ;
      parseDeviceDefinition ![@lstring new ! deviceForConfigDescription !here] ?piccoloDeviceModel ;
      message deviceForConfigDescription . " has " . [[[piccoloDeviceModel mConfigRegisterMap] count] string] . " configuration registers:\n" ;
      foreach [piccoloDeviceModel mConfigRegisterMap] do
        @string s := "REGISTER '" . lkey . "' at " . [[mRegisterAddress uint] hexString] . ", width " . [[mRegisterWidth uint] string] . "\n" ;
        foreach mIllegalMaskList do
          s .= "  illegal value " . [[mIllegalValue uint] hexString] . " mask " . [[mIllegalMask uint] hexString] . " description \"" . mDescription . "\"\n" ;
        end foreach ;
        foreach mConfigRegisterMaskMap prefixedby others_ do
          s .= "  setting '" . others_lkey . "': mask " . [[others_mMaskValue uint] hexString] . " description \"" . others_mDescription . "\"\n" ;
          foreach others_mFieldSettingMap prefixedby second_ do
            s .= "    value " . [second_mValue hexString] . " description \"" . second_lkey . "\"\n" ;
          end foreach ;
        end foreach ;
        message s ;
      end foreach ;
    else
      error here:"The " . deviceForConfigDescription . " device is not supported or does not exist" ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*

when . "piccolo"
message "a source text file with the .piccolo extension"
??@lstring inSourceFile {
  grammar piccolo_grammar in inSourceFile ;
}

#----------------------------------------------------------------------------*

#--- Epilogue routine
after {
}

#----------------------------------------------------------------------------*

end program ;
