semantics piccolo_semantics :
import semantics piccolo_build_binary_code in "piccolo_build_binary_code.gSemantics" ;
import semantics piccolo_decompose_structured_instructions in "piccolo_decompose_structured_instructions.gSemantics" ;
import semantics piccolo_convert_relatives in "piccolo_convert_relatives.gSemantics" ;
import option piccolo_options in "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool hasLowInterrupt := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [mInterruptName string] == "high" then
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
  end foreach ;
#-------------------------------- Ram definition
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
  #--- Find ram bank
    @uint lastAddressPlusOne ;
    @uint firstFreeAddress ;
    [ramBank searchKey !mBankName ?firstFreeAddress ?lastAddressPlusOne] ;
    foreach mDeclaration do
      if [mSize uint] == 0 then
        error mSize: "zero size is not allowed" ;
      end if ;
      @bitSliceTable bitSliceTable [emptyMap] ;
      [!?registerTable insertKey !mName ![@uintlist listWithValue !firstFreeAddress] ![mSize uint] !bitSliceTable] ;
      firstFreeAddress := firstFreeAddress + [mSize uint] ;
      [!?ramBank setMFirstFreeAddressForKey !firstFreeAddress ![mBankName string]] ;
      if firstFreeAddress > lastAddressPlusOne then
        error mName: "overflow in '" . mBankName . "' ram bank for '" . mName . "' declaration" ;
      end if ;
    end foreach ;
  end foreach ;
#-------------------------------- Perform Semantics checkings

#-------------------------------- Build Assembly Instruction List
  @ipic_instructionList generatedInstructionList ;
  buildAssemblyInstructionList
    !inPiccoloModel
    !hasHighInterrupt
    !hasLowInterrupt
    ?generatedInstructionList
  ;
#-------------------------------- Convert relative branchs to absolute, when needed
  if not [option piccolo_options.doNotConvertRelative] then
    convertRelativeBranchsToAbsoluteWhenNeeded !?generatedInstructionList ;
  end if ;
#-------------------------------- Code generation
#--- If no error, generate object file
  if [@uint errorCount] == 0 then
    if [option piccolo_options.generateAssembly] then
      @string assemblyCode ;
      buildAssemblyCode
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        ?assemblyCode
      ;
      @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !destinationFile] ;
    else
      buildBinaryCode
        !registerTable
        !generatedInstructionList
      ;
      @string contents ;
      getGeneratedContents ?contents ;
      @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
      [contents writeToFileWhenDifferentContents !destinationFile] ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
