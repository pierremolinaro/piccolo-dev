semantics piccolo_semantics :
import semantics piccolo_build_binary_code in "piccolo_build_binary_code.gSemantics" ;
import semantics buildIPICAssemblyInstructionList in "buildIPICAssemblyInstructionList.gSemantics" ;
import semantics piccolo_convert_relatives in "piccolo_convert_relatives.gSemantics" ;
import semantics ipic_optimizations in "ipic_optimizations.gSemantics" ;
import semantics piccolo_config in "piccolo_config.gSemantics" ;

import option piccolo_options in "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*
#                                                                            *
#           R A M    D E C L A R A T I O N    A N A L Y S I S                *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @declarationInRam.handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
;

#----------------------------------------------------------------------------*

override method @commonDeclarationInRam.handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
:
  @uint firstFreeAddressBeforeCommon ;
  [ioRamBank searchKey !inCurrentRamBank ?firstFreeAddressBeforeCommon ?*] ;
  @bool firstFreeAddressDefined := false ;
  @uint firstFreeAddress := 0 ;
  foreach mBranchList do
    @ramBankTable ramBank := ioRamBank ;
    foreach mDeclarations do
      [mDeclaration handleDeclaration !?ramBank !?ioRegisterTable !inCurrentRamBank] ;
    end foreach ;
    @uint ffa ;
    [ramBank searchKey !inCurrentRamBank ?ffa ?*] ;
    if not firstFreeAddressDefined then
      firstFreeAddress := ffa ;
      firstFreeAddressDefined := true ;
    elsif ffa != firstFreeAddress then
      error mEndOfBranchLocation: "this branch allocates " . [ffa - firstFreeAddressBeforeCommon string]
      . " byte(s), while the first branch allocates "
      . [firstFreeAddress - firstFreeAddressBeforeCommon string] . " byte(s)" ;
    end if ;
  end foreach ;
  [!?ioRamBank setMFirstFreeAddressForKey !firstFreeAddress ![inCurrentRamBank string]] ;
end method ;

#----------------------------------------------------------------------------*

override method @byteDeclarationInRam.handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
:
  @uint lastAddressPlusOne ;
  @uint firstFreeAddress ;
  [ioRamBank searchKey !inCurrentRamBank ?firstFreeAddress ?lastAddressPlusOne] ;
  if [mSize uint] == 0 then
    error mSize: "zero size is not allowed" ;
  end if ;
  [!?ioRegisterTable insertKey !mName ![@uintlist listWithValue !firstFreeAddress] ![mSize uint] !mBitSliceTable !mBitDefinitionString] ;
  firstFreeAddress := firstFreeAddress + [mSize uint] ;
  [!?ioRamBank setMFirstFreeAddressForKey !firstFreeAddress ![inCurrentRamBank string]] ;
  if firstFreeAddress > lastAddressPlusOne then
    error mName: "overflow in '" . inCurrentRamBank . "' ram bank for '" . mName . "' declaration" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
  @string listFileContents := "" ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
  @uint accessBankSplitOffset ;
  switch [piccoloDeviceModel mProcessorType]
    when pic18_60 : accessBankSplitOffset := 0x60 ;
    when pic18_80 : accessBankSplitOffset := 0x80 ;
  end switch ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool highInterruptIsFast := false ;
  @bool hasLowInterrupt := false ;
  @bool lowInterruptIsFast := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [mInterruptName string] == "high" then
      highInterruptIsFast := mFastReturn ;
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      lowInterruptIsFast := mFastReturn ;
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
    if highInterruptIsFast & lowInterruptIsFast then
      error mInterruptName:"either low interrupt or high interrupt can be \"fast\", not both" ;
    end if ;
  end foreach ;
#-------------------------------- Config definition
  @actualConfigurationMap actualConfigurationMap ;
  buildConfig
    ![piccoloDeviceModel mConfigRegisterMap]
    ![inPiccoloModel mConfigDefinitionList]
    ![inPiccoloModel mAcceptDefaultConfiguration]
    !?listFileContents
    ?actualConfigurationMap
  ;
#-------------------------------- Ram definition
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
    foreach mDeclaration do
      [mDeclaration handleDeclaration !?ramBank !?registerTable !mBankName] ;
    end foreach ;
  end foreach ;
  if [option piccolo_options.ouputListingFile] then
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    listFileContents .= "*" . ["DECLARED VARIABLES" stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    listFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    foreach registerTable do
      if not [[piccoloDeviceModel mRegisterTable] hasKey ![key string]] then
        listFileContents .= [[key string] stringByLeftPadding !40 !' '] . " " ;
        @uint address ; [mRegisterAddressList first ?address] ;
        listFileContents .= [address hexString] . mBitDefinitionString . "\n" ;
      end if ;
    end foreach ;
    listFileContents .= "\n" ;
  end if ;
#-------------------------------- Build IPIC Assembly Instruction List
  @ipic_instructionList generatedInstructionList ;
  buildIPICAssemblyInstructionList
    !accessBankSplitOffset
    !registerTable
    !inPiccoloModel
    !hasHighInterrupt
    !hasLowInterrupt
    ?generatedInstructionList
    !?listFileContents
  ;
#-------------------------------- Perform Code Optimization
  if ([@uint errorCount] == 0) & [option piccolo_options.performOptimizations] then
    performOptimizations !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Convert relative branchs to absolute, when needed
  if [@uint errorCount] == 0 then
    convertRelativeBranchsToAbsoluteWhenNeeded !?generatedInstructionList !?listFileContents ;
  end if ;
#-------------------------------- Code generation
  if [option piccolo_options.ouputListingFile] then
    @string listFile := [inSourceFileName stringByDeletingPathExtension] . ".list" ;
    [listFileContents writeToFileWhenDifferentContents !listFile] ;
  end if ;
#--- If no error, generate object file(s)
  if [@uint errorCount] == 0 then
  #--- Generate hex file
    buildBinaryCode
      !generatedInstructionList
      ![[piccoloDeviceModel mRomSize] uint]
      !actualConfigurationMap
    ;
    @string contents ;
    getGeneratedContents ?contents ;
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFileWhenDifferentContents !hexDestinationFile] ;
  #--- Generate asm file, if corresponding option enabled
    if [option piccolo_options.generateAssembly] then
      @string assemblyCode ;
      buildAssemblyCode
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        !actualConfigurationMap
        ?assemblyCode
      ;
      @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !asmDestinationFile] ;
    end if ;
  else # There are errors : delete hex and asm files
    @string hexDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    if [hexDestinationFile fileExists] then
      [@string deleteFile !hexDestinationFile] ;
    end if ;
    @string asmDestinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
    if [asmDestinationFile fileExists] then
      [@string deleteFile !asmDestinationFile] ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
