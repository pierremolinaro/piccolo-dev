semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

extern routine setEmitAddress ??@uint inAddress ;

extern routine currentEmitAddress !@uint outAddress ;

extern routine emitCode ??@uint inCode ;

extern routine getGeneratedContents !@string outContents ;

#----------------------------------------------------*
#           DECOMPOSE COMPLEX INSTRUCTION            *
#----------------------------------------------------*

method @instruction.decomposeComplexInstruction
  ?!@uint unused ioLocalLabelIndex
  ?!@instructionList unused ioGeneratedInstructionList
:
end method ;

#----------------------------------------------------*

override method @instruction_FOREVER.decomposeComplexInstruction
  ?!@uint ioLocalLabelIndex
  ?!@instructionList ioGeneratedInstructionList
:
  [!?ioGeneratedInstructionList popLast ?*] ;
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; 
  ioLocalLabelIndex ++ ;
  ioGeneratedInstructionList += ![@pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation]] ;
  foreach mInstructionList do
    ioGeneratedInstructionList += !mInstruction ;
    [mInstruction decomposeComplexInstruction !?ioLocalLabelIndex !?ioGeneratedInstructionList] ;
  end foreach ;
  ioGeneratedInstructionList += ![@instruction_BRA new !mInstructionLocation ![@lstring new !label0 !mInstructionLocation]] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON.decomposeComplexInstruction
  ?!@uint ioLocalLabelIndex
  ?!@instructionList ioGeneratedInstructionList
:
  [!?ioGeneratedInstructionList popLast ?*] ;
  @FA_instruction_base_code baseCode ;
  switch mOpCode
    when CPFSEQ : baseCode := [@FA_instruction_base_code CPFSEQ] ;
    when CPFSGT : baseCode := [@FA_instruction_base_code CPFSGT] ;
    when CPFSLT : baseCode := [@FA_instruction_base_code CPFSLT] ;
    when TSTFSZ : baseCode := [@FA_instruction_base_code TSTFSZ] ;
  end switch ;
  ioGeneratedInstructionList += ![@instruction_FA new
    !mInstructionLocation
    !baseCode
    !mRegisterExpression
  ] ;
#--- Append Instruction
  ioGeneratedInstructionList += !mInstruction ;
  [mInstruction decomposeComplexInstruction !?ioLocalLabelIndex !?ioGeneratedInstructionList] ;
end method ;

#----------------------------------------------------*

override method @instruction_IF_BitTest.decomposeComplexInstruction
  ?!@uint ioLocalLabelIndex
  ?!@instructionList ioGeneratedInstructionList
:
  [!?ioGeneratedInstructionList popLast ?*] ;
  @bit_oriented_op baseCode ;
  if mSkipIfSet then
    baseCode := [@bit_oriented_op BTFSS] ;
  else
    baseCode := [@bit_oriented_op BTFSC] ;
  end if ;
  ioGeneratedInstructionList += ![@instruction_FBA new
    !mInstructionLocation
    !baseCode
    !mRegisterExpression
    !mBitNumber
  ] ;
#--- Append Instruction
  ioGeneratedInstructionList += !mInstruction ;
  [mInstruction decomposeComplexInstruction !?ioLocalLabelIndex !?ioGeneratedInstructionList] ;
end method ;

#----------------------------------------------------*

abstract method @structured_if_condition.decomposeIFcondition
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@instructionList ioGeneratedInstructionList
;

#----------------------------------------------------*

override method @bcc_in_structured_if_condition.decomposeIFcondition
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@instructionList ioGeneratedInstructionList
:
  ioGeneratedInstructionList += ![@instruction_conditionalBranch new
    !inInstructionLocation
    !mCondition
    ![@lstring new !inTargetLabel !inInstructionLocation]
  ] ;
end method ;

#----------------------------------------------------*

override method @bitTest_in_structured_if_condition.decomposeIFcondition
  ??@location inInstructionLocation
  ??@string inTargetLabel
  ?!@instructionList ioGeneratedInstructionList
:
  @bit_oriented_op op ;
  if mBTFSSinstruction then
    op := [@bit_oriented_op BTFSS] ;
  else
    op := [@bit_oriented_op BTFSC] ;
  end if ;
  ioGeneratedInstructionList += ![@instruction_FBA new
    !inInstructionLocation
    !op
    !mRegisterExpression
    !mBitNumber
  ] ;
  ioGeneratedInstructionList += ![@instruction_BRA new !inInstructionLocation ![@lstring new !inTargetLabel !inInstructionLocation]] ;
end method ;

#----------------------------------------------------*

override method @instruction_structured_if.decomposeComplexInstruction
  ?!@uint ioLocalLabelIndex
  ?!@instructionList ioGeneratedInstructionList
:
#---
  [!?ioGeneratedInstructionList popLast ?*] ;
  @string label0 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
  @string label1 := "_label_" . [ioLocalLabelIndex string] ; ioLocalLabelIndex ++ ;
#--- Translate condition
  [mIfCondition decomposeIFcondition !mInstructionLocation !label0 !?ioGeneratedInstructionList] ;
#--- 'then' instructions
  foreach mThenInstructionList do
    ioGeneratedInstructionList += !mInstruction ;
    [mInstruction decomposeComplexInstruction !?ioLocalLabelIndex !?ioGeneratedInstructionList] ;
  end foreach ;
  if [mElseInstructionList length] > 0 then
    ioGeneratedInstructionList += ![@instruction_BRA new !mInstructionLocation ![@lstring new !label1 !mInstructionLocation]] ;
  end if ;
#--- 'else' instructions
  ioGeneratedInstructionList += ![@pseudo_LABEL new ![@lstring new !label0 !mInstructionLocation]] ;
  foreach mElseInstructionList do
    ioGeneratedInstructionList += !mInstruction ;
    [mInstruction decomposeComplexInstruction !?ioLocalLabelIndex !?ioGeneratedInstructionList] ;
  end foreach ;
  if [mElseInstructionList length] > 0 then
    ioGeneratedInstructionList += ![@pseudo_LABEL new ![@lstring new !label1 !mInstructionLocation]] ;
  end if ;
end method ;

#----------------------------------------------------*
#                BUILD ASSEMBLY CODE                 *
#----------------------------------------------------*

method @instruction.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string unused ioString :
end method ;

#----------------------------------------------------*

override method @pseudo_ORG.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  ORG " . [mOrigin hexString] . "\n" ;
end method ;

#----------------------------------------------------*

override method @pseudo_LABEL.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= [mTargetLabel string] . ":\n" ;
end method ;

#----------------------------------------------------*

method @registerExpression.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
  !@bool outUseBSRregister
  !@bitSliceTable outBitSliceTable
:
  ioString .= [mRegisterName string] ;
  if [mOffset uint] > 0 then
    ioString .= " + " . [[mOffset uint] hexString] ;
  end if ;
  @uintlist registerAddressList ;
  @uint size ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  outUseBSRregister := false ;
  if not found then
    outUseBSRregister := true ;
  end if ;
end method ;

#----------------------------------------------------*

override method @instruction_FDA.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  @bool useBSRaccess ;
#log mInstruction_FDA_base_code ;
#message "*** '" . [mInstruction_FDA_base_code mnemonic] . "'\n" ;
  ioString .= "  " . [mInstruction_FDA_base_code mnemonic] . " " ;
#  ioString .= "  /* " . [[mInstruction_FDA_base_code mnemonic] description] . " */ " ;
  [mRegisterExpression buildAssemblyCode !inRegisterTable !?ioString ?useBSRaccess ?*] ;
  if m_W_isDestination & useBSRaccess then
    ioString .= ", W, BSR_ACCESS" ;
  elsif useBSRaccess then
    ioString .= ", F, BSR_ACCESS" ;
  elsif m_W_isDestination then
    ioString .= ", W" ;
  else
    ioString .= ", F" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_MOVFF.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  ioString .= "  MOVFF " ;
  [mSourceRegisterName buildAssemblyCode !inRegisterTable !?ioString ?* ?*] ;
  ioString .= ", " ;
  [mDestinationRegisterName buildAssemblyCode !inRegisterTable !?ioString ?* ?*] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
:
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
end method ;

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
:
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
end method ;

#----------------------------------------------------*

override method @instruction_FBA.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  @bool useBSRaccess ;
  ioString .= "  " . [mBitOrientedOp mnemonic] . " " ;
  @bitSliceTable bitSliceTable ;
  [mRegisterExpression buildAssemblyCode !inRegisterTable !?ioString ?useBSRaccess ?bitSliceTable] ;
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
  ioString .= ", " . [bitNumber string] ;
  if useBSRaccess then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_FA.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  @bool useBSRaccess ;
  ioString .= "  " . [mFAinstruction mnemonic] . " " ;
  [mRegisterExpression buildAssemblyCode !inRegisterTable !?ioString ?useBSRaccess ?*] ;
  if useBSRaccess then
    ioString .= ", BSR_ACCESS" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_conditionalBranch.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  " . [mConditionalBranch mnemonic] . " " . [mTargetLabel string] . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_BRA.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  BRA  " . [mTargetLabel string] . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_CALL.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  CALL " . mTargetLabel . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_GOTO.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  GOTO " . mTargetLabel . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_RCALL.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  RCALL " . mTargetLabel . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_CLRWDT.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  CLRWDT\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_DAW.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  DAW\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_NOP.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  NOP\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_POP.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  POP\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_PUSH.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  PUSH\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_RESET.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  RESET\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_RETURN.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  RETURN\n" ;
end method ;

#----------------------------------------------------*

 override method @instruction_RETFIE.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  RETFIE" ;
  if mFastReturn then
    ioString .= " 1" ;
  end if ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

 override method @instruction_SLEEP.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  SLEEP\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_literalOperation.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  " . [mLiteralInstruction mnemonic] . " " . [[mLiteralValue uint] hexString] . "\n" ;
end method ;

#----------------------------------------------------*

 override method @instruction_LFSR.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  ioString .= "  LFSR " . [[mFSRindex uint] string] . ", " ;
  [mRegisterExpression  buildAssemblyCode
    !inRegisterTable
    !?ioString
    ?*
    ?*
  ] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

 override method @instruction_MOVAW.buildAssemblyCode
  ??@registerTable inRegisterTable
  ?!@string ioString
:
  ioString .= "  MOVLW " ;
  [mRegisterExpression  buildAssemblyCode
    !inRegisterTable
    !?ioString
    ?*
    ?*
  ] ;
  ioString .= "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_MNOP.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    ioString .= "  NOP\n" ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLRD.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  TBLRD " . [mOption mnemonic] . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_TBLWT.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  ioString .= "  TBLWT " . [mOption mnemonic] . "\n" ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_retlw.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  if mUsesRelativeCall then
    ioString .= "  RCALL _computed_goto_2\n" ;
  else
    ioString .= "  CALL _computed_goto_2\n" ;
  end if ;
  foreach mLiteralValues do
    ioString .= "  RETLW " . [[mValue uint] hexString] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_bra.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  if mUsesRelativeCall then
    ioString .= "  RCALL _computed_goto_2\n" ;
  else
    ioString .= "  CALL _computed_goto_2\n" ;
  end if ;
  foreach mTargetLabels do
    ioString .= "  BRA " . [mValue string] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

override method @instruction_computed_goto.buildAssemblyCode
  ??@registerTable unused inRegisterTable
  ?!@string ioString
:
  if mUsesRelativeCall then
    ioString .= "  RCALL _computed_goto_4\n" ;
  else
    ioString .= "  CALL _computed_goto_4\n" ;
  end if ;
  foreach mTargetLabels do
    ioString .= "  GOTO " . [mValue string] . "\n" ;
  end foreach ;
end method ;

#----------------------------------------------------*

routine buildAssemblyCode
  ??@string inProcessorName
  ??@registerTable inPredefinedRegisters
  ??@registerTable inAllRegisters
  ??@instructionList inInstructionList
  !@string outAssemblyCode
:
  outAssemblyCode := "  PROCESSOR " . inProcessorName . "\n" ;
#--- Prefined registers
  outAssemblyCode .= ";--- Prefefined registers\n" ;
  foreach inPredefinedRegisters do
    @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
    outAssemblyCode .= [key string] . " EQU " . [firstRegister hexString] . "\n" ;
  end foreach ;
#--- User defined registers in ram
  outAssemblyCode .= ";--- User defined registers (in RAM)\n" ;
  foreach inAllRegisters do
    if not [inPredefinedRegisters hasKey ![key string]] then
      @uint firstRegister ; [mRegisterAddressList first ?firstRegister] ;
      outAssemblyCode .= [key string] . " EQU " . [firstRegister hexString] . "\n" ;
    end if ;
  end foreach ;
#--- PICCOLO defined symbols
  outAssemblyCode .= ";--- Piccolo defined symbols\n" ;
  outAssemblyCode .= "F EQU 0\n" ;
  outAssemblyCode .= "W EQU 1\n" ;
  outAssemblyCode .= "BSR_ACCESS EQU 1\n" ;
#--- Code
  outAssemblyCode .= ";--- Code\n" ;
  outAssemblyCode .= "  ORG 0\n" ;
  foreach inInstructionList do
    [mInstruction buildAssemblyCode !inAllRegisters !?outAssemblyCode] ;
  end foreach ;
  outAssemblyCode .= "\n" ;
  outAssemblyCode .= ";---\n\n" ;
  outAssemblyCode .= "  END\n\n" ;
end routine ;

#----------------------------------------------------*
#                                                    *
#----------------------------------------------------*

routine checkCurrentEmitAddress ??@uint inCurrentAddress :
  @uint addr ; currentEmitAddress ? addr ;
  if ([@uint errorCount] == 0) & (addr != inCurrentAddress) then
    error here:"internal error: current emit address is " . [addr hexString]
    . "; it should be " . [inCurrentAddress hexString] ;
  end if ;
end routine ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  @uint mRequiredSelectedBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
  ?!@uint unused ioCurrentlySelectedBank
:
end method ;

#----------------------------------------------------*

override
method @pseudo_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
:
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress !ioCurrentlySelectedBank] ;
end method ;

#----------------------------------------------------*

override
method @instruction_FOREVER.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
:
  @uint address := inAddress ;
  foreach mInstructionList do
    [mInstruction enterLabelAtAddress
      !?ioRoutineSymbolTable
      !address
      !?ioCurrentlySelectedBank
    ] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    address := address + lg ;
  end foreach ;
end method ;

#----------------------------------------------------*

override
method @instruction_structured_if.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
:
#--- Condition length
  @uint conditionLength ;
  [mIfCondition  conditionLength ?conditionLength] ;
  @uint address := inAddress + conditionLength ;
  foreach mThenInstructionList do
    [mInstruction enterLabelAtAddress
      !?ioRoutineSymbolTable
      !address
      !?ioCurrentlySelectedBank
    ] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    address := address + lg ;
  end foreach ;
  if [mElseInstructionList length] > 0 then
    address := address + 2 ; # Bra for skipping else part
  end if ;
  foreach mElseInstructionList do
    [mInstruction enterLabelAtAddress
      !?ioRoutineSymbolTable
      !address
      !?ioCurrentlySelectedBank
    ] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    address := address + lg ;
  end foreach ;
end method ;

#----------------------------------------------------*

struct @codeGenerationContext {
  @routineSymbolTable mRoutineSymbolTable ;
  @registerTable mRegisterTable ;
  @uint mCurrentBank ;
  @uint mComputedGoto2RoutineAddress ;
  @uint mComputedGoto4RoutineAddress ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddress
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
:
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?*] ;
  if [mOffset uint] > size then
    error mOffset:"The index (" . [[mOffset uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
  [registerAddressList first ?outRegisterAddress] ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddressingInformations
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
  !@bool outUseBSRregister
  !@bitSliceTable outBitSliceTable
:
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable] ;
  @bool found := false ;
  outRegisterAddress := 0 ;
  foreach registerAddressList while not found do
    outRegisterAddress := mValue ;
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  outUseBSRregister := false ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    outUseBSRregister := true ;
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . mRegisterName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error mRegisterName: errorMessage ;
  end if ;
  if found & ([mOffset uint] >= size) then
    error mOffset:"index (" . [[mOffset uint] string] . ") is should be lower than size (". [size string] . ")" ;
  end if ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
end method ;

#----------------------------------------------------------------------------*

routine checkInstructionIsReachable ?!@bool ioIsReachable ??@location inErrorLocation :
  if not ioIsReachable then
    error inErrorLocation: "dead code: execution cannot reach this instruction" ;
  end if ;
  ioIsReachable := true ; # So that error message is sent once
end routine ;

#----------------------------------------------------------------------------*

abstract method @instruction.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool unused ioContinuesInSequence
;

#----------------------------------------------------------------------------*

override method @instruction_FDA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint sourceRegisterAddress ;
  [mSourceRegisterName getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  @uint destinationRegisterAddress ;
  [mDestinationRegisterName getRegisterAddress !inCodeGenerationContext ?destinationRegisterAddress] ;
  emitCode !0xC000 | sourceRegisterAddress ;
  emitCode !0xF000 | destinationRegisterAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FBA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
#--- Register
  @bitSliceTable bitSliceTable;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

routine emitConditionalBranchInstruction
  ??@uint inConditionalBranchInstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
  ??@conditional_branch inConditionalBranch
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inConditionalBranchInstructionAddress sint]) >> 1 ;
  if (displacement > 127S) | (displacement < - 128S) then
    error inErrorLocation: "displacement too large for conditional branch instruction" ;
  end if ;
#  log displacement ;
  @uint baseCode ;
  getBccBaseCode !inConditionalBranch ?baseCode ;
  emitCode !baseCode | [displacement & 0x0FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  emitConditionalBranchInstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
    !mConditionalBranch
  ;
end method ;

#----------------------------------------------------------------------------*

routine emitBRAinstruction
  ??@uint inBRAinstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inBRAinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inErrorLocation: "displacement too large for BRA instruction" ;
  end if ;
#  log displacement ;
  emitCode !0xD000 | [displacement & 0x07FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_BRA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
####  ioContinuesInSequence := false ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  @sint displacement := ([targetAddress sint] - 2S - [inAddress sint]) >> 1 ;
  if (displacement > 0x800S) | (displacement < - 0x800S) then
    error mTargetLabel: "displacement too large for RCALL instruction" ;
  end if ;
#--- Emit Code
  emitBRAinstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
  ;
end method ;

#----------------------------------------------------------------------------*

routine emitGOTOinstruction
  ??@uint inTargetAddress
:
  emitCode !0xEF00 | ((inTargetAddress >> 1) & 255) ;
  emitCode !0xF000 | (inTargetAddress >> 9) ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_GOTO.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
####  ioContinuesInSequence := false ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  emitGOTOinstruction !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

routine emitCALLinstruction
  ??@uint inTargetAddress
:
  emitCode !0xEC00 | ((inTargetAddress >> 1) & 255) ;
  emitCode !0xF000 | (inTargetAddress >> 9) ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_CALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  emitCALLinstruction !targetAddress ;
end method ;

#----------------------------------------------------------------------------*

routine emitRCALLinstruction
  ??@uint inRCALLinstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inRCALLinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inErrorLocation: "displacement too large for RCALL instruction" ;
  end if ;
#  log displacement ;
  emitCode !0xD800 | [displacement & 0x07FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_RCALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  emitRCALLinstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
  ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_CLRWDT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0004 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_DAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0007 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_NOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0000 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_POP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0006 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_PUSH.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0005 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_RESET.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x00FF ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_RETURN.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0012 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_SLEEP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0003 ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mLiteralValue uint] > 255 then
    error mLiteralValue: "A literal value (" . [[mLiteralValue uint] string] . ") should be lower or equal to 255" ;
  end if ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | [mLiteralValue uint] ;
  emitCode !code ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_LFSR.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mFSRindex uint] > 2 then
    error mFSRindex: "LFSR index should be lower or equal to 2" ;
  end if ;
  @uint sourceRegisterAddress ;
  [mRegisterExpression getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  emitCode !0xEE00 | ([mFSRindex uint] << 4) | (sourceRegisterAddress >> 8) ;
  emitCode !0xF000 | (sourceRegisterAddress & 255) ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVLB.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
end method ;

#----------------------------------------------------------------------------*

override method @pseudo_LABEL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  ioContinuesInSequence := true ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (targetAddress != inAddress) then
    error mTargetLabel: "Internal second pass error: the '" . mTargetLabel
    . "' label gets " . [inAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  [mRegisterExpression getRegisterAddress
    !inCodeGenerationContext
    ?registerAddress
  ] ;
  if registerAddress > 255 then
    error here : "for MOVAW instruction, address (" . [registerAddress hexString] . ") should be lower or equal to 0xFF" ;
  end if ;
  emitCode !0x0E00 | registerAddress ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_TBLRD.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  switch mOption
  when simpleAccess  : emitCode !0x0008 ;
  when postIncrement : emitCode !0x0009 ;
  when postDecrement : emitCode !0x000A ;
  when preIncrement  : emitCode !0x000B ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_TBLWT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  switch mOption
  when simpleAccess  : emitCode !0x000C ;
  when postIncrement : emitCode !0x000D ;
  when postDecrement : emitCode !0x000E ;
  when preIncrement  : emitCode !0x000F ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MNOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    emitCode !0x0000 ;
    idx ++ ;
  end loop ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FOREVER.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  @uint currentAddress := inAddress ;
  @bool continuesInSequence := true ;
  foreach mInstructionList do
    [mInstruction generateCodeAtAddress !inCodeGenerationContext !currentAddress !?continuesInSequence] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    currentAddress := currentAddress + lg ;
  end foreach ;
#--- Generate BRA instruction
  emitBRAinstruction
    !currentAddress
    !inAddress
    !mInstructionLocation
  ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?registerAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (registerAddress & 255) ;
  emitCode !code ;
  @bool unusedContinuesInSequence := true ;
  [mInstruction generateCodeAtAddress !inCodeGenerationContext !inAddress + 2 !?unusedContinuesInSequence] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_IF_BitTest.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  @bool useBSRregister ;
  @bitSliceTable bitSliceTable;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?registerAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (registerAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;
  @bool unusedContinuesInSequence := true ;
  [mInstruction generateCodeAtAddress !inCodeGenerationContext !inAddress + 2 !?unusedContinuesInSequence] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_retlw.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto2RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto2RoutineAddress] ;
  end if ;
  foreach mLiteralValues do
    if [mValue uint] > 255 then
      error here : "immediate value (" . [[mValue uint] string] . ") should be lower or equal to 255" ;
    end if ;
    emitCode !0x0C00 | [mValue uint] ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_bra.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto2RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto2RoutineAddress] ;
  end if ;
  @uint address := inAddress + 4 ;
  foreach mTargetLabels do
    @uint targetAddress ;
    @uint requiredSelectedBank ;
    [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mValue ?targetAddress ?requiredSelectedBank] ;
    emitBRAinstruction
      !address
      !targetAddress
      ![mValue location]
    ;
    address := address + 2 ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_goto.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto4RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto4RoutineAddress] ;
  end if ;
  foreach mTargetLabels do
    @uint targetAddress ;
    @uint requiredSelectedBank ;
    [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mValue ?targetAddress ?requiredSelectedBank] ;
    emitGOTOinstruction
      !targetAddress
    ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

abstract method @structured_if_condition.emitInstruction
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inConditionalBranchInstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
;

#----------------------------------------------------------------------------*

override method @bcc_in_structured_if_condition.emitInstruction
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint inCurrentAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
  emitConditionalBranchInstruction
    !inCurrentAddress
    !inTargetAddress
    !inErrorLocation
    !mCondition
  ;
end method ;

#----------------------------------------------------------------------------*

override method @bitTest_in_structured_if_condition.emitInstruction
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inCurrentAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
#--- Register
  @bitSliceTable bitSliceTable;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ;
  [self baseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;

  emitBRAinstruction
   !inCurrentAddress + 2
   !inTargetAddress
   !inErrorLocation
  ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_structured_if.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
:
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
#--- 'then' instructions length
  @uint thenInstructionsLength := 0 ;
  foreach mThenInstructionList do
    @uint lg ; [mInstruction instructionLength ?lg] ;
    thenInstructionsLength := thenInstructionsLength + lg ;
  end foreach ;
#--- 'else' instructions length
  @uint elseInstructionsLength := 0 ;
  foreach mElseInstructionList do
    @uint lg ; [mInstruction instructionLength ?lg] ;
    elseInstructionsLength := elseInstructionsLength + lg ;
  end foreach ;
#--- Condition length
  @uint conditionLength ;
  [mIfCondition  conditionLength ?conditionLength] ;
#--- Emit condition
  @uint conditionalBranchDestination := inAddress + thenInstructionsLength + conditionLength ;
  if [mElseInstructionList length] > 0 then
    conditionalBranchDestination := conditionalBranchDestination + 2 ;
  end if ;
  [mIfCondition emitInstruction
    !inCodeGenerationContext
    !inAddress
    !conditionalBranchDestination
    !mInstructionLocation
  ] ;
#--- Emit 'then' instructions
  @uint currentAddress := inAddress + conditionLength ;
  @bool continuesInSequence := true ;
  foreach mThenInstructionList do
    [mInstruction generateCodeAtAddress
      !inCodeGenerationContext
      !currentAddress
      !?continuesInSequence
    ] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    currentAddress := currentAddress + lg ;
  end foreach ;
#--- Emit 'else' instructions
  if [mElseInstructionList length] > 0 then
    emitBRAinstruction
      !currentAddress
      !currentAddress + elseInstructionsLength + 2
      !mInstructionLocation
    ;
    currentAddress := currentAddress + 2 ;
    continuesInSequence := true ;
    foreach mElseInstructionList do
      [mInstruction generateCodeAtAddress
        !inCodeGenerationContext
        !currentAddress
        !?continuesInSequence
      ] ;
      @uint lg ; [mInstruction instructionLength ?lg] ;
      currentAddress := currentAddress + lg ;
    end foreach ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool hasLowInterrupt := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [mInterruptName string] == "high" then
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
  end foreach ;
#-------------------------------- Ram definition
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
  #--- Find ram bank
    @uint lastAddressPlusOne ;
    @uint firstFreeAddress ;
    [ramBank searchKey !mBankName ?firstFreeAddress ?lastAddressPlusOne] ;
    foreach mDeclaration do
      if [mSize uint] == 0 then
        error mSize: "zero size is not allowed" ;
      end if ;
      @bitSliceTable bitSliceTable [emptyMap] ;
      [!?registerTable insertKey !mName ![@uintlist listWithValue !firstFreeAddress] ![mSize uint] !bitSliceTable] ;
      firstFreeAddress := firstFreeAddress + [mSize uint] ;
      [!?ramBank setMFirstFreeAddressForKey !firstFreeAddress ![mBankName string]] ;
      if firstFreeAddress > lastAddressPlusOne then
        error mName: "overflow in '" . mBankName . "' ram bank for '" . mName . "' declaration" ;
      end if ;
    end foreach ;
  end foreach ;
#-------------------------------- First Pass
  @instructionList generatedInstructionList [emptyList] ;
  @uint localLabelIndex := 0 ;
#--- At zero, generate 'goto main' instruction
  generatedInstructionList += ![@instruction_GOTO new !here ![@lstring new !"main" !here]] ;
#--- At 0x08, generate 'bra _fast_interrupt' instruction, if both interrupt are defined
  if hasLowInterrupt & hasHighInterrupt then
    generatedInstructionList += ![@pseudo_ORG new !0x8] ;
    generatedInstructionList += ![@instruction_BRA new !here ![@lstring new !"_fast_interrupt" !here]] ;
  end if ;
#--- First, handle low interrupt (if any)
  @uint currentROMaddress := 0x18 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  if hasLowInterrupt then
    generatedInstructionList += ![@pseudo_ORG new !0x18] ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          generatedInstructionList += !mInstruction ;
          [mInstruction decomposeComplexInstruction !?localLabelIndex !?generatedInstructionList] ;
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        generatedInstructionList += ![@instruction_RETFIE new !here !true] ;
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Then, handle high interrupt (if any)
  @uint highInterruptStartAddress := currentROMaddress ;
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
  end if ;
  if hasHighInterrupt then
    if hasLowInterrupt then
      generatedInstructionList += ![@pseudo_LABEL new ![@lstring new !"_fast_interrupt" !here]] ;
    else
      generatedInstructionList += ![@pseudo_ORG new !0x8] ;
    end if ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          generatedInstructionList += !mInstruction ;
          [mInstruction decomposeComplexInstruction !?localLabelIndex !?generatedInstructionList] ;
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        generatedInstructionList += ![@instruction_RETFIE new !here !true] ;
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Handle routines
  if (not hasHighInterrupt) & (not hasLowInterrupt) then # No interrupts
    currentROMaddress := 0x4 ;
  end if ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    generatedInstructionList += ![@pseudo_LABEL new !mRoutineName] ;
    @uint currentlySelectedBank := [mBanksel uint] ;
    [!?routineSymbolTable insertKey !mRoutineName !currentROMaddress !currentlySelectedBank] ;
    foreach mInstructionList do
      generatedInstructionList += !mInstruction ;
      [mInstruction decomposeComplexInstruction !?localLabelIndex !?generatedInstructionList] ;
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- computed_goto2, computed_goto4 routines needed ?
  @uint computedGoto4RoutineAddress := currentROMaddress ;
  @uint computedGoto2RoutineAddress := currentROMaddress + 2 ;
  if [inPiccoloModel mNeedsComputedGoto4] then
    currentROMaddress := currentROMaddress + 12 ; # Routine size
  elsif [inPiccoloModel mNeedsComputedGoto2] then
    currentROMaddress := currentROMaddress + 10 ; # Routine size
  end if ;
#--- computed_goto2 routine needed ?
  if [inPiccoloModel mNeedsComputedGoto4] then
    generatedInstructionList += ![@pseudo_LABEL new ![@lstring new !"_computed_goto_4" !here]] ;
    generatedInstructionList += ![@instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      ![@registerExpression new ![@lstring new !"WREG" !here] ![@luint new !0 !here]]
      !true
    ] ; # ADDWF WREG, W
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] then
    generatedInstructionList += ![@pseudo_LABEL new ![@lstring new !"_computed_goto_2" !here]] ;
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] | [inPiccoloModel mNeedsComputedGoto4] then
    generatedInstructionList += ![@instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      ![@registerExpression new ![@lstring new !"WREG" !here] ![@luint new !0 !here]]
      !true
    ] ; # ADDWF WREG, W
    generatedInstructionList += ![@instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWF]
      ![@registerExpression new ![@lstring new !"TOSL" !here] ![@luint new !0 !here]]
      !false
    ] ; # ADDWF TOSL, F
    generatedInstructionList += ![@instruction_literalOperation new
      !here
      ![@literal_instruction_opcode MOVLW]
      ![@luint new !0 !here]
    ] ; # MOVLW 0
    generatedInstructionList += ![@instruction_FDA new
      !here
      ![@instruction_FDA_base_code ADDWFC]
      ![@registerExpression new ![@lstring new !"TOSH" !here] ![@luint new !0 !here]]
      !false
    ] ; # ADDWFC TOSH, F
    generatedInstructionList += ![@instruction_RETURN new
      !here
    ] ; # RETURN 0
  end if ;
  @uint programSize := currentROMaddress ;
#-------------------------------- Prepare code generation
#--- At Address 0, generate a GOTO main instruction
  setEmitAddress !0 ;
  if not [routineSymbolTable hasKey !"main"] then
    error here: "there is no 'main' routine" ;
  else
    @uint mainRoutineAddress ;
    [routineSymbolTable searchKey ![@lstring new !"main" !here] ?mainRoutineAddress ?*] ;
    emitCode !0xEF00 | ((mainRoutineAddress >> 1) & 255) ;
    emitCode !0xF000 | (mainRoutineAddress >> 9) ;
  end if ;
#---- At address 0x8, if there is an high interrupt routine :
#  - generate this routine if no low interrupt
#  - generate a BRA to interrupt routine if there is a low interrupt routine
  if hasHighInterrupt & hasLowInterrupt then
    setEmitAddress !8 ;
    emitCode !0xEF00 | ((highInterruptStartAddress >> 1) & 255) ;
    emitCode !0xF000 | (highInterruptStartAddress >> 9) ;
  end if ;
#-------------------------------- Second Pass
  @codeGenerationContext codeGenerationContext [new
    !routineSymbolTable
    !registerTable
    !0 # Current bank is 0, as BSR is initialized to zero
    !computedGoto2RoutineAddress
    !computedGoto4RoutineAddress
  ] ;
#--- Generate low interrupt routine (if any)
  currentROMaddress := 0x18 ;
  if hasLowInterrupt then
    setEmitAddress !0x18 ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        @bool continuesInSequence := true ;
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate high interrupt routine (if any)
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
    setEmitAddress !0x8 ;
  end if ;
  if hasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        @bool continuesInSequence := true ;
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate routines
  if (not hasLowInterrupt) & (not hasHighInterrupt) then
    currentROMaddress := 0x4 ;
    setEmitAddress !0x4 ;
  end if ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    codeGenerationContext.mCurrentBank := [mBanksel uint] ;
    if ([mRoutineName string] == "main") & ([mBanksel uint] != 0) then
      error mRoutineName:"as PIC18 is started with BSR register set to 0, the 'main' routine requires the 'banksel 0' declaration" ;
    end if ;
    if ([mRoutineName string] == "main") & not mHasNoReturn then
      error mRoutineName:"as the 'main' routine is an endless loop, it should be declared with 'noreturn' qualifier" ;
    end if ;
    @bool continuesInSequence := true ;
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
      checkCurrentEmitAddress !currentROMaddress ;
    end foreach ;
  end foreach ;
#--- computed_goto2 routine needed ?
  if [inPiccoloModel mNeedsComputedGoto4] then
    emitCode !0x24E8 ; # ADDWF WREG, W
    currentROMaddress := currentROMaddress + 2 ; # Instruction size
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] | [inPiccoloModel mNeedsComputedGoto4] then
    emitCode !0x24E8 ; # ADDWF WREG, W
    emitCode !0x26FD ; # ADDWF TOSL, F
    emitCode !0x0E00 ; # MOVLW 0
    emitCode !0x22FE ; # ADDWFC TOSH, F
    emitCode !0x0012 ; # RETURN 0
    currentROMaddress := currentROMaddress + 10 ; # Routine size
  end if ;
#--- Check genereted code size against size computed in the first pass
  if (programSize != currentROMaddress) then
    error here: "Internal second pass error: the last address gets " . [currentROMaddress hexString]
    . " value in second pass, while it gets "
    . [programSize hexString] . " in first pass" ;
  end if ;
#--- If no error, generate object file
  if [@uint errorCount] == 0 then
    if [option piccolo_options. generateAssembly] then
      @string assemblyCode ;
      buildAssemblyCode
        ![[piccoloDeviceModel mDeviceName] string]
        ![piccoloDeviceModel mRegisterTable]
        !registerTable
        !generatedInstructionList
        ?assemblyCode
      ;
      @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".asm" ;
      [assemblyCode writeToFileWhenDifferentContents !destinationFile] ;
    else
      @string contents ;
      getGeneratedContents ?contents ;
      @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
      [contents writeToFileWhenDifferentContents !destinationFile] ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
