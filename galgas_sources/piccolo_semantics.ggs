semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

extern routine setEmitAddress ??@uint inAddress ;

extern routine emitCode ??@uint inCode ;

extern routine getGeneratedContents !@string outContents ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  @uint mRequiredSelectedBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
  ?!@uint unused ioCurrentlySelectedBank
{
}

#----------------------------------------------------*

override
method @instruction_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
{
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress !ioCurrentlySelectedBank] ;
}

#----------------------------------------------------*

struct @codeGenerationContext {
  @routineSymbolTable mRoutineSymbolTable ;
  @registerTable mRegisterTable ;
  @uint mCurrentBank ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @instruction.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
;

#----------------------------------------------------------------------------*

override method @instruction_FDA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  @bitSliceTable bitSliceTable ;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size ?bitSliceTable] ;
  @bool found := false ;
  @uint usedRegisterAddress := 0 ;
  foreach registerAddressList while not found do
    usedRegisterAddress := mValue ;
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  @bool useBSRregister := false ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      usedRegisterAddress := mValue ;
      found := (mValue >= lowBound) & (mValue <= highBound) ;
      useBSRregister := true ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
#--- Emit Code
  @uint code := 0 ;# [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_FA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  @bitSliceTable bitSliceTable;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size ?bitSliceTable] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
{
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
}

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
{
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
}

#----------------------------------------------------------------------------*

override method @instruction_FBA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  @bitSliceTable bitSliceTable ;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size ?bitSliceTable] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_BRA.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_GOTO.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_CALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_RCALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_CLRWDT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_DAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_NOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_POP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_PUSH.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_RESET.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_RETURN.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_SLEEP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_LFSR.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_MOVLB.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_LABEL.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_TBLRD.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_TBLWT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "' should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- First Pass
  @uint currentROMaddress := 26 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    @uint currentlySelectedBank [max] ; # No selected bank by default
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  #--- Ajouter l'instruction REFFIE
    currentROMaddress := currentROMaddress + 2 ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @uint currentlySelectedBank := [mBanksel uint] ;
    [!?routineSymbolTable insertKey !mRoutineName !currentROMaddress !currentlySelectedBank] ;
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- Ram definition
  @uint currentRamAddress := 0 ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
   @bitSliceTable bitSliceTable [emptyMap] ;
   [!?registerTable insertKey !mName ![@uintlist listWithValue !currentRamAddress] ![mSize uint] !bitSliceTable] ;
   currentRamAddress := currentRamAddress + [mSize uint] ;
  end foreach ;
#  message "Used RAM size: " . [currentRamAddress string] . " bytes\n" ;
#-------------------------------- Prepare code generation
  setEmitAddress !0 ;
  if not [routineSymbolTable hasKey !"main"] then
    error here: "there is no 'main' routine" ;
  else
    @uint mainRoutineAddress ;
    [routineSymbolTable searchKey ![@lstring new !"main" !here] ?mainRoutineAddress ?*] ;
    emitCode !0xEF00 | ((mainRoutineAddress >> 1) & 255) ;
    emitCode !0xF000 | (mainRoutineAddress >> 9) ;
  end if ;
#-------------------------------- Second Pass
  @codeGenerationContext codeGenerationContext [new
    !routineSymbolTable
    !registerTable
    !0 # Current bank is 0, as BSR is initialized to zero
  ] ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    codeGenerationContext.mCurrentBank := [mBanksel uint] ;
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- If no error, generate object file
  if [@uint errorCount] == 0 then
    @string contents ;
    getGeneratedContents ? contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFile !destinationFile] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
