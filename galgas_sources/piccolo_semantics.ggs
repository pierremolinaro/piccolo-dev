semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  @uint mRequiredSelectedBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
  ?!@uint unused ioCurrentlySelectedBank
{
}

#----------------------------------------------------*

override
method @instruction_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
{
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress !ioCurrentlySelectedBank] ;
}

#----------------------------------------------------*

struct @codeGenerationContext {
  @routineSymbolTable mRoutineSymbolTable ;
  @registerTable mRegisterTable ;
  @uint mCurrentBank ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @instruction.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
;

#----------------------------------------------------------------------------*

override method @instruction_FDA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_FA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_FBA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @lstring registerName := [mRegisterExpression mRegisterName] ;
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !registerName ?registerAddressList ?size] ;
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . registerName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error registerName: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_BRA.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_GOTO.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_CALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_RCALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_CLRWDT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_DAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_NOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_POP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_PUSH.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_RESET.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_RETURN.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_SLEEP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_LFSR.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_MOVLB.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_LABEL.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_TBLRD.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_TBLWT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel :
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- First Pass
  @uint currentROMaddress := 26 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    @uint currentlySelectedBank [max] ; # No selected bank by default
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  #--- Ajouter l'instruction REFFIE
    currentROMaddress := currentROMaddress + 2 ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @uint currentlySelectedBank := [mBanksel uint] ;
    [!?routineSymbolTable insertKey !mRoutineName !currentROMaddress !currentlySelectedBank] ;
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- Ram definition
  @uint currentRamAddress := 0 ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
   [!?registerTable insertKey !mName ![@uintlist listWithValue !currentRamAddress] ![mSize uint]] ;
   currentRamAddress := currentRamAddress + [mSize uint] ;
  end foreach ;
#  message "Used RAM size: " . [currentRamAddress string] . " bytes\n" ;
#-------------------------------- Second Pass
  @codeGenerationContext codeGenerationContext [new
    !routineSymbolTable
    !registerTable
    !0 # Current bank is 0, as BSR is initialized to zero
  ] ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    codeGenerationContext.mCurrentBank := [mBanksel uint] ;
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------*

end semantics ;
