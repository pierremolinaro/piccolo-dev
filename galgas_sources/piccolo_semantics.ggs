semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

extern routine setEmitAddress ??@uint inAddress ;

extern routine currentEmitAddress !@uint outAddress ;

extern routine emitCode ??@uint inCode ;

extern routine getGeneratedContents !@string outContents ;

#----------------------------------------------------*

routine checkCurrentEmitAddress ??@uint inCurrentAddress :
  @uint addr ; currentEmitAddress ? addr ;
  if ([@uint errorCount] == 0) & (addr != inCurrentAddress) then
    error here:"internal error: current emit address is " . [addr hexString]
    . "; it should be " . [inCurrentAddress hexString] ;
  end if ;
end routine ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  @uint mRequiredSelectedBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
  ?!@uint unused ioCurrentlySelectedBank
{
}

#----------------------------------------------------*

override
method @instruction_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
{
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress !ioCurrentlySelectedBank] ;
}

#----------------------------------------------------*

struct @codeGenerationContext {
  @routineSymbolTable mRoutineSymbolTable ;
  @registerTable mRegisterTable ;
  @uint mCurrentBank ;
  @uint mComputedGoto2RoutineAddress ;
  @uint mComputedGoto4RoutineAddress ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddress
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
{
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?*] ;
  if [mOffset uint] > size then
    error mOffset:"The index (" . [[mOffset uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
  [registerAddressList first ?outRegisterAddress] ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
}

#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddressingInformations
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
  !@bool outUseBSRregister
  !@bitSliceTable outBitSliceTable
{
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable] ;
  @bool found := false ;
  outRegisterAddress := 0 ;
  foreach registerAddressList while not found do
    outRegisterAddress := mValue ;
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  outUseBSRregister := false ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    outUseBSRregister := true ;
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . mRegisterName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error mRegisterName: errorMessage ;
  end if ;
  if found & ([mOffset uint] >= size) then
    error mOffset:"index (" . [[mOffset uint] string] . ") is should be lower than size (". [size string] . ")" ;
  end if ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
}

#----------------------------------------------------------------------------*

routine checkInstructionIsReachable ?!@bool ioIsReachable ??@location inErrorLocation :
  if not ioIsReachable then
    error inErrorLocation: "dead code: execution cannot reach this instruction" ;
  end if ;
  ioIsReachable := true ; # So that error message is sent once
end routine ;

#----------------------------------------------------------------------------*

abstract method @instruction.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool unused ioContinuesInSequence
;

#----------------------------------------------------------------------------*

override method @instruction_FDA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_FA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint sourceRegisterAddress ;
  [mSourceRegisterName getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  @uint destinationRegisterAddress ;
  [mDestinationRegisterName getRegisterAddress !inCodeGenerationContext ?destinationRegisterAddress] ;
  emitCode !0xC000 | sourceRegisterAddress ;
  emitCode !0xF000 | destinationRegisterAddress ;
}

#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
{
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
}

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
{
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
}

#----------------------------------------------------------------------------*

override method @instruction_FBA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
#--- Register
  @bitSliceTable bitSliceTable;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

routine emitConditionalBranchInstruction
  ??@uint inConditionalBranchInstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
  ??@uint inConditionalBranchInstructionCode
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inConditionalBranchInstructionAddress sint]) >> 1 ;
  if (displacement > 127S) | (displacement < - 128S) then
    error inErrorLocation: "displacement too large for conditional branch instruction" ;
  end if ;
#  log displacement ;
  emitCode !inConditionalBranchInstructionCode | [displacement & 0x0FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  @uint baseCode ; [self getBaseCode ?baseCode] ;
  emitConditionalBranchInstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
    !baseCode
  ;
}

#----------------------------------------------------------------------------*

routine emitBRAinstruction
  ??@uint inBRAinstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inBRAinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inErrorLocation: "displacement too large for BRA instruction" ;
  end if ;
#  log displacement ;
  emitCode !0xD000 | [displacement & 0x07FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_BRA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
####  ioContinuesInSequence := false ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  @sint displacement := ([targetAddress sint] - 2S - [inAddress sint]) >> 1 ;
  if (displacement > 0x800S) | (displacement < - 0x800S) then
    error mTargetLabel: "displacement too large for RCALL instruction" ;
  end if ;
#--- Emit Code
  emitBRAinstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
  ;
}

#----------------------------------------------------------------------------*

routine emitGOTOinstruction
  ??@uint inTargetAddress
:
  emitCode !0xEF00 | ((inTargetAddress >> 1) & 255) ;
  emitCode !0xF000 | (inTargetAddress >> 9) ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_GOTO.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
####  ioContinuesInSequence := false ;
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  emitGOTOinstruction !targetAddress ;
}

#----------------------------------------------------------------------------*

routine emitCALLinstruction
  ??@uint inTargetAddress
:
  emitCode !0xEC00 | ((inTargetAddress >> 1) & 255) ;
  emitCode !0xF000 | (inTargetAddress >> 9) ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_CALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  emitCALLinstruction !targetAddress ;
}

#----------------------------------------------------------------------------*

routine emitRCALLinstruction
  ??@uint inRCALLinstructionAddress
  ??@uint inTargetAddress
  ??@location inErrorLocation
:
  @sint displacement := ([inTargetAddress sint] - 2S - [inRCALLinstructionAddress sint]) >> 1 ;
  if (displacement > 1023S) | (displacement < - 1024S) then
    error inErrorLocation: "displacement too large for RCALL instruction" ;
  end if ;
#  log displacement ;
  emitCode !0xD800 | [displacement & 0x07FFS uint] ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_RCALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  emitRCALLinstruction
    !inAddress
    !targetAddress
    ![mTargetLabel location]
  ;
}

#----------------------------------------------------------------------------*

override method @instruction_CLRWDT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0004 ;
}

#----------------------------------------------------------------------------*

override method @instruction_DAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0007 ;
}

#----------------------------------------------------------------------------*

override method @instruction_NOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0000 ;
}

#----------------------------------------------------------------------------*

override method @instruction_POP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0006 ;
}

#----------------------------------------------------------------------------*

override method @instruction_PUSH.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0005 ;
}

#----------------------------------------------------------------------------*

override method @instruction_RESET.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x00FF ;
}

#----------------------------------------------------------------------------*

override method @instruction_RETURN.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0012 ;
}

#----------------------------------------------------------------------------*

override method @instruction_SLEEP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  emitCode !0x0003 ;
}

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mLiteralValue uint] > 255 then
    error mLiteralValue: "A literal value (" . [[mLiteralValue uint] string] . ") should be lower or equal to 255" ;
  end if ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | [mLiteralValue uint] ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_LFSR.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mFSRindex uint] > 2 then
    error mFSRindex: "LFSR index should be lower or equal to 2" ;
  end if ;
  @uint sourceRegisterAddress ;
  [mRegisterExpression getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  emitCode !0xEE00 | ([mFSRindex uint] << 4) | (sourceRegisterAddress >> 8) ;
  emitCode !0xF000 | (sourceRegisterAddress & 255) ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVLB.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
}

#----------------------------------------------------------------------------*

override method @instruction_LABEL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  ioContinuesInSequence := true ;
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (targetAddress != inAddress) then
    error mTargetLabel: "Internal second pass error: the '" . mTargetLabel
    . "' label gets " . [inAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  [mRegisterExpression getRegisterAddress
    !inCodeGenerationContext
    ?registerAddress
  ] ;
  if registerAddress > 255 then
    error here : "for MOVAW instruction, address (" . [registerAddress hexString] . ") should be lower or equal to 0xFF" ;
  end if ;
  emitCode !0x0E00 | registerAddress ;
}

#----------------------------------------------------------------------------*

override method @instruction_TBLRD.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  switch mOption
  when simpleAccess  : emitCode !0x0008 ;
  when postIncrement : emitCode !0x0009 ;
  when postDecrement : emitCode !0x000A ;
  when preIncrement  : emitCode !0x000B ;
  end switch ;
}

#----------------------------------------------------------------------------*

override method @instruction_TBLWT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  switch mOption
  when simpleAccess  : emitCode !0x000C ;
  when postIncrement : emitCode !0x000D ;
  when postDecrement : emitCode !0x000E ;
  when preIncrement  : emitCode !0x000F ;
  end switch ;
}

#----------------------------------------------------------------------------*

override method @instruction_MNOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor: "No generated code" ;
  end if ;
  @uint idx := 0 ;
  loop [mOccurrenceFactor uint] :
  while idx < [mOccurrenceFactor uint]
  do
    emitCode !0x0000 ;
    idx ++ ;
  end loop ;
}

#----------------------------------------------------------------------------*

override method @instruction_FOREVER.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  @uint currentAddress := inAddress ;
  @bool continuesInSequence := true ;
  foreach mInstructionList do
    [mInstruction generateCodeAtAddress !inCodeGenerationContext !currentAddress !?continuesInSequence] ;
    @uint lg ; [mInstruction instructionLength ?lg] ;
    currentAddress := currentAddress + lg ;
  end foreach ;
#--- Generate BRA instruction
  emitBRAinstruction
    !currentAddress
    !inAddress
    !mInstructionLocation
  ;
}

#----------------------------------------------------------------------------*

override method @instruction_IF_SEMI_COLON.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?registerAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (registerAddress & 255) ;
  emitCode !code ;
  @bool unusedContinuesInSequence := true ;
  [mInstruction generateCodeAtAddress !inCodeGenerationContext !inAddress + 2 !?unusedContinuesInSequence] ;
}

#----------------------------------------------------------------------------*

override method @instruction_IF_BitTest.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  @uint registerAddress ;
  @bool useBSRregister ;
  @bitSliceTable bitSliceTable;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?registerAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (registerAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;
  @bool unusedContinuesInSequence := true ;
  [mInstruction generateCodeAtAddress !inCodeGenerationContext !inAddress + 2 !?unusedContinuesInSequence] ;
}

#----------------------------------------------------------------------------*

override method @instruction_computed_retlw.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto2RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto2RoutineAddress] ;
  end if ;
  foreach mLiteralValues do
    if [mValue uint] > 255 then
      error here : "immediate value (" . [[mValue uint] string] . ") should be lower or equal to 255" ;
    end if ;
    emitCode !0x0C00 | [mValue uint] ;
  end foreach ;
}

#----------------------------------------------------------------------------*

override method @instruction_computed_bra.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto2RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto2RoutineAddress] ;
  end if ;
  @uint address := inAddress + 4 ;
  foreach mTargetLabels do
    @uint targetAddress ;
    @uint requiredSelectedBank ;
    [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mValue ?targetAddress ?requiredSelectedBank] ;
    emitBRAinstruction
      !address
      !targetAddress
      ![mValue location]
    ;
    address := address + 2 ;
  end foreach ;
}

#----------------------------------------------------------------------------*

override method @instruction_computed_goto.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
  ?!@bool ioContinuesInSequence
{
  checkInstructionIsReachable !?ioContinuesInSequence !mInstructionLocation ;
  ioContinuesInSequence := false ;
  if mUsesRelativeCall then
    emitRCALLinstruction !inAddress ![inCodeGenerationContext mComputedGoto4RoutineAddress] !mInstructionLocation ;
  else
    emitCALLinstruction ![inCodeGenerationContext mComputedGoto4RoutineAddress] ;
  end if ;
  foreach mTargetLabels do
    @uint targetAddress ;
    @uint requiredSelectedBank ;
    [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mValue ?targetAddress ?requiredSelectedBank] ;
    emitGOTOinstruction
      !targetAddress
    ;
  end foreach ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "') should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool hasLowInterrupt := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [mInterruptName string] == "high" then
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
  end foreach ;
#-------------------------------- First Pass
#--- First, handle low interrupt (if any)
  @uint currentROMaddress := 0x18 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  if hasLowInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Then, handle high interrupt (if any)
  @uint highInterruptStartAddress := currentROMaddress ;
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
  end if ;
  if hasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Handle routines
  if (not hasHighInterrupt) & (not hasLowInterrupt) then # No interrupts
    currentROMaddress := 0x4 ;
  end if ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @uint currentlySelectedBank := [mBanksel uint] ;
    [!?routineSymbolTable insertKey !mRoutineName !currentROMaddress !currentlySelectedBank] ;
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- computed_goto2, computed_goto4 routines needed ?
  @uint computedGoto4RoutineAddress := currentROMaddress ;
  @uint computedGoto2RoutineAddress := currentROMaddress + 2 ;
  if [inPiccoloModel mNeedsComputedGoto4] then
    currentROMaddress := currentROMaddress + 12 ; # Routine size
  elsif [inPiccoloModel mNeedsComputedGoto2] then
    currentROMaddress := currentROMaddress + 10 ; # Routine size
  end if ;
#--- Ram definition
  @ramBankTable ramBank := [piccoloDeviceModel mRamBankTable] ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
  #--- Find ram bank
    @uint lastAddressPlusOne ;
    @uint firstFreeAddress ;
    [ramBank searchKey !mBankName ?firstFreeAddress ?lastAddressPlusOne] ;
    foreach mDeclaration do
      if [mSize uint] == 0 then
        error mSize: "zero size is not allowed" ;
      end if ;
      @bitSliceTable bitSliceTable [emptyMap] ;
      [!?registerTable insertKey !mName ![@uintlist listWithValue !firstFreeAddress] ![mSize uint] !bitSliceTable] ;
      firstFreeAddress := firstFreeAddress + [mSize uint] ;
      [!?ramBank setMFirstFreeAddressForKey !firstFreeAddress ![mBankName string]] ;
      if firstFreeAddress > lastAddressPlusOne then
        error mName: "overflow in '" . mBankName . "' ram bank for '" . mName . "' declaration" ;
      end if ;
    end foreach ;
  end foreach ;
#  message "Used RAM size: " . [currentRamAddress string] . " bytes\n" ;
  @uint programSize := currentROMaddress ;
#-------------------------------- Prepare code generation
#--- At Address 0, generate a GOTO main instruction
  setEmitAddress !0 ;
  if not [routineSymbolTable hasKey !"main"] then
    error here: "there is no 'main' routine" ;
  else
    @uint mainRoutineAddress ;
    [routineSymbolTable searchKey ![@lstring new !"main" !here] ?mainRoutineAddress ?*] ;
    emitCode !0xEF00 | ((mainRoutineAddress >> 1) & 255) ;
    emitCode !0xF000 | (mainRoutineAddress >> 9) ;
  end if ;
#---- At address 0x8, if there is an high interrupt routine :
#  - generate this routine if no low interrupt
#  - generate a BRA to interrupt routine if there is a low interrupt routine
  if hasHighInterrupt & hasLowInterrupt then
    setEmitAddress !8 ;
    emitCode !0xEF00 | ((highInterruptStartAddress >> 1) & 255) ;
    emitCode !0xF000 | (highInterruptStartAddress >> 9) ;
  end if ;
#-------------------------------- Second Pass
  @codeGenerationContext codeGenerationContext [new
    !routineSymbolTable
    !registerTable
    !0 # Current bank is 0, as BSR is initialized to zero
    !computedGoto2RoutineAddress
    !computedGoto4RoutineAddress
  ] ;
#--- Generate low interrupt routine (if any)
  currentROMaddress := 0x18 ;
  if hasLowInterrupt then
    setEmitAddress !0x18 ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        @bool continuesInSequence := true ;
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate high interrupt routine (if any)
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
    setEmitAddress !0x8 ;
  end if ;
  if hasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        @bool continuesInSequence := true ;
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate routines
  if (not hasLowInterrupt) & (not hasHighInterrupt) then
    currentROMaddress := 0x4 ;
    setEmitAddress !0x4 ;
  end if ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    codeGenerationContext.mCurrentBank := [mBanksel uint] ;
    if ([mRoutineName string] == "main") & ([mBanksel uint] != 0) then
      error mRoutineName:"as PIC18 is started with BSR register set to 0, the 'main' routine requires the 'banksel 0' declaration" ;
    end if ;
    if ([mRoutineName string] == "main") & not mHasNoReturn then
      error mRoutineName:"as the 'main' routine is an endless loop, it should be declared with 'noreturn' qualifier" ;
    end if ;
    @bool continuesInSequence := true ;
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress !?continuesInSequence] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
      checkCurrentEmitAddress !currentROMaddress ;
    end foreach ;
  end foreach ;
#--- computed_goto2 routine needed ?
  if [inPiccoloModel mNeedsComputedGoto4] then
    emitCode !0x24E8 ; # ADDWF WREG, W
    currentROMaddress := currentROMaddress + 2 ; # Instruction size
  end if ;
  if [inPiccoloModel mNeedsComputedGoto2] | [inPiccoloModel mNeedsComputedGoto4] then
    emitCode !0x24E8 ; # ADDWF WREG, W
    emitCode !0x26FD ; # ADDWF TOSL, F
    emitCode !0x0E00 ; # MOVLW 0
    emitCode !0x22FE ; # ADDWFC TOSH, F
    emitCode !0x0012 ; # RETURN 0
    currentROMaddress := currentROMaddress + 10 ; # Routine size
  end if ;
#--- Check genereted code size against size computed in the first pass
  if (programSize != currentROMaddress) then
    error here: "Internal second pass error: the last address gets " . [currentROMaddress hexString]
    . " value in second pass, while it gets "
    . [programSize hexString] . " in first pass" ;
  end if ;
#--- If no error, generate object file
  if [@uint errorCount] == 0 then
    @string contents ;
    getGeneratedContents ? contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFile !destinationFile] ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
