semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

extern routine setEmitAddress ??@uint inAddress ;

extern routine currentEmitAddress !@uint outAddress ;

extern routine emitCode ??@uint inCode ;

extern routine getGeneratedContents !@string outContents ;

#----------------------------------------------------*

routine checkCurrentEmitAddress ??@uint inCurrentAddress :
  @uint addr ; currentEmitAddress ? addr ;
  if ([@uint errorCount] == 0) & (addr != inCurrentAddress) then
    error here:"internal error: current emit address is " . [addr hexString]
    . "; it should be " . [inCurrentAddress hexString] ;
  end if ;
end routine ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  @uint mRequiredSelectedBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
  ?!@uint unused ioCurrentlySelectedBank
{
}

#----------------------------------------------------*

override
method @instruction_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
  ?!@uint ioCurrentlySelectedBank
{
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress !ioCurrentlySelectedBank] ;
}

#----------------------------------------------------*

struct @codeGenerationContext {
  @routineSymbolTable mRoutineSymbolTable ;
  @registerTable mRegisterTable ;
  @uint mCurrentBank ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               C O D E    G E N E R A T I O N                               *
#                                                                            *
#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddress
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
{
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?*] ;
  if [mOffset uint] > size then
    error mOffset:"The index (" . [[mOffset uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
  [registerAddressList first ?outRegisterAddress] ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
}

#----------------------------------------------------------------------------*

method @registerExpression.getRegisterAddressingInformations
  ??@codeGenerationContext inCodeGenerationContext
  !@uint outRegisterAddress
  !@bool outUseBSRregister
  !@bitSliceTable outBitSliceTable
{
  @uintlist registerAddressList ;
  @uint size ;
  [[inCodeGenerationContext mRegisterTable] searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable] ;
  @bool found := false ;
  outRegisterAddress := 0 ;
  foreach registerAddressList while not found do
    outRegisterAddress := mValue ;
    found := (mValue < 0x60) | (mValue >= 0xF60) ;
  end foreach ;
  outUseBSRregister := false ;
  if (not found) & ([inCodeGenerationContext mCurrentBank] != [@uint max]) then
    outUseBSRregister := true ;
    @uint lowBound := [inCodeGenerationContext mCurrentBank] * 256 ;
    @uint highBound := lowBound + 255 ;
    foreach registerAddressList while not found do
      found := (mValue >= lowBound) & (mValue <= highBound) ;
    end foreach ;
  end if ;
  if not found then
    @string errorMessage := "register '" . mRegisterName . "' at " ;
    foreach registerAddressList while not found
    do
      errorMessage .= [mValue hexString] ;
    between
      errorMessage .= ", " ;
    end foreach ;
    errorMessage .= " cannot be accessed, neither throught access bank, neither with BSR value" ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= " (unknown)" ;
    else
      errorMessage .= " (" . [[inCodeGenerationContext mCurrentBank] string] . ")" ;
    end if ;
    error mRegisterName: errorMessage ;
  end if ;
  if found & ([mOffset uint] >= size) then
    error mOffset:"index (" . [[mOffset uint] string] . ") is should be lower than size (". [size string] . ")" ;
  end if ;
  outRegisterAddress := outRegisterAddress + [mOffset uint] ;
}

#----------------------------------------------------------------------------*

abstract method @instruction.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
;

#----------------------------------------------------------------------------*

override method @instruction_FDA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  if not m_W_isDestination then
    code := code | 0x0200 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_FA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?*
  ] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint sourceRegisterAddress ;
  [mSourceRegisterName getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  @uint destinationRegisterAddress ;
  [mDestinationRegisterName getRegisterAddress !inCodeGenerationContext ?destinationRegisterAddress] ;
  emitCode !0xC000 | sourceRegisterAddress ;
  emitCode !0xF000 | destinationRegisterAddress ;
}

#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.getBitNumber
  ??@bitSliceTable unused inBitSliceTable
  !@uint outBitNumber
{
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
  outBitNumber := [mBitNumberLiteralValue uint] ;
}

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.getBitNumber
  ??@bitSliceTable inBitSliceTable
  !@uint outBitNumber
{
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
  outBitNumber := sliceIndex + [mBitNumberIndexValue uint] ;
}

#----------------------------------------------------------------------------*

override method @instruction_FBA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
#--- Register
  @bitSliceTable bitSliceTable;
  @uint usedRegisterAddress ;
  @bool useBSRregister ;
  [mRegisterExpression getRegisterAddressingInformations
    !inCodeGenerationContext
    ?usedRegisterAddress
    ?useBSRregister
    ?bitSliceTable
  ] ;
#--- Bit
  @uint bitNumber ;
  [mBitNumber getBitNumber !bitSliceTable ?bitNumber] ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  if useBSRregister then
    code := code | 0x0100 ;
  end if ;
  code := code | (usedRegisterAddress & 255) ;
  code := code | (bitNumber << 9) ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_conditionalBranch.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
{
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  @sint displacement := ([targetAddress sint] - 2S - [inAddress sint]) >> 1 ;
  if (displacement > 0x800S) | (displacement < - 0x800S) then
    error mTargetLabel: "displacement too large for RCALL instruction" ;
  end if ;
  @uint code ; [self getBaseCode ? code] ;
  code := code | [displacement & 0x00FFS uint] ;
  emitCode ! code ;
}

#----------------------------------------------------------------------------*

override method @instruction_BRA.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
{
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  @sint displacement := ([targetAddress sint] - 2S - [inAddress sint]) >> 1 ;
  if (displacement > 0x800S) | (displacement < - 0x800S) then
    error mTargetLabel: "displacement too large for RCALL instruction" ;
  end if ;
  emitCode !0xD000 | [displacement & 0x07FFS uint] ;
}

#----------------------------------------------------------------------------*

override method @instruction_GOTO.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?*] ;
#--- Emit Code
  emitCode !0xEF00 | ((targetAddress >> 1) & 255) ;
  emitCode !0xF000 | (targetAddress >> 9) ;
}

#----------------------------------------------------------------------------*

override method @instruction_CALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  emitCode !0xEC00 | ((targetAddress >> 1) & 255) ;
  emitCode !0xF000 | (targetAddress >> 9) ;
}

#----------------------------------------------------------------------------*

override method @instruction_RCALL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (requiredSelectedBank != [@uint max]) & (requiredSelectedBank != [inCodeGenerationContext mCurrentBank]) then
    @string errorMessage := "The routine requires the " . [requiredSelectedBank string]
    . " bank to be selected, but " ;
    if [inCodeGenerationContext mCurrentBank] == [@uint max] then
      errorMessage .= "no bank is currentled selected" ;
    else
      errorMessage .= "the " . [[inCodeGenerationContext mCurrentBank] string] . " bank is currentled selected" ;
    end if ;
    error mTargetLabel: errorMessage ;
  end if ;
#--- Emit Code
  @sint displacement := ([targetAddress sint] - 2S - [inAddress sint]) >> 1 ;
  if (displacement > 0x800S) | (displacement < - 0x800S) then
    error mTargetLabel: "displacement too large for RCALL instruction" ;
  end if ;
  emitCode !0xD800 | [displacement & 0x07FFS uint] ;
}

#----------------------------------------------------------------------------*

override method @instruction_CLRWDT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0004 ;
}

#----------------------------------------------------------------------------*

override method @instruction_DAW.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0007 ;
}

#----------------------------------------------------------------------------*

override method @instruction_NOP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0000 ;
}

#----------------------------------------------------------------------------*

override method @instruction_POP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0006 ;
}

#----------------------------------------------------------------------------*

override method @instruction_PUSH.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0005 ;
}

#----------------------------------------------------------------------------*

override method @instruction_RESET.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x00FF ;
}

#----------------------------------------------------------------------------*

override method @instruction_RETURN.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0012 ;
}

#----------------------------------------------------------------------------*

override method @instruction_SLEEP.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  emitCode !0x0003 ;
}

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  if [mLiteralValue uint] > 255 then
    error mLiteralValue: "A literal value (" . [[mLiteralValue uint] string] . ") should be lower or equal to 255" ;
  end if ;
#--- Emit Code
  @uint code ; [self getBaseCode ? code] ;
  code := code | [mLiteralValue uint] ;
  emitCode !code ;
}

#----------------------------------------------------------------------------*

override method @instruction_LFSR.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  if [mFSRindex uint] > 2 then
    error mFSRindex: "LFSR index should be lower or equal to 2" ;
  end if ;
  @uint sourceRegisterAddress ;
  [mRegisterExpression getRegisterAddress !inCodeGenerationContext ?sourceRegisterAddress] ;
  emitCode !0xEE00 | ([mFSRindex uint] << 4) | (sourceRegisterAddress >> 8) ;
  emitCode !0xF000 | (sourceRegisterAddress & 255) ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVLB.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
}

#----------------------------------------------------------------------------*

override method @instruction_LABEL.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint inAddress
{
  @uint targetAddress ;
  @uint requiredSelectedBank ;
  [[inCodeGenerationContext mRoutineSymbolTable] searchKey !mTargetLabel ?targetAddress ?requiredSelectedBank] ;
  if (targetAddress != inAddress) then
    error mTargetLabel: "Internal second pass error: the '" . mTargetLabel
    . "' label gets " . [inAddress hexString] . " value in second pass, while it gets "
    . [targetAddress hexString] . " in first pass" ;
  end if ;
}

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.generateCodeAtAddress
  ??@codeGenerationContext inCodeGenerationContext
  ??@uint unused inAddress
{
  @uint registerAddress ;
  [mRegisterExpression getRegisterAddress
    !inCodeGenerationContext
    ?registerAddress
  ] ;
  if registerAddress > 255 then
    error here : "for MOVAW instruction, address (" . [registerAddress hexString] . ") should be lower or equal to 0xFF" ;
  end if ;
  emitCode !0x0E00 | registerAddress ;
}

#----------------------------------------------------------------------------*

override method @instruction_TBLRD.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  switch mOption
  when simpleAccess  : emitCode !0x0008 ;
  when postIncrement : emitCode !0x0009 ;
  when postDecrement : emitCode !0x000A ;
  when preIncrement  : emitCode !0x000B ;
  end switch ;
}

#----------------------------------------------------------------------------*

override method @instruction_TBLWT.generateCodeAtAddress
  ??@codeGenerationContext unused inCodeGenerationContext
  ??@uint unused inAddress
{
  switch mOption
  when simpleAccess  : emitCode !0x000C ;
  when postIncrement : emitCode !0x000D ;
  when postDecrement : emitCode !0x000E ;
  when preIncrement  : emitCode !0x000F ;
  end switch ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel ??@string inSourceFileName :
  @string sourceFileBaseName := [[inSourceFileName lastPathComponent] stringByDeletingPathExtension] ;
  if sourceFileBaseName != [[inPiccoloModel mProgramName] string] then
    error [inPiccoloModel mProgramName]: "the program name ('" . [inPiccoloModel mProgramName]
    . "' should be identical to the file base name '" . sourceFileBaseName . "'" ;
  end if ;
#-------------------------------- Analyze Device
  @piccoloDeviceModel piccoloDeviceModel ;
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ?piccoloDeviceModel ;
#-------------------------------- Interrupts ?
  @bool hasHighInterrupt := false ;
  @bool hasLowInterrupt := false ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    if [mInterruptName string] == "high" then
      if hasHighInterrupt then
        error mInterruptName: "Only one 'high' interrupt routine is allowed" ;
      end if ;
      hasHighInterrupt := true ;
    elsif [mInterruptName string] == "low" then
      if hasLowInterrupt then
        error mInterruptName: "Only one 'low' interrupt routine is allowed" ;
      end if ;
      hasLowInterrupt := true ;
    else
      error mInterruptName: "An interrupt routine should be named 'low' or 'high'" ;
    end if ;
  end foreach ;
#-------------------------------- First Pass
#--- First, handle low interrupt (if any)
  @uint currentROMaddress := 0x18 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  if hasLowInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Then, handle high interrupt (if any)
  @uint highInterruptStartAddress := currentROMaddress ;
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
  end if ;
  if hasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        @uint currentlySelectedBank [max] ; # No selected bank by default
        foreach mInstructionList do
          [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
        end foreach ;
      #--- Ajouter l'instruction REFFIE
        currentROMaddress := currentROMaddress + 2 ;
      end if ;
    end foreach ;
  end if ;
#--- Handle routines
  if (not hasHighInterrupt) & not hasLowInterrupt then # Both interrupts
    currentROMaddress := 0x4 ;
  end if ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @uint currentlySelectedBank := [mBanksel uint] ;
    [!?routineSymbolTable insertKey !mRoutineName !currentROMaddress !currentlySelectedBank] ;
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress !?currentlySelectedBank] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#--- Ram definition
  @uint currentRamAddress := 0 ;
  @registerTable registerTable := [piccoloDeviceModel mRegisterTable] ;
  foreach [inPiccoloModel mRamDefinitionList] do
   @bitSliceTable bitSliceTable [emptyMap] ;
   [!?registerTable insertKey !mName ![@uintlist listWithValue !currentRamAddress] ![mSize uint] !bitSliceTable] ;
   currentRamAddress := currentRamAddress + [mSize uint] ;
  end foreach ;
#  message "Used RAM size: " . [currentRamAddress string] . " bytes\n" ;
  @uint programSize := currentROMaddress ;
#-------------------------------- Prepare code generation
#--- At Address 0, generate a GOTO main instruction
  setEmitAddress !0 ;
  if not [routineSymbolTable hasKey !"main"] then
    error here: "there is no 'main' routine" ;
  else
    @uint mainRoutineAddress ;
    [routineSymbolTable searchKey ![@lstring new !"main" !here] ?mainRoutineAddress ?*] ;
    emitCode !0xEF00 | ((mainRoutineAddress >> 1) & 255) ;
    emitCode !0xF000 | (mainRoutineAddress >> 9) ;
  end if ;
#---- At address 0x8, if there is an high interrupt routine :
#  - generate this routine if no low interrupt
#  - generate a BRA to interrupt routine if there is a low interrupt routine
  if hasHighInterrupt & hasLowInterrupt then
    setEmitAddress !8 ;
    emitCode !0xEF00 | ((highInterruptStartAddress >> 1) & 255) ;
    emitCode !0xF000 | (highInterruptStartAddress >> 9) ;
  end if ;
#-------------------------------- Second Pass
  @codeGenerationContext codeGenerationContext [new
    !routineSymbolTable
    !registerTable
    !0 # Current bank is 0, as BSR is initialized to zero
  ] ;
#--- Generate low interrupt routine (if any)
  currentROMaddress := 0x18 ;
  if hasLowInterrupt then
    setEmitAddress !0x18 ;
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "low" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate high interrupt routine (if any)
  if not hasLowInterrupt then
    currentROMaddress := 0x8 ;
    setEmitAddress !0x8 ;
  end if ;
  if hasHighInterrupt then
    foreach [inPiccoloModel mInterruptDefinitionList] do
      if [mInterruptName string] == "high" then
        codeGenerationContext.mCurrentBank := [@uint max] ; # No selected bank
        foreach mInstructionList do
          [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
          @uint length ;
          [mInstruction instructionLength ?length] ;
          currentROMaddress := currentROMaddress + length ;
          checkCurrentEmitAddress !currentROMaddress ;
        end foreach ;
        currentROMaddress := currentROMaddress + 2 ;
        emitCode !0x0011 ; # RETFIE 1
        checkCurrentEmitAddress !currentROMaddress ;
      end if ;
    end foreach ;
  end if ;
#--- Generate routines
  foreach [inPiccoloModel mRoutineDefinitionList] do
    codeGenerationContext.mCurrentBank := [mBanksel uint] ;
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !codeGenerationContext !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
      checkCurrentEmitAddress !currentROMaddress ;
    end foreach ;
  end foreach ;
  if (programSize != currentROMaddress) then
    error here: "Internal second pass error: the last address gets " . [currentROMaddress hexString]
    . " value in second pass, while it gets "
    . [programSize hexString] . " in first pass" ;
  end if ;
#--- If no error, generate object file
#  if [@uint errorCount] == 0 then
    @string contents ;
    getGeneratedContents ? contents ;
    @string destinationFile := [inSourceFileName stringByDeletingPathExtension] . ".hex" ;
    [contents writeToFile !destinationFile] ;
#  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
