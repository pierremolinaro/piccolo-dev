semantics piccolo_semantics :
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;
import semantics piccolo_embedded_devices in "piccolo_embedded_devices.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;

#----------------------------------------------------*

map @routineSymbolTable {
  @uint mRoutineAddress ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------*

method @instruction.enterLabelAtAddress
  ?!@routineSymbolTable unused ioRoutineSymbolTable
  ??@uint unused inAddress
{
}

#----------------------------------------------------*

override
method @instruction_LABEL.enterLabelAtAddress
  ?!@routineSymbolTable ioRoutineSymbolTable
  ??@uint inAddress
{
  [!?ioRoutineSymbolTable insertKey !mTargetLabel !inAddress] ;
}

#----------------------------------------------------*

map @registerTable {
  @uint mRegisterAddress ;
  @uint mSize ;
  insert insertKey error message "the '%K' register is already declared in %L" ;
  search searchKey error message "the '%K' register is not declared" ;
}

#----------------------------------------------------*

method @instruction.generateCodeAtAddress
  ??@routineSymbolTable unused inRoutineSymbolTable
  ??@registerTable unused inRegisterTable
  ??@uint unused inAddress
{
}

#----------------------------------------------------*

routine analyze ??@piccoloModel inPiccoloModel :
#-------------------------------- Analyze Device
  parseDeviceDefinition ![inPiccoloModel mDeviceName] ;
#-------------------------------- First Pass
  @uint currentROMaddress := 26 ;
  @routineSymbolTable routineSymbolTable [emptyMap] ;
  foreach [inPiccoloModel mInterruptDefinitionList] do
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  #--- Ajouter l'instruction REFFIE
    currentROMaddress := currentROMaddress + 2 ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    [!?routineSymbolTable insertKey !mRoutineName ! currentROMaddress] ;
    foreach mInstructionList do
      [mInstruction enterLabelAtAddress !?routineSymbolTable !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
#  foreach routineSymbolTable do
#    message "Symbol '" . key . "': " . [mRoutineAddress hexString] . "\n" ;
#  end foreach ;
#  message "Last Address: " . [currentROMaddress hexString] . "\n" ;
#--- Ram definition
  @uint currentRamAddress := 0 ;
  @registerTable registerTable [emptyMap] ;
  foreach [inPiccoloModel mRamDefinitionList] do
   [!?registerTable insertKey !mName !currentRamAddress ![mSize uint]] ;
   currentRamAddress := currentRamAddress + [mSize uint] ;
  end foreach ;
#  message "Used RAM size: " . [currentRamAddress string] . " bytes\n" ;
#-------------------------------- Second Pass
  foreach [inPiccoloModel mInterruptDefinitionList] do
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !routineSymbolTable !registerTable !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ?length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    foreach mInstructionList do
      [mInstruction generateCodeAtAddress !routineSymbolTable !registerTable !currentROMaddress] ;
      @uint length ;
      [mInstruction instructionLength ? length] ;
      currentROMaddress := currentROMaddress + length ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------*

end semantics ;
