syntax piccolo_syntax :
import lexique piccolo_lexique in "piccolo_lexique.gLexique" ;
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;

#----------------------------------------------------*

nonterminal <configuration_definition> ;

nonterminal <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
;

nonterminal <interrupt_definition>
  ?!@interruptDefinitionList outInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <simple_instruction> !@piccolo_instruction outInstruction ;

nonterminal <structured_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <start_symbol>
  !@piccoloModel outPiccoloModel
;

nonterminal <register_parsing> !@registerExpression outRegisterExpression ;

nonterminal <optional_w_as_dest> !@bool out_W_isDestination ;

nonterminal <bit_number_parsing> !@bitNumberExpression outBitNumber ;

nonterminal <literal_value_parsing> !@luint outLiteralValue ;

nonterminal <condition_factor> !@conditionExpression outCondition ;

nonterminal <condition_term> !@conditionExpression outCondition ;

nonterminal <condition_expression> !@conditionExpression outCondition ;

#----------------------------------------------------*

rule <start_symbol>
  !@piccoloModel outPiccoloModel
:
  $program$ ;
  $identifier$ ? @lstring programName ;
  $literal_string$ ? @lstring deviceName ;
  $:$ ;
  @interruptDefinitionList interruptDefinitionList [emptyList] ;
  @routineDefinitionList routineDefinitionList [emptyList] ;
  @ramDefinitionList ramDefinitionList [emptyList] ;
  @bool needsComputedGoto2 := false ;
  @bool needsComputedGoto4 := false ;
  repeat
  while
    <configuration_definition> ;
  while
    <ram_definition> !?ramDefinitionList ;
  while
    <interrupt_definition>
      !?interruptDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  while
    <routine_definition>
      !?routineDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  end repeat ;
  $end$ ;
  outPiccoloModel := [@piccoloModel new
    !programName
    !deviceName
    !ramDefinitionList
    !interruptDefinitionList
    !routineDefinitionList
    !needsComputedGoto2
    !needsComputedGoto4
  ] ;
end rule ;

#----------------------------------------------------*

rule <configuration_definition> :
  $config$ ;
  ${$ ;
  $}$ ;
end rule ;

#----------------------------------------------------*

rule <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
:
  $ram$ ;
  $identifier$ ? @lstring bankName ;
  ${$ ;
  @declarationInRamList declarationInRamList [emptyList] ;
  repeat
  while
    $byte$ ;
    $identifier$ ? @lstring name ;
    @luint size ;
    select
      size := [@luint new !1 !here] ;
    or
      $[$ ;
      $integer$ ?size ;
      $]$ ;
    end select ;
    declarationInRamList += !name !size ;
  end repeat ;
  ioRamDefinitionList += !bankName !declarationInRamList ;
  $}$ ;
end rule ;

#----------------------------------------------------*

rule <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  outInstructionList := [@instructionList emptyList] ;
  repeat
  while
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstructionList += !instruction ;
  while
    @piccolo_instruction instruction ;
    <structured_instruction>
      ?instruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    outInstructionList += !instruction ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <interrupt_definition>
  ?!@interruptDefinitionList ioInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $interrupt$ ;
  $identifier$ ? @lstring interruptName ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioInterruptDefinitionList += !interruptName !instructionList ;
end rule ;

#----------------------------------------------------*

rule <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $routine$ ;
  $identifier$ ? @lstring routineName ;
  @luint banksel ;
  select
    banksel := [@luint new ![@uint max] !here] ;
  or
    $banksel$ ;
    $integer$ ? banksel ;
  end select ;
  @bool noreturn ;
  select
    noreturn := false ;
  or
    $noreturn$ ;
    noreturn := true ;
  end select ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioRoutineDefinitionList += !routineName !banksel !noreturn !instructionList ;
end rule ;

#----------------------------------------------------*

rule <register_parsing> !@registerExpression outRegisterExpression :
  $identifier$ ?@lstring registerName ;
  @luint offset ;
  select
    offset := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? offset ;
    $]$ ;
  end select ;
  outRegisterExpression := [@registerExpression new
    !registerName
    !offset
  ] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $identifier$ ?@lstring bitNumberLabel ;
  @luint bitIndex ;
  select
    bitIndex := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? bitIndex ;
    $]$ ;
  end select ;
  outBitNumber := [@bitNumberLabelValue new !bitNumberLabel !bitIndex] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $integer$ ?@luint bitNumberLiteral ;
  outBitNumber := [@bitNumberLiteralValue new !bitNumberLiteral] ;
end rule ;

#----------------------------------------------------*

rule <literal_value_parsing> !@luint outLiteralValue :
  $integer$ ? outLiteralValue ;
end rule ;

#----------------------------------------------------*

rule <literal_value_parsing> !@luint outLiteralValue :
  $literal_char$ ? @lchar literalCharValue ;
  outLiteralValue := [@luint new ![[literalCharValue char] uint] ![literalCharValue location]] ;
end rule ;

#----------------------------------------------------*

rule <optional_w_as_dest> !@bool out_W_isDestination :
  select
    out_W_isDestination := false ;
  or
    $,$ ;
    $w$ ;
    out_W_isDestination := true ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  $!$ ;
  @conditionExpression condition ;
  <condition_factor> ? condition ;
  outCondition := [@negateCondition new !condition] ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  <condition_expression> ? outCondition ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  select
    @bool isIncrement ;
    select
      $incf$ ; isIncrement := true ;
    or
      $decf$ ; isIncrement := false ;
    end select ;
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @bool W_isDestination ;
    select
      W_isDestination := false ;
    or
      $,$ ; $w$ ; W_isDestination := true ;
    end select ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> branchIfZero
      ;
    end if ;
    outCondition := [@incDecRegisterInCondition new
      !registerExpression
      !isIncrement
      !W_isDestination
      !branchIfZero
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @registerComparison comparison ;
    select
      $!=$ ; $w$ ; comparison := [@registerComparison notEqual] ;
    or
      $==$ ; $w$ ; comparison := [@registerComparison equal] ;
    or
      $<=$ ; $w$ ; comparison := [@registerComparison lowerOrEqual] ;
    or
      $>=$ ; $w$ ; comparison := [@registerComparison greaterOrEqual] ;
    or
      $<$  ; $w$ ; comparison := [@registerComparison lower] ;
    or
      $>$  ; $w$ ; comparison := [@registerComparison greater] ;
    end select ;
    outCondition := [@registerComparisonCondition new
      !registerExpression
      !comparison
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    $.$ ;
    @bitNumberExpression bitNumberExpression ;
    <bit_number_parsing> ?bitNumberExpression ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool BTFSSinstruction ;
    if condition == "Z" then
      BTFSSinstruction := true ;
    elsif condition == "NZ" then
      BTFSSinstruction := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> BTFSSinstruction
      ;
    end if ;
    outCondition := [@bitTest_in_structured_if_condition new
      !registerExpression
      !bitNumberExpression
      !BTFSSinstruction
    ] ;
  or
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> branchIfZero
      ;
    end if ;
    outCondition := [@registerTestCondition new !registerName !branchIfZero] ;
  or
    @conditional_branch conditional_branch ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      conditional_branch := [@conditional_branch bz] ;
    elsif condition == "NZ" then
      conditional_branch := [@conditional_branch bnz] ;
    elsif condition == "NN" then
      conditional_branch := [@conditional_branch bnn] ;
    elsif condition == "N" then
      conditional_branch := [@conditional_branch bn] ;
    elsif condition == "C" then
      conditional_branch := [@conditional_branch bc] ;
    elsif condition == "NC" then
      conditional_branch := [@conditional_branch bnc] ;
    elsif condition == "OV" then
      conditional_branch := [@conditional_branch bov] ;
    elsif condition == "NOV" then
      conditional_branch := [@conditional_branch bnov] ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      -> conditional_branch
      ;
    end if ;
    outCondition := [@bcc_in_structured_if_condition new !conditional_branch] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <condition_expression>
  !@conditionExpression outCondition
:
  $($ ;
  <condition_term> ? outCondition ;
  repeat
  while
    $|$ ;
    @conditionExpression c ;
    <condition_term> ? c ;
    @conditionExpression rc := [@negateCondition new !c] ;
    @conditionExpression lc := [@negateCondition new !outCondition] ;
    outCondition := [@negateCondition new ![@andCondition new !lc !rc]] ;
  end repeat ;
  $)$ ;
end rule ;

#----------------------------------------------------*

rule <condition_term>
  !@conditionExpression outCondition
:
  <condition_factor> ? outCondition ;
  repeat
  while
    $&$ ;
    @conditionExpression c ;
    <condition_factor> ? c ;
    outCondition := [@andCondition new !outCondition !c] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <structured_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  @location instructionLocation := here ;
  select
    $forever$ ;
    @instructionList instructionList ;
    <instruction_list> ? instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@instruction_FOREVER new
      !instructionLocation
      !instructionList
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @if_semi_colon_op opCode ;
    select
      $!=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSEQ] ;
    or
      $<=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSGT] ;
    or
      $>=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSLT] ;
    or
      $identifier$ ? @lstring conditionString ;
      @string condition := [[conditionString string] uppercaseString] ;
      if condition != "NZ" then
        error conditionString:"invalid '" . condition . "' condition; it should be 'nz'" ;
      end if ;
      opCode := [@if_semi_colon_op TSTFSZ] ;
    end select ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_FA_SEMI_COLON new
      !instructionLocation
      !instruction
      !opCode
      !registerName
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    @bool skipIfSet ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      skipIfSet := true ;
    elsif condition == "NZ" then
      skipIfSet := false ;
    else
      error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" -> skipIfSet ;
    end if ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_BitTest new
      !instructionLocation
      !instruction
      !skipIfSet
      !registerName
      !bitNumber
    ] ;
  or
    $if$ ;
    @bool increment ;
    select
      $decf$ ; increment := false ;
    or
      $incf$ ; increment := true ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool w_isTarget ;
    select
      w_isTarget := false ;
    or
      $,$ ; $w$ ; w_isTarget := true ;
    end select ;
    @bool skipIfZero ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      skipIfZero := false ;
    elsif condition == "NZ" then
      skipIfZero := true ;
    else
      error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" -> skipIfZero ;
    end if ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_IncDec new
      !instructionLocation
      !instruction
      !increment
      !skipIfZero
      !registerName
      !w_isTarget
    ] ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $retlw$ ;
    @luintlist argumentList [emptyList] ;
    repeat
      @luint literalValue ;
      <literal_value_parsing> ?literalValue ;
      argumentList += ! literalValue ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_retlw new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto2 := true ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $bra$ ;
    @lstringlist argumentList [emptyList] ;
    repeat
      $identifier$ ? @lstring targetRoutine ;
      argumentList += ! targetRoutine ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_bra new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto2 := true ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $goto$ ;
    @lstringlist argumentList [emptyList] ;
    repeat
      $identifier$ ? @lstring targetRoutine ;
      argumentList += ! targetRoutine ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_goto new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto4 := true ;
  or
    $if$ ;
    @conditionExpression structured_if_condition ;
    <condition_expression> ?structured_if_condition ;
    @instructionList thenInstructionList ;
    <instruction_list>
      ?thenInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    @partList elsifPartList [emptyList] ;
    repeat
    while
      $elsif$ ;
      @conditionExpression condition ;
      <condition_expression> ?condition ;
      @instructionList instructionList ;
      <instruction_list>
        ?instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
      elsifPartList += !condition !instructionList ;
    end repeat ;
    @instructionList elseInstructionList ;
    select
      elseInstructionList := [@instructionList emptyList] ;
    or
      $else$ ;
      <instruction_list>
        ?elseInstructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
    end select ;
    $end$ ;
    outInstruction := [@instruction_structured_if new
      !instructionLocation
      !structured_if_condition
      !thenInstructionList
      !elsifPartList
      !elseInstructionList
    ] ;
  or
    $do$ ;
    @instructionList repeatedInstructionList ;
    <instruction_list>
      ?repeatedInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    @partList whilePartList [emptyList] ;
    repeat
      $while$ ;
      @conditionExpression whileCondition ;
      <condition_expression> ?whileCondition ;
      @instructionList instructionList ;
      <instruction_list>
        ?instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
      whilePartList += !whileCondition !instructionList ;
    while
    end repeat ;
    $end$ ;
    outInstruction := [@instruction_do_while new
      !instructionLocation
      !repeatedInstructionList
      !whilePartList
    ] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <simple_instruction> !@piccolo_instruction outInstruction :
  @location instructionLocation := here ;
  select
    @instruction_FDA_base_code baseCode ;
    select
      $addwf$ ;
      baseCode := [@instruction_FDA_base_code ADDWF] ;
    or
      $addwfc$ ;
      baseCode := [@instruction_FDA_base_code ADDWFC] ;
    or
      $andwf$ ;
      baseCode := [@instruction_FDA_base_code ANDWF] ;
    or
      $comf$ ;
      baseCode := [@instruction_FDA_base_code COMF] ;
    or
      $decf$ ;
      baseCode := [@instruction_FDA_base_code DECF] ;
    or
      $decfsz$ ;
      baseCode := [@instruction_FDA_base_code DECFSZ] ;
    or
      $dcfsnz$ ;
      baseCode := [@instruction_FDA_base_code DCFSNZ] ;
    or
      $incf$ ;
      baseCode := [@instruction_FDA_base_code INCF] ;
    or
      $incfsz$ ;
      baseCode := [@instruction_FDA_base_code INCFSZ] ;
    or
      $infsnz$ ;
      baseCode := [@instruction_FDA_base_code INFSNZ] ;
    or
      $iorwf$ ;
      baseCode := [@instruction_FDA_base_code IORWF] ;
    or
      $movf$ ;
      baseCode := [@instruction_FDA_base_code MOVF] ;
    or
      $rlcf$ ;
      baseCode := [@instruction_FDA_base_code RLCF] ;
    or
      $rlncf$ ;
      baseCode := [@instruction_FDA_base_code RLNCF] ;
    or
      $rrcf$ ;
      baseCode := [@instruction_FDA_base_code RRCF] ;
    or
      $rrncf$ ;
      baseCode := [@instruction_FDA_base_code RRNCF] ;
    or
      $subfwb$ ;
      baseCode := [@instruction_FDA_base_code SUBFWB] ;
    or
      $subwf$ ;
      baseCode := [@instruction_FDA_base_code SUBWF] ;
    or
      $subwfb$ ;
      baseCode := [@instruction_FDA_base_code SUBWFB] ;
    or
      $swapf$ ;
      baseCode := [@instruction_FDA_base_code SWAPF] ;
    or
      $xorwf$ ;
      baseCode := [@instruction_FDA_base_code XORWF] ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool W_isDestination ;
    <optional_w_as_dest> ?W_isDestination ;
    outInstruction := [@instruction_FDA new
      !instructionLocation
      !baseCode
      !registerName
      !W_isDestination
    ] ;
  or
    @FA_instruction_base_code FAinstruction ;
    select
      $clrf$ ;
      FAinstruction := [@FA_instruction_base_code CLRF] ;
    or
      $cpfsgt$ ;
      FAinstruction := [@FA_instruction_base_code CPFSGT] ;
    or
      $cpfslt$ ;
      FAinstruction := [@FA_instruction_base_code CPFSLT] ;
    or
      $movwf$ ;
      FAinstruction := [@FA_instruction_base_code MOVWF] ;
    or
      $mulwf$ ;
      FAinstruction := [@FA_instruction_base_code MULWF] ;
    or
      $negf$ ;
      FAinstruction := [@FA_instruction_base_code NEGF] ;
    or
      $setf$ ;
      FAinstruction := [@FA_instruction_base_code SETF] ;
    or
      $tstfsz$ ;
      FAinstruction := [@FA_instruction_base_code TSTFSZ] ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_FA new
      !instructionLocation
      !FAinstruction
      !registerName
    ] ;
  or
    $movff$ ;
    @registerExpression sourceRegisterName ;
    <register_parsing> ?sourceRegisterName ;
    $,$ ;
    @registerExpression destinationRegisterName ;
    <register_parsing> ? destinationRegisterName ;
    outInstruction := [@instruction_MOVFF new
      !instructionLocation
      !sourceRegisterName
      !destinationRegisterName
    ] ;
  or
    @bit_oriented_op bitOrientedOp ;
    select
      $bcf$ ; bitOrientedOp := [@bit_oriented_op BCF] ;
    or
      $bsf$ ; bitOrientedOp := [@bit_oriented_op BSF] ;
    or
      $btfsc$ ; bitOrientedOp := [@bit_oriented_op BTFSC] ;
    or
      $btfss$ ; bitOrientedOp := [@bit_oriented_op BTFSS] ;
    or
      $btg$ ; bitOrientedOp := [@bit_oriented_op BTG] ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_FBA new
      !instructionLocation
      !bitOrientedOp
      !registerName
      !bitNumber
    ] ;
  or
    @conditional_branch conditionalBranch ;
    select
      $bc$ ; conditionalBranch := [@conditional_branch bc] ;
    or
      $bnc$ ; conditionalBranch := [@conditional_branch bnc] ;
    or
      $bz$ ; conditionalBranch := [@conditional_branch bz] ;
    or
      $bnz$ ; conditionalBranch := [@conditional_branch bnz] ;
    or
      $bn$ ; conditionalBranch := [@conditional_branch bn] ;
    or
      $bnn$ ; conditionalBranch := [@conditional_branch bnn] ;
    or
      $bov$ ; conditionalBranch := [@conditional_branch bov] ;
    or
      $bnov$ ; conditionalBranch := [@conditional_branch bnov] ;
    end select ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_conditionalBranch new
      !instructionLocation
      ![@condionalBranchMode native]
      !conditionalBranch
      !targetLabelName
    ] ;
  or
    $bra$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_BRA new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $call$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_CALL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $goto$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_GOTO new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $rcall$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_RCALL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $clrwdt$ ;
    outInstruction := [@instruction_CLRWDT new !instructionLocation] ;
  or
    $daw$ ;
    outInstruction := [@instruction_DAW new !instructionLocation] ;
  or
    $nop$ ;
    outInstruction := [@instruction_NOP new !instructionLocation] ;
  or
    $pop$ ;
    outInstruction := [@instruction_POP new !instructionLocation] ;
  or
    $push$ ;
    outInstruction := [@instruction_PUSH new !instructionLocation] ;
  or
    $reset$ ;
    outInstruction := [@instruction_RESET new !instructionLocation] ;
  or
    $return$ ;
    outInstruction := [@instruction_RETURN new !instructionLocation] ;
  or
    $sleep$ ;
    outInstruction := [@instruction_SLEEP new !instructionLocation] ;
  or
    @literal_instruction_opcode literalInstruction ;
    select
      $addlw$ ; literalInstruction := [@literal_instruction_opcode ADDLW] ;
    or
      $andlw$ ; literalInstruction := [@literal_instruction_opcode ANDLW] ;
    or
      $iorlw$ ; literalInstruction := [@literal_instruction_opcode IORLW] ;
    or
      $movlw$ ; literalInstruction := [@literal_instruction_opcode MOVLW] ;
    or
      $mullw$ ; literalInstruction := [@literal_instruction_opcode MULLW] ;
    or
      $retlw$ ; literalInstruction := [@literal_instruction_opcode RETLW] ;
    or
      $sublw$ ; literalInstruction := [@literal_instruction_opcode SUBLW] ;
    or
      $xorlw$ ; literalInstruction := [@literal_instruction_opcode XORLW] ;
    end select ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_literalOperation new
      !instructionLocation
      !literalInstruction
      !literalValue
    ] ;
  or
    $lfsr$ ;
    $integer$ ? @luint FSRindex ;
    $,$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_LFSR new !instructionLocation !FSRindex !registerName] ;
  or
    $movlb$ ;
    $integer$ ? @luint pageIndex ;
    outInstruction := [@instruction_MOVLB new !instructionLocation !pageIndex] ;
  or
    $label$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@pseudo_LABEL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $movaw$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_MOVAW new !instructionLocation !registerName] ;
  or
    $tblrd$ ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLRD new !instructionLocation !accessOption] ;
  or
    $tblwt$ ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLWT new !instructionLocation !accessOption] ;
  or
    $mnop$ ;
    $integer$ ? @luint occurrenceFactor ;
    outInstruction := [@instruction_MNOP new !instructionLocation !occurrenceFactor] ;
  end select ;
end rule ;

#----------------------------------------------------*

end syntax ;
