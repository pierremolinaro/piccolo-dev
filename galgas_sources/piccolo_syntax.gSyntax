syntax piccolo_syntax :
import lexique piccolo_lexique in "piccolo_lexique.gLexique" ;
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;

#----------------------------------------------------*

nonterminal <configuration_definition>
  ?!@configDefinitionList ioConfigDefinitionList
  ?!@bool ioAcceptDefaultConfiguration
;

nonterminal <declaration_in_ram>
  !@declarationInRam outDeclaration
;

nonterminal <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
;

nonterminal <interrupt_definition>
  ?!@interruptDefinitionList outInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <simple_instruction> !@piccolo_instruction outInstruction ;

nonterminal <structured_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <structured_if_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <start_symbol>
  !@piccoloModel outPiccoloModel
;

nonterminal <register_parsing> !@registerExpression outRegisterExpression ;

nonterminal <optional_w_as_dest> !@bool out_W_isDestination ;

nonterminal <bit_number_parsing> !@bitNumberExpression outBitNumber ;

nonterminal <condition_factor> !@conditionExpression outCondition ;

nonterminal <condition_term> !@conditionExpression outCondition ;

nonterminal <condition_expression> !@conditionExpression outCondition ;

nonterminal <immediate_expression> !@immediatExpression outExpression ;

nonterminal <immediate_bitwise_term> !@immediatExpression outExpression ;

nonterminal <immediate_bitwise_factor> !@immediatExpression outExpression ;

nonterminal <immediate_term> !@immediatExpression outExpression ;

nonterminal <immediate_factor> !@immediatExpression outExpression ;

nonterminal <immediate_primary> !@immediatExpression outExpression ;

#----------------------------------------------------*

rule <start_symbol>
  !@piccoloModel outPiccoloModel
:
  $program$ ;
  $identifier$ ? @lstring programName ;
  $literal_string$ ? @lstring deviceName ;
  $:$ ;
  @interruptDefinitionList interruptDefinitionList [emptyList] ;
  @routineDefinitionList routineDefinitionList [emptyList] ;
  @ramDefinitionList ramDefinitionList [emptyList] ;
  @configDefinitionList configDefinitionList [emptyList] ;
  @bool acceptDefaultConfiguration := false ;
  @bool needsComputedGoto2 := false ;
  @bool needsComputedGoto4 := false ;
  repeat
  while
    <configuration_definition> !?configDefinitionList !?acceptDefaultConfiguration ;
  while
    <ram_definition> !?ramDefinitionList ;
  while
    <interrupt_definition>
      !?interruptDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  while
    <routine_definition>
      !?routineDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  end repeat ;
  $end$ ;
  outPiccoloModel := [@piccoloModel new
    !programName
    !deviceName
    !configDefinitionList
    !acceptDefaultConfiguration
    !ramDefinitionList
    !interruptDefinitionList
    !routineDefinitionList
    !needsComputedGoto2
    !needsComputedGoto4
    !here
  ] ;
end rule ;

#----------------------------------------------------*

rule <configuration_definition>
  ?!@configDefinitionList ioConfigDefinitionList
  ?!@bool ioAcceptDefaultConfiguration
:
  $config$ ;
  @configSettingList settingList [emptyList] ;
  ${$ ;
  repeat
  while
    $default$ ;
    if ioAcceptDefaultConfiguration then
      warning here:"'default' for configuration is already set" ;
    end if ;
    ioAcceptDefaultConfiguration := true ;
  while
    $identifier$ ? @lstring settingName ;
    $:$ ;
    @lstring settingValue ;
    select
      $identifier$ ? settingValue ;
    or
      $literal_string$ ? settingValue ;
    end select ;
    settingList += !settingName !settingValue ;
  end repeat ;
  $}$ ;
  ioConfigDefinitionList += !settingList ;
end rule ;

#----------------------------------------------------*

rule <declaration_in_ram>
  !@declarationInRam outDeclaration
:
  $byte$ ;
  $identifier$ ? @lstring name ;
  @luint size ;
  select
    size := [@luint new !1 !here] ;
  or
    $[$ ;
    $integer$ ?size ;
    $]$ ;
  end select ;
  @bitSliceTable bitSliceTable [emptyMap] ;
  @string bitDefinitionString ;
  select
    bitDefinitionString := "" ;
  or
    $<$ ;
    bitDefinitionString := " <" ;
    @sint sliceIndex := 8S ;
    repeat
     select
        @uint sliceWidth := 0 ; # Means undefined
        repeat
          @uint sliceBase := 0 ;
          if sliceIndex >= 0S then
            sliceBase := [sliceIndex uint] ;
          end if ;
          $identifier$ ? @lstring sliceName ;
          select
            if (sliceWidth != 0) & (sliceWidth != 1) then
              error sliceName:"a slice of 1 bit is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := 1 ;
            bitDefinitionString .= [sliceName string] ; 
          or
            $[$ ;
            $integer$ ? @luint sliceSize ;
            if (sliceWidth != 0) & (sliceWidth != [sliceSize uint]) then
              error sliceName:"a slice of " . [sliceWidth string] . " bits is expected for '" . sliceName . "'" ; 
            end if ;
            sliceWidth := [sliceSize uint] ;
            sliceBase := sliceBase + 1 - [sliceSize uint] ;
            bitDefinitionString .= [sliceName string] . "[" . [[sliceSize uint] string] . "]" ; 
            $]$ ;
          end select ;
          @uint base := 0 ;
          if sliceIndex >= [sliceWidth sint] then
            base := [sliceIndex uint] - sliceWidth ;
          end if ;
          [!?bitSliceTable insertKey !sliceName !base !sliceWidth] ;
        while
          $/$ ;
          bitDefinitionString .= "/" ;
        end repeat ;
        sliceIndex := sliceIndex - [sliceWidth sint] ;
      or
        $-$ ;
        bitDefinitionString .= "-" ;
        sliceIndex -- ;
      end select ;
    while
      $,$ ;
      bitDefinitionString .= ", " ; 
    end repeat ;
    if sliceIndex != 0S then
      error name:"Incorrect bit definition for register '" . name . "': " . [8S - sliceIndex string] . " bits (s) are defined, instead of 8" ;
    end if ;
    $>$ ;
    bitDefinitionString .= ">" ;
  end select ;
  outDeclaration := [@byteDeclarationInRam new !name !size !bitSliceTable !bitDefinitionString] ;
end rule ;

#----------------------------------------------------*

rule <declaration_in_ram>
  !@declarationInRam outDeclaration
:
  $common$ ;
  @commonBranchList commonBranchList [emptyList] ;
  repeat
    @declarationInRamList declarationInRamList [emptyList] ;
    repeat
    while
      @declarationInRam declaration ;
      <declaration_in_ram> ?declaration ;
      declarationInRamList += !declaration ;
    end repeat ;
    commonBranchList += !declarationInRamList !here ;
  while
    $|$ ;
  end repeat ;
  outDeclaration := [@commonDeclarationInRam new !commonBranchList] ;
  $end$ ;
end rule ;

#----------------------------------------------------*

rule <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
:
  $ram$ ;
  $identifier$ ? @lstring bankName ;
  ${$ ;
  @declarationInRamList declarationInRamList [emptyList] ;
  repeat
  while
    @declarationInRam declaration ;
    <declaration_in_ram> ?declaration ;
    declarationInRamList += !declaration ;
  end repeat ;
  ioRamDefinitionList += !bankName !declarationInRamList ;
  $}$ ;
end rule ;

#----------------------------------------------------*

rule <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  outInstructionList := [@instructionList emptyList] ;
  repeat
  while
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstructionList += !instruction ;
  while
    @piccolo_instruction instruction ;
    <structured_instruction>
      ?instruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    outInstructionList += !instruction ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <interrupt_definition>
  ?!@interruptDefinitionList ioInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $interrupt$ ;
  $identifier$ ? @lstring interruptName ;
  @bool isFast ;
  select
    isFast := false ;
  or
    $fast$ ;
    isFast := true ;
  end select ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioInterruptDefinitionList += !interruptName !isFast !instructionList !here ;
end rule ;

#----------------------------------------------------*

rule <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  @bool noreturn ;
  select
    noreturn := false ;
  or
    $noreturn$ ;
    noreturn := true ;
  end select ;
  $routine$ ;
  $identifier$ ? @lstring routineName ;
  @luint requiredBank ;
  @luint returnedBank ;
  @bool preservesBank ;
  select
    requiredBank := [@luint new ![@uint max] !here] ;
    returnedBank := [@luint new ![@uint max] !here] ;
    preservesBank := false ;
  or
    $bank$ ;
    $:$ ;
    select
      $preserved$ ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:preserved\" setting" ;
      end if ;
      preservesBank := true ;
      requiredBank := [@luint new ![@uint max] !here] ;
      returnedBank := [@luint new ![@uint max] !here] ;
    or
      $requires$ ;
      $integer$ ? requiredBank ;
      preservesBank := false ;
      select
        returnedBank := [@luint new ![@uint max] !here] ;
      or
        $ensures$ ;
        $integer$ ? returnedBank ;
        if noreturn then
          error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
        end if ;
      end select ;
    or
      $ensures$ ;
      $integer$ ? returnedBank ;
      if noreturn then
        error here: "a \"noreturn\" routine cannot accept \"bank:returned\" setting" ;
      end if ;
      preservesBank := false ;
      requiredBank := [@luint new ![@uint max] !here] ;
    end select ;
  end select ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioRoutineDefinitionList += !routineName !requiredBank !returnedBank !preservesBank !noreturn !instructionList !here ;
end rule ;

#----------------------------------------------------*

rule <register_parsing> !@registerExpression outRegisterExpression :
  $identifier$ ?@lstring registerName ;
  @luint offset ;
  select
    offset := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? offset ;
    $]$ ;
  end select ;
  outRegisterExpression := [@registerExpression new
    !registerName
    !offset
  ] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $identifier$ ?@lstring bitNumberLabel ;
  @luint bitIndex ;
  select
    bitIndex := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? bitIndex ;
    $]$ ;
  end select ;
  outBitNumber := [@bitNumberLabelValue new !bitNumberLabel !bitIndex] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $integer$ ?@luint bitNumberLiteral ;
  outBitNumber := [@bitNumberLiteralValue new !bitNumberLiteral] ;
end rule ;

#----------------------------------------------------*

rule <optional_w_as_dest> !@bool out_W_isDestination :
  select
    out_W_isDestination := false ;
  or
    $,$ ;
    $w$ ;
    out_W_isDestination := true ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  $!$ ;
  @conditionExpression condition ;
  <condition_factor> ? condition ;
  outCondition := [@negateCondition new !condition] ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  <condition_expression> ? outCondition ;
end rule ;

#----------------------------------------------------*

rule <condition_factor>
  !@conditionExpression outCondition
:
  select
    @bool isIncrement ;
    select
      $incf$ ; isIncrement := true ;
    or
      $decf$ ; isIncrement := false ;
    end select ;
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @bool W_isDestination ;
    select
      W_isDestination := false ;
    or
      $,$ ; $w$ ; W_isDestination := true ;
    end select ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> branchIfZero
      ;
    end if ;
    outCondition := [@incDecRegisterInCondition new
      !registerExpression
      !isIncrement
      !W_isDestination
      !branchIfZero
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    @registerComparison comparison ;
    select
      $!=$ ; $w$ ; comparison := [@registerComparison notEqual] ;
    or
      $==$ ; $w$ ; comparison := [@registerComparison equal] ;
    or
      $<=$ ; $w$ ; comparison := [@registerComparison lowerOrEqual] ;
    or
      $>=$ ; $w$ ; comparison := [@registerComparison greaterOrEqual] ;
    or
      $<$  ; $w$ ; comparison := [@registerComparison lower] ;
    or
      $>$  ; $w$ ; comparison := [@registerComparison greater] ;
    end select ;
    outCondition := [@registerComparisonCondition new
      !registerExpression
      !comparison
    ] ;
  or
    @registerExpression registerExpression ;
    <register_parsing> ? registerExpression ;
    $.$ ;
    @bitNumberExpression bitNumberExpression ;
    <bit_number_parsing> ?bitNumberExpression ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool BTFSSinstruction ;
    if condition == "Z" then
      BTFSSinstruction := true ;
    elsif condition == "NZ" then
      BTFSSinstruction := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> BTFSSinstruction
      ;
    end if ;
    outCondition := [@bitTest_in_structured_if_condition new
      !registerExpression
      !bitNumberExpression
      !BTFSSinstruction
    ] ;
  or
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    @bool branchIfZero ;
    if condition == "Z" then
      branchIfZero := true ;
    elsif condition == "NZ" then
      branchIfZero := false ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z' and 'nz'"
      -> branchIfZero
      ;
    end if ;
    outCondition := [@registerTestCondition new !registerName !branchIfZero] ;
  or
    @conditional_branch conditional_branch ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      conditional_branch := [@conditional_branch bz] ;
    elsif condition == "NZ" then
      conditional_branch := [@conditional_branch bnz] ;
    elsif condition == "NN" then
      conditional_branch := [@conditional_branch bnn] ;
    elsif condition == "N" then
      conditional_branch := [@conditional_branch bn] ;
    elsif condition == "C" then
      conditional_branch := [@conditional_branch bc] ;
    elsif condition == "NC" then
      conditional_branch := [@conditional_branch bnc] ;
    elsif condition == "OV" then
      conditional_branch := [@conditional_branch bov] ;
    elsif condition == "NOV" then
      conditional_branch := [@conditional_branch bnov] ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      -> conditional_branch
      ;
    end if ;
    outCondition := [@bcc_in_structured_if_condition new !conditional_branch] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <condition_expression>
  !@conditionExpression outCondition
:
  $($ ;
  <condition_term> ? outCondition ;
  repeat
  while
    $|$ ;
    @conditionExpression c ;
    <condition_term> ? c ;
    @conditionExpression rc := [@negateCondition new !c] ;
    @conditionExpression lc := [@negateCondition new !outCondition] ;
    outCondition := [@negateCondition new ![@andCondition new !lc !rc]] ;
  end repeat ;
  $)$ ;
end rule ;

#----------------------------------------------------*

rule <condition_term>
  !@conditionExpression outCondition
:
  <condition_factor> ? outCondition ;
  repeat
  while
    $&$ ;
    @conditionExpression c ;
    <condition_factor> ? c ;
    outCondition := [@andCondition new !outCondition !c] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <structured_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  select
    $banksel$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint bank ;
    outInstruction := [@instruction_banksel new ! instructionLocation !bank] ;
  or
    $nobank$ ;
    outInstruction := [@instruction_nobanksel new !here] ;
  or
    $banksave$ ;
    @location instructionLocation := here ;
    @registerExpression register ;
    <register_parsing> ?register ;
    @instructionList instructionList ;
    <instruction_list> ?instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@instruction_savebank new
      !instructionLocation
      !register
      !instructionList
      !here
    ] ;
  or
    $computed$ ;
    @location instructionLocation := here ;
    $[$ ;
    @immediatExpression sizeExpression ;
    <immediate_expression> ?sizeExpression ;
    $]$ ;
    select
      $retlw$ ;
      @immediatExpressionList argumentList [emptyList] ;
      repeat
        @immediatExpression expression ;
        <immediate_expression> ?expression ;
        argumentList += !expression ;
      while
        $,$ ;
      end repeat ;
      outInstruction := [@instruction_computed_retlw new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto2 := true ;
    or
      $bra$ ;
      @lstringlist argumentList [emptyList] ;
      repeat
        $identifier$ ? @lstring targetRoutine ;
        argumentList += ! targetRoutine ;
      while
        $,$ ;
     end repeat ;
       outInstruction := [@instruction_computed_bra new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto2 := true ;
    or
      $goto$ ;
      @lstringlist argumentList [emptyList] ;
      repeat
        $identifier$ ? @lstring targetRoutine ;
        argumentList += ! targetRoutine ;
      while
        $,$ ;
      end repeat ;
      outInstruction := [@instruction_computed_goto new
        !instructionLocation
        !sizeExpression
        !argumentList
        !true
      ] ;
      ioNeedsComputedGoto4 := true ;
    end select ;
  or
    $forever$ ;
    @location instructionLocation := here ;
    @instructionList instructionList ;
    <instruction_list> ?instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@instruction_FOREVER new
      !instructionLocation
      !instructionList
      !here
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @if_semi_colon_op opCode ;
    select
      $!=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSEQ] ;
    or
      $<=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSGT] ;
    or
      $>=$ ; $w$ ; opCode := [@if_semi_colon_op CPFSLT] ;
    or
      $identifier$ ? @lstring conditionString ;
      @string condition := [[conditionString string] uppercaseString] ;
      if condition != "NZ" then
        error conditionString:"invalid '" . condition . "' condition; it should be 'nz'" ;
      end if ;
      opCode := [@if_semi_colon_op TSTFSZ] ;
    end select ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_FA_SEMI_COLON new
      !instructionLocation
      !instruction
      !opCode
      !registerName
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    @bool skipIfSet ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      skipIfSet := true ;
    elsif condition == "NZ" then
      skipIfSet := false ;
    else
      error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" -> skipIfSet ;
    end if ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_BitTest new
      !instructionLocation
      !instruction
      !skipIfSet
      !registerName
      !bitNumber
    ] ;
  or
    $if$ ;
    @location instructionLocation := here ;
    @bool increment ;
    select
      $decf$ ; increment := false ;
    or
      $incf$ ; increment := true ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool w_isTarget ;
    select
      w_isTarget := false ;
    or
      $,$ ; $w$ ; w_isTarget := true ;
    end select ;
    @bool skipIfZero ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      skipIfZero := false ;
    elsif condition == "NZ" then
      skipIfZero := true ;
    else
      error conditionString:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" -> skipIfZero ;
    end if ;
    $:$ ;
    @piccolo_instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_IncDec new
      !instructionLocation
      !instruction
      !increment
      !skipIfZero
      !registerName
      !w_isTarget
    ] ;
  or
    $if$ ;
    <structured_if_instruction>
      ?outInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    $end$ ;
  or
    $do$ ;
    @location instructionLocation := here ;
    @instructionList repeatedInstructionList ;
    <instruction_list>
      ?repeatedInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    @location endOfRepeatedInstructionList := here ;
    @partList whilePartList [emptyList] ;
    repeat
      $while$ ;
      @conditionExpression whileCondition ;
      <condition_expression> ?whileCondition ;
      @instructionList instructionList ;
      <instruction_list>
        ?instructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
      whilePartList += !whileCondition !instructionList !here ;
    while
    end repeat ;
    $end$ ;
    outInstruction := [@instruction_do_while new
      !instructionLocation
      !repeatedInstructionList
      !endOfRepeatedInstructionList
      !whilePartList
    ] ;
  or
    $mnop$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint occurrenceFactor ;
    outInstruction := [@instruction_MNOP new !instructionLocation !occurrenceFactor] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <structured_if_instruction>
  !@piccolo_instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  @location instructionLocation := here ;
  @conditionExpression structured_if_condition ;
  <condition_expression> ?structured_if_condition ;
  @instructionList thenInstructionList ;
  <instruction_list>
    ?thenInstructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  @instructionList elseInstructionList ;
  select
    elseInstructionList := [@instructionList emptyList] ;
  or
    $elsif$ ;
    @piccolo_instruction elsifPartInstruction ;
    <structured_if_instruction>
      ?elsifPartInstruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    elseInstructionList := [@instructionList emptyList] ;
    elseInstructionList += !elsifPartInstruction ;
  or
    $else$ ;
    <instruction_list>
      ?elseInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
  end select ;
  @location endOfElsePartLocation := here ;
  outInstruction := [@instruction_structured_if new
    !instructionLocation
    !structured_if_condition
    !thenInstructionList
    !elseInstructionList
    !endOfElsePartLocation
  ] ;
end rule ;

#----------------------------------------------------*

rule <simple_instruction> !@piccolo_instruction outInstruction :
  select
    @instruction_FDA_base_code baseCode ;
    select
      $addwf$ ;
      baseCode := [@instruction_FDA_base_code ADDWF] ;
    or
      $addwfc$ ;
      baseCode := [@instruction_FDA_base_code ADDWFC] ;
    or
      $andwf$ ;
      baseCode := [@instruction_FDA_base_code ANDWF] ;
    or
      $comf$ ;
      baseCode := [@instruction_FDA_base_code COMF] ;
    or
      $decf$ ;
      baseCode := [@instruction_FDA_base_code DECF] ;
    or
      $incf$ ;
      baseCode := [@instruction_FDA_base_code INCF] ;
    or
      $iorwf$ ;
      baseCode := [@instruction_FDA_base_code IORWF] ;
    or
      $movf$ ;
      baseCode := [@instruction_FDA_base_code MOVF] ;
    or
      $rlcf$ ;
      baseCode := [@instruction_FDA_base_code RLCF] ;
    or
      $rlncf$ ;
      baseCode := [@instruction_FDA_base_code RLNCF] ;
    or
      $rrcf$ ;
      baseCode := [@instruction_FDA_base_code RRCF] ;
    or
      $rrncf$ ;
      baseCode := [@instruction_FDA_base_code RRNCF] ;
    or
      $subfwb$ ;
      baseCode := [@instruction_FDA_base_code SUBFWB] ;
    or
      $subwf$ ;
      baseCode := [@instruction_FDA_base_code SUBWF] ;
    or
      $subwfb$ ;
      baseCode := [@instruction_FDA_base_code SUBWFB] ;
    or
      $swapf$ ;
      baseCode := [@instruction_FDA_base_code SWAPF] ;
    or
      $xorwf$ ;
      baseCode := [@instruction_FDA_base_code XORWF] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool W_isDestination ;
    <optional_w_as_dest> ?W_isDestination ;
    outInstruction := [@instruction_FDA new
      !instructionLocation
      !baseCode
      !registerName
      !W_isDestination
    ] ;
  or
    @FA_instruction_base_code FAinstruction ;
    select
      $clrf$ ;
      FAinstruction := [@FA_instruction_base_code CLRF] ;
    or
      $movwf$ ;
      FAinstruction := [@FA_instruction_base_code MOVWF] ;
    or
      $mulwf$ ;
      FAinstruction := [@FA_instruction_base_code MULWF] ;
    or
      $negf$ ;
      FAinstruction := [@FA_instruction_base_code NEGF] ;
    or
      $setf$ ;
      FAinstruction := [@FA_instruction_base_code SETF] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_FA new
      !instructionLocation
      !FAinstruction
      !registerName
    ] ;
  or
    $movff$ ;
    @location instructionLocation := here ;
    @registerExpression sourceRegisterName ;
    <register_parsing> ?sourceRegisterName ;
    $,$ ;
    @registerExpression destinationRegisterName ;
    <register_parsing> ? destinationRegisterName ;
    outInstruction := [@instruction_MOVFF new
      !instructionLocation
      !sourceRegisterName
      !destinationRegisterName
    ] ;
  or
    @bit_oriented_op bitOrientedOp ;
    select
      $bcf$ ; bitOrientedOp := [@bit_oriented_op BCF] ;
    or
      $bsf$ ; bitOrientedOp := [@bit_oriented_op BSF] ;
    or
      $btg$ ; bitOrientedOp := [@bit_oriented_op BTG] ;
    end select ;
    @location instructionLocation := here ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_FBA new
      !instructionLocation
      !bitOrientedOp
      !registerName
      !bitNumber
    ] ;
  or
    $jsr$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind ipicRelative]
    ] ;
  or
    $call$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind absolute]
    ] ;
  or
    $rcall$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JSR new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind relative]
    ] ;
  or
    $jump$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind ipicRelative]
    ] ;
  or
    $goto$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind absolute]
    ] ;
  or
    $bra$ ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JUMP new
      !instructionLocation
      !targetLabelName
      ![@jumpInstructionKind relative]
    ] ;
  or
    @conditional_branch condition ;
    select
      $bc$ ; condition := [@conditional_branch bc] ;
    or
      $bnc$ ; condition := [@conditional_branch bnc] ;
    or
      $bn$ ; condition := [@conditional_branch bn] ;
    or
      $bnn$ ; condition := [@conditional_branch bnn] ;
    or
      $bov$ ; condition := [@conditional_branch bov] ;
    or
      $bnov$ ; condition := [@conditional_branch bnov] ;
    or
      $bz$ ; condition := [@conditional_branch bz] ;
    or
      $bnz$ ; condition := [@conditional_branch bnz] ;
    end select ;
    @location instructionLocation := here ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JUMPCC new
      !instructionLocation
      !targetLabelName
      !condition
      !true
    ] ;
  or
    $jump$ ;
    @location instructionLocation := here ;
    @conditional_branch conditional_branch ;
    $identifier$ ? @lstring conditionString ;
    @string condition := [[conditionString string] uppercaseString] ;
    if condition == "Z" then
      conditional_branch := [@conditional_branch bz] ;
    elsif condition == "NZ" then
      conditional_branch := [@conditional_branch bnz] ;
    elsif condition == "NN" then
      conditional_branch := [@conditional_branch bnn] ;
    elsif condition == "N" then
      conditional_branch := [@conditional_branch bn] ;
    elsif condition == "C" then
      conditional_branch := [@conditional_branch bc] ;
    elsif condition == "NC" then
      conditional_branch := [@conditional_branch bnc] ;
    elsif condition == "OV" then
      conditional_branch := [@conditional_branch bov] ;
    elsif condition == "NOV" then
      conditional_branch := [@conditional_branch bnov] ;
    else
      error conditionString: "invalid '" . conditionString
      . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
      -> conditional_branch
      ;
    end if ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_JUMPCC new
      !instructionLocation
      !targetLabelName
      !conditional_branch
      !false
    ] ;
  or
    $clrwdt$ ;
    outInstruction := [@instruction_CLRWDT new !here] ;
  or
    $daw$ ;
    outInstruction := [@instruction_DAW new !here] ;
  or
    $nop$ ;
    outInstruction := [@instruction_NOP new !here] ;
  or
    $pop$ ;
    outInstruction := [@instruction_POP new !here] ;
  or
    $push$ ;
    outInstruction := [@instruction_PUSH new !here] ;
  or
    $reset$ ;
    outInstruction := [@instruction_RESET new !here] ;
  or
    $sleep$ ;
    outInstruction := [@instruction_SLEEP new !here] ;
  or
    @literal_instruction_opcode literalInstruction ;
    select
      $addlw$ ; literalInstruction := [@literal_instruction_opcode ADDLW] ;
    or
      $andlw$ ; literalInstruction := [@literal_instruction_opcode ANDLW] ;
    or
      $iorlw$ ; literalInstruction := [@literal_instruction_opcode IORLW] ;
    or
      $movlw$ ; literalInstruction := [@literal_instruction_opcode MOVLW] ;
    or
      $mullw$ ; literalInstruction := [@literal_instruction_opcode MULLW] ;
    or
      $sublw$ ; literalInstruction := [@literal_instruction_opcode SUBLW] ;
    or
      $xorlw$ ; literalInstruction := [@literal_instruction_opcode XORLW] ;
    end select ;
    @location instructionLocation := here ;
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    outInstruction := [@instruction_literalOperation new
      !instructionLocation
      !literalInstruction
      !expression
    ] ;
  or
    $lfsr$ ;
    @location instructionLocation := here ;
    $integer$ ? @luint FSRindex ;
    $,$ ;
    @immediatExpression expression ;
    <immediate_expression> ?expression ;
    outInstruction := [@instruction_LFSR new !instructionLocation !FSRindex !expression] ;
  or
    $tblrd$ ;
    @location instructionLocation := here ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLRD new !instructionLocation !accessOption] ;
  or
    $tblwt$ ;
    @location instructionLocation := here ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLWT new !instructionLocation !accessOption] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <immediate_expression> !@immediatExpression outExpression :
  <immediate_bitwise_term> ?outExpression ;
  repeat
  while
    $|$ ;
    @immediatExpression rightExpression ;
    <immediate_bitwise_term> ?rightExpression ;
    outExpression := [@immediatOr new !outExpression! rightExpression] ;
  while
    $^$ ;
    @immediatExpression rightExpression ;
    <immediate_bitwise_term> ?rightExpression ;
    outExpression := [@immediatXor new !outExpression! rightExpression] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule  <immediate_bitwise_term> !@immediatExpression outExpression :
  <immediate_bitwise_factor> ?outExpression ;
  repeat
  while
    $&$ ;
    @immediatExpression rightExpression ;
    <immediate_bitwise_factor> ?rightExpression ;
    outExpression := [@immediatAnd new !outExpression! rightExpression] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <immediate_bitwise_factor> !@immediatExpression outExpression :
  <immediate_term> ?outExpression ;
  select
  or
    $==$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatEqualTest new !outExpression! rightExpression] ;
  or
    $!=$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatNotEqualTest new !outExpression! rightExpression] ;
  or
    $>=$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatGreaterOrEqualTest new !outExpression! rightExpression] ;
  or
    $<=$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatLowerOrEqualTest new !outExpression! rightExpression] ;
  or
    $>$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatGreaterTest new !outExpression! rightExpression] ;
  or
    $<$ ; 
    @immediatExpression rightExpression ;
    <immediate_term> ?rightExpression ;
    outExpression := [@immediatLowerTest new !outExpression! rightExpression] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <immediate_term> !@immediatExpression outExpression :
  <immediate_factor> ?outExpression ;
  repeat
  while
    $+$ ;
    @immediatExpression rightExpression ;
    <immediate_factor> ?rightExpression ;
    outExpression := [@immediatAdd new !outExpression! rightExpression] ;
  while
    $-$ ;
    @immediatExpression rightExpression ;
    <immediate_factor> ?rightExpression ;
    outExpression := [@immediatSub new !outExpression! rightExpression] ;
  while
    $<<$ ;
    @immediatExpression rightExpression ;
    <immediate_factor> ?rightExpression ;
    outExpression := [@immediatLeftShift new !outExpression! rightExpression] ;
  while
    $>>$ ;
    @immediatExpression rightExpression ;
    <immediate_factor> ?rightExpression ;
    outExpression := [@immediatRightShift new !outExpression! rightExpression] ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <immediate_factor> !@immediatExpression outExpression :
  <immediate_primary> ?outExpression ;
  repeat
  while
    $*$ ;
    @immediatExpression rightExpression ;
    <immediate_primary> ?rightExpression ;
    outExpression := [@immediatMul new !outExpression! rightExpression] ;
  while
    $%$ ;
    @immediatExpression rightExpression ;
    <immediate_primary> ?rightExpression ;
    outExpression := [@immediatMod new !outExpression! rightExpression] ;
  while
    $/$ ;
    @immediatExpression rightExpression ;
    <immediate_primary> ?rightExpression ;
    outExpression := [@immediatDiv new !outExpression! rightExpression] ;
  end repeat ;
end rule ;


#----------------------------------------------------*

rule <immediate_primary> !@immediatExpression outExpression :
  select
    $-$ ;
    @immediatExpression expression ;
    <immediate_primary> ?expression ;
    outExpression := [@immediatNegate new !expression] ;
  or
    $~$ ;
    @immediatExpression expression ;
    <immediate_primary> ?expression ;
    outExpression := [@immediatComplement new !expression] ;
  or
    $integer$ ? @luint constant ;
    outExpression := [@immediatInteger new !constant] ;
  or
    $literal_char$ ? @lchar literalCharValue ;
    outExpression := [@immediatInteger new ![@luint new ![[literalCharValue char] uint] ![literalCharValue location]]] ;
  or
    $identifier$ ?@lstring registerName ;
    @luint offset ;
    select
      offset := [@luint new !0 !here] ;
    or
      $[$ ;
      $integer$ ? offset ;
      $]$ ;
    end select ;
    @registerExpression registerExpression [new
      !registerName
      !offset
    ] ;
    outExpression := [@immediatRegister new !registerExpression] ;
  or
    $($ ;
    <immediate_expression> ?outExpression ;
    $)$ ;
  end select ;
end rule ;

#----------------------------------------------------*

end syntax ;
