syntax piccolo_syntax :
import lexique piccolo_lexique in "piccolo_lexique.ggs" ;
import option piccolo_options in "piccolo_options.ggs" ;
import semantics piccolo_metamodel in "piccolo_metamodel.ggs" ;

#----------------------------------------------------*

nonterminal <configuration_definition> ;

nonterminal <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
;

nonterminal <interrupt_definition>
  ?!@interruptDefinitionList outInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <simple_instruction> !@instruction outInstruction ;

nonterminal <structured_instruction>
  !@instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
;

nonterminal <start_symbol>
  !@piccoloModel outPiccoloModel
;

nonterminal <register_parsing> !@registerExpression outRegisterExpression ;

nonterminal <optional_w_as_dest> !@bool out_W_isDestination ;

nonterminal <bit_number_parsing> !@bitNumberExpression outBitNumber ;

nonterminal <literal_value_parsing> !@luint outLiteralValue ;

#----------------------------------------------------*

rule <start_symbol>
  !@piccoloModel outPiccoloModel
:
  $program$ ;
  $identifier$ ? @lstring programName ;
  $literal_string$ ? @lstring deviceName ;
  $:$ ;
  @interruptDefinitionList interruptDefinitionList [emptyList] ;
  @routineDefinitionList routineDefinitionList [emptyList] ;
  @ramDefinitionList ramDefinitionList [emptyList] ;
  @bool needsComputedGoto2 := false ;
  @bool needsComputedGoto4 := false ;
  repeat
  while
    <configuration_definition> ;
  while
    <ram_definition> !?ramDefinitionList ;
  while
    <interrupt_definition>
      !?interruptDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  while
    <routine_definition>
      !?routineDefinitionList
      !?needsComputedGoto2
      !?needsComputedGoto4
    ;
  end repeat ;
  $end$ ;
  outPiccoloModel := [@piccoloModel new
    !programName
    !deviceName
    !ramDefinitionList
    !interruptDefinitionList
    !routineDefinitionList
    !needsComputedGoto2
    !needsComputedGoto4
  ] ;
end rule ;

#----------------------------------------------------*

rule <configuration_definition> :
  $config$ ;
  ${$ ;
  $}$ ;
end rule ;

#----------------------------------------------------*

rule <ram_definition>
  ?!@ramDefinitionList ioRamDefinitionList
:
  $ram$ ;
  $identifier$ ? @lstring bankName ;
  ${$ ;
  @declarationInRamList declarationInRamList [emptyList] ;
  repeat
  while
    $byte$ ;
    $identifier$ ? @lstring name ;
    @luint size ;
    select
      size := [@luint new !1 !here] ;
    or
      $[$ ;
      $integer$ ?size ;
      $]$ ;
    end select ;
    declarationInRamList += !name !size ;
  end repeat ;
  ioRamDefinitionList += !bankName !declarationInRamList ;
  $}$ ;
end rule ;

#----------------------------------------------------*

rule <instruction_list>
  !@instructionList outInstructionList
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  outInstructionList := [@instructionList emptyList] ;
  repeat
  while
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstructionList += !instruction ;
  while
    @instruction instruction ;
    <structured_instruction>
      ?instruction
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    outInstructionList += !instruction ;
  end repeat ;
end rule ;

#----------------------------------------------------*

rule <interrupt_definition>
  ?!@interruptDefinitionList ioInterruptDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $interrupt$ ;
  $identifier$ ? @lstring interruptName ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioInterruptDefinitionList += !interruptName !instructionList ;
end rule ;

#----------------------------------------------------*

rule <routine_definition>
  ?!@routineDefinitionList ioRoutineDefinitionList
  ?!@bool ioNeedsComputedGoto2 
  ?!@bool ioNeedsComputedGoto4
:
  $routine$ ;
  $identifier$ ? @lstring routineName ;
  @luint banksel ;
  select
    banksel := [@luint new ![@uint max] !here] ;
  or
    $banksel$ ;
    $integer$ ? banksel ;
  end select ;
  @bool noreturn ;
  select
    noreturn := false ;
  or
    $noreturn$ ;
    noreturn := true ;
  end select ;
  ${$ ;
  @instructionList instructionList ;
  <instruction_list>
    ?instructionList
    !?ioNeedsComputedGoto2
    !?ioNeedsComputedGoto4
  ;
  $}$ ;
  ioRoutineDefinitionList += !routineName !banksel !noreturn !instructionList ;
end rule ;

#----------------------------------------------------*

rule <register_parsing> !@registerExpression outRegisterExpression :
  $identifier$ ?@lstring registerName ;
  @luint offset ;
  select
    offset := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? offset ;
    $]$ ;
  end select ;
  outRegisterExpression := [@registerExpression new
    !registerName
    !offset
  ] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $identifier$ ?@lstring bitNumberLabel ;
  @luint bitIndex ;
  select
    bitIndex := [@luint new !0 !here] ;
  or
    $[$ ;
    $integer$ ? bitIndex ;
    $]$ ;
  end select ;
  outBitNumber := [@bitNumberLabelValue new !bitNumberLabel !bitIndex] ;
end rule ;

#----------------------------------------------------*

rule <bit_number_parsing> !@bitNumberExpression outBitNumber :
  $integer$ ?@luint bitNumberLiteral ;
  outBitNumber := [@bitNumberLiteralValue new !bitNumberLiteral] ;
end rule ;

#----------------------------------------------------*

rule <literal_value_parsing> !@luint outLiteralValue :
  $integer$ ? outLiteralValue ;
end rule ;

#----------------------------------------------------*

rule <literal_value_parsing> !@luint outLiteralValue :
  $literal_char$ ? @lchar literalCharValue ;
  outLiteralValue := [@luint new ![[literalCharValue char] uint] ![literalCharValue location]] ;
end rule ;

#----------------------------------------------------*

rule <optional_w_as_dest> !@bool out_W_isDestination :
  select
    out_W_isDestination := false ;
  or
    $,$ ;
    $w$ ;
    out_W_isDestination := true ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <structured_instruction>
  !@instruction outInstruction
  ?!@bool ioNeedsComputedGoto2
  ?!@bool ioNeedsComputedGoto4
:
  @location instructionLocation := here ;
  select
    $forever$ ;
    @instructionList instructionList ;
    <instruction_list> ? instructionList !?ioNeedsComputedGoto2 !?ioNeedsComputedGoto4 ;
    $end$ ;
    outInstruction := [@instruction_FOREVER new
      !instructionLocation
      !instructionList
    ] ;
    $forever$ ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $!=$ ;
    $w$ ;
    $:$ ;
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_CPF_NotEqual new
      !instructionLocation
      !registerName
      !instruction
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $<=$ ;
    $w$ ;
    $:$ ;
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_CPF_LowerOrEqual new
      !instructionLocation
      !registerName
      !instruction
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $>=$ ;
    $w$ ;
    $:$ ;
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_CPF_GreaterOrEqual new
      !instructionLocation
      !registerName
      !instruction
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $identifier$ ? @lstring condition ;
    if [condition string] != "nz" then
      error condition:"invalid '" . condition . "' condition; it should be 'nz'" ;
    end if ;
    $:$ ;
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_TST_NotZero new
      !instructionLocation
      !registerName
      !instruction
    ] ;
  or
    $if$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    @bool skipIfSet ;
    $identifier$ ? @lstring condition ;
    if [condition string] == "z" then
      skipIfSet := true ;
    elsif [condition string] == "nz" then
      skipIfSet := false ;
    else
      error condition:"invalid '" . condition . "' condition; it should be 'z' or 'nz'" -> skipIfSet ;
    end if ;
    $:$ ;
    @instruction instruction ;
    <simple_instruction> ?instruction ;
    outInstruction := [@instruction_IF_BitTest new
      !instructionLocation
      !registerName
      !instruction
      !bitNumber
      !skipIfSet
    ] ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $retlw$ ;
    @luintlist argumentList [emptyList] ;
    repeat
      @luint literalValue ;
      <literal_value_parsing> ?literalValue ;
      argumentList += ! literalValue ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_retlw new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto2 := true ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $bra$ ;
    @lstringlist argumentList [emptyList] ;
    repeat
      $identifier$ ? @lstring targetRoutine ;
      argumentList += ! targetRoutine ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_bra new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto2 := true ;
  or
    @bool useRelativeCall ;
    select
      $computed$ ;
      useRelativeCall := false ;
    or
      $rcomputed$ ;
      useRelativeCall := true ;
    end select ;
    $goto$ ;
    @lstringlist argumentList [emptyList] ;
    repeat
      $identifier$ ? @lstring targetRoutine ;
      argumentList += ! targetRoutine ;
    while
      $,$ ;
    end repeat ;
    outInstruction := [@instruction_computed_goto new
      !instructionLocation
      !argumentList
      !useRelativeCall
    ] ;
    ioNeedsComputedGoto4 := true ;
  or
    $if$ ;
    @structured_if_condition structured_if_condition ;
    select
      @registerExpression registerExpression ;
      <register_parsing> ? registerExpression ;
      $.$ ;
      @bitNumberExpression bitNumberExpression ;
      <bit_number_parsing> ?bitNumberExpression ;
      $identifier$ ? @lstring conditionString ;
      @bool BTFSSinstruction ;
      if [conditionString string] == "z" then
        BTFSSinstruction := false ;
      elsif [conditionString string] == "nz" then
        BTFSSinstruction := true ;
      else
        error conditionString: "invalid '" . conditionString
        . "' condition; valid ones are: 'z' and 'nz'"
        -> BTFSSinstruction
        ;
      end if ;
      structured_if_condition := [@bitTest_in_structured_if_condition new
        !registerExpression
        !bitNumberExpression
        !BTFSSinstruction
      ] ;
    or
      @conditional_branch conditional_branch ;
      $identifier$ ? @lstring conditionString ;
      if [conditionString string] == "z" then
        conditional_branch := [@conditional_branch bnz] ;
      elsif [conditionString string] == "nz" then
        conditional_branch := [@conditional_branch bz] ;
      elsif [conditionString string] == "n" then
        conditional_branch := [@conditional_branch bnn] ;
      elsif [conditionString string] == "nn" then
        conditional_branch := [@conditional_branch bn] ;
      elsif [conditionString string] == "c" then
        conditional_branch := [@conditional_branch bnc] ;
      elsif [conditionString string] == "nc" then
        conditional_branch := [@conditional_branch bc] ;
      elsif [conditionString string] == "ov" then
        conditional_branch := [@conditional_branch bnov] ;
      elsif [conditionString string] == "nov" then
        conditional_branch := [@conditional_branch bov] ;
      else
        error conditionString: "invalid '" . conditionString
        . "' condition; valid ones are: 'z', 'nz', 'n', 'nn', 'c', 'nc', 'ov' and 'nov'"
        -> conditional_branch
        ;
      end if ;
      structured_if_condition := [@bcc_in_structured_if_condition new !conditional_branch] ;
    end select ;
    ${$ ;
    @instructionList thenInstructionList ;
    <instruction_list>
      ?thenInstructionList
      !?ioNeedsComputedGoto2
      !?ioNeedsComputedGoto4
    ;
    $}$ ;
    @instructionList elseInstructionList ;
    select
      elseInstructionList := [@instructionList emptyList] ;
    or
      $else$ ;
      ${$ ;
      <instruction_list>
        ?elseInstructionList
        !?ioNeedsComputedGoto2
        !?ioNeedsComputedGoto4
      ;
    $}$ ;
    end select ;
    outInstruction := [@instruction_structured_if new
      !instructionLocation
      !structured_if_condition
      !thenInstructionList
      !elseInstructionList
    ] ;
  end select ;
end rule ;

#----------------------------------------------------*

rule <simple_instruction> !@instruction outInstruction :
  @location instructionLocation := here ;
  select
    @instruction_FDA_base_code baseCode ;
    select
      $addwf$ ;
      baseCode := [@instruction_FDA_base_code ADDWF] ;
    or
      $addwfc$ ;
      baseCode := [@instruction_FDA_base_code ADDWFC] ;
    or
      $andwf$ ;
      baseCode := [@instruction_FDA_base_code ANDWF] ;
    or
      $comf$ ;
      baseCode := [@instruction_FDA_base_code COMF] ;
    or
      $decf$ ;
      baseCode := [@instruction_FDA_base_code DECF] ;
    or
      $decfsz$ ;
      baseCode := [@instruction_FDA_base_code DECFSZ] ;
    or
      $dcfsnz$ ;
      baseCode := [@instruction_FDA_base_code DCFSNZ] ;
    or
      $incf$ ;
      baseCode := [@instruction_FDA_base_code INCF] ;
    or
      $incfsz$ ;
      baseCode := [@instruction_FDA_base_code INCFSZ] ;
    or
      $infsnz$ ;
      baseCode := [@instruction_FDA_base_code INFSNZ] ;
    or
      $iorwf$ ;
      baseCode := [@instruction_FDA_base_code IORWF] ;
    or
      $movf$ ;
      baseCode := [@instruction_FDA_base_code MOVF] ;
    or
      $rlcf$ ;
      baseCode := [@instruction_FDA_base_code RLCF] ;
    or
      $rlncf$ ;
      baseCode := [@instruction_FDA_base_code RLNCF] ;
    or
      $rrcf$ ;
      baseCode := [@instruction_FDA_base_code RRCF] ;
    or
      $rrncf$ ;
      baseCode := [@instruction_FDA_base_code RRNCF] ;
    or
      $subfwb$ ;
      baseCode := [@instruction_FDA_base_code SUBFWB] ;
    or
      $subwf$ ;
      baseCode := [@instruction_FDA_base_code SUBWF] ;
    or
      $subwfb$ ;
      baseCode := [@instruction_FDA_base_code SUBWFB] ;
    or
      $swapf$ ;
      baseCode := [@instruction_FDA_base_code SWAPF] ;
    or
      $xorwf$ ;
      baseCode := [@instruction_FDA_base_code XORWF] ;
    end select ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    @bool W_isDestination ;
    <optional_w_as_dest> ?W_isDestination ;
    outInstruction := [@instruction_FDA new
      !instructionLocation
      !baseCode
      !registerName
      !W_isDestination
    ] ;
  or
    $clrf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_CLRF new
      !instructionLocation
      !registerName
    ] ;
  or
    $cpfsgt$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_CPFSGT new
      !instructionLocation
      !registerName
    ] ;
  or
    $cpfslt$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_CPFSLT new
      !instructionLocation
      !registerName
    ] ;
  or
    $movwf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_MOVWF new
      !instructionLocation
      !registerName
    ] ;
  or
    $mulwf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_MULWF new
      !instructionLocation
      !registerName
    ] ;
  or
    $negf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_NEGF new
      !instructionLocation
      !registerName
    ] ;
  or
    $setf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_SETF new
      !instructionLocation
      !registerName
    ] ;
  or
    $tstfsz$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_TSTFSZ new
      !instructionLocation
      !registerName
    ] ;
  or
    $movff$ ;
    @registerExpression sourceRegisterName ;
    <register_parsing> ?sourceRegisterName ;
    $,$ ;
    @registerExpression destinationRegisterName ;
    <register_parsing> ? destinationRegisterName ;
    outInstruction := [@instruction_MOVFF new
      !instructionLocation
      !sourceRegisterName
      !destinationRegisterName
    ] ;
  or
    $bcf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_BCF new
      !instructionLocation
      !registerName
      !bitNumber
    ] ;
  or
    $bsf$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_BSF new
      !instructionLocation
      !registerName
      !bitNumber
    ] ;
  or
    $btfsc$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $,$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_BTFSC new
      !instructionLocation
      !registerName
      !bitNumber
    ] ;
  or
    $btfss$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $,$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_BTFSS new
      !instructionLocation
      !registerName
      !bitNumber
    ] ;
  or
    $btg$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    $.$ ;
    @bitNumberExpression bitNumber ;
    <bit_number_parsing> ?bitNumber ;
    outInstruction := [@instruction_BTG new
      !instructionLocation
      !registerName
      !bitNumber
    ] ;
  or
    @conditional_branch conditionalBranch ;
    select
      $bc$ ; conditionalBranch := [@conditional_branch bc] ;
    or
      $bnc$ ; conditionalBranch := [@conditional_branch bnc] ;
    or
      $bz$ ; conditionalBranch := [@conditional_branch bz] ;
    or
      $bnz$ ; conditionalBranch := [@conditional_branch bnz] ;
    or
      $bn$ ; conditionalBranch := [@conditional_branch bn] ;
    or
      $bnn$ ; conditionalBranch := [@conditional_branch bnn] ;
    or
      $bov$ ; conditionalBranch := [@conditional_branch bov] ;
    or
      $bnov$ ; conditionalBranch := [@conditional_branch bnov] ;
    end select ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_conditionalBranch new
      !instructionLocation
      !conditionalBranch
      !targetLabelName
    ] ;
  or
    $bra$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_BRA new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $call$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_CALL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $goto$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_GOTO new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $rcall$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_RCALL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $clrwdt$ ;
    outInstruction := [@instruction_CLRWDT new !instructionLocation] ;
  or
    $daw$ ;
    outInstruction := [@instruction_DAW new !instructionLocation] ;
  or
    $nop$ ;
    outInstruction := [@instruction_NOP new !instructionLocation] ;
  or
    $pop$ ;
    outInstruction := [@instruction_POP new !instructionLocation] ;
  or
    $push$ ;
    outInstruction := [@instruction_PUSH new !instructionLocation] ;
  or
    $reset$ ;
    outInstruction := [@instruction_RESET new !instructionLocation] ;
  or
    $return$ ;
    outInstruction := [@instruction_RETURN new !instructionLocation] ;
  or
    $sleep$ ;
    outInstruction := [@instruction_SLEEP new !instructionLocation] ;
  or
    $addlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_ADDLW new !instructionLocation !literalValue] ;
  or
    $andlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_ANDLW new !instructionLocation !literalValue] ;
  or
    $iorlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_IORLW new !instructionLocation !literalValue] ;
  or
    $movlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_MOVLW new !instructionLocation !literalValue] ;
  or
    $mullw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_MULLW new !instructionLocation !literalValue] ;
  or
    $retlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_RETLW new !instructionLocation !literalValue] ;
  or
    $sublw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_SUBLW new !instructionLocation !literalValue] ;
  or
    $xorlw$ ;
    @luint literalValue ;
    <literal_value_parsing> ?literalValue ;
    outInstruction := [@instruction_XORLW new !instructionLocation !literalValue] ;
  or
    $lfsr$ ;
    $integer$ ? @luint FSRindex ;
    $,$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_LFSR new !instructionLocation !FSRindex !registerName] ;
  or
    $movlb$ ;
    $integer$ ? @luint pageIndex ;
    outInstruction := [@instruction_MOVLB new !instructionLocation !pageIndex] ;
  or
    $label$ ;
    $identifier$ ? @lstring targetLabelName ;
    outInstruction := [@instruction_LABEL new
      !instructionLocation
      !targetLabelName
    ] ;
  or
    $movaw$ ;
    @registerExpression registerName ;
    <register_parsing> ?registerName ;
    outInstruction := [@instruction_MOVAW new !instructionLocation !registerName] ;
  or
    $tblrd$ ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLRD new !instructionLocation !accessOption] ;
  or
    $tblwt$ ;
    @tableAccessOption accessOption ;
    select
      $*$ ;
      accessOption := [@tableAccessOption simpleAccess] ;
    or
      $*+$ ;
      accessOption := [@tableAccessOption postIncrement] ;
    or
      $*-$ ;
      accessOption := [@tableAccessOption postDecrement] ;
    or
      $+*$ ;
      accessOption := [@tableAccessOption preIncrement] ;
    end select ;
    outInstruction := [@instruction_TBLWT new !instructionLocation !accessOption] ;
  or
    $mnop$ ;
    $integer$ ? @luint occurrenceFactor ;
    outInstruction := [@instruction_MNOP new !instructionLocation !occurrenceFactor] ;
  end select ;
end rule ;

#----------------------------------------------------*

end syntax ;
