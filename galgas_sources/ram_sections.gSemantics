semantics ram_sections :
import semantics piccoloDevice_semantics in "piccoloDevice_semantics.gSemantics" ;
import semantics ipic18_metamodel in "ipic18_metamodel.gSemantics" ;
import "piccoloDevice_semantics.gSemantics" ;
import "ipic18_metamodel.gSemantics" ;

import option piccolo_options in "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*
#                                                                            *
#           R A M    D E C L A R A T I O N    A N A L Y S I S                *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @declarationInRam handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
;

#----------------------------------------------------------------------------*

override method @commonDeclarationInRam handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
:
  @uint firstFreeAddressBeforeCommon ;
  [ioRamBank searchKey !inCurrentRamBank ?* ?firstFreeAddressBeforeCommon ?* ?*] ;
  @bool firstFreeAddressDefined := false ;
  @uint firstFreeAddress := 0 ;
  foreach mBranchList do
    @ramBankTable ramBank := ioRamBank ;
    foreach mDeclarations do
      [mDeclarationInRAM handleDeclaration !?ramBank !?ioRegisterTable !inCurrentRamBank] ;
    end foreach ;
    @uint ffa ;
    [ramBank searchKey !inCurrentRamBank ?* ?ffa ?* ?*] ;
    if not firstFreeAddressDefined then
      firstFreeAddress := ffa ;
      firstFreeAddressDefined := true ;
    elsif ffa != firstFreeAddress then
      error mEndOfBranchLocation: "this branch allocates " . [ffa - firstFreeAddressBeforeCommon string]
      . " byte(s), while the first branch allocates "
      . [firstFreeAddress - firstFreeAddressBeforeCommon string] . " byte(s)" ;
    end if ;
  end foreach ;
  [!?ioRamBank setMFirstFreeAddressForKey !firstFreeAddress ![inCurrentRamBank string]] ;
end method ;

#----------------------------------------------------------------------------*

override method @byteDeclarationInRam handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
:
  @uint lastAddressPlusOne ;
  @uint firstFreeAddress ;
  @uintlist mirrorOffsetList ;
  [ioRamBank searchKey !inCurrentRamBank ?* ?firstFreeAddress ?lastAddressPlusOne ?mirrorOffsetList] ;
  if [mSize uint] == 0 then
    error mSize: "zero size is not allowed" ;
  end if ;
  @uintlist addressList [listWithValue !firstFreeAddress] ;
  foreach mirrorOffsetList do
    addressList += !firstFreeAddress + mValue ;
  end foreach ;
  [!?ioRegisterTable insertKey !mName !addressList ![mSize uint] !mBitSliceTable !mBitDefinitionString] ;
  firstFreeAddress := firstFreeAddress + [mSize uint] ;
  [!?ioRamBank setMFirstFreeAddressForKey !firstFreeAddress ![inCurrentRamBank string]] ;
  if firstFreeAddress > lastAddressPlusOne then
    error mName: "overflow in '" . inCurrentRamBank . "' ram bank for '" . mName . "' declaration" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze_ram_sections
  ??@string inListingTitle
  ??@ramDefinitionList inRamDefinitionList
  ?!@ramBankTable ioRamBankTable
  ??@registerTable inSpecialRegisterTable
  ?!@string ioListFileContents
  ?!@registerTable ioAllRegisters :
  foreach inRamDefinitionList do
    foreach mDeclaration do
      [mDeclarationInRAM handleDeclaration !?ioRamBankTable !?ioAllRegisters !mBankName] ;
    end foreach ;
  end foreach ;
  if [option piccolo_options.ouputListingFile] then
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . [inListingTitle stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    ioListFileContents .= ["Variable" stringByLeftPadding !40 !' '] . " Address\n" ;
    foreach ioAllRegisters do
      if not [inSpecialRegisterTable hasKey ![key string]] then
        ioListFileContents .= [[key string] stringByLeftPadding !40 !' '] . " " ;
        foreach mRegisterAddressList
        do ioListFileContents .= [mValue hexString] ;
        between ioListFileContents .= ", " ;
        end foreach ;
        ioListFileContents .= mBitDefinitionString . "\n" ;
      end if ;
    end foreach ;
    ioListFileContents .= "\n" ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
