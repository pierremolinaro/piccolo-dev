semantics ram_sections :
import "piccoloDevice_semantics.gSemantics" ;
import "pic18_intermediate_classes.gSemantics" ;
import "piccolo_options.gOption" ;

#----------------------------------------------------------------------------*
#                                                                            *
#           R A M    D E C L A R A T I O N    A N A L Y S I S                *
#                                                                            *
#----------------------------------------------------------------------------*

abstract method @declarationInRam handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
  ?!@declaredByteMap ioDeclaredByteMap
;

#----------------------------------------------------------------------------*

override method @byteDeclarationInRam handleDeclaration
  ?!@ramBankTable ioRamBank
  ?!@registerTable ioRegisterTable
  ??@lstring inCurrentRamBank
  ?!@declaredByteMap ioDeclaredByteMap
:
  @uint lastAddressPlusOne ;
  @uint firstFreeAddress ;
  @uintlist mirrorOffsetList ;
  [ioRamBank searchKey !inCurrentRamBank ?* ?firstFreeAddress ?lastAddressPlusOne ?mirrorOffsetList] ;
  if [mSize uint] == 0 then
    error mSize: "zero size is not allowed" ;
  end if ;
  @uintlist addressList [listWithValue !firstFreeAddress] ;
  foreach mirrorOffsetList do
    addressList += !firstFreeAddress + mValue ;
  end foreach ;
  if not [ioDeclaredByteMap hasKey !mName->string] then
    [!?ioDeclaredByteMap insertKey !mName] ;
  end if ;
  [!?ioRegisterTable insertKey !mName !addressList ![mSize uint] !mBitSliceTable !mBitDefinitionString] ;
  firstFreeAddress := firstFreeAddress + [mSize uint] ;
  [!?ioRamBank setMFirstFreeAddressForKey !firstFreeAddress ![inCurrentRamBank string]] ;
  if firstFreeAddress > lastAddressPlusOne then
    error mName: "overflow in '" . inCurrentRamBank . "' ram bank for '" . mName . "' declaration" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                                                                            *
#               S E M A N T I C    A N A L Y S I S                           *
#                                                                            *
#----------------------------------------------------------------------------*

routine analyze_ram_sections
  ??@string inListingTitle
  ??@ramDefinitionList inRamDefinitionList
  ?!@ramBankTable ioRamBankTable
  ??@registerTable inSpecialRegisterTable
  ?!@string ioListFileContents
  ?!@registerTable ioAllRegisters
  !@declaredByteMap outDeclaredByteMap
:
  outDeclaredByteMap := [@declaredByteMap emptyMap] ;
  foreach inRamDefinitionList do
    foreach mDeclaration do
      [mDeclarationInRAM handleDeclaration !?ioRamBankTable !?ioAllRegisters !mBankName !?outDeclaredByteMap] ;
    end foreach ;
  end foreach ;
  if [option piccolo_options.ouputListingFile value] then
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n" ;
    ioListFileContents .= "*" . [inListingTitle stringByLeftAndRightPadding !77 !' '] . "*\n" ;
    ioListFileContents .= ["" stringByLeftAndRightPadding !79 !'*'] . "\n\n" ;
    ioListFileContents .= ["Variable" stringByLeftPadding !40 !' '] . " Address\n" ;
    foreach ioAllRegisters do
      if not [inSpecialRegisterTable hasKey ![lkey string]] then
        ioListFileContents .= [[lkey string] stringByLeftPadding !40 !' '] . " " ;
        foreach mRegisterAddressList
        do ioListFileContents .= [mValue hexString] ;
        between ioListFileContents .= ", " ;
        end foreach ;
        ioListFileContents .= mBitDefinitionString . "\n" ;
      end if ;
    end foreach ;
    ioListFileContents .= "\n" ;
  end if ;
end routine ;

#----------------------------------------------------*

end semantics ;
