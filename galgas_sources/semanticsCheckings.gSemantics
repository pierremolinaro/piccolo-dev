semantics semanticsCheckings :
import semantics piccolo_metamodel in "piccolo_metamodel.gSemantics" ;
import semantics piccoloDevice_semantics in "piccoloDevice_semantics.gSemantics" ;
import "ipic_metamodel.gSemantics" ;

#----------------------------------------------------------------------------*
#                          ROUTINE MAP                                       *
#----------------------------------------------------------------------------*

map @routineMap {
  @bool mIsNoReturn ;
  @uint mRequiredBank ;
  @uint mReturnedBank ;
  @bool mPreservesBank ;
  insert insertKey error message "the '%K' routine is already declared in %L" ;
  search searchKey error message "the '%K' routine is not declared" ;
}

#----------------------------------------------------------------------------*
#                          CHECK BIT NUMBER                                  *
#----------------------------------------------------------------------------*

abstract method @bitNumberExpression.checkBitNumber
  ??@bitSliceTable inBitSliceTable
;

#----------------------------------------------------------------------------*

override method @bitNumberLiteralValue.checkBitNumber
  ??@bitSliceTable unused inBitSliceTable
:
  if [mBitNumberLiteralValue uint] > 7 then
    error mBitNumberLiteralValue:"The bit number is " . [[mBitNumberLiteralValue uint] string] . " (should be <= 7)" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @bitNumberLabelValue.checkBitNumber
  ??@bitSliceTable inBitSliceTable
:
  @uint sliceIndex ;
  @uint sliceSize ;
  [inBitSliceTable searchKey !mBitNumberLabelValue ?sliceIndex ? sliceSize] ;
  if [mBitNumberIndexValue uint] > sliceSize then
    error mBitNumberIndexValue: "The " . [[mBitNumberIndexValue uint] string]
    . " index is too large (should be < " . [sliceSize string] . ")" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                      CHECK REGISTER ADDRESSING                             *
#----------------------------------------------------------------------------*

method @registerExpression.checkRegisterDeclaration
  ??@registerTable inRegisterTable
:
#--- 
  @uint size ;
  [inRegisterTable searchKey !mRegisterName ?* ?size ?*] ;
#--- Check size
  if [mOffset uint] >= size then
    error mOffset:"index (" . [[mOffset uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression.checkRegisterDeclarationAndAddressLowerThan256
  ??@registerTable inRegisterTable
:
#--- Do not check size
  @uintlist registerAddressList ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?* ?*] ;
#--- Check if register has address < 256
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue + [mOffset uint]) < 256 ;
  end foreach ;
  if not found then
    error mRegisterName:"the register '" . mRegisterName . "' should be should have an address < 256" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

method @registerExpression.checkRegisterAddressingAndBankAccess
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  !@bitSliceTable outBitSliceTable
:
#--- 
  @uintlist registerAddressList ;
  @uint size ;
  [inRegisterTable searchKey !mRegisterName ?registerAddressList ?size ?outBitSliceTable] ;
#--- Check size
  if [mOffset uint] >= size then
    error mOffset:"index (" . [[mOffset uint] string] . ") should be lower than size (" . [size string] . ")" ;
  end if ;
#--- Check if register can be accessed throught Access Bank
  @bool found := false ;
  foreach registerAddressList while not found do
    found := (mValue < inAccessBankSplitOffset) | (mValue >= (0x0F00 + inAccessBankSplitOffset)) ;
  end foreach ;
#--- If not, try BSR
  if not found then
    if ioCurrentBank == [@uint max] then
      error mRegisterName:"the register '" . mRegisterName . "' should be addressed with BSR, but BSR does not contain a reliable value" ;
    else
      @uint bankFirst := ioCurrentBank * 256 ;
      @uint bankLast := bankFirst + 255 ;
      foreach registerAddressList while not found do
        found := (mValue >= bankFirst) & (mValue <= bankLast) ;
      end foreach ;
      if not found then
        error mRegisterName:"the register '" . mRegisterName . "' should be addressed with BSR, but BSR contains " . [ioCurrentBank string] . " that does not correspond to register bank" ;
      end if ;
    end if ;
  end if ;
end method ;

#----------------------------------------------------------------------------*
#                          CHECK INSTRUCTIONS                                *
#----------------------------------------------------------------------------*

enum @routineKind {
  constructor regularRoutine ;
  constructor noReturnRoutine ;
  constructor interruptRoutine ;
}{
}

#----------------------------------------------------------------------------*

method @piccolo_instruction.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
end method ;

#----------------------------------------------------------------------------*

routine checkInstructionList
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  !@bool outContinuesInSequence
  ??@routineKind inRoutineKind
  ??@instructionList inInstructionList
:
  outContinuesInSequence := true ;
  foreach inInstructionList do
    if not outContinuesInSequence then
      error [mInstruction mInstructionLocation] : "Unreachable code" ;
      outContinuesInSequence := true ;
    end if ;
    [mInstruction check
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !?ioCurrentBank
      !inShouldPreserveBSR
      !?outContinuesInSequence
      !inRoutineKind
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

override method @instruction_nobanksel.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \nobank\" here: BSR should be preserved (use it in a \"banksave\" construct)" ;
  end if ;
  ioCurrentBank := [@uint max] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_banksel.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if inShouldPreserveBSR then
    error mInstructionLocation: "cannot use \"banksel\" here: BSR should be preserved (use it in \"banksave\" construct)" ;
  end if ;
  if [mBankIndex uint] > 15 then
    error mBankIndex:"selected bank index should be lower or equal to 15" ;
    ioCurrentBank := [@uint max] ; # No selected bank
  elsif [mBankIndex uint] == ioCurrentBank then
    warning mBankIndex:"useless instruction: the bank " . [ioCurrentBank string] . " is already selected" ;
  else
    ioCurrentBank := [mBankIndex uint] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_savebank.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  [mRegister checkRegisterDeclaration !inRegisterTable] ;
#---
  @uint finalBank := ioCurrentBank ;
  checkInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?finalBank
    !false # Do not preserve bank now
    ?ioContinuesInSequence
    !inRoutineKind
    !mInstructionList
  ;
  if not ioContinuesInSequence then
    error mEndOfSaveBankInstruction:"useless saving: execution does reach the end of \"savebank\" instruction list" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FDA.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FA.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVFF.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mSourceRegisterName checkRegisterDeclaration !inRegisterTable] ;
  [mDestinationRegisterName checkRegisterDeclaration !inRegisterTable] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FBA.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @bitSliceTable bitSliceTable ;
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?bitSliceTable
  ] ;
  [mBitNumber checkBitNumber !bitSliceTable] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_JSR.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @bool isNoReturn ;
  @uint requiredBank ;
  @uint returnedBank ;
  @bool preservesBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?returnedBank ?preservesBank] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if isNoReturn then
    error mTargetLabel:"a \"noreturn\" routine should be called with a BRA, GOTO, Bcc or JUMP instruction" ;
  end if ;
  if not preservesBank then
    ioCurrentBank := returnedBank ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_JUMP.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @bool isNoReturn ;
  @uint requiredBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_JUMPCC.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  @bool isNoReturn ;
  @uint requiredBank ;
  [inRoutineMap searchKey !mTargetLabel ?isNoReturn ?requiredBank ?* ?*] ;
  if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
    @string errorMessage := "the routine '" . mTargetLabel . "' requires BSR to be set to " . [requiredBank string] ;
    errorMessage .= ", but BSR " ;
    if ioCurrentBank == [@uint max] then
      errorMessage .= "does contain any reliable value" ;
    else
      errorMessage .= "is set to " . [ioCurrentBank string] ;
    end if ;
    error mTargetLabel:errorMessage ;
  end if ;
  if not isNoReturn then
    error mTargetLabel:"a regular routine should be called with a RCALL, CALL or JSR instruction" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_literalOperation.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if [mLiteralValue uint] > 255 then
    error mLiteralValue:"the literal value (" . [[mLiteralValue uint] string] . ") should be lower or equal to 255" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_LFSR.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if [mFSRindex uint] > 2 then
    error mFSRindex:"the LFSR register index (" . [[mFSRindex uint] string] . ") should be lower or equal to 2" ;
  end if ;
  [mRegisterExpression checkRegisterDeclaration !inRegisterTable] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MOVAW.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  [mRegisterExpression checkRegisterDeclarationAndAddressLowerThan256 !inRegisterTable] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_retlw.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine : # ok
  when noReturnRoutine :
    error mInstructionLocation:"a \"noreturn\" routine does not accept computed retlw instruction" ;
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed retlw instruction" ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_MNOP.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap unused inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind unused inRoutineKind
:
  if [mOccurrenceFactor uint] == 0 then
    warning mOccurrenceFactor:"occurrence argument is zero: no generated code" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_bra.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  foreach mTargetLabels do
    @bool isNoReturn ;
    @uint requiredBank ;
    [inRoutineMap searchKey !mValue ?isNoReturn ?requiredBank ?* ?*] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if not isNoReturn then
      error mValue:"for being named in a computed bra, the '" . mValue . "' routine should be declared with the \"noreturn\" qualifier" ;
	 end if ;
  end foreach ;
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept computed bra instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed bra instruction" ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_computed_goto.check
  ??@uint unused inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable unused inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool unused inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  foreach mTargetLabels do
    @bool isNoReturn ;
    @uint requiredBank ;
    [inRoutineMap searchKey !mValue ?isNoReturn ?requiredBank ?* ?*] ;
    if (requiredBank != [@uint max]) & (requiredBank != ioCurrentBank) then
      @string errorMessage := "the routine '" . mValue . "' requires BSR to be set to " . [requiredBank string] ;
      errorMessage .= ", but BSR " ;
      if ioCurrentBank == [@uint max] then
        errorMessage .= "does contain any reliable value" ;
      else
        errorMessage .= "is set to " . [ioCurrentBank string] ;
      end if ;
      error mValue: errorMessage ;
    end if ;
    if not isNoReturn then
      error mValue:"for being named in a computed goto, the '" . mValue . "' routine should be declared with the \"noreturn\" qualifier" ;
	 end if ;
  end foreach ;
  ioContinuesInSequence := false ;
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept computed goto instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept computed goto instruction" ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_FOREVER.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  switch inRoutineKind
  when regularRoutine :
    error mInstructionLocation:"a regular routine does not accept the \"forever\" instruction" ;
  when noReturnRoutine : # ok
  when interruptRoutine :
    error mInstructionLocation:"an interrupt routine does not accept the \"forever\" instruction" ;
  end switch ;
#--- Check instruction list does not change bank
  @uint finalBank := ioCurrentBank ;
  checkInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?finalBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind
    !mInstructionList
  ;
  if ioCurrentBank != finalBank then
    error mEndOfInstructionList:"instruction list does not leave BSR value unchanged";
  end if ;
#---
  ioContinuesInSequence := false ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_IF_FA_SEMI_COLON.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
#--- Check embedded instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction check
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_IF_BitTest.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  @bitSliceTable bitSliceTable ;
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?bitSliceTable
  ] ;
  [mBitNumber checkBitNumber !bitSliceTable] ;
#--- Check embedded instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction check
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

abstract method @conditionExpression.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
;

#----------------------------------------------------------------------------*

override method @bcc_in_structured_if_condition.checkCondition
  ??@uint unused inAccessBankSplitOffset
  ??@registerTable unused inRegisterTable
  ?!@uint unused ioCurrentBank
:
end method ;

#----------------------------------------------------------------------------*

override method @registerComparisonCondition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @incDecRegisterInCondition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @registerTestCondition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @negateCondition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  [mCondition checkCondition
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @andCondition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  [mLeftExpression checkCondition
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
  ] ;
  [mRightExpression checkCondition
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @bitTest_in_structured_if_condition.checkCondition
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
:
  @bitSliceTable bitSliceTable ;
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?bitSliceTable
  ] ;
  [mBitNumber checkBitNumber !bitSliceTable] ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_structured_if.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Check condition
  [mIfCondition checkCondition
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
  ] ;
#--- 'then' instructions
  @uint finalBank := ioCurrentBank ;
  checkInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?finalBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind
    !mThenInstructionList
  ;
#--- 'elsif' parts
  foreach mElsifPartList do
    [mCondition checkCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioCurrentBank
    ] ;
    @bool continuesInSequence ;
    @uint elsifPartCurrentBank := ioCurrentBank ;
    checkInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !?elsifPartCurrentBank
      !inShouldPreserveBSR
      ?continuesInSequence
      !inRoutineKind
      !mInstructionList
    ;
    if elsifPartCurrentBank != finalBank then
      error mEndOfPartLocation:"This branch does not leave BSR value as the first one does";
    end if ;
    ioContinuesInSequence := ioContinuesInSequence | continuesInSequence ;
  end foreach ;
#--- 'else' instructions
  @bool continuesInSequence ;
  @uint elsePartCurrentBank := ioCurrentBank ;
  checkInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?elsePartCurrentBank
    !inShouldPreserveBSR
    ?continuesInSequence
    !inRoutineKind
    !mElseInstructionList
  ;
  if elsePartCurrentBank != finalBank then
    error mEndOfElsePartLocation:"This branch does not leave BSR value as the first one does";
  end if ;
#---
  ioContinuesInSequence := ioContinuesInSequence | continuesInSequence ;
  ioCurrentBank := finalBank ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_do_while.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool ioContinuesInSequence
  ??@routineKind inRoutineKind
:
#--- Repeated instructions
  @uint finalBank := ioCurrentBank ;
  checkInstructionList
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?finalBank
    !inShouldPreserveBSR
    ?ioContinuesInSequence
    !inRoutineKind
    !mRepeatedInstructionList
  ;
  if ioCurrentBank != finalBank then
    error mEndOfRepeatedInstructionList:"This branch does not leave BSR value unchanged";
  end if ;
#--- while parts
  foreach mWhilePartList do
    [mCondition checkCondition
      !inAccessBankSplitOffset
      !inRegisterTable
      !?ioCurrentBank
    ] ;
    @uint bank := ioCurrentBank ;
    checkInstructionList
      !inAccessBankSplitOffset
      !inRoutineMap
      !inRegisterTable
      !?bank
      !inShouldPreserveBSR
      ?ioContinuesInSequence
      !inRoutineKind
      !mInstructionList
    ;
    if ioCurrentBank != bank then
      error mEndOfPartLocation:"This branch does not leave BSR value unchanged";
    end if ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

override method @instruction_IF_IncDec.check
  ??@uint inAccessBankSplitOffset
  ??@routineMap inRoutineMap
  ??@registerTable inRegisterTable
  ?!@uint ioCurrentBank
  ??@bool inShouldPreserveBSR
  ?!@bool unused ioContinuesInSequence
  ??@routineKind inRoutineKind
:
  [mRegisterExpression checkRegisterAddressingAndBankAccess
    !inAccessBankSplitOffset
    !inRegisterTable
    !?ioCurrentBank
    ?*
  ] ;
#--- Check embedded instruction
  @bool unusedContinuesInSequence := true ;
  [mInstruction check
    !inAccessBankSplitOffset
    !inRoutineMap
    !inRegisterTable
    !?ioCurrentBank
    !inShouldPreserveBSR
    !?unusedContinuesInSequence
    !inRoutineKind
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine semanticsCheckings
  ??@uint inAccessBankSplitOffset
  ??@registerTable inRegisterTable
  ??@piccoloModel inPiccoloModel
  ??@bool unused inHasHighInterrupt
  ??@bool unused inHasLowInterrupt
  ?!@string unused ioListFileContents
:
#-------------------------------- Build routine map
  @routineMap routineMap [emptyMap] ;
  foreach [inPiccoloModel mRoutineDefinitionList] do
    if ([mRequiredBank uint] != [@uint max]) & ([mRequiredBank uint] > 15) then
      error mRequiredBank:"the required bank value should be lower or equal to 15" ;
    end if ;
    if ([mReturnedBank uint] != [@uint max]) & ([mReturnedBank uint] > 15) then
      error mReturnedBank:"the returned bank value should be lower or equal to 15" ;
    end if ;
    [!?routineMap insertKey !mRoutineName !mIsNoReturn ![mRequiredBank uint] ![mReturnedBank uint] !mPreservesBank] ;
  end foreach ;
#-------------------------------- Check the "main" routine is declared
  if [routineMap hasKey !"main"] then
    @bool isNoReturn ;
    @uint requiredBank ;
    [routineMap searchKey ![@lstring new !"main" !here] ?isNoReturn ?requiredBank ?* ?*] ;
    if not isNoReturn then
      error here :"the \"main\" should be declared with \"noreturn\" qualifier: \"noreturn main requiresbank 0\"" ;
    end if ;
    if requiredBank != 0 then
      error here :"the \"main\" should be declared with \"requiresbank 0\" qualifier: \"noreturn main requiresbank 0\"" ;
    end if ;
  else
    error [inPiccoloModel mEndOfProgram]: "the program should declare the \"main\" routine" ;
  end if ;
#-------------------------------- Check routines
  foreach [inPiccoloModel mRoutineDefinitionList] do
    @bool continuesInSequence := true ;
    @uint currentBank := [mRequiredBank uint] ;
    @routineKind routineKind ;
    if mIsNoReturn then
      routineKind := [@routineKind noReturnRoutine] ;
    else
      routineKind := [@routineKind regularRoutine] ;
    end if ;
    foreach mInstructionList do
      if not continuesInSequence then
        error [mInstruction mInstructionLocation] : "Unreachable code" ;
        continuesInSequence := true ;
      end if ;
      [mInstruction check
        !inAccessBankSplitOffset
        !routineMap
        !inRegisterTable
        !?currentBank
        !mPreservesBank
        !?continuesInSequence
        !routineKind
      ] ;
    end foreach ;
    if (not mIsNoReturn) & ([mReturnedBank uint] != [@uint max]) & (currentBank != [mReturnedBank uint]) then
      error mEndOfRoutineLocation:"execution will not set BSR to " . [[mReturnedBank uint] string] ;
    end if ;
    if mIsNoReturn & continuesInSequence then
      error mEndOfRoutineLocation:"execution should not reach the end of a \"noreturn\" routine" ;
    end if ;
  end foreach ;
#-------------------------------- Check Interrupts
  foreach [inPiccoloModel mInterruptDefinitionList] do
    @bool continuesInSequence := true ;
    @uint currentBank [max] ; # No bank
    foreach mInstructionList do
      if not continuesInSequence then
        error [mInstruction mInstructionLocation] : "Unreachable code" ;
        continuesInSequence := true ;
      end if ;
      [mInstruction check
        !inAccessBankSplitOffset
        !routineMap
        !inRegisterTable
        !?currentBank
        !false # Can change BSR
        !?continuesInSequence
        ![@routineKind interruptRoutine]
      ] ;
    end foreach ;
    if not continuesInSequence then
      error mEndOfInterruptLocation:"execution cannot reach the end of the interrupt routine" ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
