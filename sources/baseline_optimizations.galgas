//----------------------------------------------------------------------------*

map @baselineSymbolTableForOptimizations {
  public let @uint mDefinitionLineIndex
  insert insertKey error message "the '%K' label is already declared in %L"
  search searchKey error message "the '%K' label is not declared"
  remove removeKey error message "the '%K' label is not declared"
}

//----------------------------------------------------------------------------*
////                                                                            *
////    S E T    C U R R E N T    A D D R E S S                                 *
//                                                                            *
//----------------------------------------------------------------------------*

method @baseline_intermediate_instruction setCurrentAddress
  ?!@uint ioCurrentWordAdress {
  ioCurrentWordAdress = ioCurrentWordAdress + [self length]
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_pseudo_PAGE setCurrentAddress
  ?!@uint ioCurrentWordAdress {
  ioCurrentWordAdress = self.mPage * 512
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          isLABEL                                           *
//                                                                            *
//----------------------------------------------------------------------------*

getter @baseline_intermediate_instruction isLABEL -> @bool outIsLABEL {
  outIsLABEL = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_pseudo_LABEL isLABEL -> @bool outIsLABEL {
  outIsLABEL = true
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_pseudo_PAGE isLABEL -> @bool outIsLABEL {
  outIsLABEL = true
}

////----------------------------------------------------------------------------*

override getter @baseline_intermediate_pseudo_END_ROUTINE isLABEL -> @bool outIsLABEL {
  outIsLABEL = true
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          isNULL                                            *
//                                                                            *
//----------------------------------------------------------------------------*

getter @baseline_intermediate_instruction isNULL -> @bool outIsNULL {
  outIsNULL = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_NULL isNULL -> @bool outIsNULL {
  outIsNULL = true
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          isSkippingInstruction                             *
//                                                                            *
//----------------------------------------------------------------------------*

getter @baseline_intermediate_instruction isSkippingInstruction -> @bool outIsSkipping {
  outIsSkipping = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_instruction_BitTestSkip isSkippingInstruction -> @bool outIsSkipping {
  outIsSkipping = true
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          nextInstructionIsReachable                        *
//                                                                            *
//----------------------------------------------------------------------------*

getter @baseline_intermediate_instruction nextInstructionIsReachable
  -> @bool outIsReachable {
  outIsReachable = true
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_GOTO nextInstructionIsReachable
  -> @bool outIsReachable {
  outIsReachable = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_JUMP nextInstructionIsReachable
  -> @bool outIsReachable {
  outIsReachable = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_pseudo_END_ROUTINE nextInstructionIsReachable
  -> @bool outIsReachable {
  outIsReachable = false
}

//----------------------------------------------------------------------------*

override getter @baseline_intermediate_instruction_literalOperation nextInstructionIsReachable
  -> @bool outIsReachable {
  outIsReachable = self.mInstruction != @baseline_literal_instruction_opcode. RETLW
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          enterReferencedLabel                              *
//                                                                            *
//----------------------------------------------------------------------------*

method @baseline_intermediate_instruction enterReferencedLabel
  ?!@stringset unused ioReferencedLabelSet {
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_GOTO enterReferencedLabel
  ?!@stringset ioReferencedLabelSet {
  ioReferencedLabelSet ++= self.mTargetLabel.string
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_JUMP enterReferencedLabel
  ?!@stringset ioReferencedLabelSet {
  ioReferencedLabelSet ++= self.mTargetLabel.string
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_CALL enterReferencedLabel
  ?!@stringset ioReferencedLabelSet {
  ioReferencedLabelSet ++= self.mTargetLabel.string
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_JSR enterReferencedLabel
  ?!@stringset ioReferencedLabelSet {
  ioReferencedLabelSet ++= self.mTargetLabel.string
}

//----------------------------------------------------------------------------*

override method @baseline_intermediate_incDecRegisterInCondition enterReferencedLabel
  ?!@stringset ioReferencedLabelSet {
  ioReferencedLabelSet ++= self.mTargetLabel
}

//----------------------------------------------------------------------------*
//                                                                            *
//                          defineLabel                                       *
//                                                                            *
//----------------------------------------------------------------------------*

method @baseline_intermediate_instruction defineLabel
  ?!@baselineSymbolTableForOptimizations unused ioRoutineSymbolTable
  ?let @uint unused inLineIndex {
}

//----------------------------------------------------------------------------*

override
method @baseline_intermediate_pseudo_LABEL defineLabel
  ?!@baselineSymbolTableForOptimizations ioRoutineSymbolTable
  ?let @uint inLineIndex {
  [!?ioRoutineSymbolTable insertKey !self.mLabel !inLineIndex]
}

//----------------------------------------------------------------------------*

proc findBaselineFirstInstructionFromAddress
  ?let @uint inLineIndex
  ?let @baseline_intermediate_instructionList inGeneratedInstructionList
  !@baseline_intermediate_instruction outFirstInstruction {
//--- Line Index
  var @uint currentAddress = inLineIndex
//--- Find first executable instruction
  outFirstInstruction = @baseline_intermediate_NULL () // By default, no instruction
  var @bool found = false
  loop( [inGeneratedInstructionList count])
  while (currentAddress < [inGeneratedInstructionList count]) & not found
  do
    if let instr = [inGeneratedInstructionList mInstructionAtIndex !currentAddress] as @baseline_intermediate_actualInstruction then
//    cast [inGeneratedInstructionList mInstructionAtIndex !currentAddress]
//    case >= @baseline_intermediate_actualInstruction instr :
      outFirstInstruction = instr
      found = true
    else
      currentAddress += 1
    end
  end
}

//----------------------------------------------------------------------------*

proc findBaselineFirstInstructionOrLabelFromAddress
  ?let @uint inLineIndex
  ?let @baseline_intermediate_instructionList inGeneratedInstructionList
  !@baseline_intermediate_instruction outFirstInstruction
  !@stringset outReachedLabelSet {
  outReachedLabelSet = @stringset. emptySet
//--- Line Index
  var @uint currentAddress = inLineIndex
//--- Find first executable instruction
  outFirstInstruction = @baseline_intermediate_NULL () // By default, no instruction
  var @bool found = false
  loop( [inGeneratedInstructionList count])
  while (currentAddress < [inGeneratedInstructionList count]) & not found
  do
    let instruction = [inGeneratedInstructionList mInstructionAtIndex !currentAddress]
    if let instr = instruction as @baseline_intermediate_actualInstruction then
//    cast [inGeneratedInstructionList mInstructionAtIndex !currentAddress]
//    case >= @baseline_intermediate_actualInstruction instr :
      outFirstInstruction = instr
      found = true
    elsif let instr = instruction as @baseline_intermediate_pseudo_PAGE then
//    case >= @baseline_intermediate_pseudo_PAGE instr :
      outFirstInstruction = instr
      found = true
    elsif let instr = instruction as @baseline_intermediate_pseudo_LABEL then
//    case == @baseline_intermediate_pseudo_LABEL instr :
      outFirstInstruction = instr
      outReachedLabelSet ++= instr.mLabel.string
      currentAddress += 1
    else
      currentAddress += 1
    end
  end
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_GOTO optimizeGOTO
  ?let @baselineSymbolTableForOptimizations inSymbolTable
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- The GOTO goes to the next instruction ?
  findBaselineFirstInstructionOrLabelFromAddress ( !inLineIndex+1 !ioGeneratedInstructionList ?* ?let reachedLabelSet )
  if [reachedLabelSet hasKey !self.mTargetLabel.string] then
    [!?ioGeneratedInstructionList setMInstructionAtIndex !@baseline_intermediate_NULL () !inLineIndex]
    ioListFileContents += "  line " + [inLineIndex string] + ": GOTO branching to next instruction deleted\n"
  else      
  //--- Find destination label definition line
    [inSymbolTable searchKey !self.mTargetLabel ?let @uint line]
  //--- Find first executable instruction
    findBaselineFirstInstructionFromAddress ( !line + 1 !ioGeneratedInstructionList ?let firstInstruction )
  //--- Optimization from found first instruction
    if let literalOp = firstInstruction as @baseline_intermediate_instruction_literalOperation then
//    cast firstInstruction
//    case == @baseline_intermediate_instruction_literalOperation literalOp :
      if literalOp.mInstruction == @baseline_literal_instruction_opcode. RETLW then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          !literalOp
          !inLineIndex
        ]
        ioOptimizationsDone = true
        ioListFileContents += "  line " + [inLineIndex string] + ": GOTO branching to RETLW replaced by RETLW\n"
      end
    elsif let goto = firstInstruction as @baseline_intermediate_GOTO then
//    case == @baseline_intermediate_GOTO goto :
      if self.mTargetLabel != goto.mTargetLabel then
        [!?ioGeneratedInstructionList setMInstructionAtIndex
          !@baseline_intermediate_GOTO {
            !self.mInstructionLocation
            !goto.mTargetLabel}
          !inLineIndex
        ]
        ioOptimizationsDone = true
        ioListFileContents += "  line " + inLineIndex + ": GOTO " + self.mTargetLabel + " branching to GOTO " + goto.mTargetLabel + " replaced by GOTO " + goto.mTargetLabel + "\n"
      end
//    else // No Optimization
    end
  end      
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_JUMP optimizeJUMP
  ?let @baselineSymbolTableForOptimizations inSymbolTable
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- Find destination label definition line
  [inSymbolTable searchKey !self.mTargetLabel ?let @uint line]
//--- Find first executable instruction
  findBaselineFirstInstructionFromAddress (
    !line + 1
    !ioGeneratedInstructionList
    ?let @baseline_intermediate_instruction firstInstruction
  )
//--- Optimization from found first instruction
  if let literalOp = firstInstruction as @baseline_intermediate_instruction_literalOperation then
//  cast firstInstruction
//  case == @baseline_intermediate_instruction_literalOperation literalOp :
    if literalOp.mInstruction == @baseline_literal_instruction_opcode. RETLW then
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        !literalOp
        !inLineIndex
      ]
      ioOptimizationsDone = true
      ioListFileContents += "  line " + [inLineIndex string] + ": JUMP branching to RETLW replaced by RETLW\n"
    end
  elsif let goto = firstInstruction as @baseline_intermediate_GOTO then
//  case == @baseline_intermediate_GOTO goto :
    if self.mTargetLabel != goto.mTargetLabel then
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        !@baseline_intermediate_JUMP {
          !self.mInstructionLocation
          !goto.mTargetLabel
          !self.mCurrentPage
          !self.mTargetPage}
        !inLineIndex
      ]
      ioOptimizationsDone = true
      ioListFileContents += "  line " + inLineIndex + ": JUMP " + self.mTargetLabel
        + " branching to GOTO " + goto.mTargetLabel
        + " replaced by JUMP " + goto.mTargetLabel + "\n"
    end
  elsif let jump = firstInstruction as @baseline_intermediate_JUMP then
////  case == @baseline_intermediate_JUMP jump :
    if self.mTargetLabel != jump.mTargetLabel then
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        !@baseline_intermediate_JUMP {
          !self.mInstructionLocation
          !jump.mTargetLabel
          !self.mCurrentPage
          !jump.mTargetPage}
        !inLineIndex
      ]
      ioOptimizationsDone = true
      ioListFileContents += "  line " + inLineIndex + ": JUMP " + self.mTargetLabel
        + " branching to JUMP " + jump.mTargetLabel
        + " replaced by JUMP " + jump.mTargetLabel + "\n"
    end
//  else // No Optimization
  end
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_CALL optimizeCALL
  ?let @baselineSymbolTableForOptimizations inSymbolTable
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- Find destination label definition line
  [inSymbolTable searchKey !self.mTargetLabel ?let @uint line]
//--- Find first executable instruction
  findBaselineFirstInstructionFromAddress (
    !line + 1
    !ioGeneratedInstructionList
    ?let @baseline_intermediate_instruction firstInstruction
  )
//--- Optimization from found first instruction
  if let literalOp = firstInstruction as @baseline_intermediate_instruction_literalOperation then
//  cast firstInstruction
//  case == @baseline_intermediate_instruction_literalOperation literalOp :
    if literalOp.mInstruction == @baseline_literal_instruction_opcode. RETLW then
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        !@baseline_intermediate_instruction_literalOperation {
          !self.mInstructionLocation
          !@baseline_literal_instruction_opcode. MOVLW
          !literalOp.mLiteralValue}
        !inLineIndex
      ]
      ioOptimizationsDone = true
      ioListFileContents += "  line " + inLineIndex + ": CALL " + self.mTargetLabel
       + " to RETLW " + literalOp.mLiteralValue
       + " replaced by MOVLW " + literalOp.mLiteralValue + "\n"
    end
//  else
  end
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_JSR optimizeJSR
  ?let @baselineSymbolTableForOptimizations inSymbolTable
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- Find destination label definition line
  [inSymbolTable searchKey !self.mTargetLabel ?let @uint line]
//--- Find first executable instruction
  findBaselineFirstInstructionFromAddress (
    !line + 1
    !ioGeneratedInstructionList
    ?let @baseline_intermediate_instruction firstInstruction
  )
//--- Optimization from found first instruction
  if let literalOp = firstInstruction as @baseline_intermediate_instruction_literalOperation then
//  cast firstInstruction
//  case == @baseline_intermediate_instruction_literalOperation literalOp :
    if literalOp.mInstruction == @baseline_literal_instruction_opcode. RETLW then
      [!?ioGeneratedInstructionList setMInstructionAtIndex
        !@baseline_intermediate_instruction_literalOperation {
          !self.mInstructionLocation
          !@baseline_literal_instruction_opcode. MOVLW
          !literalOp.mLiteralValue}
        !inLineIndex
      ]
      ioOptimizationsDone = true
      ioListFileContents += "  line " + inLineIndex + ": JSR " + self.mTargetLabel
       + " to RETLW " + literalOp.mLiteralValue
       + " replaced by MOVLW " + literalOp.mLiteralValue + "\n"
    end
//  else
  end
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_pseudo_BEGIN_ROUTINE optimizeBEGIN_ROUTINE
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- If next instruction is not a label definition,
//    the routine is not reachable and should be deleted (until END_ROUTINE)
//--- Get next instruction
  let @baseline_intermediate_instruction nextInstruction = [ioGeneratedInstructionList mInstructionAtIndex !inLineIndex + 1]
//--- Next instruction is a label ?
  var @bool reachable = false
  if let * = nextInstruction as @baseline_intermediate_pseudo_LABEL then
//  cast nextInstruction
//  case == @baseline_intermediate_pseudo_LABEL :
    reachable = true
//  else
  end
//--- delete ?
  if not reachable then
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      !@baseline_intermediate_NULL ()
      !inLineIndex
    ]
    ioOptimizationsDone = true
    ioListFileContents += "  line " + inLineIndex + ": dead code is deleted\n"
  end
}

//----------------------------------------------------------------------------*

method @baseline_intermediate_incDecRegisterInCondition optimizeTestDecInc
  ?let @baselineSymbolTableForOptimizations inSymbolTable
  ?let @uint inLineIndex
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents
  ?!@bool ioOptimizationsDone {
//--- Find destination label definition line
  [inSymbolTable searchKey !@lstring { !self.mTargetLabel !@location.here} ?let @uint line]
//--- Find first executable instruction
  findBaselineFirstInstructionFromAddress (
    !line + 1
    !ioGeneratedInstructionList
    ?let @baseline_intermediate_instruction firstInstruction
  )
//--- Optimization from found first instruction
  if let goto = firstInstruction as @baseline_intermediate_GOTO then
//  cast firstInstruction
//  case == @baseline_intermediate_GOTO goto :
    [!?ioGeneratedInstructionList setMInstructionAtIndex
      !@baseline_intermediate_incDecRegisterInCondition {
        !self.mInstructionLocation
        !self.mRegisterDescription
        !goto.mTargetLabel.string
        !self.mIncrement
        !self.m_W_isDestination
        !self.mBranchIfZero}
      !inLineIndex
    ]
    ioOptimizationsDone = true
    ioListFileContents += "  line " + [inLineIndex string] + ": label of "
    ioListFileContents += "GOTO "
    if self.mIncrement then
      ioListFileContents += "INCF "
    else
      ioListFileContents += "DECF "
    end
    ioListFileContents += self.mRegisterDescription.mAssemblyString
    if self.m_W_isDestination then
      ioListFileContents += ", W"
    end
    if self.mBranchIfZero then
      ioListFileContents += " Z"
    else
      ioListFileContents += " NZ"
    end
    ioListFileContents += ": branching to GOTO replaced by second GOTO label\n"
//  else
  end
}

//----------------------------------------------------------------------------*
//                                                                            *
//               S E M A N T I C    A N A L Y S I S                           *
//                                                                            *
//----------------------------------------------------------------------------*

proc perform_baseline_optimizations
  ?!@baseline_intermediate_instructionList ioGeneratedInstructionList
  ?!@string ioListFileContents {
//-------------------------------- List file
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n"
  ioListFileContents += "*" + ["CODE OPTIMIZATION" stringByLeftAndRightPadding !117 !' '] + "*\n"
  ioListFileContents += ["" stringByLeftAndRightPadding !119 !'*'] + "\n\n"
//-------------------------------- Build label map
  var symbolTable =@baselineSymbolTableForOptimizations ()
  for (mInstruction) in  ioGeneratedInstructionList do(lineIndex)
    [mInstruction defineLabel !?symbolTable !lineIndex]
  end
//-------------------------------- Iterative optimizations
  var @bool optimizationsDone = true
  var @uint iteration = 0
  loop( [ioGeneratedInstructionList count])
  while optimizationsDone
  do
    optimizationsDone = false
    iteration += 1
    ioListFileContents += "Pass " + [iteration string] + ":\n"
  //--- Optimization loop
    for (instruction) in  ioGeneratedInstructionList do (idx)
      if let inst = instruction as @baseline_intermediate_pseudo_BEGIN_ROUTINE then
//      cast instruction
//      case == @baseline_intermediate_pseudo_BEGIN_ROUTINE inst :
        [inst optimizeBEGIN_ROUTINE !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
      elsif let inst = instruction as @baseline_intermediate_GOTO then
//      case == @baseline_intermediate_GOTO inst :
        [inst optimizeGOTO !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
      elsif let inst = instruction as @baseline_intermediate_JUMP then
//      case == @baseline_intermediate_JUMP inst :
        [inst optimizeJUMP !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
      elsif let inst = instruction as @baseline_intermediate_CALL then
//      case == @baseline_intermediate_CALL inst :
        [inst optimizeCALL !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
      elsif let inst = instruction as @baseline_intermediate_JSR then
//      case == @baseline_intermediate_JSR inst :
        [inst optimizeJSR !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
      elsif let inst = instruction as @baseline_intermediate_incDecRegisterInCondition then
//      case == @baseline_intermediate_incDecRegisterInCondition inst :
        [inst optimizeTestDecInc !symbolTable !idx !?ioGeneratedInstructionList !?ioListFileContents !?optimizationsDone]
//      else
      end
    end
  //--- Delete non referenced labels
    var referencedLabels =@stringset ()
    for (mInstruction) in  ioGeneratedInstructionList do
      [mInstruction enterReferencedLabel !?referencedLabels]
    end
    for (lkey *) in  symbolTable do
      if not [referencedLabels hasKey !lkey.string] then
        [symbolTable searchKey !lkey ?let @uint definitionLine]
        ioListFileContents += "  line " + [definitionLine  string] + ": unreferenced label '" + lkey + "' is deleted\n"
        [!?ioGeneratedInstructionList setMInstructionAtIndex !@baseline_intermediate_NULL () !definitionLine]
        [!?symbolTable removeKey !lkey ?*]
      end
    end
  //--- Dead code elimination
    var @bool reachable = true
    var @bool skippingInstruction = false
    var @bool previousWasSkippingInstruction = false
    for (mInstruction) in  ioGeneratedInstructionList do(idx)
       if reachable | previousWasSkippingInstruction then
         reachable = [mInstruction nextInstructionIsReachable]
         previousWasSkippingInstruction = skippingInstruction
         skippingInstruction = [mInstruction isSkippingInstruction]
       else
         let @bool isLABEL = [mInstruction isLABEL]
         if (not isLABEL) & (not [mInstruction isNULL]) then
           ioListFileContents += "  line " + idx + ": dead code is deleted\n"
           [!?ioGeneratedInstructionList setMInstructionAtIndex !@baseline_intermediate_NULL () !idx]
         elsif isLABEL then
           reachable = [mInstruction nextInstructionIsReachable]
           previousWasSkippingInstruction = false
           skippingInstruction = false
         end
       end
    end
    if not optimizationsDone then
      ioListFileContents += "  No optimization\n\n"
    //--- Compute code size
      var @uint currentAddress = 0
      for (mInstruction) in  ioGeneratedInstructionList do
        [mInstruction setCurrentAddress !?currentAddress]
      end
      ioListFileContents += "Minimum code size: " + [currentAddress string] + " words\n\n"
    end
  end
}

//----------------------------------------------------------------------------*

